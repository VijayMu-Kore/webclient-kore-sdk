(function (ng) {

    'use strict';
    (function envConfig() {
        String.prototype.endsWith = function (suffix) {
            return this.indexOf(suffix, this.length - suffix.length) !== -1;
        };
        //fallback config if domain is with .com all service calls goes to same host other wise it picks up from grunt configs(/config/env/qa/config.js)
        //if(!window.location.host.endsWith(".ai")){
        if (window.appConfig) {
            window.appConfig.API_SERVER_URL = window.location.protocol + "//" + window.location.host;
        }
        //}

        //config for dev env
        if (!window.appConfig) {
            window.appConfig = {
                API_SERVER_URL: "https://qa1-bots.kore.ai",
                // API_SERVER_URL: "https://staging-bots.korebots.com",
                //API_SERVER_URL: "localhost",
                CONTEXT_PATH: '',
                MESSENGER_URL: 'https://qa.kore.com',
                BOT_ADMIN_URL: 'https://qa-admin.kore.ai',
                LOAD_WHATFIX: true,
                INLINE_MANUAL_SITE_KEY: '052870f28d65bd4a4d91ff683003e274',
                ON_PREMISE: false,
                HIDE_SSO_LOGIN: false,
                SSO_PROVIDERS:{'google':true,'microsoft':true,'linkedin':true,'github':false},
                SDK_SPEECH_URL: "https://qa-speech.kore.ai/",
                GOOGLE_ANALYTICS_KEY: 'UA-104304523-1',
                ENABLE_GOOGLE_SPEECH: false,
                GOOGLE_MAPS_API_KEY: 'AIzaSyBrFX3oIiPxvRTmywKPBFfudkttUej7nAU',
                ENABLE_GOOGLE_MAPS: true,
                ENABLE_SHARE_LOCATION: true, //chat window detects users location and send it to ML
                USE_SESSION_STORE:false,
                NO_CARRY_SSO_EMAIL:false, // enable for not to pass email in sso redirects, default is false or undefined
                ENABLE_SESSION_EXPIRY_TIMER:true, // enabling this will start a timer 5 mins before the ideal time set for the account about to expire// 
                SESSION_VALIDITY_POLLING:true, // enabling this will start polling the access token validitty check every 5 mins //
                DIRECT_SSO_LOGIN:false, //Should be enabled if only services supports. If this is enabled, app will check for directSSO flag from api and if true it will redirect to given sso login based on idp, insted of builder login page//
                SMALLTALK_DEPTH:2, // change the depth in-order to increase the depth level in small-talk
                MIX_PANEL_TOKEN:'ed0fdb1ab47068a456b068ff3a92ddf4',
                ENABLE_MIX_PANEL:false,
                MIX_PANEL_DEV:false,
                USE_SERVER_SOCKET_URL:false,//for on-prem's socket url is taken from browser url,this flag forces to pick only from server even on on prem
                enableHomepage : true,
                homePageIframeUrl:'https://pilot-site.kore.ai/bot-home-3/'
            };
        }
        if (window.appConfig) {
            window.appConfig.TMPLT_PRE_PATH = window.appConfig.CONTEXT_PATH ? window.appConfig.CONTEXT_PATH + '/' : '';
        }
    })();

    if (window.appConfig) {
        window.appConfig.MP_URL = location.protocol + "//" + location.host + '/botstore';
    }

    window.___app_kickOff = function startApplication() {
        ng.element(document).ready(function () {
            ng.bootstrap(document, ["BuilderApp"]);
        });
        // if (self == top) {
        //     ng.element(document).ready(function () {
        //         ng.bootstrap(document, ["BuilderApp"]);
        //     });
        // } else {
        //     var locHref = window.parent.location.href;
        //     var fromValidDomain = locHref.indexOf(".kore.ai") !== -1 ||
        //                           locHref.indexOf(".smartassist.ai") !== -1 ||
        //                           locHref.indexOf("localhost") !== -1;
        //     if (fromValidDomain) {
        //         ng.element(document).ready(function () {
        //             ng.bootstrap(document, ["BuilderApp"]);
        //         });
        //     } else {
        //         console.error('opening Kore.ai bot builder in iframe is not supported');
        //     }
        // }
    }();

    window._log_info = function logInfo() {
        if (window.localStorage.enableLogs) {
            console.info.apply(console, arguments);
        }
    };

    var btBuilderApp = ng.module('BuilderApp',
        [
            'ngRoute',
            'ngSanitize',
            'ui.select2',
            'ng.jsoneditor',
            'datePicker',
            'ui.bootstrap',
            'validation.match',
            'LocalStorageModule',
            'dibari.angular-ellipsis',
            'angular-uuid',
            'ui.tree',
            'ui.tree-filter',
            'ui.highlight',
            'bt-components',
            'bt-streams',
            'utterances-module',
            'patterns-module',
            'synonyms-module',
            'bt-wf-create',
            'bt-flowTask-create',
            'bt-flowTask-edit',
            'bt-flowTask-view',
            'bt-forms',
            'bt-login',
            'ml-threshold',
            'bt-wf-mapping',
            'bt-bot-publish',
            'bt-resource-view',
            'bt-resource-versions',
            'bt-wf-edit',
            'bt-app-create',
            'bt-app-view',
            'bt-stream-edit',
            'bt-stream-create',
            'bt-wf-logs',
            'bt-chat-settings',
            'app.helpers',
            'factories',
            'services',
            'version.manager',
            'bt-kora-users',
            'bt-kora-logs',
            'bt-changelog',
            'bt-knowledge-create',
            'bt-train-bot',
            'bt-solution-install',
            'bt-kore-components',
            'jsonFormatter',
            'ui.sortable',
            'manage-components',
            'bt-import-bot',
            'bt-variable-management',
            'ngCsv',
            'ngTagsInput',
            'oc.lazyLoad'
        ]);


    btBuilderApp.filter('trustUrl', function ($sce) {
          return function(url) {
            return $sce.trustAsResourceUrl(url);
          };
    });
    btBuilderApp.config(['$locationProvider',
        function ($locationProvider) {
            $locationProvider.html5Mode(true);
        }
    ]);
    btBuilderApp.config(['$httpProvider',
        function ($httpProvider) {

            $httpProvider.interceptors.push('AuthInterceptor', 'languageInterceptor', 'i18nLagInterceptor', 'accountInterceptor', 'stateInterceptor','cryptoInterceptor','accessTokenTimerInterceptor','timezoneInterceptor');

            $httpProvider.useApplyAsync([true]);

            $httpProvider.defaults.headers.delete = {
                "Content-Type": "application/json;charset=utf-8"
            };
        }]);

    btBuilderApp.config(['$rootScopeProvider',
        function ($rootScopeProvider) {
            $rootScopeProvider.digestTtl(20);
        }
    ]);

    btBuilderApp.run(['$rootScope', '$http', '$timeout', '$templateCache', '_constants_', '$window', '$endpoints', '$translator', '$applicationService', '$location', '$localstorage', 'BTSeedDataService', '$workflowService', 'env_conf', 'domEvents', 'versionMonitor', '$anchorScroll', 'security', 'scriptLoader','i18n',
        function ($rootScope, $http, $timeout, $templateCache, _constants_, $window, $endpoints, $translator, $applicationService, $location, $localstorage, BTSeedDataService, $workflowService, env_conf, domEvents, versionMonitor, $anchorScroll, security, scriptLoader,i18n) {
            $rootScope._ = _;
            $rootScope.contextPath = env_conf['context-url'];
            $rootScope.tmpltPrePath = window.appConfig.TMPLT_PRE_PATH;
            $rootScope.appVersion = env_conf['app-version'];
            $rootScope.appConfig = window.appConfig;
            $rootScope.logoIcon = window.appConfig.CONTEXT_PATH + '/assets/landingImages/logo.png';//botdetail sidenav
            $rootScope.logoIconSmart = window.appConfig.CONTEXT_PATH + '/assets/landingImages/smart-logo.svg';//botdetail sidenav
            $rootScope.logoFull = window.appConfig.CONTEXT_PATH + '/assets/landingImages/kore-logo.svg';//main logo
            $rootScope.logoFullInverted = window.appConfig.CONTEXT_PATH + '/img/kore-logo-inverse.svg';//main logo inverted
            if(window.appConfig.PFIZER){
                $rootScope.logoIcon = window.appConfig.CONTEXT_PATH + '/assets/landingImages/logo-pfizer.svg';
                $rootScope.logoFull = window.appConfig.CONTEXT_PATH + '/assets/landingImages/pfizer-logo.svg';
                $rootScope.logoFullInverted = window.appConfig.CONTEXT_PATH + '/img/pfizer-logo-inverse.svg';//main logo inverted
            }
            domEvents.register();
            scriptLoader.loadScripts();
            var _lskey = 'bt.userInfo',
                _koreUserInfoKey = "jStorage",
                _externalInfo = $localstorage.get(_lskey),
                userInfo, auth, koreUserInfo, _koreUserInfo;


            $templateCache.put('langpopover.html', 'This is the content of the template');

            if (typeof localStorage === 'object') {
                try {
                    localStorage.setItem('localStorage', 1);
                    localStorage.removeItem('localStorage');
                } catch (e) {
                    Storage.prototype._setItem = Storage.prototype.setItem;
                    Storage.prototype.setItem = function () { };
                    alert(i18n.i18nString('website_loaded'));
                }
            }

            daterangepicker.prototype.hoverDate = function () { };

            function getJSON(string) {
                var json;
                try {
                    json = JSON.parse(string);
                    return json;
                }
                catch (e) {
                    return false;
                }
            }
            function decodeBase64(string){
                var json;
                try {
                  return atob(string);
                }
                catch (e) {
                    return false;
                }
            }
    
            var search = $location.search(), hash = $location.hash(),
                id_token, json, endIdToken,qp;
                if(search && search.iframeBodyClass){
                    $('html, body').addClass(search.iframeBodyClass);
                }
            //var _qstring = $location.search();
            if (search && search.lang) {
                $workflowService.i18nSelectedLanguage(search.lang);
                // var selectedQueryParamLanguage= localStorage.getItem('queryParamLang');
                // if(!selectedQueryParamLanguage){
                    localStorage.setItem('queryParamLang',search.lang);
                // }
            }
            // 
            if(search.emailId ||  search.phoneNo) {
                security.resetlocalStoragAfterLogout(); // to clear the Local storage from previous user
                var  _emailJson = {'email':search.emailId || search.phoneNo}; 
                window.localStorage.setItem('emailIdStorage', JSON.stringify(_emailJson));
            }
            if(search.utm_source || search.utm_campaign || search.utm_id || search.utm_term || search.utm_content) {
              var uatDetails = {
                  "UTM Source": search.utm_source || "",
                  "UTM Campaign": search.utm_campaign || "",
                  "UTM Id": search.utm_id || "",
                  "UTM Term": search.utm_term || "",
                  "UTM Content": search.utm_content || "",
              };
              window.localStorage.setItem('utmDetails', JSON.stringify(uatDetails));
            }
            if(search.streamId){
                var invitedStreamId = '';
                if(search.streamId){
                    invitedStreamId = search.streamId;
                    localStorage.setItem('invitedBot',invitedStreamId);
                }
            }
            var checkForPendingInstalation = window.localStorage.getItem("installFromStore");
            if (search && search.qp) { // global store
                var getQueryParams = atob(search.qp);
                if(getQueryParams){
                    var queryParamsObj = JSON.parse(getQueryParams);
                if(queryParamsObj && (queryParamsObj.origin === 'botStore')) { // checks specifically for bot store call
                    $workflowService.globalStoreQueryParams(queryParamsObj);
                    // Add condition here //
                    if (queryParamsObj.streamId || queryParamsObj.processId){
                        if(queryParamsObj.streamId){
                            $workflowService.globalStoreQueryParams(queryParamsObj);
                        }
                        if(queryParamsObj.processId){
                            $workflowService.toInstallProcessApp(queryParamsObj);
                        }
                        $location.search({});
                        $location.hash('');
                    }
                 }
                }
               
            } else if(checkForPendingInstalation){
               var storeParms =  JSON.parse(checkForPendingInstalation);
               $workflowService.globalStoreQueryParams(storeParms);
            }
            if((hash === 'login') || (hash === 'signup')) {  // #login
                security.resetlocalStoragAfterLogout(); // to clear the Local storage from previous user
                var  _emailJsonObj = {'email':search.email || search.emailId || search.phoneNo}; 
                if(_emailJsonObj.email){
                    window.localStorage.setItem('emailIdStorage', JSON.stringify(_emailJsonObj));
                } else {
                    window.localStorage.removeItem('emailIdStorage');
                }
               $location.path(window.appConfig.CONTEXT_PATH + '/login');
            } else if (hash.indexOf('id_token') > -1) {
                json = getJSON(search.query);
                qp=decodeBase64(search.qp);//JSON string encoded in base64
                /*
                qp: sample
                    {
                        streamId:"st-96babf56-3b0d-565e-82d6-038066ed6dad",//to land into streamPage directly, selectedAccount is dependency  
                        selectedAccount:"5f0bf6fe4568d4115e0ea8a0"
                    }
                */
                if(qp){
                    qp=getJSON(qp);
                }

                var _obj;
                if (true || json) { // ssoProvider key is sent from security while loggin in using sso
                    //removed json condition to support without query as param BB-6692
                    endIdToken = hash.indexOf('&email')>-1 ? hash.indexOf('&email') : hash.length;
                    id_token = hash.substring(hash.indexOf('id_token') + 9, endIdToken);
                    if ($location.path().indexOf('kora') > -1) {
                        _obj = {
                            isFromKora: true,
                            path: $location.path()
                        };
                        $workflowService.kgDataFromKora(_obj);
                    }

                    if(qp.hasOwnProperty('usecaseType')) {
                        _obj = {};
                        if(qp.usecaseType == 'faq') {
                            _obj = {
                                kgId: qp.kgId,
                                landOnKg: true,
                                streamId: qp.streamId,
                                selectedAccount:qp.selectedAccount,
                               // fromSmart: true //commented to support redirection for workbench, from workbench there will be key 'fromWorkbench' in qp to know its from workbench
                            };
                            if(qp.workbenchSolutionType){
                                _obj.workbenchSolutionType = qp.workbenchSolutionType;
                            }
                            if(qp.returnUrl){
                                _obj.returnUrl = qp.returnUrl;
                            }
                            if(qp.fromWorkbench){
                                _obj.fromWorkbench = true;
                            }else{
                                _obj.fromSmart = true;
                            }
                            $workflowService.kgDataFromKora(_obj);
                        } else if(qp.usecaseType == 'conversation') {
                            _obj = {
                                dgId: qp.dgId,
                                landOnDialog: true,
                                streamId: qp.streamId,
                                selectedAccount:qp.selectedAccount,
                               // fromSmart: true, //commented to support redirection for workbench, from workbench there will be key 'fromWorkbench' in qp to know its from workbench
                                state: qp.state
                            }; 
                            if(qp.workbenchSolutionType){
                                _obj.workbenchSolutionType = qp.workbenchSolutionType;
                            }
                            if(qp.fromWorkbench){
                                _obj.fromWorkbench = true;
                            }else{
                                _obj.fromSmart = true;
                            } 
                            if(qp.returnUrl){
                                _obj.returnUrl = qp.returnUrl;
                            }
                            $workflowService.kgDataFromKora(_obj);
                        }
                    } 
                    else if(qp.landOnPublish) {
                        _obj = {
                            landOnPublish: true,
                            streamId: qp.streamId,
                            accountId: qp.selectedAccount,
                            selectedAccount: qp.selectedAccount,
                           // fromSmart: true
                        };  
                        if(qp.fromWorkbench){
                            _obj.fromWorkbench = true;
                        }else{
                            _obj.fromSmart = true;
                        }
                        if(qp.returnUrl){
                            _obj.returnUrl = qp.returnUrl;
                        }
                        $workflowService.kgDataFromKora(_obj);
                    }else if(qp && qp.landOnSummary){
                        var _sampleObj = {
                            landOnSummary : true,
                            streamId:qp.streamId,
                            accountId:qp.selectedAccount
                        };
                        $workflowService.sampleBotDataFromBotStore(_sampleObj);
                    } else if(qp && qp.streamId){
                        var _obj1 = {
                            landOnStream: true,
                            streamId: qp.streamId,
                            selectedAccount:qp.selectedAccount
                        };
                        $workflowService.kgDataFromKora(_obj1);
                    } else if(qp && qp.processId){
                        var _objProcess = {
                            processId: qp.processId,
                            selectedAccount:qp.selectedAccount
                        };
                        $workflowService.toInstallProcessApp(_objProcess);
                    }
                    
                    security.ssoLogin(id_token, json, qp);
                }
                else {
                    console.error('ssoLogin: Invalid JSON'); // Debugging purpose
                }

                $location.search({});
                $location.hash('');
            }
            else if (hash.indexOf('iir') > -1) {            
                var idp_redirect_key = hash.substring(hash.indexOf('iir') + 4, endIdToken);
                window.location.href =  $endpoints.baseUrl+$endpoints.apiPreFix+'/sso/login/idpinit/redirect/callback?iir='+idp_redirect_key;
            }
            else if (hash === '_accountactivation') {
                security.resetlocalStoragAfterLogout();
                $location.path(window.appConfig.CONTEXT_PATH + '/login');

                // This case is being handled inside login module
                //$location.path('/bt/login');
            }
            else if (hash === '_resetpassword') {
                $location.path(window.appConfig.CONTEXT_PATH + '/login');
                // This case is being handled inside login module
                //$location.path('/bt/login');
            }
            else if (search.form === "accountsList") {
                security.resetOAuth();
                search.form = "accountsList";
            }
            else {
                security.resumeOldSession();
            }

            $rootScope.$on('$locationChangeSuccess', function (event, newUrl, oldUrl) {
                if (window.appConfig.GOOGLE_ANALYTICS_KEY) {
                    $window.ga('send', 'pageview', $location.path());
                }
                var _noHeaderPattern = new RegExp("login|requestbtaccess|acceptbtlicense");
                if (newUrl && _noHeaderPattern.test(newUrl)) {
                    $rootScope.showHeader = false;
                } else {
                    $rootScope.showHeader = true;
                }
            });

            function genRandQuery() {
                return 'rnd=' + Math.random().toString(36).substr(7);
            }

            $rootScope.lableData = {};

            $rootScope.changeLanguage = function (languageType) {
                var url = env_conf['components-source'];
                //$http.get(url + 'resources/' + languageType + '.json?' + genRandQuery())
                   // .then(function (res) {
                        $rootScope.lableData = i18n.i18nString('resource');
                       // i18nString('resource')//res.data;
                    //}, function (error) {
                    //    $rootScope.lableData = {};
                    //});
            };

            $rootScope.resolveHostUrl = function() {
                var url = window.location.protocol + '//' + window.location.host;
                if (url === 'https://qa-bots.kore.ai') {
                    return 'https://qa-smartassist.kore.ai/';
                }
                if (url === 'https://qa1-bots.kore.ai') {
                    return 'https://qa1-smartassist.kore.ai/';
                }
                if (url === 'https://uat.kore.ai') {
                    return 'https://uat-smartassist.kore.ai/';
                }
                if (url === 'https://uat-demo.kore.ai') {
                    return 'https://demo-app-smartassist.kore.ai/';
                }
                if (url === 'https://staging-bots.korebots.com') {
                    return 'https://staging-smartassist.kore.ai/';
                }
                if (url === 'https://pilot-bots.kore.ai') {
                    return 'https://pilot-app.smartassist.ai/';
                }
                if (url === 'https://bots.kore.ai') {
                    return 'https://smartassist.kore.ai/';
                }
                if (url === 'https://jp-bots.kore.ai') {
                    return 'https://smartassist-jp.kore.ai/';
                }
                return url + "/";
            };

            $rootScope.resolveWorkbenchHostUrl = function() {
                var url = window.location.protocol + '//' + window.location.host;
                var workbenchData = $workflowService.kgDataFromKora();
                var workbenchSolutionType = workbenchData.workbenchSolutionType;
                if(workbenchData && workbenchData.returnUrl){
                    return workbenchData.returnUrl;
                }else{
                if(workbenchSolutionType === 'Banking'){
                    if ((url === 'https://staging-bots.korebots.com/botbuilder') || (url === 'https://staging-bots.korebots.com')) {
                        return 'https://staging-workbench-external.korebots.com/workbench';
                    }
                    else if ((url === 'https://bots.kore.ai/botbuilder') || (url === 'https://bots.kore.ai')) {
                        return 'https://bankassist.kore.ai/workbench';
                    }
                    else if (url === 'https://bankassist-dev-bots.kore.ai') {
                        return 'https://bankassist-dev.kore.ai';
                    }
                    else if (url === 'https://bankassist-qa-bots.kore.ai') {
                        return 'https://bankassist-qa.kore.ai';
                    }
                    else if (url === 'https://bankingassistant-qa-bots.kore.ai') {
                        return 'https://bankingassistant-qa.kore.ai';
                    }
                    else{
                        url = window.appConfig.WORKBENCH_SERVER_URL + "/workbench";
                    }
                }else if(workbenchSolutionType === 'ITSM'){
                    if ((url === 'https://staging-bots.korebots.com/botbuilder') || (url === 'https://staging-bots.korebots.com')) {
                        return 'https://itassist-qa.kore.ai';
                    } else {
                        return 'https://itassist.kore.ai';
                    }
                }
                else if(workbenchSolutionType === 'HR'){
                    if ((url === 'https://staging-bots.korebots.com/botbuilder') || (url === 'https://staging-bots.korebots.com')) {
                        return 'https://hrassist-qa.kore.ai';
                    } else {
                        return 'https://hrassist.kore.ai';
                    }
                }
                else if(workbenchSolutionType === 'Applicant'){
                    if ((url === 'https://staging-bots.korebots.com/botbuilder') || (url === 'https://staging-bots.korebots.com')) {
                        return 'https://applicantassist-qa.kore.ai';
                    } else  {
                        return 'https://applicantassist.kore.ai';
                    }
                }
                else{
                    // return window.location.protocol + '//' + window.location.host+'/workbench';
                    url = window.appConfig.WORKBENCH_SERVER_URL + "/workbench";
                }
                }
                return url;
            };

            $rootScope.$on('$locationChangeStart', function (event, next, current) {
                //                if (current.indexOf('login') > 0 && next.indexOf('login') < 0 && !security.isAuthenticated()) {
                //                    NotificationService.notify("Please login first","warning");
                //                    event.preventDefault();
                //                    return;
                //                }
                if ($('.join-accounts-modal .pendingAccounts').length || $('.join-accounts-modal .requestAck').length) {
                    security.logout();
                    return;
                }
                if($('.alert-modal.navigationRouteModule').length){
                    return false;
                }
                //If user clicks on browser back this looks for in app back button with .closeBtn selector and trigger click on it
                var _inAppBack = $('#dialogCloseAction');
                var isBotDetalForm = $('#botDetailsFormDir');
                var isBotForm = $('#botsFormDir');
                if (_inAppBack.length && security.isAuthenticated()) {
                    console.log('#dialogCloseAction');
                    event.preventDefault();
                    var message = '<p><i class="fa fa-exclamation-circle fa-2x" aria-hidden="true" style="color: #009dac;"></i></p> "'+ i18n.i18nString('are_you_sure')+'"</br>"'+i18n.i18nString('want_navigate')+'"';
                    window.bootbox.dialog({
                        message: message,
                        title: "",
                        className: "alert-modal zindexshowmodal navigationRouteModule",
                        buttons: {
                            main: {
                                label: i18n.i18nString('no'),
                                className: "btn closeCancel",
                                callback: angular.noop
                            }, yes: {
                                label: i18n.i18nString('yes'),
                                className: "btn-primary",
                                callback: function () {
                                    $timeout(function () {
                                        _inAppBack[_inAppBack.length - 1].click();
                                    });
                                }
                            }

                        },
                        onEscape: false,
                        closeButton: false
                    });
                    
                    return;
                } else if(isBotDetalForm && isBotDetalForm.length && security.isAuthenticated()){
                    console.log('#botDetailsFormDir');
                    event.preventDefault();
                    var backHome = '<p><i class="fa fa-exclamation-circle fa-2x" aria-hidden="true" style="color: #009dac;"></i></p> "'+ i18n.i18nString('are_you_sure')+'"</br>"'+i18n.i18nString('want_navigate')+'"';
                    window.bootbox.dialog({
                        message: backHome,
                        title: "",
                        className: "alert-modal zindexshowmodal navigationRouteModule",
                        buttons: {
                            main: {
                                label: i18n.i18nString('no'),
                                className: "btn closeCancel",
                                callback: angular.noop
                            }, yes: {
                                label: i18n.i18nString('yes'),
                                className: "btn-primary",
                                callback: function () {
                                    $timeout(function () {
                                        $('.backToBotList').click();
                                    });
                                }
                            }

                        },
                        onEscape: false,
                        closeButton: false
                    });
                    return;
                } else if(isBotForm && isBotForm.length && security.isAuthenticated()) {
                    console.log('#botsFormDir');
                    event.preventDefault();
                    var popMessage = '<p><i class="fa fa-exclamation-circle fa-2x" aria-hidden="true" style="color: #009dac;"></i></p> "'+ i18n.i18nString('are_you_sure')+'"</br>"'+i18n.i18nString('want_navigate')+'"';
                    window.bootbox.dialog({
                        message: popMessage,
                        title: "",
                        className: "alert-modal zindexshowmodal navigationRouteModule",
                        buttons: {
                            main: {
                                label: i18n.i18nString('no'),
                                className: "btn closeCancel",
                                callback: angular.noop
                            }, yes: {
                                label: i18n.i18nString('yes'),
                                className: "btn-primary",
                                callback: function () {
                                    $timeout(function () {
                                        security.logout();
                                    });
                                }
                            }

                        },
                        onEscape: false,
                        closeButton: false
                    });
                    return;
                }
                if (/\/alert|action\/.*\/edit/.test(current)) {
                    if (!$workflowService.alertInfo() && !$workflowService.actionInfo()) {
                        $location.path(window.appConfig.CONTEXT_PATH);
                    }
                }
            });
            $rootScope._constants_ = _constants_;
        }]);

})(angular);


;(function (ng) {

    'use strict';

    var btBuilderApp = ng.module('BuilderApp');

    btBuilderApp.controller('MainController', ['$scope', '$rootScope', '$location', '$localstorage', '$window', '$timeout', '$endpoints', '_constants_', '$http', 'BTSeedDataService', 'BTProcessAppDataService', '$workflowService', 'BTStreamsService', '$translator', 'env_conf', '$applicationService', 'security', '$sce', '$sanitize', '$modal', '$modalStack', 'AuthService', 'NotificationService', 'scriptLoader', '$route','BTFileUploadService','languageConfig','localstore','jsEvents','i18n','mixPanel',
        function ($scope, $rootScope, $location, $localstorage, $window, $timeout, $endpoints, _constants_, $http, BTSeedDataService, BTProcessAppDataService, $workflowService, BTStreamsService, $translator, env_conf, $applicationService, security, $sce, $sanitize, $modal, $modalStack, AuthService, NotificationService, scriptLoader, $route,BTFileUploadService,languageConfig,localstore,jsEvents,i18n,mixPanel) {
            $scope.mainCntrlCb =  {};
            var botOptions = {};
            var chatConfig = {};
            var _botInfo;
            var onBoardingFlow={
                onboardingJourneyStarted:false,
                onboardingJourneyCompleted:false,
            };
            $scope.mainControlDependencies = {
                securityAuthenticated:false,
                translationsLoaded:false
            };
            $scope.welcomeFormCb={};
            var _loggerInstance = {};
            botOptions.logLevel = 'debug';
            botOptions.koreAPIUrl = $endpoints.urlWithVersion;
            botOptions.assertionFn = assertion;
            botOptions.koreAnonymousFn = koreAnonymousFn;
            botOptions.test = false;
            botOptions.showDownloadPopUps = _constants_.showDownloadPopUps;
            botOptions.openDownloadfWarnModal = function(cb){
                function startExport(){
                    cb();
                }
             function cancleExport(){
                 return;
             }
             function checkBoxCb(checkValue){
               _constants_.updateDownloadPopUppreferance(checkValue);
             }
             if(_constants_.config.showDownloadPopUps){
              NotificationService.userConfirm(_constants_.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{"enable":true,"checkBoxCb":checkBoxCb}}, "", undefined,i18n.i18nString('download'));  
             }else{
              startExport();
             }
            };
            $rootScope.licenseUpdate =  false;
            $rootScope.isOnPremise = function(){
                return window.appConfig.ON_PREMISE;
            };
            if ($rootScope.isOnPremise() && !window.appConfig.USE_SERVER_SOCKET_URL) {
                botOptions.reWriteSocketURL = {
                    protocol: (location.protocol === 'https'||location.protocol === 'https:') ? 'wss' : 'ws',
                    hostname: location.hostname,
                    port: location.port
                };
            }

            botOptions.botInfo = {};

            botOptions.client = "botbuilder";

            chatConfig = {
                "chatTitle": "Kora Bot",
                botOptions: botOptions,
                "allowIframe": false,
                isTTSEnabled: true,
                isSpeechEnabled: true,
                // isSpeechAuthorizationRequired: _constants_.config.ENABLE_SPEECH_AUTHORIZATION,
                allowGoogleSpeech : false,
                // googleSpeechKey : _constants_.config.googleSpeechAPIKey,
                // allowLocation : window.appConfig.ENABLE_SHARE_LOCATION,
                // loadHistory: _constants_.config.loadHistory,
                messageHistoryLimit: 10,
                pickersConfig:{
                    showDatePickerIcon:false,
                    showDateRangePickerIcon:false,
                    showClockPickerIcon:false,
                    showTaskMenuPickerIcon:false,
                    showradioOptionMenuPickerIcon:false
                }
                // autoEnableSpeechAndTTS: _constants_.config.autoEnableSpeechAndTTS,
                // graphLib: _constants_.config.graphLib
            };

            var chatApp;
            var authToken = null;
            $scope.checkingOnboarding =  null;
            clearInterval($scope.checkingOnboarding);
//------------------------------------------------------- Load function starts ----------------------------------------------------------------------- //            
function checkOnboarding() {
    // console.log('Welcome --Main Controler Loaded---', $scope.mainLoad);
    // console.log('Welcome --securty---', $scope.securityAuthenticated);
    // console.log('Welcome --User Info---', $rootScope.koreUserInfo);
    $scope.checkingOnboarding = setInterval(function(){
        if($scope.mainControlDependencies.securityAuthenticated && $scope.mainControlDependencies.translationsLoaded){
            clearInterval($scope.checkingOnboarding);
            console.log('completed checking user status');
        if($scope.securityAuthenticated) {
            if(!$rootScope.koreUserInfo.isBotsOnboarded){
                $scope.showWelcomeForm();
            }
         }
        }
    },1000);
        
}  
$scope.selectAccount=function(account){
    localstore.setFromLoginScreenFlag();
    localStorage.removeItem("previousState");
    if(account.hasOwnProperty('idp')){
        var dataobject = {};
        dataobject.username = $applicationService.userInfo().appControls.userInfo.emailId;
        //dataobject.idp = dataobject.username+'_'+account.idp;
        dataobject.idp = account.idp;
        //localStorage.setItem("selectedAccount",JSON.stringify(account));
        account.client_email=$applicationService.userInfo().appControls.userInfo.emailId;
        localStorage.setItem("selectedSSOAccount",JSON.stringify(account));
        security.handleSSORedirect(dataobject, 'direct');
    }
    else{
        localStorage.removeItem("selectedSSOAccount");
        localstore.setSelectedAccount(account);
        window.location.reload();
    }

};      
function load(){
    $scope.mainLoad = true;
            var showNotificationBar = true;
            $scope._trainStatus = null;
            $scope._speechTrainStatus = null;
            $scope.showClaimDomain = false;
            $scope.claimDomainMsg = i18n.i18nString('claim_your_domain');
            //var _loggerInstance = {};
            $rootScope.$on('$locationChangeStart', function (event, to, from) {
                if (!(/alert|action|new/.test(to))) {
                    $scope.showControls = false;
                    $scope.$emit('WORKFLOW_FINISHED');
                }
            });
            function updateUserProfile(userObj) {
                var _usrInfo = localstore.getAuthData();
                _usrInfo.currentAccount.userInfo = angular.copy(userObj.koreUserInfo, _usrInfo.currentAccount.userInfo);
                $rootScope.koreUserInfo = _usrInfo.currentAccount.userInfo;
                if ($rootScope.koreUserInfo !== 'no-avatar') {
                    $rootScope.profileImgLinkPrefix = $endpoints.baseUrl + $endpoints.apiPreFix + "/getMediaStream/profilePictures/" + $applicationService.userInfo().userId + '/r_64x64_profile.png';
                    $rootScope.profileImgLinkPrefix = $rootScope.profileImgLinkPrefix + '?v=1.1' + Math.random() * 1000;
                }
                localstore.getAuthData(_usrInfo);
            }
            $scope.launchUserProfile = function () {
                $timeout(function () {
                    showUserProfileModal();
                }, 500);


                function showUserProfileModal() {
                    $modal.open({
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bt-user-profile/bt-user-profile.html',
                        controller: 'BTUserProfileCtrl',
                        backdrop: 'static',
                        windowClass: 'taskCreateOverlayModal userOverlay height-width-100 bt-user-profile-modal',
                        resolve: {
                            config: function () {
                                return {
                                    cbBridge: updateUserProfile
                                };
                            }
                        }
                    });

                    $rootScope.$on("onUserprofileClose", function () {
                        $modalStack.dismissAll();
                    });
                }

            };

            $scope.switchBotStore = function () {

                var targetURL = $endpoints.baseUrl;
                $window.open(targetURL + '/enterprise', '_blank');
            };
            $scope.launchAdminConsole = function () {
                var targetURL = window.appConfig.BOT_ADMIN_URL;//$endpoints.baseUrl + '/botadmin';
                if (targetURL) {
                    $window.open(targetURL, '_blank');
                }
            };

            $scope.skipUpdateBar = function () {
                AuthService.profileUpdate({ enableTips: false })
                    .then(function (res) {
                        $('.notificationHeader').css('height','0');
                        if ($applicationService.userInfo() && $applicationService.userInfo().koreUserInfo) {
                            $applicationService.userInfo().koreUserInfo.enableTips = false;
                        }
                      }, function (err) {
                        console.error("Error updating enableTips info");
                    });
            };

            $scope.getTextIncludingTags = function(name) {
                if(name && name.trim()){
                    return name.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                }
                   return "";
                };

            $scope.launchBotStore = function () {
                var targetURL = window.appConfig.MP_URL;
                $window.open(targetURL, '_blank');
            };

            $scope.launchKoreMessaging = function () {
                var targetURL = window.appConfig.MESSENGER_URL;//_constants_.messengerDomains[$endpoints.baseUrl];
                if (targetURL) {
                    $window.open(targetURL, '_blank');
                }
            };
            $rootScope.isAdmin = function () {
                var _selectedAcc = $workflowService.selectedAccount();
                if (_selectedAcc && _selectedAcc.roles && _selectedAcc.roles.length > 0) {
                    if (_selectedAcc.roles.indexOf('admin')>-1) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            };

            $rootScope.isAdminCheck = function(){
                var _selectedAcc = $workflowService.selectedAccount();
                if(_selectedAcc && _selectedAcc.roles && _selectedAcc.roles.length > 0){
                    return true;
                }else{
                    return false;
                }
            };



            


            $rootScope.showConfirmationPopup = function(msg, callBackFn){
                NotificationService.alert(msg, callBackFn, arguments);
            };

            //Scroll Snippet
            $rootScope.scrollToDiv = function (parentEle, targetEle) {
                $timeout(function () {
                    $(parentEle).animate({
                        scrollTop: $(targetEle).position().top
                    }, 800, 'swing');

                }, 800);
            };
            //End Scroll Snippet
            window.$location=$location;
            $rootScope.logOut = function () {
                $location.search('');
                $timeout(function(){
                    localStorage.removeItem("previousState");
                    security.logout();
                },500);

            };
            $rootScope.redirectToLink = function (linkType , event, isExtLink) {
                if(event){
                    event.stopImmediatePropagation();
                    event.stopPropagation();
                }

                var targetURL = "https://developer.kore.ai/docs/bots/bot-builder/";

                if (linkType) {
                    targetURL = $rootScope.helpLinks[linkType];
                }
                if (isExtLink) {
                    targetURL = linkType;
                }

                $window.open(targetURL, '_blank');
            };

            $rootScope.getSanitizedText = function (text) {

                text = text || '';

                try {
                    text = $sanitize(text);
                } catch (ex) {
                    console.warn(ex);
                }

                return text;

            };
            

            

            botOptions.logLevel = 'debug';
            botOptions.koreAPIUrl = $endpoints.urlWithVersion;
            botOptions.assertionFn = assertion;
            botOptions.koreAnonymousFn = koreAnonymousFn;
            botOptions.test = false;
            botOptions.showDownloadPopUps = _constants_.showDownloadPopUps;
            botOptions.openDownloadfWarnModal = function(cb){
                function startExport(){
                    cb();
                }
             function cancleExport(){
                 return;
             }
             function checkBoxCb(checkValue){
            //    console.log(checkValue);
               _constants_.updateDownloadPopUppreferance(checkValue);
             }
             if(_constants_.config.showDownloadPopUps){
              NotificationService.userConfirm(_constants_.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{"enable":true,"checkBoxCb":checkBoxCb}}, "", undefined,i18n.i18nString('download'));  
             }else{
              startExport();
             }
            };
            if ($rootScope.isOnPremise() && !window.appConfig.USE_SERVER_SOCKET_URL) {
                botOptions.reWriteSocketURL = {
                    protocol: (location.protocol === 'https'||location.protocol === 'https:') ? 'wss' : 'ws',
                    hostname: location.hostname,
                    port: location.port
                };
            }

            botOptions.botInfo = {};

            botOptions.client = "botbuilder";

            chatConfig = {
                "chatTitle": "Kora Bot",
                botOptions: botOptions,
                "allowIframe": false,
                isTTSEnabled: true,
                isSpeechEnabled: true,
                isSpeechAuthorizationRequired: _constants_.config.ENABLE_SPEECH_AUTHORIZATION,
                allowGoogleSpeech : false,
                googleSpeechKey : _constants_.config.googleSpeechAPIKey,
                allowLocation : window.appConfig.ENABLE_SHARE_LOCATION,
                loadHistory: _constants_.config.loadHistory,
                messageHistoryLimit: 10,
                autoEnableSpeechAndTTS: _constants_.config.autoEnableSpeechAndTTS,
                graphLib: _constants_.config.graphLib,
                pickersConfig:{
                    showDatePickerIcon:false,
                    showDateRangePickerIcon:false,
                    showClockPickerIcon:false,
                    showTaskMenuPickerIcon:false,
                    showradioOptionMenuPickerIcon:false
                }
            };

            authToken = null;
            $scope.initialTTSEnaleDecision = chatConfig.isTTSEnabled;
            function checkForUserDetails() {
//                var appControls = $applicationService.userInfo().appControls;
//                if (appControls.isFreeDomain) {
//                    $location.path(window.appConfig.CONTEXT_PATH + '/requestbtaccess').search('isFreeDomain', 'true');
//                }
//                else {
//                    if (appControls.licenses && appControls.licenses.length > 0 && appControls.licenses[0].costCateogory === 'free' && !appControls.isTrial) {
////                        // Free Enterprise Domain
////                        //User is already created so opening saleforce url instead of bot builder's salesforce modal(requestsfbtaccess)
////                        //'requestsfbtaccess' is for signup and then calling the sales force api.
////                        var url = _constants_.buySBEndpoints[$endpoints.baseUrl];
////                        if (url && url.trim() !== '') {
////                            var userInfo = appControls.userInfo;
////                            url = url + '?userId=' + userInfo.id;
////                            var childWindow = $window.open(url, '_blank');
////                            if (!childWindow) {
////                                NotificationService.notify('Pop-up Blocker is enabled! Please add this site to your exception list.', 'info');
////                            }
////                        }
////                        else {
////                            NotificationService.notify('Something went wrong. Please try again later.', 'error');
////                        }
////                        security.logout();
////                        $route.reload();
//                        var _userId=$applicationService.userInfo().userId;
//
//                        $location.path(window.appConfig.CONTEXT_PATH + '/requestsfbtaccess').search({userId: _userId});
//                    } else {
//                        // Is Trail/Paid user
//                        $location.path(window.appConfig.CONTEXT_PATH + '/requestbtaccess');
//                    }
//                }
            }
            $scope.welcomeFormCb.selectBot=function(bot){
                if($scope.callbacks && $scope.callbacks.selectOrChangeBot){
                    $scope.callbacks.selectOrChangeBot(bot);
                  }
            };
            $scope.welcomeFormCb.showView=function(viewType){
                if($scope.callbacks && $scope.callbacks.showView){
             $scope.callbacks.showView(viewType);
            }
            };
            $scope.closeNotificationBar = function () {
                showNotificationBar = false;
                $scope.showClaimDomain = false;
            };
           

            
            $scope.welcomeFormCb.showView=function(viewType){
                if($scope.callbacks && $scope.callbacks.showView){
             $scope.callbacks.showView(viewType);
            }
            };
            $scope.closeNotificationBar = function () {
                showNotificationBar = false;
                $scope.showClaimDomain = false;
            };
         }
//------------------------------------------------------- Load function ends --------------------------------------------------------------------------//
            $rootScope.$on('botTestStart', function ($event, data, containerInfo, debugFn, debugConsoleTrigger, onNewMessageCallback, botHistoryUpdateCB, recordProgress, recordStop, _userInfo) {
                var eventInfo = {
                    $email:$applicationService.userInfo().emailPhone,
                    FirstName: $applicationService.userInfo().firstName,
                    LastName: $applicationService.userInfo().lastName,
                    "Level":"Engagement L2",
                    "Category":"Engagement L2",
                    "Sub Category":"Conversation - Storyboard",
                };
                   mixPanel.postEvent('Conversation - Talk to Bot',eventInfo);
                _botInfo = data;
                chatConfig.sesId = _userInfo.authObj.sesId;
                // chatConfig.mixPanel =  mixPanel;
                localStorage.setItem('currentBotLanguage', $workflowService.currentLanguage()); // Passing language to SDK
                if (_botInfo) {
                    chatConfig.botOptions.botInfo = _botInfo;
                    chatConfig.botOptions.speechSocketUrl = 'wss://speech.kore.ai/stream/kore/decode';
                    chatConfig.botOptions.ttsSocketUrl = 'wss://speech.kore.ai/tts/ws';
                    chatConfig.botOptions.koreSpeechAPIUrl = window.appConfig.SDK_SPEECH_URL;
                }
                if (containerInfo !== undefined) {
                    chatConfig.container = containerInfo;
                    chatConfig.DisableDragResize = true;
                } else {
                    chatConfig.container = 'body';
                    chatConfig.DisableDragResize = false;
                }
                if (!chatConfig.botOptions) {
                    chatConfig.botOptions = {};
                }
                chatConfig.botIcon = $workflowService.selectedStream().icon;
                chatConfig.allowGoogleSpeech = window.appConfig.ENABLE_GOOGLE_SPEECH;
                if (window.appConfig.ON_PREMISE) {
                    chatConfig.googleSpeechKey = window.appConfig.GOOGLE_SPEECH_API_KEY;
                }
                chatConfig.botOptions.userIdentity = JSONPath({ json: localstore.getAuthData(), path: '$..currentAccount.userInfo.emailId' })[0];
                chatConfig.botOptions.recorderWorkerPath = env_conf['speech-worker-url'];
                chatConfig.isSendButton = false;
                if ($scope.initialTTSEnaleDecision) {
                    chatConfig.isTTSEnabled = (_botInfo.defaultLanguage === 'en') ? true : false;
                }
                /* // this check only for sdk
                if (_botInfo) {
                    var _speechEnabledForBot = false;
                    for(var i=0; i<_botInfo.channels.length;i++) {
                        if(_botInfo.channels[i].type === "rtm") {
                            _speechEnabledForBot = _botInfo.channels[i].sttEnabled || false;
                            break;
                        }
                    }
                    if(chatConfig.isTTSEnabled) {
                        chatConfig.isTTSEnabled = _speechEnabledForBot;
                    }
                    if(chatConfig.isSpeechEnabled) {
                        chatConfig.isSpeechEnabled = _speechEnabledForBot;
                    }
                }
                */
                destroyApp();
                if($rootScope.isConversationTesting) {
                    chatConfig.isConversationTesting = $rootScope.isConversationTesting;
                } else {
                    chatConfig.isConversationTesting = false;
                }   
                var logger_config = {
                    botName: botOptions.botInfo.name,
                    botId: botOptions.botInfo._id
                };
                _loggerInstance = new KoreLogger(logger_config);
                var _chatWinConfig = {
                    koreLogger: _loggerInstance
                };
                $rootScope.$broadcast('loggerInstance', _loggerInstance);
                var koreBot = koreBotChat(_chatWinConfig, i18n);
                $rootScope.koreBot = koreBot;
                chatApp = koreBot.show(chatConfig);
                //chatApp = koreBotChat().show(chatConfig);
                if (typeof (debugConsoleTrigger) === 'function') {
                    chatApp.addListener('debugConsole', debugConsoleTrigger);
                }
                if (typeof (recordProgress) === 'function') {
                    chatApp.addListener('recordInProgress', recordProgress);
                }
                if (typeof (recordStop) === 'function') {
                    chatApp.addListener('recordStop', recordStop);
                }



                var _queue = [];
                var _serviceInProgress = false;
                function getContextObj() {
                    if (_queue.length && !_serviceInProgress) {
                        var _event = _queue[_queue.length - 1];
                        var _contextId = _event.contextId;
                        _queue = [];
                        _serviceInProgress = true;

                        BTStreamsService.getContextById(_contextId, $workflowService.selectedStream()._id)
                            .then(function (res) {
                                _serviceInProgress = false;
                                _event.context = res.data;
                                debugFn(_event);
                                if (_queue.length) {
                                    var lasteventUpdateObj = _queue[_queue.length - 1];
                                    var eventUpdate = moment(lasteventUpdateObj.updatedOn);
                                    var lastUpdate = moment(res.data.updatedOn);
                                    //comparing updatedOn and  context objects id aswell 
                                    if (_contextId !== lasteventUpdateObj.contextId || eventUpdate.isAfter(lastUpdate)) {
                                        getContextObj();
                                    }

                                }

                            }, function (res) {
                                _serviceInProgress = false;
                            });
                    }
                }
                var debugFunInstance = function (data) {
                    if (data.contextId && data.type === "contextUpdate") {
                        // console.log("1:" + data.contextId);
                        _queue.push(data);
                        // console.log("2:" + JSON.stringify(_queue));
                        getContextObj();
                    } else {
                        debugFn(data);
                    }

                };
                if (debugFn) {
                    chatApp.addListener('debugLog', debugFunInstance);
                }
                if (typeof (onNewMessageCallback) === 'function') {
                    chatApp.addListener('newMessageEvent', onNewMessageCallback);
                }

                if (typeof (botHistoryUpdateCB) === 'function') {
                    chatApp.addListener('botHistoryUpdate', botHistoryUpdateCB);
                }

                chatApp.addListener("message", function (msg) {
                    console.log("Received Message::", msg.data);
                    // Converting JSON string to object
                    var dataObj = JSON.parse(msg.data);
                    //differ user message & bot response check message type
                    if (dataObj.from === "bot" && dataObj.type === "bot_response") {
                        // Bot sends a message to you
                        console.log(dataObj);
                    }
                    // if(tempData.from === "self" && tempData.type === "user_message") {
                    //     // If you are logged in on several devices at the same time & sent a message to same Bot, it will appear on every device
                    // }
                });
                chatApp.addListener("startTraining", function () {
                    $rootScope.$broadcast('getProgressDockStatus');
                    BTStreamsService.trainUtterances($workflowService.selectedStream()._id)
                        .then(function (res) {
                            NotificationService.notify(i18n.i18nString('bot_train'), "info");
                            $rootScope.$emit('triggerAutoTrainStatusPoll');
                        },
                            function (err) {
                                if (err.data.errors.length > 0) {
                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                } else {
                                    NotificationService.notify(i18n.i18nString('bot_train_failure'), "error");
                                }
                            });
                });

            });

            $rootScope.$on('botTestEnd', function ($event) {
                destroyApp();
            });
            $rootScope.$on('downloadChatJson', function ($event) {
                var chatData = JSON.stringify(_loggerInstance.getData());
                $rootScope.recordedChatData = chatData;
                download('TestSuit.json', chatData);
                if(_loggerInstance.newTestSuit){
                    _loggerInstance.newTestSuit();
                }
            });
            $rootScope.$on('closeDownloadModal', function ($event) {
                // _loggerInstance.isRecording = true;
                $('.record-btn').removeClass('record-btn').addClass('record-stop');
            });
            $rootScope.$on('triggerAutoTrainStatusPoll', function ($event) {
                stopAutoTrainStatusPoll();
                var _trainStatus = pollTrainStatus(10);
                setTimeout(function () {
                    clearTimeout(_trainStatus);
                    _trainStatus = null;
                    $scope._trainStatus = pollTrainStatus(20000);
                }, 10);
            });
            var autoTrainStatusHandler = $rootScope.$on('stopAutoTrainStatusPoll', function ($event) {
                stopAutoTrainStatusPoll();
            });

            function stopAutoTrainStatusPoll() {
                if ($scope._trainStatus) {
                    clearTimeout($scope._trainStatus);
                    $scope._trainStatus = null;
                }
            }
            function pollTrainStatus(timeout) {
                return setInterval(function () {
                    BTStreamsService.autoTrainStatus($workflowService.selectedStream()._id)
                        .then(function (res) {
                            if( res && res.data){
                                if(res.data.trainingStatus === "Finished") {
                                    NotificationService.notify(i18n.i18nString('bot_training_completed'), "success");
                                    stopAutoTrainStatusPoll();
                                    $rootScope.$emit('MLUtterencesTrainFinished');
                                    $rootScope.$emit('MLScoreUtterencesTrainFinished');
                                    $rootScope.$emit('TestTrainUtterencesTrainFinished');
                                    $rootScope.$emit('IntentUtterencesTrainFinished');
                                    $rootScope.$emit('SmallTalkTrainFinished');
                                    $rootScope.$emit('patternTrainFinished');
                                    $rootScope.$broadcast('SynonymsTrainFinished');
                                    $rootScope.$emit('linkedBotTrainingFinished');
                                    $rootScope.$emit('isMlInSyncWithEntityRules');
                                }
                                else if(res.data.trainingStatus === "Failed") {
                                    NotificationService.notify(i18n.i18nString('bot_training_failed'), "error");
                                    stopAutoTrainStatusPoll();
                                    $rootScope.$emit('MLUtterencesTrainFailed');
                                    $rootScope.$emit('MLScoreUtterencesTrainFailed');
                                    $rootScope.$emit('IntentUtterencesTrainFailed');
                                    $rootScope.$emit('SmallTalkTrainFailed');
                                    $rootScope.$emit('patternTrainFailed');
                                    $rootScope.$broadcast('getProgressDockStatus');
                                    $rootScope.$broadcast('SynonymsTrainFailed');
                                    $rootScope.$emit('linkedBotTrainingFailed');
                                    $rootScope.$emit('isMlInSyncWithEntityRules');
                                }
                            }
                            else{ // if training status information not available
                                NotificationService.notify(i18n.i18nString('bot_training_failed'), "error");
                                stopAutoTrainStatusPoll();
                                $rootScope.$emit('MLUtterencesTrainFailed');
                                $rootScope.$emit('IntentUtterencesTrainFailed');
                                $rootScope.$emit('SmallTalkTrainFailed');
                                $rootScope.$broadcast('getProgressDockStatus');
                                $rootScope.$broadcast('SynonymsTrainFailed');
                            }
                        },
                        function (err) {
                            stopAutoTrainStatusPoll();
                            var _msg = i18n.i18nString('error_on_fetching_bot_train_status');
                            if (err.data && err.data.errors && err.data.errors.length > 0) {
                                _msg = err.data.errors[0].msg;
                            }
                            NotificationService.notify(_msg, "error");
                            $rootScope.$emit('MLUtterencesTrainFailed');
                            $rootScope.$emit('IntentUtterencesTrainFailed');
                        });
                }, timeout);
            }
            $rootScope.$on('triggerSpeechTrainStatusPoll', function ($event) {
                stopSpeechTrainStatusPoll();
                var _trainStatus = pollSpeechTrainStatus(10);
                setTimeout(function () {
                    clearTimeout(_trainStatus);
                    _trainStatus = null;
                    $scope._speechTrainStatus = pollSpeechTrainStatus(300000);
                }, 10);
            });
            $rootScope.$on('stopSpeechTrainStatusPoll', function ($event) {
                stopSpeechTrainStatusPoll();
            });
            function stopSpeechTrainStatusPoll() {
                if ($scope._speechTrainStatus) {
                    clearTimeout($scope._speechTrainStatus);
                    $scope._speechTrainStatus = null;
                }
            }
            function pollSpeechTrainStatus(timeout){
                return setInterval(function () {
                    BTStreamsService.trainBotSpeechStatus($workflowService.selectedStream()._id)
                        .then(function (res) {
                            if(res && res.data && res.data.status === "TRAINED") {
                                NotificationService.notify(i18n.i18nString('bot_training_completed'), "success");
                                stopSpeechTrainStatusPoll();
                                $rootScope.$emit('MLSpeechTrainFinished');
                            }
                            else if(res && res.data && res.data.status === "ERROR" || res.data.status === "AUTHORIZATION_CHECK_FAILURE" || res.data.status === "INVALID_ACCESS_TOKEN") {
                                NotificationService.notify(i18n.i18nString('bot_speech_training_failed'), "error");
                                stopSpeechTrainStatusPoll();
                                $rootScope.$emit('MLSpeechTrainFailed');
                            }
                        },
                        function (err) {
                            stopSpeechTrainStatusPoll();
                            var _msg = i18n.i18nString('error_on_fetching_speech_train_status');
                            if (err.data && err.data.errors && err.data.errors.length > 0) {
                                _msg = err.data.errors[0].msg;
                            }
                            NotificationService.notify(_msg, "error");
                            $rootScope.$emit('MLSpeechTrainFailed');
                        });
                }, timeout);
            }
          $('#reAuthBtnOk').click(function () {
                invalidateLocalStore();
            });
          function invalidateLocalStore() {
                var _usrInfo = localstore.getAuthData();
                localstore.removeSelectedAccount();
                localstore.setAuthData({});
                if (_usrInfo && _usrInfo.currentAccount && _usrInfo.currentAccount.userInfo && _usrInfo.currentAccount.userInfo.emailId) {
                    var _oldEmail = {'email': _usrInfo.currentAccount.userInfo.emailId};
                    window.localStorage.setItem('emailIdStorage', JSON.stringify(_oldEmail));
                }
                window.location.reload(true);
                //window.location.href = window.location.origin + window.appConfig.CONTEXT_PATH + '?showLogin=true';
            }
            window.invalidateLocalStore = invalidateLocalStore;
            function showMaxRequestLimit(response){
                var _msg2 = "";
                if (response && response.data && response.data.errors && response.data.errors.length && response.data.errors[0] &&  response.data.errors[0].msg){
                 _msg2 = response.data.errors[0].msg;
                }
                var linkObj = {
                    link: "https://developer.kore.ai/docs/bots/bot-settings/bot-management/subscription-plans/",
                    text:"here",
                    okText:i18n.i18nString('ok')
                };
                NotificationService.alert(_msg2 , function () {
                }, {linkObj:linkObj});
            }
            window.showMaxRequestLimit = showMaxRequestLimit;
          $scope.showWelcomeForm = function (guideId) {
             if(!onBoardingFlow.onboardingJourneyStarted) {
                onBoardingFlow.onboardingJourneyStarted =  true;
                var eventInfo = {
                    $email:$applicationService.userInfo().emailPhone,
                    FirstName: $applicationService.userInfo().firstName,
                    LastName: $applicationService.userInfo().lastName,
                    Category:"Onboarding",
                    SubCategory:"Welcome Message",
                    "Event Description":'When the user lands on the welcome message with the options of either collaborating on an existing prooject vs creating a virtual assistant vs creating process app',
                };
                   mixPanel.postEvent('User Onboarding - Welcome',eventInfo);
              }
               $scope.welcomeFormCb.selectAccount = $scope.selectAccount;
                if(guideId){
                    $scope.welcomeFormCb.guideId=guideId;
                  }else{
                    $scope.welcomeFormCb.guideId=null;
                  }
                  if($(".bt-welcome-modal").length){
                    $(".bt-welcome-modal").remove();
                }
                var modalInstance=$modal.open({
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bt-welcome-form/bt-welcome.html',
                    controller: 'BTWelcomeForm',
                    windowClass: 'bt-welcome-modal',
                    backdrop: 'static',
                    size :'lg',
                    resolve: {
                        config: function () {
                            return {
                                    component: $scope.welcomeFormCb||{}
                            };
                    }
                    }
                });
               setTimeout(function(){
                $(".bt-welcome-modal").css({"z-index":"1050"});
               },500);
            };
            $scope.startTourGuide = function () {
                $modal.open({
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bt-guided-tour/bt-guided-tour.html',
                    controller: 'BTGuidedTour',
                    windowClass: 'bt-guided-modal',
                    backdrop: 'static',
                    keyboard: false,
                    resolve: {
                        config: function () {
                            return {
                                    component: $scope.welcomeFormCb||{}
                            };
                    }
                    }
                });

            };
            //$scope.welcomeFormCb.startTourGuide= $scope.startTourGuide;
            $rootScope.$on('startTourGuide',$scope.startTourGuide);

           function getAccessToken() {
                var authObj = $translator.getAuthObj();
                authToken = authObj.token_type + " " + authObj.accessToken;
                return authToken;
            }

            function getProcessAppsData() {

                BTProcessAppDataService.getProcessAppsData()
                    .then(function (res) {
                        $workflowService.processAppsData(res.data.pfApplications);
                        $rootScope.$emit('updateProcessData');
                    }, function (err) {
                        $workflowService.processAppsData([]);
                    });
            }
            function accept() {

                // $scope.apiCallInProgress = true;
    
                var url = 'mp.user.acceptbtlicense';
                var params = {
                    userId: $applicationService.userInfo().userId
                };
    
                $translator.translate(url, params).then(
                    function(){
                        // var userInfo = {
                        //     $email:$applicationService.userInfo().emailPhone,
                        //     FirstName: $applicationService.userInfo().firstName,
                        //     LastName: $applicationService.userInfo().lastName,
                        // };
                        // mixPanel.postEvent('License Agreement Accepted',userInfo);
                        // $scope.apiCallInProgress = false;
                        // window.location=window.appConfig.CONTEXT_PATH;
                    },
                    function(){
                        // $scope.apiCallInProgress = false;
                    }
                );
            }
             function getSeedData() {

                    var url;

                    url = env_conf['components-source'];

                    BTSeedDataService.getSeedData()
                        .then(function (res) {
                            $workflowService.seedData(res.data);
                            languageConfig.prepareLanguage();
                        }, function (err) {
                            $workflowService.seedData([]);
                        });

                    $http.get(url + 'config/templates.json')
                        .then(function (res) {
                            $workflowService.templates(res.data);
                        });

                    $rootScope.changeLanguage("en_us");
                }
            function checkForIsBotsonBoarded() {
                // $scope.showWelcomeForm();
                window.whatfixKoreData = {};
                var localOnBoarding=false;
                var koreOnBoardingData=  localStorage.getItem('koreOnBoarding');
                try {
                    if(koreOnBoardingData){
                        koreOnBoardingData=JSON.parse(koreOnBoardingData);
                        if(koreOnBoardingData.status==='done'){
                            localOnBoarding=true;
                        }
                    }
                } catch (e) {
                    console.error('error parsing koreOnBoarding');
                }
                if (!$rootScope.koreUserInfo.isBotsOnboarded && !localOnBoarding) {
                    $scope.welcomeFormCb.guideId = null;
                    $scope.showOnboarding = true;
                } else {
                    window.whatfixKoreData.isBotsOnboarded = false;
                }
            }
         $rootScope.$on('security:authenticated', function ($event) {
                 console.log('security:authenticated');
                if(window.appConfig.SESSION_VALIDITY_POLLING){
                    jsEvents.securityAuthenticationStatus();
                }
                var userData = $applicationService.userInfo().appControls.userInfo;
                var appControls = $applicationService.userInfo().appControls;

                $rootScope.koreUserInfo = userData;
                if ($rootScope.koreUserInfo !== 'no-avatar') {
                    $rootScope.profileImgLinkPrefix = $endpoints.baseUrl + $endpoints.apiPreFix + "/getMediaStream/profilePictures/" + $applicationService.userInfo().userId + '/r_64x64_profile.png';
                    $rootScope.profileImgLinkPrefix = $rootScope.profileImgLinkPrefix + '?v=1.1' + Math.random() * 1000;
                }
//                if (!userData.isBTAccessAllowed) {
//                    checkForUserDetails();
//                }else
//else if (!userData._isBTLicenseAccepted) {
//                    $location.path(window.appConfig.CONTEXT_PATH + '/btlicenseupdate');
//                }  
                if (!userData.isBTLicenseAccepted || (appControls.isBillingEnabled && !userData.isBTLicenseAccepted_update)) {
                    // accept(); // accepting License Automatically
                    if(!userData.isBTLicenseAccepted){
                        accept();
                    } else if(!userData.isBTLicenseAccepted_update){
                        $rootScope.licenseUpdate =  true;
                    }
                    
                    // $location.path(window.appConfig.CONTEXT_PATH + '/acceptbtlicense');
                } 
                // else 
                if (!appControls.associatedAccounts.length || appControls.isSelectAccountFlow) {
                    $location.path(window.appConfig.CONTEXT_PATH + '/accountsetup');
                } else {                    
                    botOptions.bearer = getAccessToken;
                    getSeedData();
                    $location.path(window.appConfig.CONTEXT_PATH);
                    $scope.securityAuthenticated = true;
                    $scope.mainControlDependencies.securityAuthenticated =  true;
                    // checkForIsBotsonBoarded();
                    setTimeout(function(){
                        getProcessAppsData();
                    },2000);
                    setTimeout(function(){
                        checkOnboarding();
                    },500);
                    setTimeout(function(){
                        $rootScope.$broadcast('security:loadbotshome', null);
                    },200);
                    
                }
//                if (showNotificationBar && !$rootScope.isFreeDomain && !$rootScope.licenseType) {
//                    $scope.claimDomainMsg = 'Claim your domain, to manage bots and user within your enterprise. ';
//                    $scope.claimDomainLink = $location.host() + '/admin';
//                    $scope.showClaimDomain = true;
//                } else {
                    $scope.showClaimDomain = false;
//                }
                getDomain();
            });
            $scope.initialTTSEnaleDecision = chatConfig.isTTSEnabled;
            // $rootScope.$on('botTestStart', function ($event, data, containerInfo, debugFn, debugConsoleTrigger, onNewMessageCallback,botHistoryUpdateCB,recordProgress,recordStop,_userInfo) {
            //     _botInfo = data;
            //     chatConfig.sesId = _userInfo.authObj.sesId;
            //     localStorage.setItem('currentBotLanguage', $workflowService.currentLanguage()); // Passing language to SDK
            //     if (_botInfo) {
            //         chatConfig.botOptions.botInfo = _botInfo;
            //         chatConfig.botOptions.speechSocketUrl = 'wss://speech.kore.ai/stream/kore/decode';
            //         chatConfig.botOptions.ttsSocketUrl = 'wss://speech.kore.ai/tts/ws';
            //         chatConfig.botOptions.koreSpeechAPIUrl = window.appConfig.SDK_SPEECH_URL;
            //     }
            //     if (containerInfo !== undefined) {
            //         chatConfig.container = containerInfo;
            //         chatConfig.DisableDragResize = true;
            //     } else {
            //         chatConfig.container = 'body';
            //         chatConfig.DisableDragResize = false;
            //     }
            //     if (!chatConfig.botOptions) {
            //         chatConfig.botOptions = {};
            //     }
            //     chatConfig.botIcon  = $workflowService.selectedStream().icon;
            //     chatConfig.allowGoogleSpeech = window.appConfig.ENABLE_GOOGLE_SPEECH;
            //     if(window.appConfig.ON_PREMISE) {
            //         chatConfig.googleSpeechKey = window.appConfig.GOOGLE_SPEECH_API_KEY;
            //     }
            //     chatConfig.botOptions.userIdentity = JSONPath({json: localstore.getAuthData(), path: '$..currentAccount.userInfo.emailId'})[0];
            //     chatConfig.botOptions.recorderWorkerPath = env_conf['speech-worker-url'];
            //     chatConfig.isSendButton = false;
            //     if($scope.initialTTSEnaleDecision) {
            //         chatConfig.isTTSEnabled = (_botInfo.defaultLanguage === 'en')?true:false;
            //     }
            //     /* // this check only for sdk
            //     if (_botInfo) {
            //         var _speechEnabledForBot = false;
            //         for(var i=0; i<_botInfo.channels.length;i++) {
            //             if(_botInfo.channels[i].type === "rtm") {
            //                 _speechEnabledForBot = _botInfo.channels[i].sttEnabled || false;
            //                 break;
            //             }
            //         }
            //         if(chatConfig.isTTSEnabled) {
            //             chatConfig.isTTSEnabled = _speechEnabledForBot;
            //         }
            //         if(chatConfig.isSpeechEnabled) {
            //             chatConfig.isSpeechEnabled = _speechEnabledForBot;
            //         }
            //     }
            //     */
            //     destroyApp();
            //     var logger_config = {
            //         botName: botOptions.botInfo.name,
            //         botId: botOptions.botInfo._id
            //     };
            //      _loggerInstance = new KoreLogger(logger_config);
            //     var _chatWinConfig={
            //         koreLogger:_loggerInstance
            //     };
            //     $rootScope.$broadcast('loggerInstance',_loggerInstance);
            //     var koreBot = koreBotChat(_chatWinConfig,i18n);
            //     $rootScope.koreBot=koreBot;
            //     chatApp = koreBot.show(chatConfig);
            //     //chatApp = koreBotChat().show(chatConfig);
            //     if (typeof(debugConsoleTrigger) === 'function') {
            //         chatApp.addListener('debugConsole', debugConsoleTrigger);
            //     }
            //     if( typeof(recordProgress) === 'function'){
            //         chatApp.addListener('recordInProgress',recordProgress);
            //     }
            //     if(typeof(recordStop) === 'function'){
            //         chatApp.addListener('recordStop',recordStop);
            //     }



            //     var _queue=[];
            //     var _serviceInProgress=false;
            //     function getContextObj() {
            //         if (_queue.length && !_serviceInProgress) {
            //             var _event=_queue[_queue.length - 1];
            //             var _contextId =_event.contextId;
            //             _queue = [];
            //             _serviceInProgress=true;

            //             BTStreamsService.getContextById(_contextId, $workflowService.selectedStream()._id)
            //                     .then(function (res) {
            //                         _serviceInProgress=false;
            //                         _event.context=res.data;
            //                         debugFn(_event);
            //                         if (_queue.length) {
            //                             var lasteventUpdateObj=_queue[_queue.length - 1];
            //                             var eventUpdate = moment(lasteventUpdateObj.updatedOn);
            //                             var lastUpdate = moment(res.data.updatedOn);
            //                             //comparing updatedOn and  context objects id aswell 
            //                             if (_contextId!==lasteventUpdateObj.contextId || eventUpdate.isAfter(lastUpdate)) {
            //                                 getContextObj();
            //                             }

            //                         }

            //                     }, function (res) {
            //                         _serviceInProgress=false;
            //                     });
            //         }
            //     }
            //     var debugFunInstance = function (data) {
            //         if (data.contextId && data.type === "contextUpdate") {
            //             console.log("1:"+data.contextId);
            //             _queue.push(data);
            //             console.log("2:"+JSON.stringify(_queue));
            //             getContextObj();
            //         } else {
            //             debugFn(data);
            //         }

            //     };
            //     if (debugFn) {
            //         chatApp.addListener('debugLog', debugFunInstance);
            //     }
            //     if(typeof(onNewMessageCallback) === 'function') {
            //         chatApp.addListener('newMessageEvent', onNewMessageCallback);
            //     }

            //     if (typeof (botHistoryUpdateCB) === 'function') {
            //         chatApp.addListener('botHistoryUpdate', botHistoryUpdateCB);
            //     }

            //     chatApp.addListener("message",function(msg){
            //         console.log("Received Message::",msg.data);
            //         // Converting JSON string to object
            //         var dataObj = JSON.parse(msg.data);
            //         //differ user message & bot response check message type
            //         if(dataObj.from === "bot" && dataObj.type === "bot_response") {
            //             // Bot sends a message to you
            //             console.log(dataObj);
            //         }
            //         // if(tempData.from === "self" && tempData.type === "user_message") {
            //         //     // If you are logged in on several devices at the same time & sent a message to same Bot, it will appear on every device
            //         // }
            //     });
            //     chatApp.addListener("startTraining",function(){
            //         $rootScope.$broadcast('getProgressDockStatus');
            //         BTStreamsService.trainUtterances($workflowService.selectedStream()._id)
            //         .then(function (res) {
            //             NotificationService.notify("Bot training is initiated..", "info");
            //             $rootScope.$emit('triggerAutoTrainStatusPoll');
            //         },
            //         function (err) {
            //             if (err.data.errors.length > 0) {
            //                 NotificationService.notify(err.data.errors[0].msg, "error");
            //             } else {
            //                 NotificationService.notify("Problem in training the bot", "error");
            //             }
            //         });
            //     });
            // });

            // $rootScope.$on('botTestEnd', function ($event) {
            //     destroyApp();
            // });

            $scope.$on('$destroy',function(){
                clearInterval($scope.checkingOnboarding);
                autoTrainStatusHandler();
            });

            function destroyApp() {
                if (chatApp && chatApp.destroy) {
                    _loggerInstance.isRecording = false;
                     if($('.talkToBot').hasClass('minimized-bot')){
                            $('.talkToBot').removeClass('minimized-bot');
                     }
                     chatApp.destroy();
                    //  setTimeout(function() {
                    //     $rootScope.isConversationTesting = false;
                    // }, 10);
                }
            }
            $rootScope.$on('closeProgressModal',function($event){
                chatApp.closeModal(chatConfig);
            });
            $rootScope.$on('minimizeBot',function($event){
                chatApp.minimizeBot(chatConfig);
            });
            $rootScope.$on('startRecording',function($event){
                chatApp.startRecording(chatConfig);
            });
            $rootScope.$on('stopRecording',function($event){
                chatApp.stopRecording(chatConfig);
            });


         function getDomain() {
                var _usrInfo = $applicationService.userInfo().koreUserInfo;
                var emailID = _usrInfo.emailId;
                var domainName = emailID.split("@");
                var domain = domainName[1].split(".");
                $scope.userDomain = domain[0];
                if($scope.userDomain && $scope.userDomain.toLowerCase()==='kore'){
                    $('body').addClass('kore-user');
                }else{
                    $('body').addClass('non-kore-user');  
                }
            }
            function assertion(options, callback) {
                var authData;
                try {
                    authData = JSON.parse(localStorage.getItem("ls.bt.userInfo"));
                } catch (ex) {
                    security.logout();
                }

                $translator.translate('bt.post.sts', {})
                        .then(function (res) {
                            var data = res.data;
                            options.assertion = data.jwt;
                            options.chatHistory = chatApp.chatHistory;
                            options.botDetails = chatApp.botDetails;
                            callback(null, options);
                        });
            }

            function download(filename,data){
                   if (navigator.msSaveBlob) {
                        var blob = new Blob([data], { type: 'data:text/plain;charset=utf-8' });
                        return window.navigator.msSaveOrOpenBlob(blob, filename);
                     } else {
                        var element = document.createElement('a');
                        element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(data));
                        element.setAttribute('download', filename);

                        element.style.display = 'none';
                        document.body.appendChild(element);

                        element.click();

                        document.body.removeChild(element);
                    }
            }
        $rootScope.$on('loadMainCtrl', function ($event) {  
            console.log('loadMainCtrl');
            $scope.mainControlDependencies.translationsLoaded =  true;
            var element = angular.element( document.querySelector( '.landingPleaseWait' ) );
            var language ;
            language = localStorage.getItem('queryParamLang');
            // if(language){
                // element.html('');
                // element.append(i18n.i18nString('pleasewait')+"....");   // need to check 
            // }
            load();
        });
                   
        }
    ]);

    (function ($) {

        $('#xUpgradeBtnCancel').click(function () {
            window.location.href = window.location.origin + '?showLogin=true';
        });

        $('#upgradeBtnCancel').click(function () {
            window.location.href = window.location.origin + '?showLogin=true';
        });

        $('#xTermsBtnCancel').click(function () {
            window.location.href = window.location.origin + '?showLogin=true';
        });

        $('#upgradeBtn').click(function () {
            // window.location.href = window.location.origin+'/admin/#_accountPayment';
            if (window.__licenceType === 'individual') {
                window.location.href = window.location.origin + '#_messages?info=account';
            } else {
                window.location.href = window.location.origin + '?showLogin=true';
            }
        });

        $("#reloadBtnOk").click(function () {
            window.localStorage.kore_builder_version = window._buliderVersion;
            window.location.reload(true);
        });

        $.fn.hasScrollBar = function () {
            return this.get(0) ? this.get(0).scrollHeight > this.innerHeight() : false;
        };


    })(jQuery);

    (function lodashApiAdditions() {

        /**
         * @name  bounceIt
         * @description Returns the first parameter with which this method is called.
         * @param {?Object|?number|?string} value
         */

        _.bounce = function (value) {
            return value;
        };

        /**
         * @name  addProps
         * @description adds properties to the destination object if the given
         *  condition is true.
         *  @param {Boolean} condition - A Boolean Expression representing the condition.
         *  @param {Object} dest - on to which source properties has to be merged.
         *  @param {Object} source - the source object whose properties are to be merged on to destination object.
         */

        _.addProps = function (condition, dest, source) {
            if (condition) {
                _.merge(dest, source);
            }
            return dest;
        };

        /**
         * @name  delProps
         * @description deletes properties from the destination object if the given
         *  condition is true.
         *  @param {Boolean} condition - A Boolean Expression representing the condition.
         *  @param {Object} dest - from which source properties has to be removed if they exists.
         *  @param {Object} source - the source object whose properties are to be removed from the
         *                  destination object if they exists.
         */

        _.delProps = function (condition, dest, source) {
            if (condition) {
                Object.keys(source)
                    .map(function (key) {
                        delete dest[key];
                    });
            }
            return dest;
        };

    }());

})(angular);


;(function(ng) {

    'use strict';

    var btBuilderApp = ng.module('BuilderApp');

    btBuilderApp.config(['$routeProvider', function($routeProvider) {
            
            var originalWhen = $routeProvider.when;

            $routeProvider.when = function (path, route) {
                var jslintDummyVar=route.resolve || (route.resolve = {});
                angular.extend(route.resolve, {
                    dependents: function (appResover) {
                        return appResover.resolveDependencies();
                    }
                });

                return originalWhen.call($routeProvider, path, route);
            };
            $routeProvider
            
                // builder home
                    .when(window.appConfig.CONTEXT_PATH ? window.appConfig.CONTEXT_PATH : "/", {
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bots-landing-forms/bots-home/bots-home.html',
                        controller: 'botsHomeCtrl'
                    })

                .when(window.appConfig.CONTEXT_PATH+'/login', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-login/bt-login.html',
                    controller: 'BTLoginCtrl',
                    reloadOnSearch: false
                })
                .when(window.appConfig.CONTEXT_PATH+'/info/:infoType', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-login/templates/bt-information.html',
                    controller: 'BTInfoCtrl',
                })
                .when(window.appConfig.CONTEXT_PATH+'/requestsfbtaccess', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-login/templates/sf-bt-request-access.html',
                    controller: 'STBTRequestAccessCtrl'
                })
                .when(window.appConfig.CONTEXT_PATH+'/requestbtaccess', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-login/templates/bt-request-access.html',
                    controller: 'BTRequestAccessCtrl'
                })
                .when(window.appConfig.CONTEXT_PATH+'/acceptbtlicense', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-login/templates/bt-accept-license.html',
                    controller: 'BTAcceptLicenseCtrl'
                })
                .when(window.appConfig.CONTEXT_PATH + '/accountsetup', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/account-setup/account-setup.html',
                    controller: 'BTAccountSetupCtrl'
                })                
                .when(window.appConfig.CONTEXT_PATH+'/streamcreate',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-stream-create/bt-stream-create.html',
                    controller:'BTStreamCreateCtrl'
                })
                
                .when(window.appConfig.CONTEXT_PATH+'/flowTask/new',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-flowtask-create/bt-flowtask-create.html',
                    controller:'BTFlowTaskCreateCtrl'
                })
                
                .when(window.appConfig.CONTEXT_PATH+'/flowTask/edit/:flowtaskID',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-flowtask-edit/bt-flowtask-edit.html',
                    controller:'BTFlowTaskEditCtrl'
                })
                
                .when(window.appConfig.CONTEXT_PATH+'/flowTask/view/:flowtaskID',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-flowtask-view/bt-flowtask-view.html',
                    controller:'BTFlowTaskViewCtrl'
                })
                
                .when(window.appConfig.CONTEXT_PATH+'/knowledgecreate',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-knowledge-create/bt-knowledge-create.html',
                    controller:'BTKnowledgeCreateCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/knowledge/:displayMode/:knowledgeID',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-knowledge-create/bt-knowledge-create.html',
                    controller:'BTKnowledgeCreateCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/streamedit/:streamId',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-stream-edit/bt-stream-edit.html',
                    controller:'BTStreamEditCtrl'
                })
                
                .when(window.appConfig.CONTEXT_PATH+'/utterances/:streamId',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/utterances-module/utterances-module.html',
                    controller:'UtterancesModuleCtrl'
                })
                  .when(window.appConfig.CONTEXT_PATH+'/patterns/:streamId',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/patterns-module/patterns-module.html',
                    controller:'PatternsModuleCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/synonyms/:streamId',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/synonyms-module/synonyms-module.html',
                    controller:'SynonymsModuleCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/new', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-wf-create/bt-wf-create.html',
                    controller: 'BTWFCreateCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/nlp/bots/:botId/chatsettings',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-chat-settings/bt-chat-settings.html',
                    controller:'BTChatSettings'
                })

                // .when('/bt/stream/:streamId/channel', {
                //     templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bot-forms/channel-forms/bot-channels-form.html',
                //     controller: 'botChannelsController'
                // })

                .when(window.appConfig.CONTEXT_PATH+'/stream/:streamId/channel/:channelId', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bot-forms/channel-forms/bot-channels-form.html',
                    controller: 'botChannelsController'
                })

                .when(window.appConfig.CONTEXT_PATH+'/stream/:streamId/new/channel/:createChannel', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bot-forms/channel-forms/bot-channels-form.html',
                    controller: 'botChannelsController'
                })

				.when(window.appConfig.CONTEXT_PATH+'/:resourceType/:resourceId/action/:action',{
					templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-wf-edit/bt-wf-edit.html',
                    controller: 'BTWFEditCtrl'
				})

                .when(window.appConfig.CONTEXT_PATH+'/:resourceType/:resourceId/map/:mapId', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-wf-mapping/bt-wf-mapping.html',
                    controller: 'BTWFMappingCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/:resourceType/:resourceId/versionHistory', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-resource-versions/bt-resource-versions.html',
                    controller: 'BTResourceVersionsCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/:taskType/:taskId/logs',{ // taskId can be either actionId or alertId
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-wf-logs-view/bt-wf-logs-view.html',
                    controller  : 'BTWfLogsViewCtrl'
                })
                .when(window.appConfig.CONTEXT_PATH+'/bot/solution/install',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-solution-install/bt-solution-install.html',
                    controller  : 'BTSolutionInstall'
                })
                    .when(window.appConfig.CONTEXT_PATH+'/botpublish', {
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-bot-publish/bt-bot-publish.html',
                        controller: 'BTBotPublishCtrl'
                    })
                .when(window.appConfig.CONTEXT_PATH+'/:resourceType/:resourceId/:flowtype', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-resource-view/bt-resource-view.html',
                    controller: 'BTResourceViewCtrl'
                })

                .when(window.appConfig.CONTEXT_PATH+'/bot/changelog',{
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-changelog/bt-changelog.html',
                    controller: 'BTChangeLogCtrl'
                })

                

                .when(window.appConfig.CONTEXT_PATH+'/createtaskoverlay', {
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/components/task-create-overlay/task-create-overlay.html',
                    controller  : 'taskCreateOverlayController'
                })

                .otherwise({
                    redirectTo: window.appConfig.CONTEXT_PATH ? window.appConfig.CONTEXT_PATH : "/"
                });

        }]);

})(angular);


;(function(ng){

    'use strict';

    ng.module("factories", []);

})(angular);

;(function (ng) {

    'use strict';

    ng.module("factories")
        .factory("builderUtility", function ($timeout) {

            var _builderUitility = {

                "textToHtml": function (input) {
                    input = input || "";
                    input = input.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    return input;
                },
                "htmlToText": function (iput) {
                    input = input || "";
                    input = input.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return input;
                },
                "openModal": function (modalEle) {
                    $(modalEle).modal("show");
                },
                "closeModal": function(modalEle) {
                    $(modalEle).modal("hide");   
                },
                "openModalSlider": function (modalEle, parentSelector) {
                    var sliderEle = $(modalEle);
                    if(parentSelector){
                        sliderEle = $(parentSelector).find(modalEle);
                    }
                    sliderEle.addClass("open");
                    sliderEle.show();
                    sliderEle.find(".botModalDialog").animate({right: '0'});
                    $("body").addClass("bt-modal-open");
                },
                "openBottomModalSlider":function(modalEle,parentSelector){
                    var sliderEle = $(modalEle);
                    if(parentSelector){
                        sliderEle = $(parentSelector).find(modalEle);
                    }
                    sliderEle.addClass("open");
                    sliderEle.show();
                    sliderEle.find('.botModalDialog').animate({bottom:'-55px'});
                    $("body").addClass('bt-modal-open');
                },
                "closeModalSlider": function(modalEle, parentSelector) {
                     var sliderEle = $(modalEle);
                    if(parentSelector){
                        sliderEle = $(parentSelector).find(modalEle);
                    }
                    sliderEle.removeClass("open");
                    sliderEle.find(".botModalDialog").animate({right: '-'+sliderEle.find(".botModalDialog").width()+'px'});
                    $timeout(function(){
                        sliderEle.hide();
                        
                        if(!$(".modal-backdrop.in").is(":visible")){
                            $("body").removeClass("bt-modal-open");
                        }
                        
                    }, 200); 
                     
                },
                "closeBottomModalSlider":function(modalEle,parentSelector){
                    var sliderEle = $(modalEle);
                    if(parentSelector){
                        sliderEle = $(parentSelector).find(modalEle);
                    }
                    console.log(sliderEle.find(".botModalDialog").height());
                    sliderEle.find('.botModalDialog').animate({bottom:'-'+sliderEle.find(".botModalDialog").height()+'px'});

                    $timeout(function(){
                        sliderEle.removeClass("open");
                        sliderEle.hide();
                        
                        if(!$(".modal-backdrop.in").is(":visible")){
                            $("body").removeClass("bt-modal-open");
                        }
                    },200);
                },  
                "rmBTModalOpenClass": function(){
                    $("body").removeClass("bt-modal-open");
                    $("body").removeClass("modal-open");
                }

            };

            return _builderUitility;

        });
                 
})(angular);

;(function (ng) {

    'use strict';

    ng.module("factories").factory('flowsUtil', [function () {

        function arrangeMappings(mappings) {
            var results = [];
            var obj = {};
            mappings.map(function (mapping, index) {
                var key = "";
                if (mapping.sourceResourceId && mapping.targetResourceId) { // to handle dialog task mappings
                    key = mapping.sourceResourceId + '-' + mapping.targetResourceId;
                    if (!obj[key]) {
                        obj[key] = {
                            index: index,
                            sourceResourceVersion: mapping.sourceResourceVersion,
                            targetResourceVersion: mapping.targetResourceVersion,
                            oldVersions: []
                        };
                    } else if (compareVersion(obj[key].sourceResourceVersion, mapping.sourceResourceVersion, mapping) || compareVersion(obj[key].targetResourceVersion, mapping.targetResourceVersion, mapping)) {
                        obj[key].oldVersions.push(_.clone(obj[key]));
                        obj[key].index = index;
                        obj[key].sourceResourceVersion = mapping.sourceResourceVersion;
                        obj[key].targetResourceVersion = mapping.targetResourceVersion;
                    }
                }
                else {
                    key = mapping.alertId + '-' + mapping.actionId;
                    if (!obj[key]) {
                        obj[key] = {
                            index: index,
                            alertVersion: mapping.alertVersion,
                            actionVersion: mapping.actionVersion,
                            oldVersions: []
                        };
                    } else if (compareVersion(obj[key].alertVersion, mapping.alertVersion, mapping) || compareVersion(obj[key].actionVersion, mapping.actionVersion, mapping)) {
                        obj[key].oldVersions.push(_.clone(obj[key]));
                        obj[key].index = index;
                        obj[key].alertVersion = mapping.alertVersion;
                        obj[key].actionVersion = mapping.actionVersion;
                    }
                }
            });
            Object.keys(obj).map(function (key) {
                var mapping = mappings[obj[key].index];
                mapping.oldVersions = [];
                obj[key].oldVersions
                    .map(function (version) {
                        mapping.oldVersions.push(mappings[version.index]);
                        //to show parent published tasks
                        if (mappings[version.index].state === 'active' && mapping.parentMapId === mappings[version.index].mapId) {
                            mappings[version.index].parentOf = mapping.mapId;
                            results.push(mappings[version.index]);
                        }
                    });
                results.push(mapping);
            });
            return results;
        }

        function compareVersion(version1, version2, mapping) {
            version1 = version1.split('.').map(function (number) { return +number; });
            version2 = version2.split('.').map(function (number) { return +number; });
            if (+version1[0] > +version2[0]) {
                return false;
            } else if (+version1[0] == +version2[0] && +version1[1] > +version2[1]) {
                return false;
            } else if (+version1[0] == +version2[0] && +version1[1] == +version2[1] && mapping.state === "active") {
                return false;
            } else {
                return true;
            }
        }

        return {
            arrangeFlows: arrangeMappings
        };

    }]);

})(angular);

;(function (ng) {

    'use strict';

    ng.module("factories")

            .factory("templateCompiler", function ($compile) {
                var dirMap = {
                    noBotsForm: {
                        js: "js/lazycomponents/nobots-form/nobots-form.js",
                        template: '<nobots-form ng-if="views.noBotsForm" class="bots"></nobots-form>'
                    },
                    botsForm: {
                        js: "js/lazycomponents/bots-form/bots-form.js",
                        template: '<bots-form ng-if="views.botsForm"  class="bots myBots" id="botsFormDir"></bots-form>'
                    },
                    botDetailsForm: {
                        js: "js/lazycomponents/bot-details-form/bot-details-form.js",
                        template: '<bot-details-form ng-if="views.botDetailsForm"  class="botDetails botDetailsForm" id="botDetailsFormDir"></bot-details-form>'
                    },
                    botsBillingForm: {
                        js: "js/lazycomponents/bots-billing/bots-billing.js",
                        template: '<bots-billing ng-if="views.botsBillingForm" class="botsBilling"></bots-billing>'
                    },
                    teamForm: {
                        js: "js/lazycomponents/team/team.js",
                        template: '<team class="team" ng-if="views.teamForm"></team>'
                    }
                };
                var _builderUitility = {

                    getCompilerFn: function (id) {
                        return dirMap[id].compileFn;
                    },
                    getDirectiveObject: function (id) {
                        return dirMap[id];
                    },
                    setCompileFn: function (id, compileFn) {
                        dirMap[id].compileFn = compileFn;
                    }

                };
                Object.keys(dirMap).forEach(function (id) {
                    //dirMap[id].compileFn=$compile(dirMap[id].template);
                    dirMap[id].id = id;
                });
                return _builderUitility;

            });


})(angular);




;(function(ng) {

    'use strict';

    ng.module('services', []);

})(angular);

;(function(ng) {

    'use strict';
    ng.module('services').service('accessControlService', function($workflowService) {

    var _clientResultObj = [];
    var viewMode = "";
    var result = {};


            var dependencies ={
            "BOTBUILDER_TASKS":["BOTBUILDER_KNOWLEDGE_GRAPH"],
            "BOTBUILDER_NATURAL_LANGUAGE":["BOTBUILDER_BATCH_TESTING"],
            "BOTBUILDER_BOT_SETTINGS":["BOTBUILDER_BOT_DEVELOPERS","BOTBUILDER_BOT_IMPORT"],
            "BOTBUILDER_EXTENSIONS":["BOTBUILDER_APPS_AND_SCOPES"]
          };

          var serverDependencies = {
            "BOTBUILDER_TASKS":["BOTBUILDER_NATURAL_LANGUAGE","BOTBUILDER_PUBLISH_BOT","BOTBUILDER_KNOWLEDGE_GRAPH"]
          };

          // var parent={
          //   "KNOWLEDGE_GRAPH":"BOTBUILDER_TASKS"
          // };
            
    function prepareObject(result){
      _clientResultObj=[];
      angular.forEach(Object.keys(result),function(component,key){

        var _clientCompObj = {};
        _clientCompObj._id = component;
        _clientCompObj.VIEW = (result[component].indexOf("VIEW") > -1)?true:false;
        _clientCompObj.FULL = (result[component].indexOf("FULL") > -1)?true:false;
        _clientCompObj.NO = (result[component].indexOf("NO") > -1)?true:false;

        _clientCompObj.dependencies = [];
        if(dependencies[component] && dependencies[component].length > 0){
          _clientCompObj.dependencies = dependencies[component];
        }
          _clientResultObj.push(_clientCompObj);
        

      });
        return _clientResultObj;
   
    }
  

    var setPermissions = function(permissions){
        result = permissions;
        prepareObject(result);
    };

    var getPermissions = function(){
    	return _clientResultObj;
    };
    var getAccessRight = function(_componentid){
        var _serverComponent = _.find(_clientResultObj,{_id:_componentid});

        if(_serverComponent && result[_serverComponent._id][0] === 'NO'){
          return result[_serverComponent._id][0];
        }

        if($workflowService.selectedStreamState()==='published'){
           return "VIEW"; 
        }
        if(_serverComponent && result[_serverComponent._id][0] !== 'NO'){
          return result[_serverComponent._id][0];
        }
    };
    var setRetrieveValue = function(mode){
        if($workflowService.selectedStreamState()==='published'){
           return "VIEW"; 
        }
        if(mode){
           viewMode = mode; 
           return;
        }
        return viewMode;
    };
    var getDependency = function(_componentid)
    {
        var dependencyResult = _.find(_clientResultObj,{_id:_componentid});
        if(dependencyResult){
            return dependencyResult.dependencies;
        }
    };
    var getServerDependency = function(_serverComponentId){
          var result = false;
          var serverDependencyList = serverDependencies[_serverComponentId];
          angular.forEach(serverDependencyList,function(component,index){
            var accessRight = getAccessRight(component);
            if(accessRight !== "NO"){
                result = true;
            }

          });
          return result;
    };

    
    
     return {
     	'getPermissions':getPermissions,
        'getAccessRight':getAccessRight,
        'setRetrieveValue':setRetrieveValue,
        'getDependency':getDependency,
        'setPermissions':setPermissions,
        'getServerDependency':getServerDependency
     };
    });
})(angular);


;(function(ng) {
    'use strict';
    ng.module('services').service('BTActionsService', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

        var getActions = function(_streamId) {
            if (_streamId){
                return translate('bt.streams.actions.get', {streamId: _streamId}, {});
            }
            return translate('bt.actions.get', {}, {});
        };

        var getBTAction = function(actionId){
            return translate('bt.actionsId.get', {actionId: actionId}, {});
        };

        var createBTAction = function(data){
            return translate('bt.actions.post', {}, data);
        };

        var updateBTAction = function(actionId, actionObj){
            return translate('bt.actionsId.put', {actionId: actionId}, actionObj);
        };

    	var deleteBTAction = function(actionId){
    		return translate('bt.actionsId.delete', {actionId: actionId});
    	};
        var upPublishBTAction = function(actionId){
    		return translate('bt.actionsId.unpublish', {actionId: actionId});
    	};

        var cloneBTAction = function(actionId){
            return translate('bt.actionsId.clone', {actionId: actionId});
        };

        var upgradeBTAction = function(actionId){
            return translate('bt.actionsId.upgrade', {actionId: actionId});
        };

        var upgradeMPAction = function(actionId,id){
            return translate('mp.actionsId.upgrade', {actionId: actionId},{actionId:id});
        };
        
        var unlockBTAction = function (actionId, streamId) {
            return translate('bt.actionsId.unlock', {streamId: streamId},
            {"resources": [
                    {
                        "resourceType": "action",
                        "resourceId": actionId
                    }
                ]}
            );
        };

        var unlockDialog = function(dialogId, streamId, userId, requestData){
            return translate('bt.dialogsId.unlock', {dialogId: dialogId, streamId:streamId, userId:userId}, requestData);
        };

        var checkUpgrade = function(actionId){
            return translate('bt.action.checkupgrade', {actionId: actionId});
        };

    	var getMPAction = function(actionId){
    		return translate('mp.actionsId.get', {actionId: actionId}, {});
    	};

        var createMPAction = function(data){
    		return translate('mp.actions.post', {}, data);
    	};

        var updateMPAction = function(actionId, actionObj){
            return translate('mp.actionsId.put', {actionId: actionId}, actionObj);
        };

        var deleteMPAction = function(actionId){
            return translate('mp.actionsId.delete', {actionId: actionId});
        };

        var configured = function(actionId){
            return translate('bt.action.configured', {actionId: actionId});
        };

        var getErrorCodes = function(actionId){
            return translate('bt.action.errorCodes', {actionId: actionId});
        };

        var getVersions = function(actionId){
            return translate('bt.action.getVersions', {actionId: actionId});
        };

        var getApiLogs = function getApiLogs(actionId, offset, limit) {
            return translate('bt.action.logs.get', {actionId: actionId, offset: offset, limit: limit});
        };

        var getFieldPattern = function(actionId,fieldName){
            return translate('bt.action.field.pattern.get',{
                actionId  : actionId,
                fieldName : fieldName,
                patternId : ''
            });
        };

        var createFieldPattern = function(actionId,fieldName,patterns){
            return translate('bt.action.field.pattern.create',{
                actionId  : actionId,
                fieldName : fieldName,
                patternId : ''
            },patterns);
        };

        var deleteFieldPattern = function(actionId,fieldName,patternId){
            var payload = _.isObject(actionId) ? actionId : null;
            return translate('bt.action.field.pattern.delete',payload || {
                actionId  : actionId,
                fieldName : fieldName,
                patternId : patternId
            });
        };

    	return {
            getActions: getActions,
            createBTAction: createBTAction,
            updateBTAction: updateBTAction,
            unlockBTAction:unlockBTAction,
            unlockDialog:unlockDialog,
            deleteBTAction: deleteBTAction,
            getBTAction: getBTAction,
            getMPAction: getMPAction,
            createMPAction: createMPAction,
            updateMPAction: updateMPAction,
            deleteMPAction: deleteMPAction,
            cloneBTAction: cloneBTAction,
            upgradeBTAction: upgradeBTAction,
            upgradeMPAction: upgradeMPAction,
            checkUpgrade:checkUpgrade,
            configured:configured,
            getErrorCodes:getErrorCodes,
            getVersions:getVersions,
            getApiLogs : getApiLogs,
            getFieldPattern : getFieldPattern,
            createFieldPattern : createFieldPattern,
            deleteFieldPattern : deleteFieldPattern,
            upPublishBTAction:upPublishBTAction
    	};

    }]);

})(angular);


;(function(ng) {
    'use strict';
    ng.module('services').service('BTAlertsService', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

    	var getAlerts = function(_streamId) {
            if (_streamId){
                return translate('bt.streams.alerts.get', {streamId: _streamId}, {});
            }
    		return translate('bt.alerts.get', {}, {});
    	};

    	var deleteBTAlert = function(alertId){
    		return translate('bt.alertsId.delete', {alertId: alertId});
    	};
        
        var upPublishBTAlert = function(alertId){
    		return translate('bt.alertsId.unpublish', {alertId: alertId});
    	};

        var cloneBTAlert = function(alertId){
            return translate('bt.alertsId.clone', {alertId: alertId});
        };

        var upgradeBTAlert = function(alertId){
            return translate('bt.alertsId.upgrade', {alertId: alertId});
        };

        var upgradeMPAlert = function(alertId,id){
            return translate('mp.alertsId.upgrade', {alertId: alertId},{alertId:id});
        };
        
        var unlockBTAlert = function (alertId, streamId) {
            return translate('bt.alertsId.unlock', {streamId: streamId},
            {"resources": [
                    {
                        "resourceType": "alert",
                        "resourceId": alertId
                    }
                ]}
            );
        };

        var checkUpgrade = function(alertId){
            return translate('bt.alert.checkupgrade', {alertId: alertId});
        };

    	var deleteMPAlert = function(alertId){
    		return translate('mp.alertsId.delete', {alertId: alertId});
    	};

    	var createBTAlert = function(data){
    		return translate('bt.alerts.post', {}, data);
    	};

    	var createMPAlert = function(data){
    		return translate('mp.alerts.post', {}, data);
    	};

        var createBTAlertUp = function(alertId,data){
    		return translate('bt.alerts.put', {alertId: alertId}, data);
    	};

        var updateMPAlert = function(alertId,data){
    		return translate('mp.alerts.put', {alertId: alertId}, data);
    	};

        var getBTAlert = function(alertId) {
            return translate('bt.alertsId.get', {alertId: alertId});
        };

        var getMPAlert = function(alertId) {
            return translate('mp.alertsId.get', {alertId: alertId});
        };

        var resolveUxMap = function(data){
            return translate('builder.resolve_uxmap',{},data);
        };

        var configured = function(alertId){
            return translate('bt.alert.configured',{alertId:alertId});
        };

        var getErrorCodes = function(alertId){
            return translate('bt.alert.errorCodes',{alertId:alertId});
        };

        var getVersions = function(alertId){
            return translate('bt.alert.getVersions', {alertId: alertId});
        };

        var getApiLogs = function getApiLogs(alertId, offset, limit) {
            return translate('bt.alert.logs.get', {alertId: alertId, offset: offset, limit: limit});
        };

        var getFieldPattern = function(alertId,fieldName){
            return translate('bt.alert.field.pattern.get',{
                alertId   : alertId,
                fieldName : fieldName,
                patternId : ''
            });
        };

        var createFieldPattern = function(alertId,fieldName,patterns){
            return translate('bt.alert.field.pattern.create',{
                alertId   : alertId,
                fieldName : fieldName,
                patternId : ''
            },patterns);
        };

        var deleteFieldPattern = function(alertId,fieldName,patternId){
            var payload = _.isObject(alertId) ? alertId : null;
            return translate('bt.alert.field.pattern.delete',payload || {
                alertId   : alertId,
                fieldName : fieldName,
                patternId : patternId
            });
        };

    	return {
    		getAlerts  : getAlerts,
    		deleteBTAlert: deleteBTAlert,
    		deleteMPAlert: deleteMPAlert,
    		createBTAlert : createBTAlert,
    		createMPAlert : createMPAlert,
            createBTAlertUp : createBTAlertUp,
            updateMPAlert : updateMPAlert,
            unlockBTAlert:unlockBTAlert,
            getBTAlert: getBTAlert,
            getMPAlert: getMPAlert,
            cloneBTAlert:cloneBTAlert,
            upgradeBTAlert:upgradeBTAlert,
            upgradeMPAlert:upgradeMPAlert,
            checkUpgrade:checkUpgrade,
            resolveUxMap:resolveUxMap,
            configured:configured,
            getErrorCodes:getErrorCodes,
            getVersions:getVersions,
            getApiLogs: getApiLogs,
            getFieldPattern : getFieldPattern,
            createFieldPattern : createFieldPattern,
            deleteFieldPattern : deleteFieldPattern,
            upPublishBTAlert:upPublishBTAlert
    	};

    }]);

})(angular);


;(function(ng) {
    'use strict';

    ng.module('services').service('AppsDataService', ['$translator','$applicationService', function($translator,$applicationService) {

    	var getAppsList = function(streamId,getAppsUsage) {
            getAppsUsage = getAppsUsage || false;
            if ($applicationService.userInfo().appControls && $applicationService.userInfo().appControls.isManaged) {
                return $translator.translate('bt.org.apps.get');
            } else {
                if(getAppsUsage){
                     return $translator.translate('bt.appsListUsage.get',{streamId:streamId});
                }else{
                     return $translator.translate('bt.apps.get',{streamId:streamId});
                }
                
            }
        };
        var getBotsList = function() {
            return $translator.translate('bt.streams.get');
        };

    	return {
    		getAppsList: getAppsList,
                getBotsList:getBotsList
    	};

    }]);

})(angular);

;(function (ng) {
    'use strict';
    ng.module('services').service('AuthService', ['$translator', '$rootScope', 'security','localstore', function ($translator, $rootScope, security,localstore) {

            function translate(urlIdentifier, params, payload, headers) {
                return $translator.translate(urlIdentifier, params, payload, headers);
            }
            
            var  profileUpdate = function(payload){
              return translate('bt.put.profileUpdate',{}, payload);  
            };
            var  changePassword = function(payload){
              return translate('bt.put.changePassword',{}, payload);  
            };
            var changePasswordByPolicy=function(payload){
                return translate('bt.put.changePasswordByPolicy',{},payload);
            };
            var getAuthorization = function (data) {
                return translate('bt.login.post', {}, data);
            };
            /**
             * @param {type} type [joinAccount || selfAccount]
             * @param {type} accounts
             */
            var requestToJoinAccounts= function (type,accounts) {
                return translate('bt.join.accounts.post', {type:type},accounts);
            };
            var getAllowedAccountsToJoin  = function (data) {
                return translate('bt.join.accounts.get', {}, data);
            };
            var getAppControlList = function (userId) {
                return translate('mp.user.appControlList', {
                    userId: userId
                });
            };

            var sendLoginAuditEvent = function () {
                return translate('bt.post.audit.login',{},{eventOrigin:0});//  Comment start eventOrigin Comment end : <integer> //expected values 0 => BT/ 1 => BAC/ 2 => Marketplace
            };
            
            var refreshToken = function () {
                var _koreUserInfo, OAUTH_DEFAULT_PROPS = {
                    client_id: "1",
                    client_secret: "1",
                    scope: "friends",
                    grant_type: "password"
                };

                _koreUserInfo = localstore.getAuthData();
                if (!_koreUserInfo) {
                    security.logout();
                }
               
                if (_koreUserInfo && _koreUserInfo.currentAccount) {
                    var auth, params = {};
                    auth = _koreUserInfo.currentAccount.authorization;
                    if (auth) {
                        params = OAUTH_DEFAULT_PROPS;
                        params.grant_type = "refresh_token";
                        params.refresh_token = auth.refreshToken;
                        return getAuthorization(params);
                    } else {
                        security.logout();
                    }
                } else {
                    security.logout();
                }

            };

            return {
                getAuthorization: getAuthorization,
                refreshToken: refreshToken,
                profileUpdate:profileUpdate,
                changePassword:changePassword,
                changePasswordByPolicy:changePasswordByPolicy,
                getAllowedAccountsToJoin:getAllowedAccountsToJoin,
                requestToJoinAccounts:requestToJoinAccounts,
                getAppControlList:getAppControlList,
                sendLoginAuditEvent:sendLoginAuditEvent
            };
        }]);

})(angular);

;(function (ng) {
    'use strict';
    var _service = ng.module('services');

    _service.service('batchTestingService', ['$translator', function ($translator) {

        function getAllTestSuits(userId, streamId, payload) {
            return $translator.translate('bt.get.getAllTestSuits', {streamId:streamId}, payload);
        }

        function createTestSuit(userId, streamId, payload) {
            return $translator.translate('bt.post.createTestSuit', {streamId:streamId}, payload);
        }

        function updateTestSuit(userId, streamId, testSuitID, payload) {
            return $translator.translate('bt.put.updateTestSuit', {streamId:streamId, testSuitID:testSuitID}, payload);
        }

        function runTestSuit(userId, streamId, testSuitID, payload) {
            return $translator.translate('bt.post.runTestSuit', {streamId:streamId, testSuitID:testSuitID}, payload);
        }

        function getDetailsByTestRunID(userId, streamId, testSuitID, testRunID, payload) {
            return $translator.translate('bt.get.getDetailsByTestRunID', {streamId:streamId, testSuitID:testSuitID, testRunID:testRunID}, payload);
        }

        function viewReport(userId, streamId, testSuitID, payload, offset, limit) {
            return $translator.translate('bt.get.viewReport', {streamId:streamId, testSuitID:testSuitID, offset: offset, limit: limit}, payload);
        }


        return {
            getAllTestSuits: getAllTestSuits,
            createTestSuit: createTestSuit,
            updateTestSuit: updateTestSuit,
            runTestSuit: runTestSuit,
            getDetailsByTestRunID: getDetailsByTestRunID,
            viewReport: viewReport
        };

    }]);

})(angular);


;(function (ng) {
    'use strict';
    var _service = ng.module('services');

    _service.service('botOntologyService', ['$translator', function ($translator) {

        function getTerms(userId, streamId, payload) {
            return $translator.translate('bt.get.getAllTestSuits', {streamId:streamId}, payload);
        }

        function createTerm(userId, ktObject) {
            return $translator.translate('bt.post.ktCreate', {}, ktObject);
        }

        function updateTerm(userId, ktObject) {
        return $translator.translate('bt.put.ktUpdate', {"ktId":ktObject._id}, ktObject);
      }

        function createQA(userId, streamId, testSuitID, payload) {
            return $translator.translate('bt.post.runTestSuit', {streamId:streamId, testSuitID:testSuitID}, payload);
        }

        function updateQA(userId, streamId, testSuitID, testRunID, payload) {
            return $translator.translate('bt.get.getDetailsByTestRunID', {streamId:streamId, testSuitID:testSuitID, testRunID:testRunID}, payload);
        }

        function getQAForTerm(userId, streamId, testSuitID, payload) {
            return $translator.translate('bt.get.viewReport', {streamId:streamId, testSuitID:testSuitID}, payload);
        }

        function getFAQS(userId, ktID, searchParam, offSet, limit) {
            return $translator.translate('bt.get.getorsearchfaq', {"ktId": ktID, "searchParam" : searchParam, "offSet":offSet, "limit":limit});
            
        }

        function addFAQ(userId, faqObject) {
            return $translator.translate('bt.post.addFaqs', {}, faqObject);
        }


        function updateFAQ(userId, faqData, faqID) {
            return $translator.translate('bt.put.editfaqs', {"faqID":faqID}, faqData);
        }

        function createClass(userId, streamId, classData) {
            return $translator.translate('bt.post.createClass', {"streamId":streamId}, classData);
        }

        function updateClass(userId, streamId, classData, classId) {
            return $translator.translate('bt.put.updateClass', {"classId":classId, "streamId":streamId}, classData);
        }

        function deleteClass(userId, streamId, classId) {
            return $translator.translate('bt.delete.deleteClass', {"classId":classId, "streamId":streamId});
        }

        function getClasses(userId, streamId, offset, limit,state) {
            return $translator.translate('bt.get.getClasses', {"streamId":streamId, "offset":offset, "limit":limit,"state":state});
        }

        function getImportFAQStatus(userId, streamId, callName){
            return $translator.translate('bt.get.getImportFAQStatus', {"streamId":streamId, 'callName': callName});
        }

        function getTrainStatus(userId, streamId, callName){
            return $translator.translate('bt.get.getImportFAQStatus', {"streamId":streamId, 'callName': callName});
        }

        function getNodesLockStatus(userId, ktID){
            return $translator.translate('bt.get.getNodesLockStatus', {'ktID': ktID});
        }

        function exportOntology(userId, payload){
            return $translator.translate('bt.post.exportontology', {"userId":userId}, payload);
        }

        function cudOntologyNode(userId, streamId, ktId, cudOntologyData){
            return $translator.translate('bt.post.CUD_OntologyNode', {"userId":userId, "streamId":streamId, ktId: ktId}, cudOntologyData);
        }

        function getOntologyReport(userId,streamId,ktId,lang){
            return $translator.translate('bt.get.ontologyReport',{'userId':userId,"streamId":streamId,"ktId":ktId,"lang":lang});
        }

        function analysisReport(userId,streamId,ktId,dockId,lang){
            return $translator.translate('bt.get.analysisReport',{'userId':userId,"streamId":streamId,"ktId":ktId,"dockId":dockId,"lang":lang});
        }

        function exportOntologyReport(userId,streamId,ktId,lang){
            return $translator.translate('bt.get.exportOntologyReport',{'userId':userId,"streamId":streamId,"ktId":ktId,"lang":lang});
        }

        return {
            getTerms: getTerms,
            createTerm: createTerm,
            updateTerm: updateTerm,
            createQA: createQA,
            updateQA: updateQA,
            getQAForTerm: getQAForTerm,
            getFAQS: getFAQS,
            addFAQ: addFAQ,
            updateFAQ: updateFAQ,
            createClass: createClass,
            updateClass: updateClass,
            deleteClass: deleteClass,
            getClasses : getClasses,
            getImportFAQStatus: getImportFAQStatus,
            getTrainStatus: getTrainStatus,
            exportOntology: exportOntology,
            cudOntologyNode: cudOntologyNode,
            getNodesLockStatus: getNodesLockStatus,
            getOntologyReport:getOntologyReport,
            analysisReport:analysisReport,
            exportOntologyReport:exportOntologyReport
        };

    }]);

})(angular);


;(function(ng) {
    'use strict';
    ng.module('services').service('BTFileUploadService', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

        var uploadFile = function(data) {
            return translate('bt.uploadFile.post', {}, data);
        };

    	return {
    		uploadFile   : uploadFile
    	};
    }]);

})(angular);

;(function(ng) {
    'use strict';
    ng.module('services').service('BTFiltersService', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

        var createFilter = function(alertid,data) {
            return translate('bt.filters.post', {alertId : alertid}, data);
        };

        var getFilter = function() {
            return translate('bt.filters.get');
        };

        var getFiltersByAlertId=function(alertId,alertVersion){
            return translate('bt.getFiltersByAlertId.get',{alertId:alertId,alertVersion:alertVersion});
        };

        var updateFilter = function(filterId,data){
            return translate('bt.filtersId.put',{filterId:filterId},data);
        };

        var deleteFilter = function(filterid){
            return translate('bt.filtersId.delete',{filterId:filterid});
        };

    	return {
    		createFilter : createFilter,
            getFilter    :  getFilter,
            updateFilter: updateFilter,
            deleteFilter: deleteFilter,
            getFiltersByAlertId:getFiltersByAlertId
    	};

    }]);

})(angular);

;(function (ng) {
    'use strict';
    ng.module('services').service('BTFlowtaskService', ['$translator', function ($translator) {

            function translate(urlIdentifier, params, payload, headers) {
                return $translator.translate(urlIdentifier, params, payload, headers);
            }
            var getDialog = function(_streamId,_dialogId){
                return translate('get.dialog', {streamId: _streamId, dialogId: _dialogId}, {});
            };
            var getFlowtaks = function (_streamId, _dialogId,universalStreamId) {
                if (_dialogId && _dialogId.length > 0) {
                    return translate('bt.dialog.get', {streamId: _streamId, dialogId: _dialogId}, {});
                }
                if(universalStreamId && universalStreamId.length > 0){
                    return translate('bt.dialogsUB.get',{streamId:_streamId,parentBotId:universalStreamId});
                }
                return translate('bt.dialogs.get', {streamId: _streamId}, {});
            };

            var getFlowtaksByState = function(_streamId){
                return translate('bt.dialogsByState.get', {streamId: _streamId}, {});
            };

            var getRegenerateDialog = function (_streamId, _dialogId) {
                return translate('bt.regenerateDialog.get', {streamId: _streamId, dialogId:_dialogId}, {});
            };

            var getRegenerateDialogSelected = function (_streamId, _dialogId, _formId) {
                return translate('bt.getRegenerateDialogSelected.get', {streamId: _streamId, dialogId:_dialogId}, {formId:_formId});
            };

            var deleteFlowtask = function (_streamId, _dialogId) {
                return translate('bt.dialog.delete', {streamId: _streamId, dialogId: _dialogId});
            };
            var cloneDialogTask = function(streamId,dialogId, payload){
                return $translator.translate('bt.put.cloneDialogTask',{streamId:streamId,dialogId:dialogId},payload);
            };
            var recallFlowtask = function (_streamId, _dialogId) {
                return translate('bt.dialog.recall', {streamId: _streamId, dialogId: _dialogId});
            };
            
            var messagePreviewFlowtask = function (_streamId, _dialogId, _nodeId,message) {
                return translate('bt.dialog.messagePreview', {streamId: _streamId, dialogId: _dialogId, nodeId: _nodeId},message,{});
            };
            
            var unpublishFlowtask = function (_streamId, _dialogId) {
                return translate('bt.dialog.unpublish', {streamId: _streamId, dialogId: _dialogId});
            };
            
            var createFlowtask = function (streamId, flowtask) {
                return translate('bt.dialog.post', {streamId: streamId}, flowtask, {});
            };
            
            var finishFlowtask = function (streamId, dialogId) {
                return translate('bt.dialog.configure', {streamId: streamId, dialogId: dialogId});
            };
            
            var updateFlowtask = function (streamId, dialogId, flowtask) {
                return translate('bt.dialog.put', {streamId: streamId, dialogId: dialogId}, flowtask, {});
            };
            
            var upgradeFlowtask = function (streamId,dialogId) {
                return translate('bt.dialogsId.upgrade', {streamId: streamId, dialogId: dialogId});
            };

            var migrateFlowtask = function (streamId,dialogId) {
                return translate('bt.dialog.migrate', {streamId: streamId, dialogId: dialogId});
            };

            var addlinkedtasks = function (streamId,dialogId, payload) {
                return translate('bt.dialogsId.addlinkedtasks', {streamId: streamId, dialogId: dialogId},payload);
            };
            var getIntentSuggestions = function (streamId,dialogId) {
                return translate('bt.dialogsId.intentSuggestions', {streamId: streamId, dialogId: dialogId});
            };
            var getFlowtaskComponents = function (streamId, dialogId) {
                return translate('bt.dialogComponent.get', {streamId: streamId, dialogId: dialogId});
            }; 
            
            var getDialogTaskBotConfiguration = function (streamId, dialogId) {
                return translate('bt.dialogBotConfig.get', {streamId: streamId, dialogId: dialogId});
            };
            
            var setDialogTaskBotConfiguration = function (streamId, dialogId, payload) {
                return translate('bt.dialogBotConfig.put', {streamId: streamId, dialogId: dialogId}, payload);
            };
            
            var getEntitiesOrIntents = function (streamId, type) {
                return translate('bt.get.intenetsOrEntities', {streamId: streamId, type: type});
            };
            
            var updateFlowtaskNodeInfo = function (streamId, dialogId, nodeId, nodeInfo) {
                return translate('bt.dialogComponent.updateNode', {streamId: streamId, dialogId: dialogId, nodeId: nodeId}, nodeInfo);
            };
            
            var unlockFlowTask = function (dialogId) {
                return translate('bt.lock.release', {resourceId: dialogId});
            };
            var getComponents = function (_streamId, _componentId) {
                if (_componentId && _componentId.length > 0) {
                    return translate('bt.component.get', {streamId: _streamId, componentId: _componentId}, {});
                }
                return translate('bt.components.get', {streamId: _streamId}, {});
            };
            var getComponentsByType = function (_streamId, type,isConfiguredOnly) {
                isConfiguredOnly = isConfiguredOnly?isConfiguredOnly:false;
                return translate('bt.componentsByType.get', {streamId: _streamId,type:type,isConfiguredOnly:isConfiguredOnly}, {});
            };
            var getComponentsByTypeAndState = function (_streamId, type,state) {
                return translate('bt.componentsByTypeAndState.get', {streamId: _streamId,type:type,state:state}, {});
            };
            var getSearchComponentsByType = function (_streamId, type,isConfiguredOnly,name) {
                isConfiguredOnly = isConfiguredOnly?isConfiguredOnly:false;
                if(type === "intent" || type === "subDialog"){
                    return translate('bt.componentsBySearchTypeIntent.get', {streamId: _streamId,type:'intent',isConfiguredOnly:isConfiguredOnly,intentName:name}, {});
                }else{
                    return translate('bt.componentsBySearchType.get', {streamId: _streamId,type:type,isConfiguredOnly:isConfiguredOnly,name:name}, {});
                }
            };

            var getSearchComponentFormType = function (_streamId, type ,name) {
                return translate('bt.componentsBysearchFormType.get', {streamId: _streamId,type:type,name:name}, {});
            };

            var deleteComponent = function (_streamId, _componentId) {
                return translate('bt.component.delete', {streamId: _streamId, componentId: _componentId});
            };
            
            var createComponent = function (_streamId, component) {
                return translate('bt.component.post', {streamId: _streamId}, component, {});
            };
            
            var updateComponentSynonyms = function (_streamId, _componentId, payload) {
                return translate('bt.component.synonyms.put', {streamId: _streamId, componentId: _componentId}, payload, {});
            };

            var updateComponentPatterns = function (_streamId, _componentId, payload) {
                return translate('bt.component.patterns.put', {streamId: _streamId, componentId: _componentId}, payload, {});
            };

            var updateComponentTraits = function (_streamId, _componentId, payload) {
                return translate('bt.component.traits.put', {streamId: _streamId, componentId: _componentId}, payload);
            };

            var updateNegativePatterns = function(_streamId,_userId,payload){
                return translate('bt.component.negativePatterns.post',{streamId:_streamId,userId:_userId},payload,{});
            };
            
            var updateComponent = function (_streamId, _componentId, component) {
                return translate('bt.component.put', {streamId: _streamId, componentId: _componentId}, component, {});
            };
            var executeComponent = function (_streamId, _componentId, params) {
                return translate('bt.component.execute', {streamId: _streamId, componentId: _componentId}, params, {});
            };
            
            var resolveUxMap = function (data) {
                return translate('builder.resolve_uxmap', {}, data);
            };
            
            var subscribeSDK = function (_streamId) {
                return translate('bt.flowtask.SDKSubscription', {streamId: _streamId});
            };

            var importDialog = function (_streamId, _dialogId, data,params) {
                var _params={streamId: _streamId, dialogId: _dialogId};
                _params[params.importType]=true;


                return translate('bt.dialog.import',_params ,data,[params.importType]);
            };
            
            var importNewBot = function(userId, payload) {
                return translate('bt.newBot.import',{userId: userId},payload);
            };
            
            var importExistingBot = function(userId, botId, payload,params) {
                var _params={userId:userId,botId:botId};
                _params[params.importType]=true;
                return translate('bt.existingBot.import',_params,payload,[params.importType]);
            };
            
            var botImportStatus = function(userId, requestId) {
                return translate('bt.botImport.status',{userId: userId, requestId: requestId});
            };

            var botutteranceImportStatus = function(userId,_streamId,_requestId){
                return translate('bt.botImportUtterance.status',{userId:userId,streamId:_streamId,requestId:_requestId});
            };

            var startImporting = function(userId,_streamId,payload){
                return translate('bt.utterance.botImport',{userId:userId,streamId:_streamId},payload);
            };

            var exportDialog = function (_streamId, dialogId) {
                return translate('bt.dialog.export', {streamId: _streamId, dialogId: dialogId});
            };
            var addFormNodeBatch = function (_streamId, dialogId,payload) {
                return translate('bt.addFormNode.batch', {streamId: _streamId, dialogId: dialogId},payload);
            };
            var exportBot = function (_streamId, payload) {
                return translate('bt.export', {streamId: _streamId}, payload);
            };
            
            var addVariables = function(userId, _streamId, payload){
                return translate('bt.post.variables', {userId: userId, streamId: _streamId}, payload);
            };
            
            var deleteVariable = function(userId, _streamId, variableId){
                return translate('bt.delete.variables', {userId: userId, streamId: _streamId, variableId: variableId});
            };

            var editVariable = function(userId, _streamId, variableId, payload){
                return translate('bt.put.variables', {userId: userId, streamId: _streamId, variableId: variableId}, payload);
            };

            var getVariables = function(userId, _streamId,variableType){
                return translate('bt.get.variables', {userId: userId, streamId: _streamId,variableType:variableType});
            };

            var getVariablesByCollection = function(userId, _streamId,variableType, collectionRefId ){
                return translate('bt.get.variablesByCollection', {userId: userId, streamId: _streamId,variableType:variableType, collectionRefId: collectionRefId });
            };

            var getAllVariables = function(userId, _streamId,variableType){
                return translate('bt.get.allVariables', {userId: userId, streamId: _streamId});
            };
            
            var getsSampleBotAllVariables = function(userId, _streamId,standardBotId){
                return translate('bt.get.getsSampleBotAllVariables', {userId: userId, streamId: _streamId,standardBotId:standardBotId});
            };
            var saveCustomLookup = function (userId, dialogId, entityId, data) {
                return translate('bt.entity.lookup', {userId: userId, dialogId: dialogId, entityId: entityId}, data);                
            };

            var getLookupJson = function (userId, lookupId) {
                return translate('bt.getLookup.json', {userId: userId, lookupId: lookupId});                 
            };

            var exportStatusBot = function(_streamId)
            {
                return translate('bt.get.exportStatusBot',{streamId:_streamId});
            };
            
            var getDialogIdps = function(_streamId,dialogId){
                return translate('bt.get.getDialogIdps', {streamId: _streamId,dialogId:dialogId});
            };

            var exportStatusBotVersion = function(_streamId){
                return translate('bt.get.exportStatusBotVersion',{streamId:_streamId});
            };

            var getProcessApps = function(_streamId){
                return translate('bt.get.getProcessApps',{streamId:_streamId});
            };

            return {
                getDialog:getDialog,
                getFlowtaks: getFlowtaks,
                deleteFlowtask: deleteFlowtask,
                cloneDialogTask:cloneDialogTask,
                editVariable: editVariable,
                deleteVariable: deleteVariable,            
                recallFlowtask: recallFlowtask,
                messagePreviewFlowtask: messagePreviewFlowtask,
                unpublishFlowtask: unpublishFlowtask,
                createFlowtask: createFlowtask,
                finishFlowtask: finishFlowtask,
                updateFlowtask: updateFlowtask,
                upgradeFlowtask:upgradeFlowtask,
                getFlowtaskComponents: getFlowtaskComponents,
                getRegenerateDialog:getRegenerateDialog,
                getRegenerateDialogSelected:getRegenerateDialogSelected,
                getEntitiesOrIntents:getEntitiesOrIntents,
                updateFlowtaskNodeInfo: updateFlowtaskNodeInfo,
                unlockFlowTask: unlockFlowTask,
                getComponents: getComponents,
                deleteComponent: deleteComponent,
                createComponent: createComponent,
                updateComponent: updateComponent,
                updateComponentSynonyms:updateComponentSynonyms,
                updateComponentPatterns:updateComponentPatterns,
                executeComponent:executeComponent,
                resolveUxMap: resolveUxMap,
                importDialog: importDialog,
                exportDialog: exportDialog,
                saveCustomLookup: saveCustomLookup,
                getLookupJson: getLookupJson,
                getDialogTaskBotConfiguration:getDialogTaskBotConfiguration,
                setDialogTaskBotConfiguration:setDialogTaskBotConfiguration,
                exportBot : exportBot,
                addVariables: addVariables,
                getVariables: getVariables,
                getVariablesByCollection: getVariablesByCollection,
                importExistingBot:importExistingBot,
                importNewBot:importNewBot,
                botImportStatus:botImportStatus,
                getComponentsByType:getComponentsByType,
                addlinkedtasks: addlinkedtasks,
                getIntentSuggestions:getIntentSuggestions,
                getSearchComponentsByType:getSearchComponentsByType,
                getSearchComponentFormType:getSearchComponentFormType,
                exportStatusBot:exportStatusBot,
                startImporting:startImporting,
                botutteranceImportStatus:botutteranceImportStatus,
                getComponentsByTypeAndState:getComponentsByTypeAndState,
                updateNegativePatterns:updateNegativePatterns,
                getAllVariables:getAllVariables,
                getsSampleBotAllVariables:getsSampleBotAllVariables,
                updateComponentTraits:updateComponentTraits,
                getDialogIdps:getDialogIdps,
                addFormNodeBatch:addFormNodeBatch,
                exportStatusBotVersion:exportStatusBotVersion,
                getFlowtaksByState:getFlowtaksByState,
                getProcessApps:getProcessApps,
                migrateFlowtask:migrateFlowtask
            };

        }]);

})(angular);


;(function(ng) {
    'use strict';
    ng.module('services').service('BTIdpService', ['$translator','$q','$rootScope', function($translator,$q,$rootScope) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

        var getIdpList = function(_streamId) {
            //if (_streamId){
                return translate('bt.streamidps.get', {streamId: _streamId}, {});
            //}
            //return translate('bt.streamsidp.get', {}, {});
        };

        var getCallBackUrl = function() {
        	return translate('bt.callbackurl.get', {}, {});
        };

        var createIdp = function(_streamId, idpConfig) {
            return translate('bt.idp.post', {streamId:_streamId}, idpConfig);
        };

        var createStreamUserAccount = function(idpConfig){
            idpConfig.label = idpConfig.idpName || 'Test Account';
            return translate('bt.idp.test', idpConfig, {});
        };

        var deleteStreamUserAccount = function(accId){
            return translate('bt.idp.account.delete',{accId:accId},{});
        };
        var twilioChannelSms = function(appId){
            return translate('bt.post.twilioChannel',{appId:appId},{});
        };
        var testIdp = function(idpConfig){
            return translate('bt.apikey_basic.test',{},idpConfig);
        };

        var getIdp = function(appId,_streamId){
            return translate('bt.idp.get',{appId:appId,streamId:_streamId},{});
        };
        var getIdpByName = function(appName,_streamId){
            return translate('bt.idp.getbyname',{refId:appName,streamId:_streamId},{});
        };

        var editIdp = function(appId,_streamId,idpConfig){
            return translate('bt.idp.put',{appId:appId,streamId:_streamId},idpConfig);
        };

        var deleteIdp = function(appId,_streamId){
            return translate('bt.idp.delete',{appId:appId,streamId:_streamId},{});
        };

        var testRequestChain = function (requestObj) {
            return translate('bt.testAlert.post', {}, requestObj);
        };
        
        var connectors = function () {
            if (canAccessConnectors()) {
                return translate('bt.alert.connectors', {}, {});
            } else {
                return $q.reject({"errors":[{"msg":"Not a managed user","code":"Unauthorized"}]});
            }
        };

        var canAccessConnectors = function () {
            return $rootScope.isManaged;
        };

    	return {
    		getIdpList   : getIdpList,
    		getCallBackUrl : getCallBackUrl,
    		createIdp : createIdp,
            testIdp : testIdp,
            createStreamUserAccount:createStreamUserAccount,
            deleteStreamUserAccount:deleteStreamUserAccount,
            getIdp:getIdp,
            getIdpByName:getIdpByName,
            deleteIdp:deleteIdp,
            editIdp:editIdp,
            connectors:connectors,
            testRequestChain:testRequestChain
    	};

    }]);

})(angular);


;(function (ng) {
    'use strict';
    ng.module('services').service('BTKoraService', ['$translator', function ($translator) {

            function translate(urlIdentifier, params, payload, headers) {
                return $translator.translate(urlIdentifier, params, payload, headers);
            }
            var getKoraUsers = function (streamId,offset,limit) {
                return translate('bt.kora.users.get', {streamId: streamId,offset:offset,limit:limit}, {});
            };
            var getKoraLogs = function (userId, streamId, offset, limit) {
                return translate('bt.kora.logs.get', {streamId: streamId, uId: userId, offset: offset, limit: limit}, {});
            };
            return {
                getKoraUsers: getKoraUsers,
                getKoraLogs:getKoraLogs
            };
        }]);

})(angular);

;(function (ng) {

    'use strict';
    ng.module('services').service('localstore', function ($timeout) {
        
        var _storeType='localStorage';
        if(window.appConfig && window.appConfig.USE_SESSION_STORE){
            _storeType='sessionStorage';
        }
        return {
            /* jStorage Key*/
            setAuthData: function (authData) {
                window[_storeType].setItem('jStorage', JSON.stringify(authData));
            },
            /* jStorage Key*/
            getAuthData: function () {
                var _authData;
                try {
                    var _j = window[_storeType].getItem('jStorage');
                    if (_j === '{}' || _j === '') {
                        return _authData;
                    }
                    _authData = JSON.parse(_j);
                } catch (ex) {
                    return _authData;
                }
                return _authData;
            },
            /* selectedAccount Key*/
            setSelectedAccount: function (account) {
                var _storeType='sessionStorage';//local variable overrides the storeType to 'sessionStorage' always for selectedAccount
                window[_storeType].setItem('selectedAccount', JSON.stringify(account));
            },
            /* selectedAccount Key*/
            getSelectedAccount: function () {
                var _storeType='sessionStorage';//local variable overrides the storeType to 'sessionStorage' always for selectedAccount
                var _authData;
                try {
                    var _j = window[_storeType].getItem('selectedAccount');
                    if (_j === '{}' || _j === '') {
                        return _authData;
                    }
                    _authData = JSON.parse(_j);
                } catch (ex) {
                    return _authData;
                }
                return _authData;
            },
             /* selectedAccount Key*/
            removeSelectedAccount: function (authData) {
                var _storeType='sessionStorage';//local variable overrides the storeType to 'sessionStorage' always for selectedAccount
                window[_storeType].removeItem('selectedAccount');
            },
            removeFromLoginScreenFlag: function () {
                var _storeType='localStorage';//local variable overrides the storeType to 'sessionStorage' always for selectedAccount
                window[_storeType].removeItem('fromLoginScreen');
            },
            setFromLoginScreenFlag: function () {
                var _storeType='localStorage';//local variable overrides the storeType to 'sessionStorage' always for selectedAccount
                window[_storeType].setItem('fromLoginScreen',true);
            },
            getFromLoginScreenFlag: function () {
                var _storeType='localStorage';//local variable overrides the storeType to 'sessionStorage' always for selectedAccount
                return window[_storeType].getItem('fromLoginScreen');
            },
            
//             /* selectedAccount Key*/
//            setSelectedSSOAccount: function (account) {
//                window[_storeType].setItem('selectedSSOAccount', JSON.stringify(account));
//            },
//            /* selectedAccount Key*/
//            getSelectedSSOAccount: function () {
//                var _authData;
//                try {
//                    var _j = window[_storeType].getItem('selectedSSOAccount');
//                    if (_j === '{}' || _j === '') {
//                        return _authData;
//                    }
//                    _authData = JSON.parse(_j);
//                } catch (ex) {
//                    return _authData;
//                }
//                return _authData;
//            },
//             /* selectedAccount Key*/
//            removeSelectedSSOAccount: function (authData) {
//                window[_storeType].removeItem('selectedSSOAccount');
//            }
            
            
        };
    });
})(angular);


;(function(ng) {

    'use strict';
    ng.module('services').service('nlpService', function() {

    	var _nlpStore = {};

    	var intents = function(intents){
    		_nlpStore.intents = intents;
    	};

    	var alerts = function(alerts){
    		_nlpStore.alerts = alerts;
    	};

    	return {
    		intents:intents,
    		alerts:alerts,
    		nlpStore:_nlpStore
    	};

    });
 })(angular);

;(function(ng) {

    'use strict';

    ng.module('services').service('NotificationService', ['$timeout','i18n', 'env_conf', function($timeout,i18n,env_conf) {
        var clearAll = function(){
          $.noty.closeAll();
        };
      	var notify = function(msg, type,timeout){

          msg = encodeMsg(msg);

          type = type || 'warning';
          type = (type === 'info' ? 'success' : type);
          // var faCheck = env_conf['context-url']+'/assets/icons/fa-check.svg';
          // var faStop = env_conf['context-url']+'/assets/icons/fa-stop-o.svg';
          // var faExclamation = env_conf['context-url']+'/assets/icons/fa-exclamation-triangle.svg';
          // var faClose = env_conf['context-url']+'/assets/icons/fa-close.svg';
          // if(type === 'success'){
          //   msg = '<span class="fa pl-0"><img src="'+faCheck+'"></span>&nbsp;&nbsp;<span>'+msg+'</span><span class="fa"><img src="'+faClose+'"></span>';
          //   msg = '<span class="fa pl-0"><img src="'+faCheck+'"></span>&nbsp;&nbsp;<span>'+msg+'</span><span class="fa"><img src="'+faClose+'"></span>';
          // }else if(type === 'error'){
          //   msg = '<span class="fa pl-0"><img src="'+faStop+'"></span>&nbsp;&nbsp;<span>'+msg+'</span><span class="fa"><img src="'+faClose+'"></span>';
          // }else if(type === 'warning'){
          //   msg = '<span class="fa pl-0"><img src="'+faExclamation+'"></span>&nbsp;&nbsp;<span>'+msg+'</span><span class="fa"><img src="'+faClose+'"></span>';
          // }else{
          //   msg = '<span>'+msg+'</span>';
          // }

          var icon = "";
          var typeClass = "";
          if(type === 'success'){
            typeClass = "green";
            icon = "btx-billing-checked";
          } else if(type === 'error'){
            typeClass = "pink";
            icon = "btx-warning";
          } else if(type === 'warning'){
            typeClass = "yellow";
            icon = "btx-info";
          }

          msg='<div class="defaultToast '+ typeClass +'"><div class="toastIcon"><i class="'+ icon +'"></i></div><div> '+msg+' </div><i class="btx-close"></i></div>';
          var notifier = noty({
            layout: 'topRight',
            text:msg,
            type:type,
            animation: {
                open: 'animated fadeIn alertWarning0',
                easing: 'swing',
                speed: 500
            }
          });

          var interval = setInterval(function(){
             if(notifier.$bar){
               $($(notifier.$bar[0]).closest('ul')).remove();
             }
            
            $('#'+notifier.options.id).click();
            clearInterval(interval);
          },(timeout || 10000));

      	};

        var alert = function(text,cb,args,layout,isModal, heading){
          
          if(!args.addHtmlContent){
            text = encodeMsg(text); // already encoded in global level//
          }
          if($("#noty_topCenter_layout_container").find("li").length){
            return;
          }
          if(args.linkObj && args.linkObj.link){
            text = '<span>'+text+'</span>' +' '+ '<a href='+args.linkObj.link+' target="_blank">'+args.linkObj.text+'</a>';
          }
          // text = encodeMsg(text);
          else{
          text = '<span>'+text+'</span>';
          }

          heading = heading || '<span>'+i18n.i18nString('are_you_sure_label')+'</span>';
          var msg     = ''+text;
          $.noty.closeAll();
          var loader=noty({
            layout: layout || 'topCenter',
            type:'warning',
            animation: {
                open: 'animated fadeIn alertDelete',
                easing: 'swing',
                speed: 500
            },
            callback: {
                onClose: function () {
                    $('body').removeClass('alertDeleteBoxShown');
                }
            },

            modal: (isModal+'' === 'undefined')? true : false,
            text: '',
            template:'<div class="modal-header"><h4 class="modal-title">'+heading+'</h4></div><div class="noty_message  modal-body alertModel"><div><i class="btx-warning text-danger"></i></div>'+msg+'</div>',
            buttons: [
              {addClass: 'btn btn-default text-danger', text: ''+(args.okText||i18n.i18nString('ok_label'))+'', onClick: function($noty) {
                  $noty.close();
                  $timeout(function(){
                    if(_.isArray(cb)){
                      cb[0].apply(undefined,args);
                    }else{
                      cb.apply(undefined,args);
                    }
                  });
                }
              },
              {addClass: 'btn btn-danger', text: (args.cancelText||i18n.i18nString('cancel')), onClick: function($noty) {
                  $noty.close();
                  if(_.isArray(cb)){
                    cb[1].apply(undefined,[]);
                  }
                }
              }
            ]
          });

           $timeout(function(){
              $($(loader.$bar[0]).closest('.i-am-new')).addClass('alertDeleteBox');
              $('body').addClass('alertDeleteBoxShown');
            },10);

        };
        var userConfirm = function(text,cb,args,layout,isModal, heading){    // used in dailogs and KT confirmations

          if($("#noty_topCenter_layout_container").find("li").length){
            return;
          }
          if(!args.addHtmlContent){
             text = encodeMsg(text); 
          }
          var msg  = '<span>'+text+'</span>';
          var checkBox ='';
          var bodyClass = 'textCenter'; 
          if(args.checkBox && args.checkBox.enable){
            checkBox = '<div class="checkbox checkbox-primary styledCSS"><input  type="checkbox" id="showHideDownloadPopup"><label for="showHideDownloadPopup">'+i18n.i18nString('dont_show_this_msg')+'</label></div>';         
            bodyClass = 'textJustify userConfirmNotifi';
          }
          var loader=noty({
            layout: layout || 'topCenter',
            type:'warning',
            animation: {
                open: 'animated fadeIn alertDelete',
                easing: 'swing',
                speed: 500
            },
            callback: {
                onClose: function () {
                  if(args.checkBox && args.checkBox.enable){
                    args.checkBox.enable = $('#showHideDownloadPopup')[0].checked;
                    args.checkBox.checkBoxCb(args.checkBox.enable);
                  }
                    $('body').removeClass('alertDeleteBoxShown');
                }
            },

            modal: (isModal+'' === 'undefined')? true : false,
            text: '',
            template:'<div class="modal-header"><h4 class="modal-title">'+heading+'</h4></div><div class="noty_message '+ bodyClass +' modal-body">'+msg+ checkBox+'</div>' ,
            buttons: [
              {addClass: 'btn'+ ' ' + (args.btnClass||''), text: (args.okText||i18n.i18nString('ok')), onClick: function($noty) {
                if(args.checkBox && args.checkBox.enable){
                  args.enable = $(showHideDownloadPopup).checked;
                }
                  $noty.close();
                  $timeout(function(){
                    if(_.isArray(cb)){
                      cb[0].apply(undefined,args);
                    }else{
                      cb.apply(undefined,args);
                    }
                  });
                }
              },
              {addClass: 'btn btn-danger cancleUserConfirm', text: (args.cancelText||i18n.i18nString('cancel')), onClick: function($noty) {
                  $noty.close();
                  if(_.isArray(cb)){
                    cb[1].apply(undefined,[]);
                  }
                }
              }
            ]
          });

           $timeout(function(){
              $($(loader.$bar[0]).closest('.i-am-new')).addClass('alertDeleteBox');
              $('body').addClass('alertDeleteBoxShown');
            },10);

        };
        var confirmDialog = function(text,cb,args,layout,isModal,heading){
        //   if(!args.addHtmlContent){
        //     text = encodeMsg(text); // already encoded in global level//
        //  }
          var _buttons=[];
          if((args && args.noCancelBtn)){
              _buttons.push({addClass: 'btn btn-default text-danger centerButton', text: ''+(args.okText||i18n.i18nString('ok_label'))+'', onClick: function($noty) {
                  $noty.close();
                  $timeout(function(){
                    if(_.isArray(cb)){
                      cb[0].apply(undefined,args);
                    }else{
                      cb.apply(undefined,args);
                    }
                  });
                }
              });
          }
          if(!(args && args.noCancelBtn)){
              _buttons.push({addClass: 'btn btn-default text-danger', text: ''+(args.okText||i18n.i18nString('ok_label'))+'', onClick: function($noty) {
                  $noty.close();
                  $timeout(function(){
                    if(_.isArray(cb)){
                      cb[0].apply(undefined,args);
                    }else{
                      cb.apply(undefined,args);
                    }
                  });
                }
              });
              _buttons.push({addClass: 'btn btn-danger', text: (args.cancelText||i18n.i18nString('cancel')), onClick: function($noty) {
                  $noty.close();
                  if(_.isArray(cb)){
                    cb[1].apply(undefined,[]);
                  }
                }
              });
          }
              
            var template = '<div class="noty_message  modal-body"><div><i class="btx-warning text-danger"></i></div>'+text+'</div>';
            if(heading){
              template = '<div class="modal-header"><h4 class="modal-title">'+heading+'</h4></div>' + template;
            }
          var loader=noty({
            layout: layout || 'topCenter',
            type:'warning',
            animation: {
                open: 'animated fadeIn alertDelete',
                easing: 'swing',
                speed: 500
            },
            callback: {
                onClose: function () {
                    $('body').removeClass('alertDeleteBoxShown');
                }
            },

            modal: ((isModal+'' === 'undefined') || (isModal+'' === 'null'))? true : false,
            text: '',
            template:template,
            buttons:_buttons
          });

           $timeout(function(){
              $($(loader.$bar[0]).closest('.i-am-new')).addClass('alertDeleteBox');
              $('body').addClass('alertDeleteBoxShown');
            },10);

        };

        var alertNotify = function (head,msg,type){
          notify(msg,type);
        };

        var loader = function(msg,type){

          msg = encodeMsg(msg);
          msg = msg+'...';
          msg = '<i class="fa fa-circle-o-notch fa-spin"></i>&nbsp;&nbsp;<span>'+msg+'</span>';

          var loaderToast =  noty({
            layout: 'center',
            text:msg,
            type:type || 'warning',
            animation: {
                open: 'animated fadeIn alertLoading',
                easing: 'swing',
                speed: 500
            }
          });

         
              $($(loaderToast.$bar[0]).closest('ul')).addClass('loadertoast');
            

          return function close(){
              //  $($(loaderToast.$bar[0]).closest('ul')).removeClass('loadertoast');
              if(loaderToast.$bar && loaderToast.$bar.length){
                $($(loaderToast.$bar[0]).closest('ul')).remove();
              }
              
              $(".loadertoast").remove();
                $('#'+loaderToast.options.id).click();
          };

        };
		
                
                
                     var loadingMessage = function(msg,type){

          msg = encodeMsg(msg);
          msg = msg+'...';
          msg = '<div class="loading-div"><i class="fa fa-spinner fa-spin"></i>&nbsp;&nbsp;<span>'+msg+'<span></div>';

          var loadingMessage =  noty({
            layout: 'center',
            text:msg,
            animation: {
                open: 'animated fadeIn alertLoading',
                easing: 'swing',
                speed: 500
            }
          });

          return function close(){
            $timeout(function(){
              $('#'+loadingMessage.options.id).click();
            });
          };

        };
                
                
                

        /**
         * config = {
         *   callbacks : {
         *     success : func,
         *     failure : func
         *   },
         *   arguments : {
         *     success : [],
         *     failure : []
         *   },
         *   btnText : {
         *     success : 'text',
         *     failure : 'failed'
         *   }
         * }
         */

        var timerAlert = function(message,config,context){

          message         = encodeMsg(message);
          message         = '<span>'+message+'</span>';
          var heading     = '<span></span>';
          var msg         = message;
          var succCb      = config.callbacks.success;
          var failCb      = config.callbacks.failure;
          var succArgs    = config.arguments.success;
          var failArgs    = config.arguments.failure;
          var succBtnTxt  = config.btnText.success;
          var failBtnTxt  = config.btnText.failure;

          noty({
            layout: 'topCenter',
            type:'warning',
            animation: {
                open: 'animated fadeIn alertWarning3',
                easing: 'swing',
                speed: 500
            },
            modal: true,
            text: '',
            template:'<div class="noty_message modal-body">'+msg+'<span class="noty_text"></span><div class="noty_close"></div></div>',
            buttons: [
              {addClass: 'btn btn-default', text: succBtnTxt, onClick: function($noty) {
                  $noty.close();
                  $timeout(function(){
                    succCb.apply(context,succArgs);
                  });
                }
              },
              {addClass: 'btn btn-danger', text: failBtnTxt, onClick: function($noty) {
                  failCb.apply(context,failArgs);
                  $noty.close();
                }
              }
            ]
          });

        };

        function encodeMsg(msg){
          msg = msg || '';
          return msg.replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }

        var confirm = function(config){

          var text;

          var defaultConfig = {
            msg       : '',
            heading   : '',
            successCb : angular.noop,
            failCb    : angular.noop,
            layout    : '',
            isModal   : true,
            btnTexts  : {
              success : i18n.i18nString('ok_label'),
              fail    : i18n.i18nString('cancel')
            }
          };

          config = angular.extend(defaultConfig,config);

          text = encodeMsg(config.msg);
          text = '<span class='+config.bodyClass+'>'+text+'</span>';

          // var heading = config.heading ? ('<span class='+config.headerClass+'>'+config.heading+'</span><br>') : '';
          var msg     = text;
          var note    = config.note ? ('<br><br><span class='+config.noteClass+'> <span class="label">'+i18n.i18nString('note_label2')+'</span> '+config.note+'</span>') : '';  
          msg = msg + note;
          var template  = '<div class="noty_message  modal-body"><div class='+config.class+'><i class="btx-warning text-danger"></i></div>'+msg+'</div>';
          if(config.heading){
            template = '<div class="modal-header"><h4 class="modal-title">'+config.heading+'</h4></div>' + template;
          }
          var _cnf={
            layout: config.layout || 'topCenter',
            type:'warning',
            animation: {
                open: 'animated fadeIn alertDelete',
                easing: 'swing',
                speed: 500
            },
            callback: {
                onClose: function () {
                    $('body').removeClass('alertDeleteBoxShown');
                }
            },
            modal: config.isModal ? true : false,
            text: '',
            template:template,
            buttons: [
              {addClass: 'btn btn-default text-danger', text: config.btnTexts.success, onClick: function($noty) {
                  $noty.close();
                  $timeout(function(){
                    config.successCb();
                  });
                }
              },
              {addClass: 'btn btn-danger', text: config.btnTexts.fail, onClick: function($noty) {
                  $noty.close();
                  config.failCb();
                }
              }
            ]
          };
          
            if (config.cancelCb) {
                _cnf.buttons.push({addClass: 'btn btn-danger close_noty_cnfm fa fa-fw', text:'<i class="fa fa-times" id="close_noty_cnfm_id" aria-hidden="true"></i>', onClick: function ($noty) {
                        $noty.close();
                        config.cancelCb();
                    }
                });
            }
          var loader=noty(_cnf);

           $timeout(function(){
              $($(loader.$bar[0]).closest('.i-am-new')).addClass('alertDeleteBox');
              $('body').addClass('alertDeleteBoxShown');
            },10);

        };

        var suggestion = function(config){
            var text;

            var defaultConfig = {
              msg       : '',
              heading   : '',
              successCb : angular.noop,
              failCb    : angular.noop,
              layout    : '',
              isModal   : true,
              btnTexts  : {
              success : i18n.i18nString('ok_label'),
             }
            };

            config = angular.extend(defaultConfig,config);

            text = encodeMsg(config.msg);
            text = '<span class='+config.bodyClass+'>'+text+'</span>';

            var heading = config.heading ? ('<span class='+config.headerClass+'>'+config.heading+'</span><br>') : '';
            var msg     = heading + text;
            var note    = config.note ? ('<br><br><span class='+config.noteClass+'> <span class="label">'+i18n.i18nString('note_label2')+'</span> '+config.note+'</span>') : '';  
            msg = msg + note;
            var _cnf={
            layout: config.layout || 'topCenter',
            type:'warning',
            animation: {
                open: 'animated fadeIn alertDelete',
                easing: 'swing',
                speed: 500
            },
            callback: {
                onClose: function () {
                    $('body').removeClass('alertDeleteBoxShown');
                }
            },
            modal: config.isModal ? true : false,
            text: '',
            template:'<div class="noty_message  modal-body"><div class='+config.class+'><i class="btx-warning text-danger"></i></div>'+msg+'</div>',
            buttons: [
              {addClass: 'btn btn-default text-danger', text: config.btnTexts.success, onClick: function($noty) {
                  $noty.close();
                  $timeout(function(){
                    config.successCb();
                  });
                }
              }
            ]
          };
          if (config.cancelCb) {
                _cnf.buttons.push({addClass: 'btn btn-danger close_noty_cnfm fa fa-fw', text:'<i class="fa fa-times" id="close_noty_cnfm_id" aria-hidden="true"></i>', onClick: function ($noty) {
                        $noty.close();
                        config.cancelCb();
                    }
                });
            }
          var loader=noty(_cnf);

           $timeout(function(){
              $($(loader.$bar[0]).closest('.i-am-new')).addClass('alertDeleteBox');
              $('body').addClass('alertDeleteBoxShown');
            },10);
        };

        var removeLoader = function () {
          $("#noty_center_layout_container").empty();
        };

      	var retObj={
          alert       : alert,
          loader      : loader,
          loadingMessage :loadingMessage,
          notify      : notify,
          confirm     : confirm,
          timerAlert  : timerAlert,
          alertNotify : alertNotify,
          confirmDialog:confirmDialog,
          removeLoader: removeLoader,
          userConfirm:userConfirm,
          suggestion:suggestion,
          clearAll:clearAll
      	};
        window.NotificationService=retObj;
        return retObj;

    }]);

})(angular);

;(function(ng) {
    'use strict';
    ng.module('services').service('BTParamMapService', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

    	var getAlert = function(alertId){
    		return translate('bt.paramMap.alert.get', {alertId: alertId});
    	};

    	var getAction = function(actionId){
    		return translate('bt.paramMap.action.get', {actionId: actionId});
    	};

    	var createParamMap = function(paramMap){
    		return translate('bt.paramMap.post', {actionId: paramMap.actionId}, paramMap);
    	};
        
        var updateParamMap = function(mappingId,paramMap){
            return translate('bt.paramMap.maping.put',{mappingId:mappingId},paramMap);
        };
        
        var updateAlertDialogParamMap = function(mappingId,paramMap){
            return translate('bt.alertDialogParamMap.maping.put',{mappingId:mappingId},paramMap);
        };

    	var getMappedActions = function(actionId, version){
    		return translate('bt.paramMap.action.get', {actionId: actionId, version: version}, {});
    	};
        
        var getMappedDialogs = function(dialogId, version){
    		return translate('bt.paramMap.dialog.get', {dialogId: dialogId, version: version}, {});
    	};

    	var getMappedAlerts = function(alertId, version){
    		return translate('bt.paramMap.alert.get',{alertId: alertId, version: version}, {});
    	};

        var getMappedAlertAction = function(mappingId){
            return translate('bt.paramMap.maping.get',{mappingId:mappingId},{});
        };
        
        var getMappedAlertDialog = function(mappingId){
            return translate('bt.paramDialogMap.maping.get',{mappingId:mappingId},{});
        };

        var deleteMappedAlertAction = function(mappingId){
            return translate('bt.paramMap.maping.delete',{mappingId:mappingId},{});
        };
        
        var deleteMappedAlertDialog = function(mappingId){
            return translate('bt.paramDialogMap.maping.delete',{mappingId:mappingId},{});
        };

        var getDotKeys = function(jsonObject){
            if(jsonObject && jsonObject.metainfo) {
                delete jsonObject.metainfo;
            }
            
            return translate('bt.dotKeys.post',{},jsonObject);
        };

    	return {
    		getAlert: getAlert,
                getDotKeys: getDotKeys,
                getAction: getAction,
                getMappedAlertAction: getMappedAlertAction,
                getMappedAlertDialog: getMappedAlertDialog,
                updateAlertDialogParamMap: updateAlertDialogParamMap,
                deleteMappedAlertAction: deleteMappedAlertAction,
                deleteMappedAlertDialog: deleteMappedAlertDialog,
                createParamMap: createParamMap,
                updateParamMap: updateParamMap,
                getMappedActions: getMappedActions,
                getMappedAlerts: getMappedAlerts,
                getMappedDialogs:getMappedDialogs
    	};
    }]);

})(angular);

;(function(ng) {

    'use strict';

    ng.module('services').service('BTProcessAppDataService', ['$translator', function($translator) {

    	var getProcessAppsData = function() {
            return $translator.translate('bt.processAppsdata.get');
        };

    	return {
    		getProcessAppsData: getProcessAppsData
    	};

    }]);

})(angular);

;(function(ng) {

    'use strict';

    ng.module('services').service('BTSeedDataService', ['$translator', function($translator) {

    	var getSeedData = function() {
            return $translator.translate('bt.seeddata.get');
        };

        var getSeedCategories = function(){
            return $translator.translate('bt.seedCategories.get');
        };

    	return {
    		getSeedData: getSeedData,
            getSeedCategories:getSeedCategories
    	};

    }]);

})(angular);

;(function(ng) {
    'use strict';
    ng.module('services').service('BTSlashCommandsService', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

        function getCommand(streamId){
            return translate('bt.command.get',{streamId:streamId},{});
        }

        function createCommand(streamId,command){
            return translate('bt.command.create',{streamId:streamId},command);
        }

        function editCommand(streamId,command){
            return translate('bt.command.edit',{streamId:streamId},command);
        }

        function deleteCommand(streamId){
            return translate('bt.command.delete',{streamId:streamId},{});
        }

        function getSubCommand(actionId){
            return translate('bt.subCommand.get',{actionId:actionId},{});
        }

        function createSubCommand(actionId,subCommand){
            return translate('bt.subCommand.create',{actionId:actionId},subCommand);
        }

        function editSubCommand(actionId,id,subCommand){
            return translate('bt.subCommand.edit',{actionId:actionId,id:id},subCommand);
        }

        function deleteSubCommand(actionId,id){
            return translate('bt.subCommand.delete',{actionId:actionId,id:id},{});
        }

    	return {
            getCommand       : getCommand,
            createCommand    : createCommand,
            editCommand      : editCommand,
            deleteCommand    : deleteCommand,
            getSubCommand    : getSubCommand,
            createSubCommand : createSubCommand,
            editSubCommand   : editSubCommand,
            deleteSubCommand : deleteSubCommand
    	};

    }]);

})(angular);


;(function(ng) {

    'use strict';

    ng.module('services').service('soap', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

        function getDescription(payload){
            return translate('bt.soap.desc',{},payload);
        }

        function execute(payload){
            return translate('bt.soap.execute',{},payload);
        }

    	return {
            getDescription : getDescription,
            execute        : execute
    	};

    }]);

})(angular);


;(function(ng) {
    'use strict'; 
    ng.module('services').service('BTStreamsService', ['$translator', function($translator) {


      var makeSDKSubscription = function(streamId, requestData) {
        return $translator.translate('bt.flowtask.SDKSubscription',{streamId: streamId}, requestData);
      };

      var deleteSDKSubscription = function(streamId, requestData) {
        return $translator.translate('bt.flowtask.SDKSubscription.delete',{streamId: streamId}, requestData);
      };

       function alexaExport(userId, streamId, echoShow) {
        return $translator.translate('bt.post.alexaExport', {streamId:streamId,echoShow: echoShow});
      }
      //  function mlUtterencesScore(streamId) {
      //   return $translator.translate('bt.get.mlUtterencesScore', {streamId:streamId});
      // }
      function mlUtterencesScore(streamId,payload) {
        return $translator.translate('bt.post.mlUtterencesScore', {streamId:streamId},payload);
      }
      function mlKfoldScore(streamId) {
        return $translator.translate('bt.get.mlKfoldScore', {streamId:streamId});
      }
      function mlKfoldScoreDownload(streamId) {
        return $translator.translate('bt.get.mlKfoldScoreDownload', {streamId:streamId});
      }
      function sampleJsTamplates(channel,name,sample) {
        return $translator.translate('bt.get.sampleJsTamplates', {"channel":channel,"name":name,"sample":sample});
      }
      /*start of services related to faqs*/

      function createKnowledgeTask(userId, ktObject) {
        return $translator.translate('bt.post.ktCreate', {}, ktObject);
      }

        function updateThresholds(streamId,thresholdObject) {
            return $translator.translate('bt.threshold.update', {"streamId":streamId}, thresholdObject);
        }
      function updateKnowledgeTask(userId, ktObject) {
        return $translator.translate('bt.put.ktUpdate', {"ktId":ktObject._id}, ktObject);
      }

      function updateMLSynonym(streamId, reset,resetkey, mlSynonymObj) {
          return $translator.translate('bt.mlSynonym.update', {"streamId":streamId,"reset":reset,"resetkey":resetkey}, mlSynonymObj);
      }

      function getMLSynonym(streamId) {
          return $translator.translate('bt.mlSynonym.get', {"streamId":streamId});
      }

      function deleteKnowledgeTask(userId, knowledgeID) {
        return $translator.translate('bt.delete.ktDelete', {"knowledgeID":knowledgeID});
      }

      function getAllKtsList(userId, requestData) {
        return $translator.translate('bt.get.ktGet', requestData, requestData );
      }
      function ktGetAllLanguage(userId, requestData) {
        return $translator.translate('bt.get.ktGetAllLanguage', requestData, requestData );
      }

      function saveAndUpdateFAQ(userId, faqObject) {
        return $translator.translate('bt.post.addFaqs', {}, faqObject);
      }

      function getPossibleTags(userId, ktId, queryObject) {
          return $translator.translate('bt.post.getPossibleTags', {"ktId": ktId}, queryObject);
      }

      function faqBulkUpdate(userId, faqCollection) {
        return $translator.translate('bt.put.faqBulkUpdate', {}, faqCollection);
      }
 
      function getFAQS(userId, ktID) {
        return $translator.translate('bt.get.getfaqs', {"ktId": ktID});
      }

      function getOrSearchFAQS(userId, ktID, searchParam, offSet, limit, parentId, withallchild, filter) {
        return $translator.translate('bt.get.getorsearchfaq', {"ktId": ktID, "searchParam" : searchParam, "offSet":offSet, "limit":limit, "parentId":parentId, "withallchild":withallchild, "filter": filter});
      }

      var getKtGlobalSynonyms = function getKtGlobalSynonyms(streamId, offset,limit,search,keyword,state,ktId) {
        return $translator.translate('bt.get.getKtGlobalSynonyms', {"streamId": streamId,"offset":offset,"limit":limit,"search":search,"keyword":keyword,"state":state,'ktId':ktId});
      };

      var addKtGlobalSynonyms = function addKtGlobalSynonyms(streamId, payload) {
        return $translator.translate('bt.post.addKtGlobalSynonyms', {streamId: streamId}, payload);
      };
      
      function deleteKtGlobalSynonyms(streamId,synonymsId) {
      return $translator.translate('bt.delete.deleteKtGlobalSynonyms', {"streamId":streamId,synonymsId: synonymsId});
      }

      function editKtGlobalSynonyms(streamId,synonymsId, payload) {
        return $translator.translate('bt.put.editKtGlobalSynonyms', {"streamId":streamId,"synonymsId":synonymsId}, payload);
      }
      function removeFAQ(userId, faqID) {
        return $translator.translate('bt.delete.removeFaqs', {faqID: faqID});
      }

      function updateFAQ(userId, faqData, faqID) {
        return $translator.translate('bt.put.editfaqs', {"faqID":faqID}, faqData);
      }

      function uploadFAQFile(userId, importedFileData) {
        return $translator.translate('bt.post.uploadfaqfile', {}, importedFileData, {"Content-Type" : "txt/csv"});
      }

      function importFAQFileBYFileID(userId, importFileData) {
        return $translator.translate('bt.post.importfaqsbyfileid', {}, importFileData);
      }

      function importFAQFileBYFileIDForce(userId, importFileData) {
        return $translator.translate('bt.post.importfaqsbyfileidForce', {}, importFileData);
      }

      function uploadBotFunctionsFile(userId, importedFileData) {
        return $translator.translate('bt.post.uploadbotfuncfile', {}, importedFileData);
      }

      function addBotFunctions(streamId,payload) {
        return $translator.translate('bt.post.botfunction',{"streamId":streamId}, payload);
      }

      function getBotFunctions(streamId) {
        return $translator.translate('bt.get.botfunction', {"streamId":streamId});
      }

      function deleteBotFunctions(streamId,payload) {
        return $translator.translate('bt.delete.botfunction', {"streamId":streamId}, payload);
      }

      var botFunctionsDownloadFile = function botFunctionsDownloadFile(streamId,fileId){
        return $translator.translate('bt.get.botFunctionsDownloadFile', {"streamId":streamId,fileId: fileId});
      };

      function getUrl(url) {
        return  $translator.translate('bt.get.url', {"url":url});
      }


      /*end of services related to faqs*/

      var getDialogs = function(streamId) {
        return translate('bt.dialogs.get', {streamId: streamId});
      };

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}


    	var getStreams = function() {
    		return translate('bt.streams.get', {}, {});
    	};

    	var editStream = function(streamId, streamObj) {
    		return translate('bt.streams.edit', {streamId: streamId}, streamObj);
    	};

      var editNlSettings = function(streamId,streamObj){
        return translate('bt.streams.editnl',{streamId:streamId},streamObj);
      };

    	var deleteBTStream = function(streamId) {
    		return translate('bt.streamsId.delete', {streamId: streamId});
    	};

      var deleteMPStream = function(streamId){
          return translate('mp.streamsId.delete', {streamId: streamId});
      };

    	var getStreamAlerts = function(streamId){
    		return translate('bt.streams.alerts.get', {streamId: streamId});
    	};

    	var getStreamActions = function(streamId){
    		return translate('bt.streams.actions.get', {streamId: streamId});
    	};

    	var createBTStream = function(userId, streamData){
    		return $translator.translate('bt.streams.post', {}, streamData);
    	};

    	var createMPStream = function(userId, streamData){
    		return $translator.translate('mp.streams.post', {}, streamData);
    	};

      var getBTStream = function(streamId,params, payload, headers){
          return $translator.translate('bt.streamsId.get', {streamId: streamId},{},headers);
      };

      var getMPStream = function(streamId){
          return $translator.translate('mp.streamsId.get', {streamId: streamId});
      };

      var getSolutionBotStream = function(streamId){
          return $translator.translate('solution.streamsId.get', {streamId: streamId});
      };

    	var updateMPStream = function(streamId, streamData){
          return $translator.translate('mp.streamsId.put', {streamId: streamId}, streamData);
      };

      var getErrorCodes = function(streamId){
  		    return $translator.translate('bt.stream.errorCodes', {streamId: streamId});
      };

      var getMappings = function(streamId){
          return $translator.translate('bt.mapsin.stream', {streamId: streamId});
      };

      var getAlertDialogMappings = function(streamId){
          return $translator.translate('bt.alertdialogmapsin.stream', {streamId: streamId});
      };

      var getSynonyms = function (streamId, taskName) {
          return $translator.translate('temp.synonyms.get', {streamId: streamId, taskName: taskName});
      };

      var postSynonyms = function (streamId, synonyms) {
          return $translator.translate('temp.synonyms.post', {streamId: streamId}, synonyms);
      };

      var updateWelcomeMessages = function (streamId, payload) {
          return $translator.translate('bt.welcomeMessage.post', {streamId: streamId}, payload);
      };

      var getGenericMessages = function getGenericMessages(streamId) {
          return translate('bt.nlp.messages.get',{streamId : streamId});
      };

      var editGenericMessages = function editGenericMessages(streamId,messages) {
        return translate('bt.nlp.messages.edit',{streamId:streamId},messages);
      };

      var editOverrideMessages = function editOverrideMessages(streamId, messages) {
        return translate('bt.nlp.messages.override', {streamId: streamId}, messages);
      };

      var channelSchema = function(){
          return $translator.translate('bt.channel.fieldschema',{});
      };

      var testNlp = function testNlp(streamId,sentence){
        return $translator.translate('bt.nlp.test', {streamId: streamId}, sentence);
      };

      var getTrainLogs = function getTrainLogs(streamId,sentence){
        return $translator.translate('bt.post.trainlogs', {streamId: streamId}, sentence);
      };

       var updateTryMode = function updateTryMode(streamId, payload) {
                return $translator.translate('bt.stream.trymode', {streamId: streamId}, payload);
       };
      var trainBotIntentLogs = function testNlp(streamId,postData){
        return $translator.translate('bt.post.trainbotintentlogs', {streamId: streamId}, postData);
      };

      var trainBotIntentBunchLogs = function testNlp(streamId,postData){
        return $translator.translate('bt.post.trainbotintentBunchlogs', {streamId: streamId}, postData);
      };

      var removeTrainBotIntentLogs = function testNlp(streamId,deleteData){
        return $translator.translate('bt.delete.removeTrainbotintentlogs', {streamId: streamId}, deleteData);
      };

      var createPattern = function createPattern(streamId,pattern){
        return $translator.translate('bt.pattern.create', {streamId: streamId}, pattern);
      };

      var taskPattern = function taskPattern(streamId,pattern){
        return $translator.translate('bt.taskPattern.edit', {streamId: streamId}, pattern);
      };

      var fieldPatternSortOrEdit = function fieldPatternSortOrEdit(streamId,pattern){
        return $translator.translate('bt.fieldPattern.edit', {streamId: streamId}, pattern);
      };

      var getPatterns  = function getPatterns(streamId){
        return $translator.translate('bt.pattern.get',{streamId:streamId});
      };

      var deletePattern = function deletePattern(context){
        return $translator.translate('bt.pattern.delete',context);
      };


      var getAccounts = function(streamId,isDeveloper,isTryOutUserConnection){
          return $translator.translate('bt.stream.accounts', {streamId: streamId,isTryOutUserConnection :isTryOutUserConnection,isDeveloper:isDeveloper});
      };


      var getRingCentralAccount = function(streamId,isDeveloper,isTryOutUserConnection, idpName){
          return $translator.translate('bt.stream.ringcentral.accounts', {streamId: streamId,isTryOutUserConnection :isTryOutUserConnection,isDeveloper:isDeveloper, idpName: idpName});
      };

      var getAuthinfo = function (streamId) {
                return $translator.translate('bt.stream.authinfo', {streamId: streamId});
       };
      var createAlertFieldSynonyms = function createAlertFieldSynonyms(taskId,fieldName,payload){
          return $translator.translate('field.synonyms.alerts.put', { taskId: taskId , fieldName : fieldName},payload);
      };
      var importEmojis = function importEmojis(streamId){
        return $translator.translate('import.emojis.post', {streamId: streamId});
      };

      var getAlertsFieldSynonyms = function getAlertsFieldSynonyms(taskId,fieldName){
          return $translator.translate('field.synonyms.alerts.get', { taskId: taskId , fieldName : fieldName });
      };

      var createActionsFieldSynonyms = function createActionsFieldSynonyms(taskId,fieldName,payload){
          return $translator.translate('field.synonyms.actions.put', { taskId: taskId , fieldName : fieldName},payload);
      };

      var getActionsFieldSynonyms = function getActionsFieldSynonyms(taskId,fieldName){
          return $translator.translate('field.synonyms.actions.get', { taskId: taskId , fieldName : fieldName });
      };

      var deleteChannel = function deleteChannel(streamId, channelType, gateway, payload){
          if(gateway){
              return $translator.translate('bt.stream.ciscoChannel.delete', { streamId: streamId, channelType: channelType, gateway: gateway });
          }
          return $translator.translate('bt.stream.channel.delete', { streamId: streamId, channelType: channelType }, payload);
      };

      var createOrEditChannel = function deleteChannel(streamId, channelType,payload){
          return $translator.translate('bt.stream.channel.create', { streamId: streamId, channelType: channelType },payload);
      };

      var getEmbedwebsdkDetails = function getEmbedwebsdkDetails(streamId){
        return $translator.translate('bt.stream.getEmbedwebsdkDetails', { streamId: streamId });
      };

      var postEmbedwebsdkDetails = function postEmbedwebsdkDetails(streamId, payload){
        return $translator.translate('bt.stream.postEmbedwebsdkDetails', { streamId: streamId }, payload);
      };

      var ivrVoiceReset = function deleteChannel(streamId){
        return $translator.translate('bt.stream.ivrVoiceReset', {streamId: streamId});
      };

      var testAuthorizeChannel = function deleteChannel(streamId, channel,rurl, params){
          return $translator.translate('bt.stream.channelAuthorize', { streamId: streamId, channel: channel, rurl: rurl },params);
      };

      var addChannelToBot = function deleteChannel(botId, payload){
          return $translator.translate('bt.stream.addChannel', { botId: botId },payload);
      };

      var getuserAdditionalIdentities = function getIdentities(userId){
          return $translator.translate('bt.user.getIdentities', { userId: userId });
      };

      var setupchecklist = function setupchecklist(userId,streamId){
        return $translator.translate('bt.get.setupchecklist', { userId: userId, streamId: streamId});
      };

      var updateChecklist = function updateChecklist(userId,streamId,payload){
        return $translator.translate('bt.put.updateChecklist', { userId: userId, streamId: streamId},payload);
      };

      var isFreeEmail = function getIdentities(emailId){
          return $translator.translate('bt.user.isFreeEmail', { emailId: emailId });
      };

      var addUserIdentity = function getIdentities(userId,params,payload){
          return $translator.translate('bt.user.addIdentity', { userId: userId },params,payload);
      };

      var deleteUserIdentity = function getIdentities(userId,identity,params){
          return $translator.translate('bt.user.deleteIdentity', { userId: userId ,identity:identity},params);
      };

      var resendIdentityVerification = function getIdentities(userId,params,payload){
          return $translator.translate('bt.user.resendIdentityVerification', { userId: userId },params,payload);
      };

      var verifyOTP = function verifyToken(token,params,payload){
          return $translator.translate('bt.user.verifyId', { token: token },params,payload);
      };

      var getWebhookUrl = function getWebhookUrl(streamId, isWorkPlace){

          if(isWorkPlace){
            return $translator.translate('bt.stream.wfb.webhookget', {streamId: streamId});
          }

          return $translator.translate('bt.stream.fb.webhookget', {streamId: streamId});
      };

      var getWebhookUrlForChannel = function(requestData){
          return $translator.translate('bt.stream.channel.webhookget', requestData);
      };

      var getBotChatScenarios = function getBotChatScenarios(streamId,streamName, result, offset, limit, search){
          return $translator.translate('bot.chat.scenarios',{streamId:streamId,streamName:streamName, result:result, offset:offset, limit:limit, search:search});
      };

      var createLock = function createLock(resourceId){
          return $translator.translate('bt.lock.create', {resourceId: resourceId},{});
      };

      var getLock = function getLock(resourceId){
          return $translator.translate('bt.lock.get',{resourceId:resourceId});
      };

      var releaseLock = function releaseLock(resourceId){
          return $translator.translate('bt.lock.release', {resourceId: resourceId},{});
      };

      var regenerateSubDialog = function regenerateSubDialog(streamId, formId, payload) {
        return $translator.translate('bt.dialogsId.regenerate', {streamId:streamId, formId: formId}, payload);
      };

      var shareBot = function shareBot(streamId,payload){
          return $translator.translate('bt.bot.share',{streamId:streamId},payload);
      };

      var inviteUser = function inviteUser(userId,payload){
        return $translator.translate('bt.bot.inviteUser',{userId:userId},payload);
      };

      var dashboardCount = function dashboardCount(userId,orgId,streamId,startDate,endDate, dimensions,channels,botTasks,languages,payload){
        return $translator.translate('bt.dashboardCount.get',{userId:userId,orgId:orgId,streamId:streamId,startDate:startDate,endDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,languages:languages},payload);
     };
      var dashboardCountUniversal = function dashboardCountUniversal(userId,orgId,streamId,startDate,endDate, dimensions,channels,botTasks,linkedbots,languages,payload){
        return $translator.translate('bt.dashboardCountUniversal.get',{userId:userId,orgId:orgId,streamId:streamId,startDate:startDate,endDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,linkedbots:linkedbots,languages:languages},payload);
     };
     var dashboardChatsUniversal = function dashboardChatsUniversal(userId,orgId,streamId,startDate,endDate, dimensions,channels,botTasks,linkedbots,languages,payload){
      return $translator.translate('bt.dashboardChatsUniversal.get',{userId:userId,orgId:orgId,streamId:streamId,startDate:startDate,endDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,linkedbots:linkedbots,languages:languages},payload);
   };
      var performingBotsUniversal = function performingBotsUniversal(userId,orgId,streamId,startDate,endDate, dimensions,channels,botTasks,linkedbots,languages){
        return $translator.translate('bt.performingBotsUniversal.get',{userId:userId,orgId:orgId,streamId:streamId,startDate:startDate,endDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,linkedbots:linkedbots,languages:languages});
     };
     var sessionsCount = function sessionsCount(userId,orgId,streamId,startDate,endDate,channels,languages,payload){
        return $translator.translate('bt.sessionsCount.put',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,channels:channels,languages:languages},payload);
     };
     var sessionsCountUniversal = function sessionsCountUniversal(userId,orgId,streamId,startDate,endDate,channels,linkedBots,languages,payload){
        return $translator.translate('bt.sessionsCountUniversal.put',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,channels:channels,linkedBots:linkedBots,languages:languages},payload);
     };
     var agentTransferMetrics = function agentTransferMetrics(userId,orgId,streamId,startDate,endDate,dimensions,channels,botTasks,languages,payload){
        return $translator.translate('bt.agentTransferMetrics.get',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,languages:languages},payload);
     };
     var agentTransferMetricsUniversal = function agentTransferMetricsUniversal(userId,orgId,streamId,startDate,endDate,dimensions,channels,botTasks,linkedbots,languages,payload){
        return $translator.translate('bt.agentTransferMetricsUniversal.get',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,linkedbots:linkedbots,languages:languages},payload);
     };
     var tasksMetrics = function tasksMetrics(userId,orgId,streamId,startDate,endDate,dimensions,channels,botTasks,languages,limit,payload){
        return $translator.translate('bt.tasksMetrics.get',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,languages:languages,limit:limit},payload);
     };
     var tasksMetricsUniversal = function tasksMetricsUniversal(userId,orgId,streamId,startDate,endDate,dimensions,channels,botTasks,linkedbots,languages,limit,payload){
        return $translator.translate('bt.tasksMetricsUniversal.get',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,linkedbots:linkedbots,languages:languages,limit:limit},payload);
     };
     var tasksMetricsExport = function tasksMetricsExport(userId,orgId,streamId,startDate,endDate,dimensions,channels,botTasks,linkedbots,languages,limit,payload){
      return $translator.translate('bt.tasksMetricsExport.get',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,linkedbots:linkedbots,languages:languages,limit:limit},payload);
   };

     var sessionsGraph = function sessionsGraph(userId,orgId,streamId,startDate,endDate,sessionInterval,channels,languages,payload){
        return $translator.translate('bt.sessionsGraph.put',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,sessionInterval:sessionInterval,channels:channels,languages:languages},payload);
     };
     var sessionsGraphUniversal = function sessionsGraphUniversal(userId,orgId,streamId,startDate,endDate,sessionInterval,channels,linkedbots,languages,payload){
        return $translator.translate('bt.sessionsGraphUniversal.put',{userId:userId,orgId:orgId,streamId:streamId,fromDate:startDate,toDate:endDate,sessionInterval:sessionInterval,channels:channels,linkedbots:linkedbots,languages:languages},payload);
     };
     var channelsMetrics = function channelsMetrics(userId,orgId,streamId,dimensions,startDate,endDate,payload){
        return $translator.translate('bt.channelsMetrics.get',{userId:userId,orgId:orgId,streamId:streamId,dimensions:"channel",fromDate:startDate,toDate:endDate},payload);
     };
     var channelsMetricsUniversal = function channelsMetricsUniversal(userId,orgId,streamId,dimensions,startDate,endDate,linkedbots,payload){
        return $translator.translate('bt.channelsMetricsUniversal.get',{userId:userId,orgId:orgId,streamId:streamId,dimensions:"channel",fromDate:startDate,toDate:endDate,linkedbots:linkedbots},payload);
     };
     var realTimeDashboard = function realTimeDashboard(userId,orgId,streamId,metrics){
       return $translator.translate('bt.realTimeDashboard.get',{userId:userId,orgId:orgId,streamId:streamId,metrics:metrics});
     };
     var realTimeDashboardChannels = function realTimeDashboardChannels(userId,orgId,streamId,dimensions,metrics){
      return $translator.translate('bt.realTimeDashboardChannels.get',{userId:userId,orgId:orgId,streamId:streamId,dimensions:dimensions,metrics:metrics});
    };

    var dashboardCharts = function dashboardCharts(userId,orgId,streamId,startDate,endDate, dimensions,channels,botTasks,languages,payload){
      return $translator.translate('bt.dashboardCharts.get',{userId:userId,orgId:orgId,streamId:streamId,startDate:startDate,endDate:endDate,dimensions:dimensions,channels:channels,botTasks:botTasks,languages:languages},payload);
   };
     var smartAlertSubscription = function smartAlertSubscription(streamId,componentId, payload){
        return $translator.translate('bt.put.smartAlertSubscription',{streamId:streamId,componentId:componentId}, payload);
     };
     var savePiiDataOptions = function savePiiDataOptions(streamId,componentId, payload){
      return $translator.translate('bt.post.savePiiDataOptions',{streamId:streamId,componentId:componentId}, payload);
   };
     var btExportVariables = function btExportVariables(userId,streamId,format) {
        return $translator.translate('bt.post.btExportVariables', {userId:userId,streamId:streamId,format:format});
     };
     var btExportVariablesStatus = function btExportVariablesStatus(userId,streamId) {
        return $translator.translate('bt.get.btExportVariablesStatus', {userId:userId,streamId:streamId});
     };
     var btImportVariables = function btImportVariables(userId, streamId, payload,format) {
        return $translator.translate('bt.post.btImportVariables', {userId:userId, streamId:streamId,format:format}, payload);
     };
     var btImportVariablesStatus = function btImportVariablesStatus(userId, streamId,_requestId) {
        return $translator.translate('bt.get.btImportVariablesStatus', {userId:userId, streamId:streamId,requestId:_requestId});
     };
     var btGetAllCollections = function btGetAllCollections(userId, streamId) {
      return $translator.translate('bt.get.btCollections', {userId:userId, streamId:streamId});
     };
     var btCreateCollection = function btCreateCollection(userId, streamId, payload) {
      return $translator.translate('bt.post.btCollections', {userId:userId, streamId:streamId}, payload);
     };
     var btUpdateCollection = function btUpdateCollection(userId, streamId, collectionId, payload) {
      return $translator.translate('bt.update.btCollections', {userId:userId, streamId:streamId, collectionId: collectionId}, payload);
     };
     var btDeleteCollection = function btDeleteCollection(userId, streamId, collectionId) {
      return $translator.translate('bt.delete.btCollections', {userId:userId, streamId:streamId, collectionId: collectionId});
     };
     var btEditVariableCollection = function btEditVariableCollection(userId, streamId, name) {
      return $translator.translate('bt.editVariable.btCollection', {userId:userId, streamId:streamId, name: name});
     };
     var addbulkBotVariables = function addbulkBotVariables(userId, streamId, payload) {
        return $translator.translate('bt.put.addBulkBotVariables', {userId:userId, streamId:streamId}, payload);
     };
      var promoteToOwner = function promoteToOwner(streamId,payload){
        return $translator.translate('bt.bot.owner',{streamId:streamId},payload);
      };

      var getContacts = function getContacts(streamId){
          return $translator.translate('bt.developers.get',{streamId:streamId});
      };

      var getUserInfo = function getUserInfo(userId){
          return $translator.translate('bt.user.resolve',{id:userId});
      };

      var authorizeIdp = function authorizeIdp(context,payload){
          return $translator.translate('bt.stream.auth.test',context,payload);
      };
      /* Changelogs start */
      var getChangeLog = function getChangeLog(streamId,offset, limit) {
            if (offset === undefined || limit === undefined) {
                return $translator.translate('bt.get.changelog', {streamId: streamId});
            } else {
                return $translator.translate('bt.get.changelog.limit', {streamId: streamId, offset: offset, limit: limit});
            }
      };
      var getChangeLogFilter = function getChangeLogFilter(streamId, offset, limit, payload) {
          return $translator.translate('bt.post.changelog.filter', {streamId: streamId, offset: offset, limit: limit}, payload);
      }; 
      var getChangeLogExport = function getChangeLogExport(userId, streamId, payload,status,filetype) {
          return $translator.translate('bt.post.changelogExport', {userId:userId, streamId:streamId, status:status,filetype:filetype}, payload);
      }; 
      /* Changelogs end */
      var getSessions = function(streamId) {
          return translate('bt.sessions.get', {streamId: streamId});
      };

      /* Analyze api's */
      var getChatHistory = function(streamId, msgId,direction,limit,showTimeLines) {
          return $translator.translate('bt.get.chatHistory',{streamId: streamId, msgId: msgId,direction: direction,limit: limit,showTimeLines: showTimeLines});
      };
      var getAnalyzeRecords = function(streamId, offset,limit,payload,mode) {
        return $translator.translate('bt.post.getRecords', {streamId: streamId, offset: offset, limit: limit, mode: mode},payload);
      };
      var updateAnalyzeRecord = function(streamId,recordId,payload) {
        return $translator.translate('bt.post.updateRecord', {streamId: streamId, recordId: recordId},payload);
      };
      var getAnalysisDetails = function(streamId,koralogId) {
        return $translator.translate('bt.get.analysisDetail', {streamId: streamId, koralogId: koralogId});
      };
      var getAnalysisPerformanceRecordDetails = function(streamId, requestTransitionRecordId, responseTransitionRecordId) {
        return $translator.translate('bt.get.analysisPerformanceRecordDetail', {streamId: streamId, requestTransitionRecordId : requestTransitionRecordId, responseTransitionRecordId:responseTransitionRecordId});
      };
      var analyzeGetRecordsExport = function(streamId,payload) {
        return $translator.translate('bt.post.getRecordsExport', {streamId: streamId},payload);
      };
      var analyzeStatus = function(userId, streamId){
        return $translator.translate('bt.post.analyzeStatus',{userId:userId, streamId:streamId});
      };
      var metaTags = function(streamId,start_date,end_date){
        return $translator.translate('bt.get.metaTags',{streamId:streamId,start_date:start_date,end_date:end_date},{},["start_date","end_date"]);
      };
      var channelSpecficChannelId = function(userId,streamId,start_date,end_date,offset,limit){
        return $translator.translate('bt.get.channelSpecficChannelId',{userId:userId,streamId:streamId,start_date:start_date,end_date:end_date,offset:offset,limit:limit},{},["start_date","end_date","offset","limit"]);
      };
      var analyzeRecordTags = function(streamId,payload){
        return $translator.translate('bt.post.analyzeRecordTags',{streamId:streamId},payload);
      };
      var getDebugLogRecords = function(streamId, offset,limit,payload) {
        return $translator.translate('bt.post.getDebugLogRecords', {streamId: streamId, offset: offset, limit: limit},payload);
      };
      var generateDebugLogRecords = function(streamId,payload) {
        return $translator.translate('bt.post.generateDebugLogRecords', {streamId: streamId},payload);
      };
      var debugLogPolling = function(streamId,taskId) {
        return $translator.translate('bt.get.debugLogPolling', {streamId: streamId,taskId:taskId}); //task id is polling id//
      };
      var getKoreUserIdsOnSearch = function(userId,streamId,start_date,end_date,search){
        return $translator.translate('bt.get.getKoreUserIdsOnSearch',{userId:userId,streamId:streamId,start_date:start_date,end_date:end_date,search:search},{},["start_date","end_date","search"]);
      };
      var getChannelsUserdIdsOnSearch = function(userId,streamId,start_date,end_date,search){
        return $translator.translate('bt.get.getChannelsUserdIdsOnSearch',{userId:userId,streamId:streamId,start_date:start_date,end_date:end_date,search:search},{},["start_date","end_date","search"]);
      };
      var analyzeDefaultFilter = function(streamId,payload){
        return $translator.translate('bt.post.getDefaultFilter',{streamId: streamId},payload);
      };
      var analyzeGetDefaultFilter = function(streamId){
        return $translator.translate('bt.get.getDefaultFilter',{streamId: streamId});
      };
      var analyzeEditDefaultFilter = function(streamId,payload){
        return $translator.translate('bt.put.getDefaultFilter',{streamId: streamId},payload);
      };

      /* End of Analyze api's*/

      /* Manage Variable Namespace APIs */
      var getAllNamespaces = function getAllNamespaces(userId, streamId, headers) {
        return $translator.translate('bt.get.allNamespaces',{userId:userId,streamId:streamId},'', headers);
      };
      var createNamespace = function createNamespace(userId, streamId, payload) {
        return $translator.translate('bt.post.createNamespace',{userId: userId, streamId:streamId}, payload);
      };
      var updateNamespace = function updateNamespace(userId, streamId, namespaceId, payload) {
        return $translator.translate('bt.put.updateNamespace',{userId:userId, streamId:streamId, namespaceId: namespaceId}, payload);
      };
      var deleteNamespace = function deleteNamespace(userId, streamId, namespaceId) {
        return $translator.translate('bt.delete.deleteNamespace',{userId:userId, streamId:streamId, namespaceId: namespaceId});
      };
      var getNSVariables = function getNSVariables(userId, streamId, namespaceId) {
        return $translator.translate('bt.get.getNSVariables',{userId:userId, streamId:streamId, namespaceId: namespaceId});
      };
      var addNamespaceKg = function addNamespaceKg(userId, ktId, payload) {
        return $translator.translate('bt.put.addNamespaceKg',{userId:userId, ktId: ktId}, payload);
      };
      var enableNamespace = function enableNamespace(userId, streamId, payload) {
        return $translator.translate('bt.put.enableNamespace', {userId: userId, streamId: streamId}, payload);
      };
      /* Manage Variable Namespace APIs */

      /*custom Library api's*/
      var createCustomTemplate = function createCustomTemplate(streamId,payload){
        return $translator.translate('bt.post.createCustomTemplate', {streamId: streamId},payload);
      };
      var getAllCustomTemplate = function getAllCustomTemplate(streamId){
        return $translator.translate('bt.get.getAllCustomTemplate', {streamId: streamId});
      };
      var deleteCustomTemplate = function deleteCustomTemplate(streamId,_id){
        return $translator.translate('bt.delete.deleteCustomTemplate', {streamId: streamId,customTemplateId:_id});
      };
      var getCustomTemplateData = function getCustomTemplateData(streamId,_id){
        return $translator.translate('bt.get.getCustomTemplateData', {streamId: streamId,customTemplateId:_id});
      };
      var updateCustomTemplate = function updateCustomTemplate(streamId,_id,payload){
        return $translator.translate('bt.put.updateCustomTemplate', {streamId: streamId,customTemplateId:_id},payload);
      };
      var customTemplatePreview = function customTemplatePreview(streamId,_id,payload){
        return $translator.translate('bt.post.customTemplatePreview', {streamId: streamId,customTemplateId:_id},payload);
      };
      /*end of custom Library api's*/

      /*Progress Dock*/
      var getAllProgressDockNotifications = function getAllProgressDockNotifications(streamId){
        return $translator.translate('bt.get.getAllProgressDockNotifications', {streamId: streamId});
      };
      var deleteProgressDockAllNotifications = function deleteProgressDockAllNotifications(streamId){
        return $translator.translate('bt.delete.deleteProgressDockAllNotifications', {streamId: streamId});
      };
      var deleteProgressDockNotification = function deleteProgressDockNotification(streamId,_id){
        return $translator.translate('bt.delete.deleteProgressDockNotification', {streamId: streamId,notificationsId:_id});
      };
      var updateProgressDockNotification = function updateProgressDockNotification(streamId,_id,payload){
        return $translator.translate('bt.put.updateProgressDockNotification', {streamId: streamId,notificationsId:_id},payload);
      };
      var downloadProgressDockExportFile = function downloadProgressDockExportFile(fileId){
        return $translator.translate('bt.get.downloadProgressDockExportFile', {fileId: fileId});
      };
      var downloadImageExportFile = function downloadImageExportFile(fileId){
        return $translator.translate('bt.get.downloadImageExportFile', {fileId: fileId});
      };
      var batchtestingReportLink = function downloadProgressDockExportFile(streamId,fileId){
        return $translator.translate('bt.get.batchtestingReportLink', {streamId:streamId,fileId: fileId});
      };
      /*End of progress Dock*/

      var getUtterances = function(taskId,offset,limit, search, autoTrained,streamId) {//componentId
          search = search || "";
          autoTrained = autoTrained || "false";
          if(streamId){
          return translate('bt.utterancesstream.get', {taskId: taskId,offset:offset,limit:limit, searchParam:search, autoTrainedParam:autoTrained,streamId:streamId});
          } else {
          return translate('bt.utterances.get', {taskId: taskId,offset:offset,limit:limit, searchParam:search, autoTrainedParam:autoTrained});
          }
      };
       var createUtterances = function(payload) {
          return translate('bt.utterances.create', {},payload);
      };
      var createBulkUtterances = function(payload) {
        return translate('bt.bulkUtterances.create', {},payload);
    };
       var trainUtterances =  function(streamId,payload) {
        return $translator.translate('bt.utterances.trainutterance', {streamId:streamId},payload);
      };
      var trainBotSpeech = function(streamId) {
          return $translator.translate('bt.post.speechTrain', {streamId:streamId});
      };
      var trainBotSpeechStatus = function(streamId){
          return $translator.translate('bt.post.speechTrainStatus', {streamId:streamId});
      };
      var autoTrainStatus =  function(streamId) {
        return $translator.translate('bt.stream.autoTrainStatus', {streamId:streamId});
      };
       var trainFaq =  function(streamId, ktId) {
        return $translator.translate('bt.train.faq', {streamId:streamId, ktId: ktId});
      };
       var editUtterances =  function(payload, utteranceId) {
        return $translator.translate('bt.utterances.edit', {"utteranceId":utteranceId}, payload);
      };
      var getUtterancesbyId =  function(utteranceId) {
        return $translator.translate('bt.utterances.getbyid', {"utteranceId":utteranceId});
      };
      var deleteUtterances =  function(payload,utteranceId) {
        return $translator.translate('bt.utterances.delete', {"utteranceId":utteranceId},payload);
      };
      var standardPublish = function multiPublish(streamId,payload){
          return $translator.translate('bt.post.standardPublish',{streamId:streamId},payload);
      };

      var solutionPublish = function multiPublish(streamId,payload){
          return $translator.translate('bt.post.solutionPublish',{streamId:streamId},payload);
      };

      var sampleBotPublish = function multiPublish(streamId,payload){
          return $translator.translate('bt.post.sampleBotPublish',{streamId:streamId},payload);
      };

      var getSessionKeys = function getSessionKeys(streamId){
          return $translator.translate('bt.get.sessionKeys',{streamId:streamId});
      };

      var previewMarkup = function previewMarkup(channel,payload){
          return $translator.translate('bt.post.markupPreview',{channel:channel},payload);
      };

      var uxPreview = function uxPreview(streamId,markup,channel,payload) {
          markup  = (markup || false).toString();
          channel = channel || 'default';
          return $translator.translate('bt.post.uxPreview',{streamId:streamId,markup:markup,channel:channel},payload);
      };

      var getContextById = function getContextById(contextId,streamId) {
          return $translator.translate('bt.get.context',{contextId:contextId,streamId:streamId},{});
      };
      var publishFlow = function publishFlow(mappingId) {
          return $translator.translate('bt.post.pubilshFlow',{mappingId:mappingId},{});
      };

      var publishAlertDialogFlow = function publishFlow(mappingId) {
          return $translator.translate('bt.post.pubilshAlertDialogFlow',{mappingId:mappingId},{});
      };

      var validateAlertDialogFlow = function publishFlow(mappingId,dialogId) {
          return $translator.translate('bt.paramMap.dialogValidate.get',{mappingId:mappingId, dialogId:dialogId},{});
      };

      var twilioChannelSms = function twilioChannelSms(mappingId) {
          return $translator.translate('twilioChannel',{mappingId:mappingId},{});
      };

      var ExecuteInitializer = function ExecuteInitializer(payload){

          return $translator.translate('bt.initializer.execute',{},payload);
      };

      var linkOrUnlinkBots = function linkOrUnlinkBots(streamId,type,payload){
          return $translator.translate('bt.universalbots.linkunlink',{streamId:streamId,type:type},payload);
      };

      var getBotDetails = function getBotDetails(streamName){
          return $translator.translate('mp.getBotDetails', {streamName:streamName});
      };

      var userProfileDetails = function userProfileDetails(param){
        return $translator.translate('mp.user.getUserProfileDetails',param);
      };

      var userConversation = function userConversation(params){
        return $translator.translate('mp.user.getUserConversation',params);
      };

      var getSampleBots = function getSampleBots() {
        return $translator.translate('bt.getSampleBots');
      };
      var getSmartBots = function getSmartBots() {
        return $translator.translate('bt.getSmartBots');
      };
      var removeBotInheritance = function removeBotInheritance(streamId) {
        return $translator.translate('bt.removeBotInheritance',{streamId:streamId});
      };
      var ktNodeUnlock = function ktNodeUnlock(streamId,ktid,payload) {
        return $translator.translate('bt.put.ktNodeUnlock',{streamId:streamId,ktid:ktid},payload);
      };
      var unlockDailogComponent = function dailogComponentUnlock(streamId ,payload){
          return $translator.translate('bt.post.dailogComponentUnlock',{streamId:streamId},payload);
      };
      var cloneDialogComponent = function(streamId,componentId, payload){
          return $translator.translate('bt.put.cloneDialogComponent',{streamId:streamId,componentId:componentId},payload);
      };
      var unlockDialog = function (dialogId, streamId, requestData) {
        return translate('bt.dialogsId.unlock', {dialogId: dialogId, streamId: streamId}, requestData);
      };
      var installSampleBotFromStore = function installSampleBotFromStore(botId) {
          return $translator.translate('bt.get.sampleBotInstallFromStore', {botId:botId});
      };
      var sampleBotpollStatus = function sampleBotpollStatus(userId,streamId) {
        return $translator.translate('bt.get.sampleBotpollStatus', {userId:userId,statusId:streamId});
    };
      var installSampleBot = function installSampleBot(botId) {
        return $translator.translate('bt.post.sampleBotInstall', {botId:botId});
    };
      var installSmartBot = function installSmartBot(streamId) {
          return $translator.translate('bt.get.smartBotInstall', {streamId:streamId});
      };

        var editDefaultDialog = function (streamId, _payload) {
            return translate('bt.stream.default_dialog', {streamId: streamId}, _payload);
        };

      var downloadDefaultLanguage = function (botId, language) {
        return $translator.translate('bt.get.defaultLanguage', {botId:botId, language: language});
      };

      var updateLanguageJson = function (botId, language, data) {
        return $translator.translate('bt.post.updateLanguageJson', {botId:botId, language: language}, data);
      };

      var addSupportedLanguage= function (botId, language,payload) {
        return $translator.translate('bt.post.addSupportedLanguage', {botId:botId, language: language},payload);
      };

      var utteranceImport = function(userId,streamId,payload){
        return $translator.translate('bt.post.utteranceImport', {userId:userId,streamId:streamId}, payload);
      };

      var utteranceExport = function(userId, streamId, status,filetype) {
        return $translator.translate('bt.post.utteranceExport', {userId:userId,streamId:streamId,status:status,filetype:filetype});
      };

      var botOntoBulkDel =  function(userId, payload) {
        return $translator.translate('bt.delete.botOntoBulkDel', {userId: userId}, payload);
      };

      var utteranceStatus = function(userId, streamId) {
        return $translator.translate('bt.post.utteranceStatus', {userId:userId,streamId:streamId});
      };

      var newEvent = function(userId, streamId, payload) {
        return $translator.translate('bt.put.newEvent', {userId:userId,streamId:streamId}, payload);
      };

      var getRoles = function(userId,streamId,orgId){
          return $translator.translate('bt.get.getRoles',{userId:userId,streamId:streamId,orgId:orgId});
      };

      var getGroups = function(userId,streamId,orgId){
        return $translator.translate('bt.get.getOrg',{userId:userId,streamId:streamId,orgId:orgId});
      };

      var getCodevelopers = function(userId,streamId){
        return $translator.translate('bt.get.coDevelopers',{userId:userId,streamId:streamId});
       };

       var getSharePermissions = function(){
          return $translator.translate('bt.get.SharePermissions', {});
       };

       var getPermissionsForRole = function(roleId){
          return $translator.translate('bt.get.PermissionByRole',{roleId:roleId});
       };

      var kgExtractImport = function(streamId, payload) {
        return $translator.translate('bt.post.kgExtractImport', {streamId: streamId}, payload);
      };

      var kgStatusPoll = function(streamId, kgImportId) {
        return $translator.translate('bt.get.kgStatusPoll', {streamId: streamId, kgImportId: kgImportId});
      };

      var kgHistory = function(streamId) {
        return $translator.translate('bt.get.kgHistory', {streamId: streamId});
      };

      var kgQuesAns = function(streamId, kgExtractId, offset, limit, search, filter) {
        return $translator.translate('bt.get.kgQuesAns', {streamId: streamId, kgExtractId: kgExtractId, offset: offset, limit: limit, search: search, filter: filter});
      };

      var kgDragDropFaq = function(userId, payload) {
        return $translator.translate('bt.post.kgDragDropFaq', {userId: userId}, payload);
      };

      var kgQnADel = function(streamId, kEId, quesId) {
        return $translator.translate('bt.delete.kgQnADel', {streamId: streamId, kEId: kEId, quesId: quesId});
      };

      var kgQnAUpdate= function(streamId, kEId, quesId, payload) {
        return $translator.translate('bt.put.kgQnAUpdate', {streamId: streamId, kEId: kEId, quesId: quesId}, payload);
      };

      var kgKeDelete = function(streamId, kEId) {
        return $translator.translate('bt.delete.kgKeDelete', {streamId: streamId, kEId: kEId});
      };

      var kgQnABulkDel = function(streamId, kEId, payload) {
        return $translator.translate('bt.delete.kgQnABulkDel', {streamId: streamId, kEId: kEId}, payload);
      };

      var kgExportFaq = function(streamId, kEId) {
        return $translator.translate('bt.get.kgExportFaq', {streamId: streamId, kEId: kEId});
      };
      
      var kgImportFaq = function(streamId, kEId, payload) {
        return $translator.translate('bt.post.kgImportFaq', {streamId: streamId, kEId: kEId}, payload);
      };

      var kgQnAnnotation = function(streamId, payload) {
        return $translator.translate('bt.post.kgQnAnnotation', {streamId: streamId}, payload);
      };

      var hangoutChannel = function (userId, botId,payload) {
        return $translator.translate('bt.post.hangoutChannel', {userId: userId, botId: botId}, payload);
      };

      var rcsBusinessChannel = function(userId, streamId, payload) {
        return $translator.translate('bt.post.rcsBusinessChannel', {userId: userId, streamId: streamId}, payload);
      };

      var rcsLaunch = function(userId, streamId, payload) {
        return $translator.translate('bt.post.rcsLaunch', {userId: userId, streamId: streamId}, payload);
      };
     
      var createPanel = function(streamId,payload) {
        return $translator.translate('bt.post.createPanel', {streamId: streamId},payload);
      };

      var getPannelById = function(streamId, panelId) {
        return $translator.translate('bt.get.getPannelById', {streamId: streamId, panelId: panelId});
      };

      var deletePanel = function(streamId, panelId) {
        return $translator.translate('bt.delete.deletePanel', {streamId: streamId, panelId: panelId});
      };

      var getBotPanels = function(streamId) {
        return $translator.translate('bt.get.getBotPanels', {streamId: streamId});
      };

      var updatePannelById = function(streamId, panelId,payload) {
        return $translator.translate('bt.put.updatePannelById', {streamId: streamId, panelId: panelId},payload);
      };

      var createWidget = function(streamId,payload) {
        return $translator.translate('bt.post.createWidget', {streamId: streamId},payload);
      };

      var getWidgetById = function(streamId, widgetId) {
        return $translator.translate('bt.get.getWidgetById', {streamId: streamId, widgetId: widgetId});
      };

      var deleteWidget = function(streamId, widgetId) {
        return $translator.translate('bt.delete.deleteWidget', {streamId: streamId, widgetId: widgetId});
      };

      var getBotWidgets = function(streamId) {
        return $translator.translate('bt.get.getBotWidgets', {streamId: streamId});
      };

      var updateWidgetById = function(streamId, widgetId,payload) {
        return $translator.translate('bt.put.updateWidgetById', {streamId: streamId, widgetId: widgetId},payload);
      };

      var rootSessionFlow = function(userId, orgId, streamId, view, startDate, endDate, lang, channels) {
        var _dynParams=[];
        if(lang){
          _dynParams.push('lang');
        }
        if(channels){
          _dynParams.push('channels');
        }
       return $translator.translate('bt.get.rootSessionFlow', {userId: userId, orgId: orgId, streamId: streamId, view: view, startDate: startDate, endDate: endDate, lang: lang, channels: channels},{},_dynParams);
      };
      var postRootSessionFlow = function(userId, orgId, streamId, view, payload, mode) {
        var qParams = {userId: userId, orgId: orgId, streamId: streamId, view: view};
        if(mode) {
          qParams.mode = mode;
        }
       return $translator.translate('bt.post.postRootSessionFlow', qParams,payload);
      };


      var nodeSessionFlow = function(userId, orgId, streamId,view, payload) {
        return $translator.translate('bt.post.nodeSessionFlow', {userId: userId, orgId: orgId, streamId: streamId, view: view}, payload);    
      };

      var utterancesSessionFlow = function(userId, orgId, streamId, payload) {
/*        var _dynParams=[];
        if(lang){
          _dynParams.push('lang');
        }
        if(channels){
          _dynParams.push('channels');
        }*/
        return $translator.translate('bt.post.utterancesSessionFlow', {userId: userId, orgId: orgId, streamId: streamId}, payload);
      };

      var uttSessionOutgo = function(userId, orgId, streamId, payload) {
/*        var _dynParams=[];
        if(lang){
          _dynParams.push('lang');
        }
        if(channels){
          _dynParams.push('channels');
        }*/
        return $translator.translate('bt.post.uttSessionOutgo', {userId: userId, orgId: orgId, streamId: streamId}, payload);
      };
      var totalUtteranceCount = function(userId, orgId, streamId, payload) {
        return $translator.translate('bt.post.totalUtteranceCount', {userId: userId, orgId: orgId, streamId: streamId}, payload);
      };
      var dropOffs = function(userId, orgId, streamId, payload) {
        return $translator.translate('bt.post.dropOffs', {userId: userId, orgId: orgId, streamId: streamId}, payload);
      };
      var extractUtterance = function(userId, orgId, streamId, payload) {
        return $translator.translate('bt.post.extractUtterance', {userId: userId, orgId: orgId, streamId: streamId}, payload);
      };

      var botTasksSummary = function (streamId) {
        return $translator.translate('bt.get.botTasksSummary', {streamId:streamId});
      };

      var botSummary = function (streamId) {
        return $translator.translate('bt.get.botSummary', {streamId:streamId});
      };
      

      var livebankChannel = function(userId, streamId, payload) {
        return $translator.translate('bt.post.livebankChannel', {userId: userId, streamId: streamId}, payload);
      };

      var getTraitGroups = function( userId,streamId) {
        return $translator.translate('bt.get.getTraitGroups', {userId: userId, streamId: streamId});
      };

      var getTraitGroupById = function( userId, streamId,traitGroupId) {
        return $translator.translate('bt.get.getTraitGroupById', {userId: userId, streamId: streamId,traitGroupId: traitGroupId});
      };

      var deleteTraitsGroup = function( userId, streamId, traitGroupId, payload) {
        return $translator.translate('bt.delete.deleteTraitsGroup', {userId: userId, streamId: streamId,traitGroupId: traitGroupId}, payload);
      };

      var updateTraitGroup = function( userId, streamId, traitGroupId, payload) {
        return $translator.translate('bt.put.updateTraitGroup', {userId: userId, streamId: streamId,traitGroupId: traitGroupId}, payload);
      };

      var createTraitGroup = function( userId, streamId, payload) {
        return $translator.translate('bt.post.createTraitGroup', {userId: userId, streamId: streamId}, payload);
      };
     
      var getTraitsByGroupId = function( userId, streamId, traitGroupId) {
        return $translator.translate('bt.get.getTraitsByGroupId', {userId: userId, streamId: streamId,traitGroupId: traitGroupId});
      };
      var getTraitsById = function( userId, streamId, traitGroupId,traitId) {
        return $translator.translate('bt.get.getTraitsById', {userId:userId, streamId:streamId, traitGroupId:traitGroupId, traitId:traitId});
      };
      var updateTraitsById = function( userId, streamId, traitGroupId,traitId,payload) {
        return $translator.translate('bt.put.updateTraitsById', {userId:userId, streamId:streamId, traitGroupId:traitGroupId, traitId:traitId},payload);
      };
      
      var getKgManageWords = function(streamId, kgTId, reset) {
        return $translator.translate('bt.get.getKgManageWords', {streamId: streamId, kgTId: kgTId, reset: reset});
      };

      var updateKgManageWords = function(streamId, kgTId, reset, payload) {
        return $translator.translate('bt.put.updateKgManageWords', {streamId: streamId, kgTId: kgTId, reset: reset}, payload);
      };

      var resetKgManageWords = function(streamId) {
        return $translator.translate('bt.get.resetKgManageWords', {streamId: streamId});
      };

      var saveSentiment = function(userId,streamId,payload){
        return $translator.translate('bt.post.saveSentiment',{userId:userId,streamId:streamId},payload);
      };

      var editSentiment = function(userId,streamId,eventId,payload){
        return $translator.translate('bt.put.editSentiment',{userId:userId,streamId:streamId,eventId:eventId},payload);
      };

      var deleteSentiment = function(userId,streamId,payload){
        return $translator.translate('bt.delete.deleteSentiment',{userId:userId,streamId:streamId},payload);
      };

      var kgExtractIsVisited = function(streamId, kEId, payload) {
        return $translator.translate('bt.put.kgExtractIsVisited', {streamId: streamId, kEId: kEId}, payload);
      };

      var scheduleCluster = function(streamId, payload) {
        return $translator.translate('bt.post.scheduleCluster', {streamId: streamId}, payload);
      };

      var reorderSentiment = function(userId,streamId,payload){
        return $translator.translate('bt.post.reorderSentiment',{userId:userId,streamId:streamId},payload);
      };

      var createGroup = function(streamId,_payload){
        return $translator.translate('bt.put.createGroup',{streamId:streamId},_payload);
      };

      var getSmallTalkGroups = function(streamId){
        return $translator.translate('bt.get.smallTalkGroups',{streamId:streamId});
      };

      var getSmallTalk = function(streamId){
        return $translator.translate('bt.get.smallTalk',{streamId:streamId});
      };

      var updateGroup = function(payload,streamId,groupId){
        return $translator.translate('bt.put.smallTalkGroups',{streamId:streamId,groupId:groupId},payload);
      };

      var creteNewNode = function(payload,streamId,groupId){
        return $translator.translate('bt.post.createNewNode',{streamId:streamId,groupId:groupId},payload);
      };

      var getCurrentGroupNodes = function(streamId,groupId,_offset){
        return $translator.translate('bt.get.currentGroupNodes',{streamId:streamId,groupId:groupId,skip:_offset.skip,limit:_offset.limit});
      };

      var updateNode = function(payload,streamId,groupId){
        return $translator.translate('bt.put.updateNode',{streamId:streamId,groupId:groupId,nodeId:payload.nodeId},payload);
      };

      var deleteNode = function(nodeId,streamId,groupId){
        return $translator.translate('bt.delete.smallTalkNode',{streamId:streamId,groupId:groupId,nodeId:nodeId});
      };

      var deleteGroup = function(streamId,groupId){
        return $translator.translate('bt.delete.smallTalkGroup',{streamId:streamId,groupId:groupId});
      };

      var paginateSmallTalk = function(streamId,groupId,_offset){
        return $translator.translate('bt.get.smallTalkPaginate',{streamId:streamId,groupId:groupId,skip:_offset.skip,limit:_offset.limit});
      };

      var searchUserSays = function(streamId,groupId,userSays){
        return $translator.translate('bt.get.smallTalkSearch',{streamId:streamId,groupId:groupId,userSays:userSays});
      };

      var exportSmallTalk = function(streamId,_payload){
        return $translator.translate('bt.export.smallTalk',{streamId:streamId},_payload);
      };

      var startImporting = function(streamId,payload){
        return $translator.translate('bt.post.importSmallTalkFile',{streamId:streamId},payload);
      };

      var statusImportingSmallTalk = function(userId,streamId){
        return $translator.translate('bt.get.statusImportSmallTalk',{userId:userId,streamId:streamId});
      };

      var migrateSmallTalk = function(streamId){
          return $translator.translate('bt.post.migrateSmallTalk',{streamId:streamId});
      };

      var reOderSmallTalk = function(streamId,payload){
        return $translator.translate('bt.put.reOrderSmallTalk',{streamId:streamId},payload);
      };

      var reOrderQuestions = function(streamId,groupId,nodeId,payload){
        return $translator.translate('bt.put.reOrderQuestions',{streamId:streamId,groupId:groupId,nodeId:nodeId},payload);
      };

      var deleteRunDetails = function(streamId, testSuiteId, runDetails) {
        return $translator.translate('bt.delete.deleteRunDetails', {streamId: streamId, testSuiteId: testSuiteId, runDetails: runDetails});
      };

      var deleteRunDetailsAll = function(streamId, testSuiteId) {
        return $translator.translate('bt.delete.deleteRunDetailsAll', {streamId: streamId, testSuiteId: testSuiteId});
      };
      
      var initiateOntologyAnalysis = function(_payload){
        return $translator.translate('bt.post.ontologyAnalyzer',{},_payload);
      };

      var fbInstallApp = function(streamId, payload) {
        return $translator.translate('bt.post.fbInstallApp', {streamId: streamId}, payload);
      };

      var getbotSpecficUsers = function getbotSpecficUsers(streamId,start_date,end_date,offset,limit){
        return $translator.translate('bt.get.getbotSpecficUsers', {streamId:streamId,start_date:start_date,end_date:end_date,offset:offset,limit:limit},{},["start_date","end_date","offset","limit"]);
      };

      /* language management */

      var disableLanguage = function(streamId,language){
        return $translator.translate('bt.post.disableLanguage',{streamId:streamId,language:language});
      };

      var defaultLanguage = function(streamId,language){
        return $translator.translate('bt.post.defaultLanguage',{streamId:streamId,language:language});
      };

      var reEnableLanguage = function(streamId,language){
        return $translator.translate('bt.post.reEnableLanguage',{streamId:streamId,language:language});
      };

      /* upgrade universal 2.0 */
      var upgradeUniversalBot = function(userId,streamId,payload){
        return $translator.translate('bt.put.upgradeUniversalBot',{streamId:streamId,userId:userId},payload);
      };

      var getLinkBot  = function(streamId,linkBotId){
        return $translator.translate('bt.get.linkbot',{streamId:streamId,botId:linkBotId});
      };

      var addTrainingData = function(streamId,payload){
        return $translator.translate('bt.post.addTrainingData',{streamId:streamId},payload);
      };

       var searchText = function(streamId,searchText,type,linkBotId){
        return $translator.translate('bt.get.searchText',{streamId:streamId,search:searchText,type:type,botId:linkBotId});
      };

      var paginateTrainingData = function(streamId,offset,limit,search,type,linkBotId){
        return $translator.translate('bt.get.paginateTrainingData',{streamId:streamId,offset:offset,limit:limit,search:search,type:type,botId:linkBotId});
      };

      var saveTriggerPhaseSettings = function(streamId,payload){
         return $translator.translate('bt.put.updateTriggerPhrase',{streamId:streamId},payload);
      };

      /* upgrade universal 2.0 end */
      
      /* UI Forms start*/
      var createUiForm = function(streamId,payload){
        return $translator.translate('bt.post.createUiForm',{streamId:streamId},payload);
      };
      var updateUiForm = function(streamId,formId,payload){
        return $translator.translate('bt.put.updateUiForm',{streamId:streamId,formId:formId},payload);
      };
      var getBotUiForms  = function(streamId,isConfiguredOnly){
        return $translator.translate(isConfiguredOnly?'bt.get.getBotUiForms.configured':'bt.get.getBotUiForms',{streamId:streamId});
      };
      var getBotUiFormById  = function(streamId,formId){
        return $translator.translate('bt.get.getBotUiFormById',{streamId:streamId,formId:formId});
      };
      var deleteBotUiFormById  = function(streamId,formId){
        return $translator.translate('bt.delete.deleteBotUiFormById',{streamId:streamId,formId:formId});
      };
      var intigrateFormToPanel  = function(streamId,panelId,payload){
        return $translator.translate('bt.post.intigrateFormToPanel',{streamId:streamId,panelId:panelId},payload);
      };
      /* UI Forms End */

      /* bot version */

      var createVersion = function(streamId,payload){
        return $translator.translate('bt.post.createVersion',{streamId:streamId},payload);
      };

      var getBotVersionDateRange = function(streamId,startDate,endDate,sortBy){
        return $translator.translate('bt.get.botVersionDateRange',{streamId:streamId,startDate:startDate,endDate:endDate,sortBy:sortBy});
      };

      var getBotVersions = function(streamId,sortBy){
        return $translator.translate('bt.get.botVersion',{streamId:streamId,sortBy:sortBy});
      };

      var deleteBotVersion = function(streamId,payload){
        return $translator.translate('bt.delete.deleteBotVersion',{streamId:streamId},payload);
      };

      var exportBotVersion = function(streamId,payload){
        return $translator.translate('bt.post.exportBotVersion',{streamId:streamId},payload);
      };

      var restoreBotVersion = function(streamId,payload){
        return $translator.translate('bt.post.restoreBotVersion',{streamId:streamId},payload);
      };

      var getVersionStatus = function(streamId,statusId){
        return $translator.translate('bt.post.versionStatus',{streamId:streamId,statusId:statusId});
      };

      var getRestoreStatus = function(streamId,statusId){
        return $translator.translate('bt.get.restoreStatus',{streamId:streamId,statusId:statusId});
      };

      var deleteVersion = function(streamId,payload){
        return $translator.translate('bt.delete.deleteVersion',{streamId:streamId},payload);
      };

      

      /* Dataservice  */
      var daasTables = function(userId,streamId){
        return $translator.translate('bt.get.daasTables',{userId:userId, streamId: streamId});
      };
      var daasViews = function(userId,streamId){
        return $translator.translate('bt.get.daasViews',{userId:userId, streamId: streamId});
      };
      var daasSaveServiceNode = function(componentId,streamId, _payload){
        return $translator.translate('bt.daasSaveServiceNode',{componentId:componentId, streamId: streamId}, _payload);
      };
      /* Dataservice end */

      /* import publish*/
      var publishImportBot = function(streamId,_payload){
        return $translator.translate('bt.post.autoPublish',{streamId:streamId},_payload);
      };

      /* advanced nl config */

      var getAdvancedConfigurations = function(streamId){
        return $translator.translate('bt.get.nlpConfigurations',{streamId:streamId});
      };

      var getAdvancedConfigurationsByName = function(streamId, configName){
        return $translator.translate('bt.get.advancedNlConfigsByName',{streamId:streamId, configName: configName});
      };

      var getSavedConfiguration = function(streamId){
        return $translator.translate('bt.get.savedConfigurations',{streamId:streamId});
      };

      var addConfiguration = function(streamId,payload){
        return $translator.translate('bt.post.addConfiguration',{streamId:streamId},payload);
      };

      var deleteConfiguration = function(streamId,configId){
        return $translator.translate('bt.delete.deleteConfiguration',{streamId:streamId,configId:configId});
      };

      var editConfigurations = function(streamId,configId,_payload){
        return $translator.translate('bt.put.editConfiguration',{streamId:streamId,configId:configId},_payload);
      };

      /* Multi intent model configuration*/
      var createCustomModel = function(streamId, _payload){
        return $translator.translate('bt.post.createCustomModel',{streamId:streamId}, _payload);
      };
      var updateCustomModel = function(streamId,customModelParamID, _payload){
        return $translator.translate('bt.put.updateCustomModel',{streamId:streamId,customModelParamID:customModelParamID}, _payload);
      };
      var deleteDialogIntentModel = function(streamId,customModelParamID){
        return $translator.translate('bt.delete.deleteDialogIntentModel',{streamId:streamId,customModelParamID:customModelParamID});
      };
      /* ** SMARTASSIST APIs START ** */

      var getDeploymentStatus = function(streamId){
        return $translator.translate('sa.get.deploymentStatus',{streamId:streamId});
      };

      /* ** SMARTASSIST APIs END ** */

      var updateBotConfigurations = function(streamId,payload){
        return $translator.translate('bt.put.botConfigurations',{streamId:streamId},payload);
      };

      var getSampleBotSettings = function(streamId){
        return $translator.translate('bt.get.getConfigurations',{streamId:streamId});
      };

      /* ** BILLING PLANS ENDPOINTS START ** */
      var getPlans = function(streamId,payload){
        return $translator.translate('bt.get.plans',{streamId:streamId},payload);
      };
      var planChange = function(payload){
        return $translator.translate('bt.put.planChange',{},payload);
      };
      var planValidate = function(params){
        return $translator.translate('bt.get.planValidate', params);
      };
      var planCheckout = function(params, payload){
        return $translator.translate('bt.publish.payment',params,payload);
      };
      var paymentstatus = function(params){
        return $translator.translate('bt.plan.paymentstatus',params);
      };
      var cancelPlanSub = function(streamId,payload){
        return $translator.translate('bt.cancel.planSub',{streamId:streamId},payload);
      };
      var planAutoRecharge = function(streamId,payload){
        return $translator.translate('bt.autorecharge.payasyougo',{streamId:streamId},payload);
      };
      var planValidation = function(streamId){
        return $translator.translate('bt.get.planvalidation',{streamId:streamId});
      };
      var getBillingsession = function(params){
        return $translator.translate('bt.get.billingSession',params);
      };
      var downloadBillingsession = function(params){
        return $translator.translate('bt.download.billingSession',params);
      };
      var getInvoices = function(streamId, limit, skip){
        return $translator.translate('bt.get.invoices',{streamId:streamId, limit: limit, skip: skip});
      };
      var getSupportPlans = function(streamId){
        return $translator.translate('bt.get.getSupportPlans',{streamId:streamId});
      };
      var supportPlanChange = function(streamId, planId, payload){
        return $translator.translate('bt.post.supportPlanChange',{streamId:streamId, planId: planId}, payload);
      };
      var supportPlanCancel = function(streamId, payload){
        return $translator.translate('bt.post.supportPlanCancel',{streamId:streamId}, payload);
      };
      var supportPlanValidate = function(streamId, targetPlanId){
        return $translator.translate('bt.get.supportPlanValidate',{streamId:streamId, targetPlanId: targetPlanId});
      };
      /* ** BILLING PLANS ENDPOINTS END ** */
      // PINMENU apis starts//
      var updatePinnedMenus = function(userId,payload) {
        return $translator.translate('bt.put.pinmenus',{userId:userId},payload);
      };
      var getPinnedMenus = function(streamId){
        return $translator.translate('bt.get.pinmenus',{streamId:streamId});
      };
     // PINMENU apis starts//
     /* ** Conversation Testing APIs start ** */
     var createtestcase = function(streamId, payload){
      return $translator.translate('bt.coversationTesting.createtestcase',{streamId:streamId}, payload);
      };
      var clonetestcase = function(streamId, testCaseId, payload){
        return $translator.translate('bt.coversationTesting.clonetestcase',{streamId:streamId, testCaseId: testCaseId}, payload);
      };
      var deletetestcase = function(streamId, payload){
        return $translator.translate('bt.coversationTesting.deletetestcase',{streamId:streamId}, payload);
      };
      var recentTags = function(streamId){
        return $translator.translate('bt.coversationTesting.recentTags',{streamId:streamId});
      };
      var runtestcases = function(streamId, payload){
        return $translator.translate('bt.coversationTesting.runtestcases',{streamId:streamId}, payload);
      };
     /* ** Conversation Testing APIs end ** */


    //  scenes //
    var getScenes = function(streamId, metaInfo,limit,skip,status){
      return $translator.translate('bt.getscenes',{streamId:streamId,metaInfo:metaInfo,limit:limit,skip:skip,status:status});
    };

    var createScene = function(streamId, payload){
      return $translator.translate('bt.createScene',{streamId:streamId}, payload);
    };
    var deleteScene = function(streamId, sceneId){
      return $translator.translate('bt.deleteScene',{streamId:streamId,sceneId:sceneId});
    };

    var cloneScene = function(streamId, sceneId,payload) {
      return $translator.translate('bt.cloneScene',{streamId:streamId,sceneId:sceneId}, payload);
    };

    var editScene =  function(streamId, sceneId,payload) {
      return $translator.translate('bt.editScene',{streamId:streamId,sceneId:sceneId}, payload);
    };

    var importScene =  function(streamId,payload) {
      return $translator.translate('bt.importScene',{streamId:streamId}, payload);
    };
    var resetShareURL = function(queryParams){
      return $translator.translate('bt.resetShareURL',queryParams,{});
    };
    var exportScene = function(streamId,sceneId,payload){
      return $translator.translate('bt.exportScene',{streamId:streamId,sceneId:sceneId}, payload);
    };
    var updateScene = function(streamId,sceneId,payload){
      return $translator.translate('bt.updateScene',{streamId:streamId,sceneId:sceneId}, payload);
    };
    //  scenes //

    // translation engine //
    var allTranslationengines =  function(streamId) {
      return $translator.translate('get.allTranslationengines',{streamId:streamId});
    };
    var gettranslationEngine =  function(streamId,transEngineId) {
      return $translator.translate('get.translationEngine',{streamId:streamId,transEngineId:transEngineId});
    };
    var editTranslationEngine =  function(streamId,transEngineId,payload) {
      return $translator.translate('edit.translationEngine',{streamId:streamId,transEngineId:transEngineId},payload);
    };
    var deletTranslationEngine =  function(streamId,transEngineId) {
      return $translator.translate('delete.translationEngine',{streamId:streamId,transEngineId:transEngineId});
    };
    var createtranslationEngine =  function(streamId,payload) {
      return $translator.translate('create.translationEngine',{streamId:streamId},payload);
    };
     // translation engine ends//
      return {
        getContextById:getContextById,
        publishFlow : publishFlow,
        publishAlertDialogFlow:publishAlertDialogFlow,
        validateAlertDialogFlow:validateAlertDialogFlow,
        twilioChannelSms:twilioChannelSms,
        uxPreview : uxPreview,
        previewMarkup : previewMarkup,
        getSessionKeys : getSessionKeys,
        standardPublish : standardPublish,
        solutionPublish : solutionPublish,
        getChangeLog : getChangeLog,
        getChangeLogFilter: getChangeLogFilter,
        getChangeLogExport: getChangeLogExport,
        getUserInfo : getUserInfo,
        getContacts : getContacts,
        shareBot : shareBot,
        createLock : createLock,
        getDialogs: getDialogs,
        getLock : getLock,
        releaseLock : releaseLock,
        getWebhookUrl : getWebhookUrl,
        authorizeIdp : authorizeIdp,
        channelSchema : channelSchema,
        promoteToOwner : promoteToOwner,
        deleteChannel : deleteChannel,
        regenerateSubDialog:regenerateSubDialog,
        createOrEditChannel:createOrEditChannel,
        getEmbedwebsdkDetails: getEmbedwebsdkDetails,
        postEmbedwebsdkDetails: postEmbedwebsdkDetails,
        ivrVoiceReset:ivrVoiceReset,
        getBotChatScenarios : getBotChatScenarios,
        getPatterns : getPatterns,
        deletePattern : deletePattern,
        getAccounts : getAccounts,
        getRingCentralAccount : getRingCentralAccount,
        getAuthinfo:getAuthinfo,
        updateTryMode:updateTryMode,
        getStreams: getStreams,
        editStream: editStream,
        deleteBTStream : deleteBTStream,
        createPattern : createPattern,
        taskPattern:taskPattern,
        fieldPatternSortOrEdit:fieldPatternSortOrEdit,
        deleteMPStream:deleteMPStream,
        getStreamAlerts : getStreamAlerts,
        getStreamActions: getStreamActions,
        createBTStream : createBTStream,
        createMPStream : createMPStream,
        getBTStream : getBTStream,
        getMPStream : getMPStream,
        getMappings:getMappings,
        getAlertDialogMappings:getAlertDialogMappings,
        updateMPStream: updateMPStream,
        getErrorCodes:getErrorCodes,
        getSynonyms: getSynonyms,
        postSynonyms: postSynonyms,
        getGenericMessages : getGenericMessages,
        editGenericMessages : editGenericMessages,
        editOverrideMessages: editOverrideMessages,
        testNlp : testNlp,
        getTrainLogs: getTrainLogs,
        createAlertFieldSynonyms : createAlertFieldSynonyms,
        importEmojis:importEmojis,
        getAlertsFieldSynonyms : getAlertsFieldSynonyms,
        createActionsFieldSynonyms : createActionsFieldSynonyms,
        getActionsFieldSynonyms : getActionsFieldSynonyms,
        saveAndUpdateFAQ : saveAndUpdateFAQ,
        createKnowledgeTask : createKnowledgeTask,
        getAllKtsList : getAllKtsList,
        ktGetAllLanguage:ktGetAllLanguage,
        uploadFAQFile : uploadFAQFile,
        updateFAQ : updateFAQ,
        importFAQFileBYFileID : importFAQFileBYFileID,
        importFAQFileBYFileIDForce: importFAQFileBYFileIDForce,
        uploadBotFunctionsFile:uploadBotFunctionsFile,
        addBotFunctions:addBotFunctions,
        getBotFunctions:getBotFunctions,
        deleteBotFunctions:deleteBotFunctions,
        botFunctionsDownloadFile:botFunctionsDownloadFile,
        getUrl:getUrl,
        getFAQS : getFAQS,
        removeFAQ : removeFAQ,
        deleteKnowledgeTask : deleteKnowledgeTask,
        updateKnowledgeTask : updateKnowledgeTask,
        btExportVariables : btExportVariables,
        btImportVariables : btImportVariables,
        btImportVariablesStatus:btImportVariablesStatus,
        btGetAllCollections:btGetAllCollections,
        btCreateCollection:btCreateCollection,
        btUpdateCollection:btUpdateCollection,
        btDeleteCollection:btDeleteCollection,
        btEditVariableCollection: btEditVariableCollection,
        btExportVariablesStatus : btExportVariablesStatus,
        getOrSearchFAQS     : getOrSearchFAQS,
        getSessions : getSessions,
        getUtterances : getUtterances,
        createUtterances :createUtterances,
        editUtterances :editUtterances,
        getUtterancesbyId:getUtterancesbyId,
        trainUtterances:trainUtterances,
        trainFaq:trainFaq,
        deleteUtterances:deleteUtterances,
        getSolutionBotStream:getSolutionBotStream,
        trainBotIntentLogs : trainBotIntentLogs,
        removeTrainBotIntentLogs : removeTrainBotIntentLogs,
        ExecuteInitializer : ExecuteInitializer,
        getWebhookUrlForChannel : getWebhookUrlForChannel,
        makeSDKSubscription : makeSDKSubscription,
        deleteSDKSubscription : deleteSDKSubscription,
        updateThresholds :updateThresholds,
        updateMLSynonym : updateMLSynonym,
        getMLSynonym : getMLSynonym,
        linkOrUnlinkBots:linkOrUnlinkBots,
        getBotDetails:getBotDetails,
        userProfileDetails:userProfileDetails,
        userConversation:userConversation,
        getSampleBots: getSampleBots,
        getSmartBots: getSmartBots,
        removeBotInheritance:removeBotInheritance,
        ktNodeUnlock:ktNodeUnlock,
        unlockDailogComponent:unlockDailogComponent,
        unlockDialog:unlockDialog,
        cloneDialogComponent:cloneDialogComponent,
        sampleBotPublish:sampleBotPublish,
        installSampleBot:installSampleBot,
        installSampleBotFromStore:installSampleBotFromStore,
        sampleBotpollStatus:sampleBotpollStatus,
        installSmartBot:installSmartBot,
        editDefaultDialog:editDefaultDialog,
        testAuthorizeChannel:testAuthorizeChannel,
        addChannelToBot:addChannelToBot,
        getuserAdditionalIdentities:getuserAdditionalIdentities,
        setupchecklist:setupchecklist,
        updateChecklist:updateChecklist,
        addUserIdentity:addUserIdentity,
        isFreeEmail:isFreeEmail,
        resendIdentityVerification:resendIdentityVerification,
        deleteUserIdentity:deleteUserIdentity,
        verifyOTP:verifyOTP,
        autoTrainStatus:autoTrainStatus,
        trainBotSpeech:trainBotSpeech,
        trainBotSpeechStatus:trainBotSpeechStatus,
        dashboardCount:dashboardCount,
        dashboardCountUniversal: dashboardCountUniversal,
        dashboardChatsUniversal:dashboardChatsUniversal,
        dashboardCharts:dashboardCharts,
        performingBotsUniversal:performingBotsUniversal,
        downloadDefaultLanguage: downloadDefaultLanguage,
        updateLanguageJson: updateLanguageJson,
        addSupportedLanguage: addSupportedLanguage,
        getPossibleTags : getPossibleTags,
        faqBulkUpdate : faqBulkUpdate,
        alexaExport : alexaExport,
        sessionsCount:sessionsCount,
        sessionsCountUniversal: sessionsCountUniversal,
        agentTransferMetrics:agentTransferMetrics,
        agentTransferMetricsUniversal: agentTransferMetricsUniversal,
        tasksMetrics:tasksMetrics,
        tasksMetricsUniversal: tasksMetricsUniversal,
        tasksMetricsExport: tasksMetricsExport,
        sessionsGraph:sessionsGraph,
        sessionsGraphUniversal:sessionsGraphUniversal,
        smartAlertSubscription:smartAlertSubscription,
        savePiiDataOptions:savePiiDataOptions,
        getAnalyzeRecords:getAnalyzeRecords,
        analyzeGetRecordsExport:analyzeGetRecordsExport,
        updateAnalyzeRecord:updateAnalyzeRecord,
        channelsMetrics:channelsMetrics,
        channelsMetricsUniversal:channelsMetricsUniversal,
        realTimeDashboard:realTimeDashboard,
        realTimeDashboardChannels:realTimeDashboardChannels,
        getAnalysisDetails:getAnalysisDetails,
        getAnalysisPerformanceRecordDetails:getAnalysisPerformanceRecordDetails,
        getDebugLogRecords:getDebugLogRecords,
        generateDebugLogRecords:generateDebugLogRecords,
        debugLogPolling:debugLogPolling,
        getChatHistory:getChatHistory,
        mlUtterencesScore:mlUtterencesScore,
        mlKfoldScore:mlKfoldScore,
        mlKfoldScoreDownload:mlKfoldScoreDownload,
        trainBotIntentBunchLogs:trainBotIntentBunchLogs,
        sampleJsTamplates:sampleJsTamplates,
        getKtGlobalSynonyms:getKtGlobalSynonyms,
        addKtGlobalSynonyms:addKtGlobalSynonyms,
        editKtGlobalSynonyms:editKtGlobalSynonyms,
        deleteKtGlobalSynonyms:deleteKtGlobalSynonyms,
        updateWelcomeMessages:updateWelcomeMessages,
        createCustomTemplate:createCustomTemplate,
        getAllCustomTemplate:getAllCustomTemplate,
        deleteCustomTemplate:deleteCustomTemplate,
        getCustomTemplateData:getCustomTemplateData,
        updateCustomTemplate:updateCustomTemplate,
        customTemplatePreview:customTemplatePreview,
        utteranceImport:utteranceImport,
        utteranceExport:utteranceExport,
        utteranceStatus:utteranceStatus,
        addbulkBotVariables:addbulkBotVariables,
        getAllProgressDockNotifications:getAllProgressDockNotifications,
        deleteProgressDockAllNotifications:deleteProgressDockAllNotifications,
        deleteProgressDockNotification:deleteProgressDockNotification,
        updateProgressDockNotification:updateProgressDockNotification,
        downloadProgressDockExportFile:downloadProgressDockExportFile,
        downloadImageExportFile:downloadImageExportFile,
        batchtestingReportLink:batchtestingReportLink,
        analyzeStatus:analyzeStatus,
        metaTags:metaTags,
        channelSpecficChannelId:channelSpecficChannelId,
        analyzeRecordTags:analyzeRecordTags,
        botOntoBulkDel: botOntoBulkDel,
        newEvent:newEvent,
        kgExtractImport: kgExtractImport,
        kgStatusPoll: kgStatusPoll,
        kgHistory: kgHistory,
        kgQuesAns: kgQuesAns,
        kgDragDropFaq: kgDragDropFaq,
        kgQnADel: kgQnADel,
        kgQnAUpdate: kgQnAUpdate,
        kgKeDelete: kgKeDelete,
        getCodevelopers:getCodevelopers,
        getRoles:getRoles,
        getGroups:getGroups,
        getSharePermissions:getSharePermissions,
        getPermissionsForRole:getPermissionsForRole,
        kgQnABulkDel: kgQnABulkDel,
        kgExportFaq: kgExportFaq,
        kgImportFaq: kgImportFaq,
        kgQnAnnotation: kgQnAnnotation,
        hangoutChannel: hangoutChannel,
        rcsBusinessChannel: rcsBusinessChannel,
        rcsLaunch: rcsLaunch,
        inviteUser:inviteUser,
        rootSessionFlow: rootSessionFlow,
        postRootSessionFlow: postRootSessionFlow,
        nodeSessionFlow: nodeSessionFlow,
        utterancesSessionFlow: utterancesSessionFlow,    
        uttSessionOutgo: uttSessionOutgo,
        totalUtteranceCount: totalUtteranceCount,
        dropOffs: dropOffs,
        botTasksSummary:botTasksSummary,
        botSummary:botSummary,
        editNlSettings:editNlSettings,
        livebankChannel: livebankChannel,
        getTraitGroups:getTraitGroups,
        updateTraitGroup:updateTraitGroup,
        createTraitGroup:createTraitGroup,
        deleteTraitsGroup:deleteTraitsGroup,
        getTraitGroupById:getTraitGroupById,
        getTraitsByGroupId:getTraitsByGroupId,
        getTraitsById:getTraitsById,
        updateTraitsById:updateTraitsById,
        getKgManageWords: getKgManageWords,
        updateKgManageWords: updateKgManageWords,
        saveSentiment:saveSentiment,
        resetKgManageWords:resetKgManageWords,
        editSentiment:editSentiment,
        deleteSentiment:deleteSentiment,
        kgExtractIsVisited: kgExtractIsVisited,
        scheduleCluster: scheduleCluster,
        reorderSentiment:reorderSentiment,
        getSmallTalkGroups:getSmallTalkGroups,
        getSmallTalk:getSmallTalk,
        updateGroup:updateGroup,
        creteNewNode:creteNewNode,
        createGroup:createGroup,
        getCurrentGroupNodes:getCurrentGroupNodes,
        updateNode:updateNode,
        deleteNode:deleteNode,
        extractUtterance: extractUtterance,
        deleteGroup:deleteGroup,
        paginateSmallTalk:paginateSmallTalk,
        searchUserSays:searchUserSays,
        exportSmallTalk:exportSmallTalk,
        startImporting:startImporting,
        statusImportingSmallTalk:statusImportingSmallTalk,
        migrateSmallTalk:migrateSmallTalk,
        reOderSmallTalk:reOderSmallTalk,
        initiateOntologyAnalysis:initiateOntologyAnalysis,
        reOrderQuestions:reOrderQuestions,
        createPanel:createPanel,
        getPannelById:getPannelById,
        getBotPanels:getBotPanels,
        updatePannelById:updatePannelById,
        createWidget:createWidget,
        getWidgetById:getWidgetById,
        getBotWidgets:getBotWidgets,
        updateWidgetById:updateWidgetById,
        deletePanel:deletePanel,
        deleteWidget:deleteWidget,
        fbInstallApp:fbInstallApp,
        getbotSpecficUsers:getbotSpecficUsers,
        deleteRunDetails: deleteRunDetails,
        deleteRunDetailsAll: deleteRunDetailsAll,
        upgradeUniversalBot:upgradeUniversalBot,
        getLinkBot : getLinkBot,
        addTrainingData:addTrainingData,
        searchText:searchText,
        paginateTrainingData:paginateTrainingData,
        createUiForm:createUiForm,
        updateUiForm:updateUiForm,
        getAllNamespaces:getAllNamespaces,
        createNamespace:createNamespace,
        updateNamespace:updateNamespace,
        deleteNamespace:deleteNamespace,
        getNSVariables: getNSVariables,
        addNamespaceKg: addNamespaceKg,
        enableNamespace: enableNamespace,
        getBotUiForms:getBotUiForms,
        getBotUiFormById:getBotUiFormById,
        deleteBotUiFormById:deleteBotUiFormById,
        intigrateFormToPanel:intigrateFormToPanel,
        getKoreUserIdsOnSearch:getKoreUserIdsOnSearch,
        getChannelsUserdIdsOnSearch:getChannelsUserdIdsOnSearch,
        analyzeDefaultFilter:analyzeDefaultFilter,
        analyzeGetDefaultFilter:analyzeGetDefaultFilter,
        analyzeEditDefaultFilter:analyzeEditDefaultFilter,
        disableLanguage:disableLanguage,
        defaultLanguage:defaultLanguage,
        reEnableLanguage:reEnableLanguage,
        createVersion:createVersion,
        getBotVersions:getBotVersions,
        getBotVersionDateRange:getBotVersionDateRange,
        deleteBotVersion:deleteBotVersion,
        exportBotVersion:exportBotVersion,
        restoreBotVersion:restoreBotVersion,
        getVersionStatus:getVersionStatus,
        getRestoreStatus:getRestoreStatus,
        deleteVersion:deleteVersion,
        saveTriggerPhaseSettings:saveTriggerPhaseSettings,
        daasTables: daasTables,
        daasViews: daasViews,
        daasSaveServiceNode: daasSaveServiceNode,
        publishImportBot:publishImportBot,
        getAdvancedConfigurations:getAdvancedConfigurations,
        getAdvancedConfigurationsByName: getAdvancedConfigurationsByName,
        addConfiguration:addConfiguration,
        getSavedConfiguration:getSavedConfiguration,
        deleteConfiguration:deleteConfiguration,
        editConfigurations:editConfigurations,
        createCustomModel:createCustomModel,
        updateCustomModel:updateCustomModel,
        deleteDialogIntentModel:deleteDialogIntentModel,
        getDeploymentStatus: getDeploymentStatus,
        updateBotConfigurations:updateBotConfigurations,
        getSampleBotSettings:getSampleBotSettings,
        getPlans:getPlans,
        planChange:planChange,
        planValidate:planValidate,
        planCheckout : planCheckout,
        paymentstatus:paymentstatus,
        cancelPlanSub : cancelPlanSub,
        planAutoRecharge:planAutoRecharge,
        planValidation : planValidation,
        getBillingsession : getBillingsession,
        downloadBillingsession : downloadBillingsession,
        getInvoices : getInvoices,
        getSupportPlans: getSupportPlans,
        supportPlanChange: supportPlanChange,
        supportPlanCancel: supportPlanCancel,
        supportPlanValidate: supportPlanValidate,
        getPinnedMenus:getPinnedMenus,
        createtestcase: createtestcase,
        clonetestcase: clonetestcase,
        deletetestcase: deletetestcase,
        recentTags: recentTags,
        runtestcases: runtestcases,
        updatePinnedMenus:updatePinnedMenus,
        createBulkUtterances:createBulkUtterances,
        getScenes:getScenes,
        createScene:createScene,
        cloneScene:cloneScene,
        deleteScene:deleteScene,
        editScene:editScene,
        importScene:importScene,
        createtranslationEngine:createtranslationEngine,
        allTranslationengines:allTranslationengines,
        gettranslationEngine:gettranslationEngine,
        editTranslationEngine:editTranslationEngine,
        deletTranslationEngine:deletTranslationEngine,
        exportScene:exportScene,
        resetShareURL:resetShareURL,
        updateScene:updateScene
      };

    }]);

})(angular);


;(function(ng) {
    'use strict';
    ng.module('services').service('BTTeamsService', ['$translator', function($translator) {

    	function translate(urlIdentifier, params, payload, headers) {
    		return $translator.translate(urlIdentifier, params, payload, headers);
    	}

        var getTeams = function() {
            return translate('bt.teams.get', {}, {});
        };

    	return {
    		getTeams   : getTeams
    	};
    }]);

})(angular);

;(function(ng) {

    'use strict';
    ng.module('services').service('$workflowService', function($timeout) {

        var _selectedStream = {}, knowledgeScope = {},__selectedStreamState='',
            nlptext = '',
            alertTasks = [],
            actionTasks = [],
            dialogTasks = [],
            informationTasks = [],
            knowledges = [],
            _dialogtasksByState=[],
            _knowledgeTasksByState = [],
            _informationTasksByState=[],
            _actionTasksByState=[],
            _alertTasksByState=[],
            _allTasksSortedData=[],
            _uiFormsTasksByState=[],
            smallTalk = [],
            _breadCrumb = [],
            _sideBarView = null,
            _authInfo = {
                sso_type: '',
                idpName: ''
            },
            _requestObject = [{
                    datatype: '',
                    sampleResponse: ''
                }],
            _wfType = '',
            _wfFields = [],
            _wfFilters = [],
            _rqChainObjects = [],
            _koreUXMap = {title: '', body: ''},
            _alrtFldObjects = [],
            _currentStep = 1,
            _taskEditInfo,
            _taskMode,
            _saveFrom,
            _alertInfo,
            _mpAlertInfo,
            _actionInfo,
            _mpActionInfo,
            _flowTaskInfo,
            _seedData = {},
            _processData = [],
            _sampleResponseKeys = {},
            _mappingInfo = {},
            _streams = [],
            _alertDescription = '',
            _alert = '',
            _alertData = {},
            _authData = {},
            _reqData = {},
            _resData = {},
            _setData = {},
            _templates=[],
            _publishInfo={},
            _stremType = '',
            _cache = null,
            _authlist = {},
            _nlpStream = {},
            _navigateTabIndex=".tasks-pane",
             connectors = [],
             linkableBots = false,
             botDetails = {},
             sampleBotModalTitle = "",
             selectedSampleBot = "",
             selectedSmartBot = "",
             sampleBots = [],
             smartBots = [],
             _publishedOrSuspended = false,
             _isTaskPublished = false,
             nlpTrainInput = {},
             _sessionContexts = {},
             _dialogNodesNames = {},
             _isInCAP = false,
             selectedLanguage = {},
             currentLanguage = "en",
             i18nSelectedLang="en",
             serveri18nLang,
             supportedLanguages = {},
             botVariables = [],
             importBotId = "",
             selectedAccount='',
             _permissions='',
             _customLibraries=[],
             _configurationData=[],
             _savedConfigurationData=[],
             _slidersList = [],
             _mlPharam={},
             debugConsoleTheme="LightTheme",
             _builderResumeState={},
             appVersion='',
             dockId='',
             componentsList = [],
             docData = {},
             createVerData = {},
             trainStatus = {},
             ontologyJobStatus = '',
             themeMode  = 'LightTheme',
             searchQry={},
             universalModalSeen = false,
             _kgStateData='',
             sampleBotData = {},
             processStoreData = {},
             searchSubTask = {},
             newDialogUpgrade = null,
             displayMode = false,
             _currentTrainStatus={},
             _globalStoreQueryParams = null,
             newBotSetup={};
        return {
            isInCAP: function(flag){
                if(flag === false || flag === true){
                    _isInCAP = flag;
                    return;
                }
                return _isInCAP;
            },
            publishedOrSuspended: function(flag){
                if(flag){
                    _publishedOrSuspended = flag;
                    return;
                }
                return _publishedOrSuspended;
            },
            globalStoreQueryParams: function(parms){
                if(parms){
                    _globalStoreQueryParams = parms;
                    window.localStorage.setItem("installFromStore",JSON.stringify(_globalStoreQueryParams));
                    return;
                }
                return _globalStoreQueryParams;
            },
            isTaskPublished: function(flag){
                if(flag){
                    _isTaskPublished = flag;
                    return;
                }
                return _isTaskPublished;
            },
            streamType : function(type){
                if(type){
                    _stremType = type;
                    return;
                }
                return _stremType;
            },
            nlpText : function nlpText(text){
                if(text){
                    nlptext = text;
                }
                return nlptext;
            },
            cache: function cache(cacheValue){
                if(cacheValue){
                    _cache = cacheValue;
                }
                return _cache;
            },
            nlpStream : function(nlpStream){
                if(typeof nlpStream === 'object'){
                    _nlpStream = nlpStream;
                }
                return _nlpStream;
            },
            publishEntity:function(publishInfo){
                if (publishInfo) {
                    _publishInfo = publishInfo;
                    return;
                }
                return _publishInfo;
            },
            templates:function(_templs){
                if (_templs) {
                    _templates = _templs;
                    return;
                }
                return _templates;
            },
            mappingInfo: function(_map) {
                if (_map) {
                    _mappingInfo = _map;
                    return;
                }
                return _mappingInfo;
            },
            sampleResponseKeys: function(_res) {
                if (_res) {
                    _sampleResponseKeys = _res;
                    return;
                }
                return _sampleResponseKeys;
            },
            isPhone: function(value) {
                var numberRegEx = /^\d\d+$/;
                return numberRegEx.test(value.trim());
            },
            formatPhone: function(value) {

            if (value.length >= 4 && value.length <= 6) {
                value = value.replace(/(\d{3})(\d{3})?/, '$1-$2');
            } else if (value.length >= 7 && value.length <= 20) {
                value = value.replace(/(\d{3})(\d{3})(\d{4})?/, '$1-$2-$3');
            }

            return value;
        },
            streamsAll: function(_res) {
                if (_res) {
                    _streams = _res;
                    return;
                }
                return _streams;
            },
            seedData: function(_data) {
                if (_data) {
                    _seedData = _data;
                    return;
                }
                return _seedData;
            },
            processAppsData: function(_data) {
                if (_data) {
                    _processData = _data;
                    return;
                }
                return _processData;
            },
            currentStep: function(_step) {
                if (_step) {
                    _currentStep = _step;
                    return;
                }
                return _currentStep;
            },
            cloneData: function(data){
                var clonedData = null;
                try {
                    clonedData =   JSON.parse(JSON.stringify(data));
                }  catch(e){
                    clonedData = _.cloneDeep(data);
                }
                return clonedData || data;
            },
            selectedStream: function(_stream) {
                if(_stream && !_stream.hasOwnProperty('_id')){
                    _selectedStream = {};
                }
                else if (_stream) {
                    
                    //Stream level data modifications can do here
                    if(_stream.taskCounts){
                        _stream._taskCounts={};
                       
                        var tasksInProgress=0;
                       $.each(_stream.taskCounts,function(key,value){
                        _stream._taskCounts[key]={indevelopment:0,published:0};
                        if(key=='faqCount'){
                            _stream._taskCounts[key].published = _stream.taskCounts.faqCount || 0;
                            _stream._taskCounts[key].indevelopment = _stream.taskCounts.faqCount || 0;
                        }
                        if(key=='flows'){
                            if(_stream.taskCounts && _stream.taskCounts.flows && _stream.taskCounts.flows){
                                _stream._taskCounts[key].indevelopment= (_stream.taskCounts.flows.paramMaps.length + _stream.taskCounts.flows.taskDGParamMaps.length);
                                _stream._taskCounts[key].published= ((_stream.taskCounts.flows.taskDGParamMaps.length) || 0);
                            }
                        }else if(key=='smalltalks'){
                            if(_stream.taskCounts && _stream.taskCounts.smalltalks){
                                $.each(value,function(i,value){
                                    if(value && value.state === 'published'){
                                         _stream._taskCounts[key].published = value.count || 0;
                                    }
                                    if(value && value.state === 'configured'){
                                        _stream._taskCounts[key].indevelopment = value.count || 0;
                                    }
                                });
                            }
                             _stream._taskCounts.totalIndevelopment = (_stream._taskCounts.totalIndevelopment || 0 )+ _stream._taskCounts[key].indevelopment; // includes all task count exept published count //
                            _stream._taskCounts.totalPublished = (_stream._taskCounts.totalPublished || 0)+ _stream._taskCounts[key].published; // includes only published count //
                            _stream._taskCounts.totalTasks = _stream._taskCounts.totalIndevelopment + _stream._taskCounts.totalPublished; // includes total tasks count for the bot //
                            _stream._taskCounts.totalTasksInUse = _stream._taskCounts.totalTasks-tasksInProgress; // tasks count excluding 'inProgress' tasks//
                        }else if(key==='forms'){
                            if(_stream.taskCounts && _stream.taskCounts.forms){
                                $.each(value,function(i,value){
                                    if(value && value.state === 'published' || value.state=== 'suspended'){
                                         _stream._taskCounts[key].published = value.count || 0;
                                    }
                                    if(value && ((value.state === 'configured') || (value.state=== 'awaitingApproval') || (value.state=== 'rejected'))){
                                        _stream._taskCounts[key].indevelopment = value.count || 0;
                                    }
                                });
                            }
                             _stream._taskCounts.totalIndevelopment = (_stream._taskCounts.totalIndevelopment || 0 )+ _stream._taskCounts[key].indevelopment; // includes all task count exept published count //
                            _stream._taskCounts.totalPublished = (_stream._taskCounts.totalPublished || 0)+ _stream._taskCounts[key].published; // includes only published count //
                            _stream._taskCounts.totalTasks = _stream._taskCounts.totalIndevelopment + _stream._taskCounts.totalPublished; // includes total tasks count for the bot //
                            _stream._taskCounts.totalTasksInUse = _stream._taskCounts.totalTasks-tasksInProgress; // tasks count excluding 'inProgress' tasks//
                        }else if(key=='widgets' || key==='panels'){
                            if(_stream.taskCounts && (_stream.taskCounts.widgets) && key==='widgets'){
                                _stream._taskCounts[key]={
                                    published:0,
                                    indevelopment:0
                                };
                                $.each(value,function(i,value){
                                    if(value && value.state === 'published' || value.state=== 'suspended'){
                                         _stream._taskCounts[key].published = (_stream._taskCounts[key].published || 0) + (value.count || 0);
                                    }
                                    if(value && ((value.state === 'configured') || (value.state=== 'awaitingApproval') || (value.state=== 'rejected'))){
                                        _stream._taskCounts[key].indevelopment = (_stream._taskCounts[key].indevelopment || 0) + (value.count || 0);
                                    }
                                });
                            }
                            if(_stream.taskCounts && (_stream.taskCounts.panels) && key==='panels'){
                                _stream._taskCounts[key]={
                                    published:0,
                                    indevelopment:0
                                };
                                $.each(value,function(i,value){
                                    if(value && (value.state === 'published' || value.state=== 'suspended')){
                                         _stream._taskCounts[key].published = (_stream._taskCounts[key].published || 0) + (value.count || 0);
                                    }
                                    if(value && ((value.state === 'configured') || (value.state=== 'awaitingApproval') || (value.state=== 'rejected'))){
                                        _stream._taskCounts[key].indevelopment =  (_stream._taskCounts[key].indevelopment || 0) + (value.count || 0);
                                    }
                                });
                            }
                             _stream._taskCounts.totalIndevelopment = (_stream._taskCounts.totalIndevelopment || 0 )+ _stream._taskCounts[key].indevelopment; // includes all task count exept published count //
                            _stream._taskCounts.totalPublished = (_stream._taskCounts.totalPublished || 0)+ _stream._taskCounts[key].published; // includes only published count //
                            _stream._taskCounts.totalTasks = _stream._taskCounts.totalIndevelopment + _stream._taskCounts.totalPublished; // includes total tasks count for the bot //
                            _stream._taskCounts.totalTasksInUse = _stream._taskCounts.totalTasks-tasksInProgress; // tasks count excluding 'inProgress' tasks//
                        }
                        else if(key!=='faqCount'){
                         $.each(value,function(i,value){
                            _stream._taskCounts[key].indevelopment= _stream._taskCounts[key].indevelopment + (value.count || 0) - (value.deletedCount || 0);
                            if(value && value.state=='published'){
                                _stream._taskCounts[key].published = value.count || 0;
                            }
                            if(value && value.state=='inProgress'){
                                tasksInProgress = (tasksInProgress || 0)+ value.count;
                            }});
                        
                            _stream._taskCounts.totalIndevelopment = (_stream._taskCounts.totalIndevelopment || 0 )+ _stream._taskCounts[key].indevelopment; // includes all task count exept published count //
                            _stream._taskCounts.totalPublished = (_stream._taskCounts.totalPublished || 0)+ _stream._taskCounts[key].published; // includes only published count //
                            _stream._taskCounts.totalTasks = _stream._taskCounts.totalIndevelopment + _stream._taskCounts.totalPublished; // includes total tasks count for the bot //
                            _stream._taskCounts.totalTasksInUse = _stream._taskCounts.totalTasks-tasksInProgress; // tasks count excluding 'inProgress' tasks//
                        }
                        });
                   }
                    //check for bot is published or not
                    if (_stream.visibility.namespace === "private") {
                        _stream.isInMarket = false;
                    } else {
                        _stream.isInMarket = true;
                    }
                    if(_stream._taskCounts && _stream._taskCounts.totalTasksInUse){
                        _isInCAP = true;
                    }else{
                        _isInCAP = false;
                    }
                    if(_stream.isInMarket){
                        _isInCAP = true;
                    }
                    //_isInCAP=_stream.isInMarket;//_isInCAP is for if for tasks available or not for bot
                                        
                    _selectedStream = _stream;
                    return _selectedStream;
                }
                return _selectedStream;
            },
            configurationList:function(configuration){
                if(configuration){
                    _configurationData = configuration;
                    return _configurationData;
                }
                return _configurationData;

            },
            savedConfigurationsList : function(savedConfiguration){
                if(savedConfiguration){
                    _savedConfigurationData = savedConfiguration;
                    return _savedConfigurationData;
                }
                return _savedConfigurationData;
            },
            registerSliders : function(slidersList){
                if(slidersList){
                    _slidersList = slidersList;
                    return _slidersList;
                }
                return _slidersList;
            },
            selectedStreamState: function(state) {
                if (state) {
                    __selectedStreamState = state;
                    return __selectedStreamState;
                }
                return __selectedStreamState;
            },
            customLibraries: function(data) {
                if (data) {
                    _customLibraries = data;
                    return _customLibraries;
                }
                return _customLibraries;
            },
            contextData: function(_context) {
                if(_context) {
                    _sessionContexts = _context;
                    return;
                }
                return _sessionContexts;
            },
            botEnvVariables: function(_variables) {
                if(_variables) {
                    botVariables = _variables;
                    return;
                }
                return botVariables;
            },
            mlPharams: function(mlPharam) {
                if (mlPharam) {
                    _mlPharam = mlPharam;
                    return _selectedStream;
                }
                return _mlPharam;
            },
            importedNewBotId: function(streamId) {
                if(streamId) {
                    importBotId = streamId;
                }
                else {
                    return importBotId;
                }
            },
            dialogNodesNames: function(_nodes) {
                if(_nodes) {
                    _dialogNodesNames = _nodes;
                    return;
                }
                return _dialogNodesNames;
            },
            workflowType: function(_type) {
                if (_type) {
                    _wfType = _type;
                    return;
                }
                return _wfType;
            },
            alertDescription: function(_desc) {
                if (_desc) {
                    _alertDescription = _desc;
                    return;
                }
                return _alertDescription;
            },
            authInfo: function(_info) {
                if (_info) {
                    _authInfo = _info;
                    return;
                }
                return _authInfo;
            },
            taskEditInfo: function(_info) {
                if (_info) {
                    _taskEditInfo = _info;
                    return;
                }
                return _taskEditInfo;
            },
            taskMode: function(_info) {
                if (_info) {
                    _taskMode = _info;
                    return;
                }
                return _taskMode;
            },
            storeSearchQry: function(_info) {
                if(_info) {
                    searchQry = _info;
                    return;
                }
                return searchQry;
            },
            subTabSearchQuery : function(subTaskQry){
                if(subTaskQry){
                    searchSubTask = subTaskQry;
                    return;
                }
                return searchSubTask;
            },
            saveFrom: function(_info) {
                if(_info){
                    _saveFrom = _info;
                    return;
                }
                return _saveFrom;
            },
            resetTaskEditInfo: function() {
                    _taskEditInfo = undefined;
            },
            alertInfo: function(_info) {
                if (_info) {
                    _alertInfo = _info;
                    return;
                }
                return _alertInfo;
            },
            mpAlertInfo: function(_info) {
                if (_info) {
                    _mpAlertInfo = _info;
                    return;
                }
                return _mpAlertInfo;
            },
            actionInfo: function(_info) {
                if (_info) {
                    _actionInfo = _info;
                    return;
                }
                return _actionInfo;
            },
            mpActionInfo: function(_info) {
                if (_info) {
                    _mpActionInfo = _info;
                    return;
                }
                return _mpActionInfo;
            },
            flowtaskInfo: function(_info) {
                if (_info) {
                    _flowTaskInfo = _info;
                    return;
                }
                return _flowTaskInfo;
            },
            requestObject: function(_rqObj) {
                if (_rqObj) {
                    _requestObject = _rqObj;
                    return;
                }
                return _requestObject;
            },
            workflowFields: function(_fields) {
                if (_fields) {
                    _wfFields = _fields;
                    return;
                }
                return _wfFields;
            },
            workflowFilters: function(_filters) {
                if (_filters) {
                    _wfFilters = _filters;
                    return;
                }
                return _wfFilters;
            },
            requestChainObjects: function(rqObj, index) {
                if (rqObj) {
                    _rqChainObjects.push(rqObj);
                    return;
                }
                return _rqChainObjects;
            },
            alrtFldObjects: function(alrtField, index) {
                if (alrtField) {
                    _alrtFldObjects.push(alrtField);
                    return;
                }
                return _alrtFldObjects;
            },
            koreUXMap: function(_map) {
                if (_map) {
                    _koreUXMap = _map;
                    return;
                }
                return _koreUXMap;
            },
            alertSelected: function(alert) {
                if (alert) {
                    _alert = alert;
                    return;
                }
                return _alert;
            },
            alertData: function(alertData) {
                if (alertData) {
                    _alertData = alertData;
                    return;
                }
                return _alertData;
            },
            authData: function(authData) {
                if (authData) {
                    _authData = authData;
                    return;
                }
                return _authData;
            },
            requestData: function(reqData) {
                if (reqData) {
                    _reqData = reqData;
                    return;
                }
                return _reqData;
            },
            responseData: function(resData) {
                if (resData) {
                    _resData = resData;
                    return;
                }
                return _resData;
            },
            settingsData: function(setData) {
                if (setData) {
                    _setData = setData;
                    return;
                }
                return _setData;
            },
            authlist: function(list) {
                if (list) {
                    _authlist = list;
                    return;
                }
                return _authlist;
            },
            alertTasks: function (alertsList) {
                if (alertsList) {
                    alertTasks = alertsList;
                    return;
                }
                return alertTasks;
            },
            actionTasks : function(actionslist){
                if(actionslist){
                    actionTasks = actionslist;
                    return;
                }
                return actionTasks;
            },
            dialogTasks:function(flowTasksList){
                if(flowTasksList){
                    dialogTasks = flowTasksList;
                    return;
                }
                return dialogTasks;
            },
            smallTalk:function(smallTalkList){
                if(smallTalkList){
                    smallTalk = smallTalkList;
                    return;
                }
                return smallTalk;
            },
            dialogTasksByState:function(tasksByState){
                if(tasksByState){
                    _dialogtasksByState = tasksByState;
                    return;
                }
                return _dialogtasksByState;
            },
            alertTasksByState:function(tasksByState){
                if(tasksByState){
                    _alertTasksByState = tasksByState;
                    return;
                }
                return _alertTasksByState;
            },
            actionTasksByState:function(tasksByState){
                if(tasksByState){
                    _actionTasksByState = tasksByState;
                    return;
                }
                return _actionTasksByState;
            },
            informationTasksByState:function(tasksByState){
                if(tasksByState){
                    _informationTasksByState = tasksByState;
                    return;
                }
                return _informationTasksByState;
            },
            knowledgeTasksByState:function(tasksByState){
                if(tasksByState){
                    _knowledgeTasksByState = tasksByState;
                    return;
                }
                return _knowledgeTasksByState;
            },
            uiFormsTasksByState:function(tasksByState){
                if(tasksByState){
                    _uiFormsTasksByState = tasksByState;
                    return;
                }
                return _uiFormsTasksByState;
            },
            allTasksSortedData:function(tasksByState){
                if(tasksByState){
                    _allTasksSortedData = tasksByState;
                    return;
                }
                return _allTasksSortedData;
            },
            informationTasks:function(informationList){
                if(informationList){
                    informationTasks = informationList;
                    return;
                }
                return informationTasks;
            },
            knowledgeTasks : function(knowledgeList) {
                if(knowledgeList){
                    knowledges = knowledgeList;
                    return;
                }
                return knowledges;
            },
            btAppVersion : function(version) {
                if(version){
                    appVersion = version;
                    return;
                }
                return appVersion;
            },
            universalModalShowStatus : function(showType){
                if(showType !== undefined){
                    universalModalSeen = showType;
                    return;
                }
                return universalModalSeen;
            },
            builderResumeState: function(paths){
                var pathObj={
                    path:[]
                };
                var localPath = window.localStorage.getItem("previousState");
                if(localPath){
                    _builderResumeState = JSON.parse(localPath);
                }
                if(paths){
                    // $.each(paths, function (i, path) {
                    //     pathObj.path[i]=path.name;
                    //     });
                        pathObj.path = paths;
                            pathObj.selectedStream ={
                                "_id":_selectedStream._id,
                                "accountId":_selectedStream.accountId,
                                "defaultLanguage":_selectedStream.defaultLanguage
                            } ;
                            pathObj.selectedStreamState = __selectedStreamState;
                        pathObj.selectedLanguage = currentLanguage;
                        pathObj.account = selectedAccount;
                        pathObj.appVersion = appVersion;
                        if(_selectedStream.type === 'universalbot'){
                            pathObj.universalSeen = universalModalSeen;
                        }
                        window.localStorage.setItem("previousState",JSON.stringify(pathObj)); // this will also be updated in bot-details form at task selection level and builderResumeState function in this file// 
                    _builderResumeState = pathObj;
                    return;
                }
                return _builderResumeState;
            },
            breadCrumb : function(breadCrumbData){
                if(breadCrumbData){ 
                   _breadCrumb = breadCrumbData;
                    return;
                }
                return _breadCrumb;
            },
            sideBarView: function(view){
                
                if(view){
                    _sideBarView = view;
                    return;
                }
                return _sideBarView;
            },
            newDialogUpgrade:function(setId,reset){
                if(setId){
                    newDialogUpgrade = setId;
                }else if (reset){
                    newDialogUpgrade = null;
                } else {
                 return newDialogUpgrade;   
                }
            },
            navigateTabIndex : function(index){
                if(index){
                    _navigateTabIndex = index;
                }else{
                 return (_navigateTabIndex || ".tasks-pane");   
                }
            },
            botConnectors :function(connectorsList){
                if(connectorsList){
                    connectors = connectorsList;
                }else{
                 return connectors;   
                }   
            },
            registerModalHiddenEvent: function(){
              //   $(".modal").off("hidden.bs.modal").on("hidden.bs.modal", function(evt) {
              //       evt.preventDefault();
              //       evt.stopPropagation();
              //       if(!$(".modal-backdrop.fade.in").is(":visible") || $(evt.target).hasClass("dialog-notification-modal") || $(evt.target).hasClass("taskCreateOrEditModal") || $(evt.target).hasClass("utteranceModal") || $(evt.target).hasClass("utterances-form")){
              //         $("body").removeClass("bt-modal-open");
              //     }else{
              //       //return;
              //       $timeout(function(){
              //            $("body").addClass("bt-modal-open");
              //       }, 500);

              //     }

              //     if($("#taskCreateOrEditModal .main-content").is(":visible")){
              //       PerfectScrollbar.destroy($("#taskCreateOrEditModal .main-content")[0]);
              //        PerfectScrollbar.initialize($("#taskCreateOrEditModal .main-content")[0],{
              //             wheelSpeed: 2,
              //             wheelPropagation: false,
              //             minScrollbarLength: 25
              //           });
              //     }
                 
              // });

                // $('.panel-collapse').on('shown.bs.collapse', function(e) {
                //     var $panel = $(this).closest('.panel');
                //     var $scrollDiv = $(this).closest('[perfect-scroll]');
                //     $($scrollDiv).animate({
                //       scrollTop: $panel.offset().top
                //   }, 500);
                // });
            },
            reigisterModalShownEvent: function() {
                // $(".modal").off("shown.bs.modal").on("shown.bs.modal", function(evt) {
                //     evt.preventDefault();
                //     evt.stopPropagation();
                //     if(!$(evt.target).hasClass("taskCreateOrEditModal") && $("#taskCreateOrEditModal .main-content").is(":visible")){
                //         PerfectScrollbar.destroy($("#taskCreateOrEditModal .main-content")[0]);
                //     }

                //     $timeout(function(){
                //         $("body").addClass("bt-modal-open");
                //     }, 500);


                // });
            }, 
            botDetails: function (streamName, details) {
                if (details) {
                    botDetails[streamName] = details;     
                } else {
                    if (botDetails[streamName]) {
                        return botDetails[streamName];
                    } else {
                        return false;
                    } 
                }
            },
            sampleBotModalTitle: function (name) {
                if(name) {
                    sampleBotModalTitle = name;
                } else {
                    return sampleBotModalTitle;
                }
            },
            selectedSampleBot: function (sampleBot) {
                if(sampleBot) {
                    selectedSampleBot = sampleBot;
                } else {
                    return selectedSampleBot;
                }
            },
             selectedSmartBot: function (sampleBot) {
                if(sampleBot) {
                    selectedSampleBot = sampleBot;
                } else {
                    return selectedSampleBot;
                }
            },
            allSampleBots: function (bots) {
                if(bots){
                    sampleBots = bots;
                } else {
                    return sampleBots;
                }
            },
             allSmartBots: function (bots) {
                if(bots){
                    smartBots = bots;
                } else {
                    return smartBots;
                }
            },
            nlpTrainInput: function (input) {
                if(input){
                    nlpTrainInput = input;
                } else {
                    return nlpTrainInput;
                }
            },
            selectedLanguage: function (language) {   //depricated //
                if(language){
                    selectedLanguage = language;
                } else {
                    return selectedLanguage;
                }
            },
            currentLanguage: function (language) {
                if(language){
                    currentLanguage = language;
                } else {
                    return currentLanguage;
                }
            },
            i18nSelectedLanguage: function (language) {
                if (language) {
                    i18nSelectedLang = language;
                }else{
                    return i18nSelectedLang;
                }
            },
            serveri18nLang: function (language) {
                if (language) {
                    serveri18nLang = language;
                    window.localStorage.setItem('queryParamLang',language);
                } else {
                    return serveri18nLang;
                }
            },
            
            supportedLanguages: function (languages) {
                 if(languages){
                    supportedLanguages = languages;
                } else {
                    return supportedLanguages;
                }
            },
            selectedAccount:function(account){
                if(account){
                    selectedAccount = account;
                } else {
                    return selectedAccount;
                } 
            },
            kgDataFromKora:function(kgStateData){
                if(kgStateData){
                    _kgStateData = kgStateData;
                } else {
                    return _kgStateData;
                } 
            },
            defaultComponentIVRProps: function () {
                var _defaultIVRProps = {
                    "initialPrompts": [],
                    "nomatchPrompts": [],
                    "timeoutPrompts": [],
                    "errorPrompts":[],
                    "grammars": [{
                            inputMode: "speech",
                            type: "custom",
                            value: ""
                        }],
                    "advance": {
                        "timeout": 10000,
                        "retry_limit": 3,
                        "bargein": false,
                        "properties": [],
                        "enable_log": false,
                        "recording": "stop"
                    }
                };
                if (_selectedStream && _selectedStream.ivrSettings && _selectedStream.ivrSettings.enable_transcript) {
                    _defaultIVRProps.grammars[0].type = 'disable';//Transcription Engine
                }
                return _defaultIVRProps;
            },
            debugConsoleThemeInfo : function(type){
                if(type){
                    debugConsoleTheme = type;
                    return;
                }
                return debugConsoleTheme;
            },
            selectedDialogComponents : function(data){
                if(data){
                    componentsList = data;
                    return;
                }else{
                    return componentsList;
                }
            },
            setCurrentDockId : function(dockId){
                if(dockId){
                    dockId = dockId;
                }else{
                    return dockId;
                }
            },
            ontologyJobStatus : function(data){
                if(data){
                    docData = data;
                }else{
                    return docData;
                }
            },
            kgTrainingStatus : function(data){
                if(data){
                    trainStatus = data;
                }else{
                    return trainStatus;
                }
            },
            createVersionStatus : function(data){
                if(data){
                    createVerData = data;
                }else{
                    return createVerData;
                }
            },
            saveThemeMode : function(type){
                 if(type){
                    themeMode = type;
                    return;
                }
                return themeMode;
            },
            sampleBotDataFromBotStore : function(data){
                if(data){
                    sampleBotData = data;
                }else{
                    return sampleBotData;
                }
            },
            toInstallProcessApp : function(data){
                if(data){
                    processStoreData = data;
                }else{
                    return processStoreData;
                }
            },
            flowTaskDisplayMode : function(datavalue){
                if(typeof(datavalue) === "string"){
                    displayMode = datavalue;
                }else{
                    return displayMode;
                }
            },
            currTrainStatus : function(status){
                if(status){
                    _currentTrainStatus = status;
                }else{
                    return _currentTrainStatus;
                }
            },
            newBotSetupProgress: function(obj) {
                if(obj){
                    newBotSetup = obj;
                    return;
                }
                return newBotSetup;
            },
        };
    });
})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components', ['bt-components']);

    _module.controller('BTAddSynonymsCtrl', ['$scope', '$translator', '$modalInstance', '$workflowService', 'BTStreamsService', 'config', 'env_conf','i18n',
        function ($scope, $translator, $modalInstance, $workflowService, BTStreamsService, config, env_conf,i18n) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.synonymsSelect2Options={maxTagLength:128};
            $scope.manageSynonym = {};
            $scope.assetsBase = env_conf['assets-url'];
            $scope.fromPP = false;

            $scope.saving = i18n.i18nString('saving');
            $scope.save   = i18n.i18nString('save');


            if(config.isFromPP) {
                $scope.fromPP = true;
            }
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.addBotSynonym = function () {
                var payload = {};
                var currentSynonmyms = angular.copy($scope.manageSynonym.synonyms);
                $scope.saveInProgress = true;
                if(config.parentSynonyms && config.parentSynonyms[$scope.manageSynonym.keyword] && config.parentSynonyms[$scope.manageSynonym.keyword].length) {
                    var existingSynonyms = angular.copy(config.parentSynonyms[$scope.manageSynonym.keyword]);
                    existingSynonyms = existingSynonyms.concat(currentSynonmyms);
                    //currentSynonmyms = existingSynonyms;
                    config.parentSynonyms[$scope.manageSynonym.keyword] = existingSynonyms;
                }
                else {
                    config.parentSynonyms[$scope.manageSynonym.keyword] = currentSynonmyms;
                } 

                payload = angular.copy(config.parentSynonyms);
              //  payload[$scope.manageSynonym.keyword] = currentSynonmyms;
                BTStreamsService
                        .postSynonyms($scope.stream._id, {synonyms: payload})
                        .then(function (res) {
                            $workflowService.selectedStream(res.data);
                            $workflowService.nlpStream(res.data);
                            $scope.saveInProgress = false;
                            if (config && config.cbBridge && config.cbBridge.onBotUpdate) {
                                config.cbBridge.onBotUpdate(res.data);
                            }
                            $scope.closeModal();
                        }, function (err) {
                            $scope.saveInProgress = false;
                        });
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToWeChatCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.assetsBase = env_conf['assets-url'];
            
        }]);

})(angular);

;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToAlexaCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToAudioCodesCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);

;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToEmailCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'BTStreamsService', 'NotificationService', 'env_conf', '$applicationService', '_constants_', '$timeout','i18n',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, BTStreamsService, NotificationService, env_conf, $applicationService, _constants_, $timeout,i18n) {
            $scope.stream = $workflowService.selectedStream();
            var curUserDetails = $applicationService.userInfo();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.identities = config.component.additionalIdentities;
            $scope.assetsBase = env_conf['assets-url'];
            $scope.emailId = null;
            $scope.emailChannel = $scope.source.type === "email" ? true : false;
            $scope._constants_ = _constants_;
            $scope.phoneNumber = {countryCode: "", countryName: "", number: ""};
            $scope.resend = false;
            $scope.resendEmail = false;
            $scope.resendPhone = false;
            $scope.resendMailStatusText = i18n.i18nString('email_sent');
            $scope.phone = {};
            $scope.phone.phoneOTP = "";
            $scope.codeSent = i18n.i18nString('code_sent');
            $scope.resendPhoneVerifyStatusText = i18n.i18nString('verify');
            $scope.isFromChangePhoneNumber = false;
            $scope.oldPhoneNumber = null;
            $scope.verificationSuccessfull = false;
            $scope.selectedIdentity = null;

            $scope.email = i18n.i18nString('bt_add_to_email_email');
            $scope.message = i18n.i18nString('bt_add_to_email_message');



            if(!$scope.stream.icon){
                $scope.stream.icon = config.component.botIcon;
            }
            $scope.closeModal = function () {
                $scope.resetSelectedIdentity();
                $modalInstance.close();
            };

            function addBotToChannel(type, value) {
                var payload = {
                    channels: [{
                            type: type,
                            value: value
                        }]
                };
                BTStreamsService.addChannelToBot($scope.stream._id, payload)
                        .then(function (response) {
                            NotificationService.notify(i18n.i18nString('bt_add_to_email_verification_successful'), "success");
                            $scope.selectedIdentity = value;
                            $scope.verificationSuccessfull = true;
                        }, function (err) {
                            var errMsg = (err && err.data && err.data.errors && err.data.errors[0].msg) || "";
                            NotificationService.notify(errMsg, "error");
                        });
            }
            $scope.resendEmailVerify = function () {
                var payload = {
                    emailId: $scope.selectedEmail
                };
                var params = {};
                $scope.resendMailStatusText = i18n.i18nString('sending_email_label');
                BTStreamsService.resendIdentityVerification(curUserDetails.userId, payload, params)
                        .then(function (res) {
                            $scope.resendMailStatusText = i18n.i18nString('email_sent_name');
                            $timeout(function () {
                                $scope.resendMailStatusText = i18n.i18nString('email_sent');
                            }, 5000);
                        }, function (err) {
                            var errorMsg = i18n.i18nString('resend_email_failed');
                            NotificationService.notify(errorMsg, "error");
                            $scope.resendMailStatusText = i18n.i18nString('email_sent');
                        });
            };
            $scope.scrollDown = function(){
                $('.add-bot').animate({scrollTop:500}, 'slow');
            };
            function switchVerifyEmailForm() {
                $scope.resend = true;
                $scope.resendEmail = true;
                $('.add-bot').animate({scrollTop:0}, 'slow');
            }
            function switchVerifyPhoneForm() {
                $scope.resend = true;
                $scope.resendPhone = true;
                $timeout(function () {
                    $('.verificationCodeInput').trigger('focus');
                    $('.add-bot').animate({scrollTop:0}, 'slow');
                }, 20);
            }
            $scope.goStepBack = function(){
                $scope.resend = false;
                $scope.resendPhone = false;
                $scope.resendEmail = false;
                $scope.verificationSuccessfull = false;
            };
            function addNewIdentity(payload, type) {
                $scope.IdentityType = type;
                var params = {
                    userId: curUserDetails.userId,
                    addBot: true,
                    streamId: $scope.stream._id
                };
                BTStreamsService.addUserIdentity(curUserDetails.userId, payload, params)
                        .then(function (res) {
                            if ($scope.IdentityType === "email") {
                                NotificationService.notify(i18n.i18nString('formtitles_verify_email'), "success");
                                switchVerifyEmailForm();
                            } else {
                                NotificationService.notify(i18n.i18nString('please_verify_phone_number'), "success");
                                switchVerifyPhoneForm();
                            }
                            getAdditionalIdenties();
                        }, function (err) {
                            var errorMsg = (err && err.data && err.data.errors && err.data.errors[0].msg) || "";
                            if (errorMsg && errorMsg === 'CompanyEmailNotAllowed') {
                                errorMsg = i18n.i18nString('company_mail_not_allowed');
                            }
                            else if(errorMsg && errorMsg === 'Validation errors/ Invalid arguments') {
                                errorMsg = $scope.IdentityType === "email"? i18n.i18nString('please_enter_valid_email') : i18n.i18nString('please_enter_valid_mobile_number');
                            }
                            NotificationService.notify(errorMsg, "error");
                            //$scope.resetSelectedIdentity();
                        });
            }
            $scope.addEmailId = function (emailId) {
                $scope.selectedEmail = emailId;
                if ($scope.selectedIdentity && $scope.selectedIdentity.status === 'unverified') {
                    NotificationService.notify(i18n.i18nString('please_verify_your_email'), "warning");
                    switchVerifyEmailForm();
                    return;
                } else if ($scope.selectedIdentity && $scope.selectedIdentity.status === 'verified') {
                    addBotToChannel('email', emailId);
                    return;
                }
                for (var i = 0; i < $scope.identities.email.length; i++) {
                    var identity = $scope.identities.email[i];
                    if (identity.val === emailId && identity.status === 'unverified') {
                        NotificationService.notify(i18n.i18nString('please_verify_your_email'), "warning");
                        switchVerifyEmailForm();
                    } else if (identity.val === emailId && identity.status === 'verified') {
                        addBotToChannel('email', emailId);
                        return;
                    }
                }
                // Otherwise add the identity
                // First check if its FREE EMAIL only
                BTStreamsService.isFreeEmail(emailId)
                        .then(function (res) {
                            var payload = {
                                emailId: emailId
                            };
                            addNewIdentity(payload, "email");
                        }, function (err) {
                            var errorMsg = (err && err.data && err.data.errors && err.data.errors[0].msg) || i18n.i18nString('error_in_checking_email');
                            NotificationService.notify(errorMsg, "error");
                            //$scope.resetSelectedIdentity();
                        });
            };
            $scope.chooseEmailIdentity = function (identity) {
                $scope.selectedIdentity = identity;
                $scope.selectedEmail = $scope.selectedIdentity.val;
                if(identity.status !== 'verified'){
                    $scope.resendEmailVerify();
                }
                $scope.addEmailId($scope.selectedIdentity.val);
            };

            $scope.resetSelectedIdentity = function () {
                $scope.selectedIdentity = null;
            };
            $scope.selectItem = function (item) {
                console.log(item);
                $scope.phoneNumber.countryCode = item.value;
                $scope.phoneNumber.countryName = item.name;
                $scope.countryCodeChoosen = item;
                $(".dropdown").removeClass("open");
                if($scope.channelForm){
                    $timeout(function () {
                        $scope.channelForm.phoneOnly.$$parseAndValidate();
                    }, 100);
                }
                $('.add-bot').animate({scrollTop:0}, 'slow');
            };
            $timeout(function () {
                $('.add-bot').on('click', '.dropdown-menu', function (evt) {
                    evt.stopPropagation();
                    //$(".cisco-channel-page .inner-scroll").animate({ scrollTop: $(".cisco-channel-page .inner-scroll").height() }, 1000);
                });
            }, 500);

            $scope.choosePhoneIdentity = function (identity) {
                $scope.selectedIdentity = identity;
                $scope.selectedPhoneNumber = identity.val;
                if(identity.status !== 'verified'){
                    $scope.resendPhoneCode();
                }
                $scope.addPhoneNumber($scope.selectedIdentity);
            };
            $scope.addPhoneNumber = function (phoneNumber) {
                if (phoneNumber.countryCode) {
                    phoneNumber = phoneNumber.countryCode + phoneNumber.number;
                    phoneNumber = phoneNumber.replace(/-/g, '');
                } else {
                    phoneNumber = phoneNumber.val;
                }
                $scope.selectedPhoneNumber = phoneNumber;
                if ($scope.selectedIdentity && $scope.selectedIdentity === 'unverified') {
                    NotificationService.notify(i18n.i18nString('please_Verify_your_phone_number'), "warning");
                    switchVerifyPhoneForm();
                    return;
                } else if ($scope.selectedIdentity && $scope.selectedIdentity === 'verified') {
                    addBotToChannel('sms', phoneNumber);
                    return;
                }

                for (var i = 0; i < $scope.identities.phone.length; i++) {
                    var identity = $scope.identities.phone[i];
                    if (identity.val === phoneNumber && identity.status === 'unverified') {
                        NotificationService.notify(i18n.i18nString('please_Verify_your_phone_number'), "warning");
                        switchVerifyPhoneForm();
                        return;
                    } else if (identity.val === phoneNumber && identity.status === 'verified') {
                        addBotToChannel('sms', phoneNumber);
                        return;
                    }
                }
                // if User comes back by clicking change mobile number
                if ($scope.isFromChangePhoneNumber) {
                    // If user changes mobile number delete old identity in background.
                    if (phoneNumber !== $scope.oldPhoneNumber) {
                        deleteOldIdentity($scope.oldPhoneNumber,phoneNumber);
                    } else { // If user doesn't change mobile number, take him to verify-phone form.
                        switchVerifyPhoneForm();
                        return; // Don't add identity since it is already added in previously.
                    }
                    $scope.oldPhoneNumber = null;
                    $scope.isFromChangePhoneNumber = false;
                }
                // Otherwise add the identity
                var payload = {
                    phoneNo: phoneNumber
                };
                addNewIdentity(payload, "phone");
            };
            // Go back to previous form to change mobile number
            $scope.changeMobileNumber = function () {
                $scope.isFromChangePhoneNumber = true;
                $scope.oldPhoneNumber = $scope.selectedPhoneNumber;
                $scope.resend = false;
                $scope.resendPhone = false;
                $timeout(function () {
                    $('.phone-field').trigger('focus');
                }, 20);
            };
            $scope.resendPhoneCode = function () {
                if ($scope.codeSent === i18n.i18nString('code_sent_name')) {
                    return;
                }
                var payload = {
                    phoneNo: $scope.selectedPhoneNumber
                };
                var params = {};
                $scope.codeSent = i18n.i18nString('sending_code');
                BTStreamsService.resendIdentityVerification(curUserDetails.userId, payload, params)
                        .then(function (res) {
                            $scope.codeSent = i18n.i18nString('code_sent_name');
                            $timeout(function () {
                                $scope.codeSent = i18n.i18nString('code_sent');
                            }, 5000);
                        }, function (err) {
                            var errorMsg = i18n.i18nString('resend_Code_failed');
                            NotificationService.notify(errorMsg, "error");
                            $scope.codeSent = i18n.i18nString('code_sent');
                        });
            };
            function updatePhoneIdentityStatus(){
                for (var i = 0; i < $scope.identities.phone.length; i++) {
                    if ($scope.identities.phone[i].val === $scope.selectedPhoneNumber) {
                        $scope.identities.phone[i].status = 'verified';
                        return;
                    }
                }
            }
            $scope.phoneVerify = function () {
                var formattedPhone = parsePhoneNumber($scope.selectedPhoneNumber);
                // Set up the data to be sent.
                var data = {
                    phone: true,
                    countryCode: formattedPhone.countryCode.value,
                    emailPhone: formattedPhone.phoneNumber,
                    token: $scope.phone.phoneOTP,
                    redirectForm: 'bot-channels-form',
                    userId: curUserDetails.userId
                };

                // Send the data to security to login.
                var params = {
                    token: data.token
                };
                var payload = {};
                if (data.phone) {
                    payload.phoneNo = (data.countryCode + data.emailPhone).replace(/-/g, '');
                    params.phoneNo = encodeURIComponent(payload.phoneNo);
                }
                if (data.userId) {
                    params.userId = data.userId;
                }
                //verify OTP
                BTStreamsService.verifyOTP(data.token, payload, params)
                        .then(function (res) {
                            // todo fetch new associated Identities
                             NotificationService.notify(i18n.i18nString('otp_verified_success'), "success");
                             updatePhoneIdentityStatus();
                             $scope.phone.phoneOTP = "";
                            addBotToChannel('sms', $scope.selectedPhoneNumber);
                        }, function (err) {
                            var errorMsg = (err && err.data && err.data.errors && err.data.errors[0].msg) || i18n.i18nString('please_enter_correct_otp');
                            if(errorMsg && errorMsg === "TOKEN_NOT_FOUND"){
                                errorMsg = i18n.i18nString('please_enter_correct_otp');
                            }
                            NotificationService.notify(errorMsg, "error");
                        });
            };
            function deleteOldIdentity(oldPhoneNumber, newPhoneNumber) {
                var params = {
                    userId: curUserDetails.userId,
                    identity: encodeURIComponent(oldPhoneNumber)
                };

                BTStreamsService.deleteUserIdentity(curUserDetails.userId, encodeURIComponent(oldPhoneNumber), params)
                        .then(function (res) {
                            // todo fetch new associated Identities
                        }, function (err) {
                            var errorMsg = (err && err.data && err.data.errors && err.data.errors[0].msg) || "";
                            NotificationService.notify(errorMsg, "error");
                        });
            }
            function parsePhoneNumber(phoneValue) {
                var result = {
                    'countryCode': '',
                    'phoneNumber': ''
                };

                var tempPhoneValue = phoneValue;

                if (phoneValue.substring(0, 1) !== '+') {
                    tempPhoneValue = '+' + phoneValue;
                } else {
                    phoneValue = phoneValue.replace("+", '');
                }
                var regionCode = libphonenumber.getRegionCodeForNumber(tempPhoneValue, '');
                var cCode = libphonenumber.getCountryCodeForRegion(regionCode);
                result.countryCode = getCountryCodeByValue(cCode);
                result.phoneNumber = phoneValue.replace(cCode, '');

                return result;
            }
            function getCountryCodeByValue(value) {
                value = '+' + value;
                var countryCodesData = $scope._constants_.countryCodes;
                for (var code in countryCodesData) {
                    if (countryCodesData[code].value === value) {
                        return countryCodesData[code];
                    }
                }
            }
            function filterAdditionalIdentities(response){
                var associatedIdentities = response.data;
                $scope.identities = null;
                $scope.identities = {
                    email : [],
                    phone: []
                };
                // filtering email ids
                var emailIds = associatedIdentities.filter(function(id){
                    return id.type === 'email';
                });
                $scope.identities.email = emailIds;
                //filterting phone numbers
                var phoneIds = associatedIdentities.filter(function(id){
                    return id.type === 'phone';
                });
                $scope.identities.phone = phoneIds;
            }
            function getAdditionalIdenties() {
                BTStreamsService.getuserAdditionalIdentities($applicationService.userInfo().userId)
                .then(function (res) {
                    filterAdditionalIdentities(res);
                }, function (err) {
                    var errorMsg = (err && err.data && err.data.errors && err.data.errors[0].msg) || "";
                    NotificationService.notify(errorMsg, "error");
                });
            }
            function InitializeComponents(){
                $scope.selectItem($scope._constants_.countryCodes[0]);
                if($scope.emailChannel){
                    $timeout(function () {
                        $('.fullInputWidth.ng-valid-email').trigger('focus');
                    }, 20);
                }
                else{
                    $timeout(function () {
                        $('.phone-field').trigger('focus');
                    }, 20);
                }
            }
            InitializeComponents();
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToGoogleHomeCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.assetsBase = env_conf['assets-url'];
            
        }]);

})(angular);

;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToHangoutChatCtrl', ['$scope', '$modalInstance','env_conf',
        function ($scope, $modalInstance, env_conf) {
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.assetsBase = env_conf['assets-url'];
            
        }]);

})(angular);

;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToIVRCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.webhookURL = config.component.channelSource.url || env_conf['API_SERVER_URL']+"/chatbot/hooks/"+$scope.stream._id;
            $scope.webhookURLV2 = config.component.channelSource.url_v2 || env_conf['API_SERVER_URL']+"/chatbot/v2/webhook/"+stream._id;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToIVRVoiceCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);

;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToLineCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToLivePersonCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToMatterMostCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.intergrationType = $scope.stream.channels.filter(function(val){
                return val.type == 'mattermost';
            })[0].integrationType;
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToTwilioVoiceCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            var mobileArray = [];
            $.each($scope.source.numbers, function(i, numbers){
                                 var formatNumber = numbers.countryCode + numbers.number;
                                 mobileArray.push(formatNumber);
                            });
                           $scope.twilioVoiceNumbers = mobileArray.join(",") || "";
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToWebmobileCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToWhatsappCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf', '$timeout',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf, $timeout) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            var clipWebhook_url;
            $scope.source = config.component.channelSource;
            $scope.assetsBase   = env_conf['assets-url'];
            // $scope.manageSynonym = {};
            $scope.phoneNum = $scope.stream.channels.filter(function(val) {
                                return val.type === 'whatsapp';
                              })[0].from;
            $scope.closeModal = function () {
                $modalInstance.close();
            };

            $scope.whatsapp = {
                'link': 'https://wa.me/' + $scope.phoneNum
            };

            $timeout(function () {
                clipWebhook_url = new Clipboard('[data-clipboard-target="#whatsAppForm_link"]');
                $scope.isSafariwh = false;
                clipWebhook_url.on('success', function(e) {
                });
                clipWebhook_url.on('error', function(e) {
                    $scope.isSafariwh = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || safari.pushNotification);
                });
            });

        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToWidgetSdkCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToWorkplaceCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToYammerCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            $scope.source = config.component.channelSource;
            $scope.assetsBase      = env_conf['assets-url'];
            $scope.manageSynonym = {};
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTAddToUnbluCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','env_conf', '$timeout',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService, env_conf, $timeout) {
            $scope.stream = $workflowService.selectedStream();
            $scope.saveInProgress = false;
            var clipWebhook_url;
            $scope.source = config.component.channelSource;
            $scope.assetsBase   = env_conf['assets-url'];
            // $scope.manageSynonym = {};
            $scope.phoneNum = $scope.stream.channels.filter(function(val) {
                                return val.type === 'unblu';
                              })[0].from;
            $scope.closeModal = function () {
                $modalInstance.close();
            };

        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btAnalyzeDetails', [function () {

            return {
                restrict: 'EA',
                scope: {
                    cb: '=',
                    filterComponent: '=',
                    currentTab: '=',
                },
                templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-analyze-details/bt-analyze-details.html',
                controller: ['$scope', '$workflowService', 'BTStreamsService', '$timeout', 'env_conf', 'NotificationService', 'form_util', '$modal', '$applicationService','channelsConfig','i18n',
                    function ($scope, $workflowService, BTStreamsService, $timeout, env_conf, NotificationService, form_util, $modal, $applicationService,channelsConfig,i18n) {
                        $scope.assetsBase = env_conf['assets-url'];
                        $scope.closeCross= env_conf['context-url']+'/assets/landingImages/closeCross.png';
                        $scope.checkTickIcon = $scope.assetsBase+"headerIcons/checkTickIcon.svg";
                        $scope.checkTickIconDisabled = $scope.assetsBase+"headerIcons/checkTickIconDisabled.svg";
                        $scope.caretDown = env_conf['context-url']+'/assets/icons/caretDown.svg';
                        $scope.user_icon = env_conf['context-url']+'/assets/icons/user_icon.png';
                        $scope.list_icon = env_conf['context-url']+'/assets/icons/list_icon.png';
                        $scope.chat_message = env_conf['context-url']+'/assets/icons/chat_bubble.png';
                        $scope.stream = $workflowService.selectedStream();
                        $scope.utteranceStr = "";
                        $scope.originalInputAfterTranslation = "";
                        $scope.nluLanguage = "";
                        $scope.botLanguage = "";
                        $scope.languageCodes = {'en': "English", 'de': "German", 'es': "Spanish", 'fr': "French",'pt':"Portugese",'it':"Italian",'zh_cn':"Chinese Simiplified",'zh_tw':"Chinese Traditional",'id':"Indonesian",'ko':"Korean",'nl':"Dutch",'ja':"Japanese",'ar':"Arabic",
                        'fi':"Finnish",'ru':"Russian",'pl':"Polish",'uk':"Ukrainian",'sv': "Swedish",'kk' : "Kazakh",'ca':"Catalan"};
                        $scope.channelType = "";
                        $scope.intent = "";
                        $scope.entity = "";
                        $scope.showNlpEditPanel = false;
                        $scope.showUserProfile = false;
                        $scope.nlpData = {};
                        $scope.serviceJsonData = {};
                        $scope.jsonDataLoading = false;
                        $scope.currScreen = 0;
                        $scope.originalIntent = null;
                        $scope.tasksValue={};

                        $scope.success = i18n.i18nString('success');
                        $scope.failure = i18n.i18nString('failure');

   

                        $scope.appControls = $applicationService.userInfo().appControls;
                        $scope.performanceDetails = {
                            'all': {
                                'moreavailable': true,
                                'loading': false,
                                'fetchingMore': false,
                                'sortBy': 'desc'
                            },
                            'success': {
                                'moreavailable': true,
                                'loading': false,
                                'fetchingMore': false,
                                'sortBy': 'desc'
                            },
                            'failure': {
                                'moreavailable': true,
                                'loading': false,
                                'fetchingMore': false,
                                'sortBy': 'desc'
                            }
                        };
                        channelsConfig.getDynamicChannels($workflowService.selectedStream());
                        $scope.channelsConfig=  channelsConfig;
                        $scope.performanceCollection = [];
                        $scope.performanceSuccessCollection = [];
                        $scope.performanceFailureCollection = [];
                        $scope.tasks = [];
                        $scope.components = [];
                        $scope.users = [];
                        $scope.options = {
                            mode: 'code',
                            ace: window.ace,
                            theme: 'ace/theme/clouds_midnight'
                        };
                        if(typeof Array.prototype.find === 'undefined') {
                            Array.prototype.find = function (callback, thisArg) {
                                for (var i = 0; i < this.length; i++) {
                                    if (callback.call(thisArg || window, this[i], i, this)) {
                                        return this[i];
                                    }
                                }
                                return undefined;
                            };
                        }
                        $scope.getLanguage = function (code) {
                            if (!code) {
                                return "---";
                            }
                            code = code.toLowerCase();
                            if ($scope.languageCodes[code] && $scope.languageCodes[code] !== "") {
                                return $scope.languageCodes[code];
                            } else {
                                return "---";
                            }
                        };
                        function init(task,intentName,recordTags) {
                            $('[data-toggle="tooltip"]').tooltip();
                            $scope.nlpData = {};
                            $scope.nlpData = task.NLAnalysis;
                            if($scope.nlpData) {
                                $scope.nlpData.input = task.input || "";
                            }
                            else {
                                $scope.nlpData = {};
                                $scope.nlpData.input = task.input || "";
                            }
                            $scope.task = task;
                            $scope.utteranceStr = $scope.task.originalInputWithoutTranslation;
                            if($scope.nlpData &&  $scope.nlpData.nlProcessing && $scope.nlpData.nlProcessing.spellCorrectedInput){
                            $scope.originalInputAfterTranslation = $scope.task.input[0];
                            }
                            $scope.channelType = $scope.task.channel || "---";
                            $scope.nluLanguage =  $scope.getLanguage($scope.task.nluLanguage) ;
                            $scope.botLanguage =  $scope.getLanguage($scope.task.language) ;
                            $scope.intent = intentName !== '---'?intentName:($scope.task.task || "---");
                            $scope.entity = ($scope.nlpData && $scope.nlpData.finalResolver && $scope.nlpData.finalResolver.entities && $scope.nlpData.finalResolver.entities.length) ? $scope.nlpData.finalResolver.entities.join(', ') : '---';
                            $scope.flow = ($scope.originalIntent && $scope.originalIntent.flow && $scope.originalIntent.flow.join(' > ')) || (task.flow && task.flow.join(' > ')) || '---';
                            $scope.recordTags = recordTags;
                            $scope.jsonData = JSON.stringify($scope.task, null, "\t");
                            var jsonDomEle = document.getElementById('jsonInfo');
                            if (jsonDomEle) {
                                jsonDomEle.innerHTML = JSON.stringify($scope.task, undefined, 2);
                            }
                            $scope.showjson = "Show JSON";
                            jsonDivToggle();
                            updateNLPLines();
                        }

                        $scope.handleDropdownClose = function (e) {
                            if (e.currentTarget.className.indexOf('analyze-dropdown') !== -1 && e.target.parentElement.className.indexOf('filterIcon') !== -1) {
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                e.stopPropagation();
                            }
                        };

                        function jsonDivToggle() {
                            setTimeout(function () {
                                $('.showJson').click(function (e) {
                                    e.stopImmediatePropagation();
                                    e.stopPropagation();
                                    $('.eachSection.jsonData').slideToggle("slow","linear");
                                    if($scope.showjson === "Show JSON") {
                                        $scope.showjson = "Hide JSON";
                                    }
                                    else {
                                        $scope.showjson = "Show JSON";
                                    }
                                });
                            }, 500);
                        }
                        $scope.getComponentName = function (compId) {
                            if ($scope.components.length > 0) {
                                var entry = $scope.components.find(function (e) {
                                    return e._id === compId;
                                });
                                if (entry && entry._id) {
                                    return entry.name;
                                } else {
                                    return "---";
                                }
                            } else {
                                return "---";
                            }
                        };
                        function loadPerformanceData(offset, limit, fromScroll,showExcludeText) {
                            if ($scope.performanceDetails.all.loading) {
                                return;
                            }
                            $scope.performanceDetails.all.loading = true;
                            var payload = {'type': 'performance'};
                            var dateObj = getISOdates($scope.cb.filterComponent.days);
                            payload.filters = {'componentId': [$scope.performanceTask.componentId], 'from': dateObj.from,'to':dateObj.to};
                            if (!$scope.cb.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = false;
                            }
                             if ($scope.cb.filterComponent && $scope.cb.filterComponent.channels && $scope.cb.filterComponent.channels.length) {
                                   payload.filters.channel = $scope.cb.filterComponent.channels ;
                            }
                            var userValues = [];
                            if($scope.cb.filterComponent.users &&  $scope.cb.filterComponent.users.length){
                                    _.forEach($scope.cb.filterComponent.users, function(user){
                                            if(user.value && user.id){
                                                delete user.value;
                                                user = user.id;
                                            }else if(user.value && !user.id){
                                                user = user.value;
                                            }else if(!user.value && user.id){
                                                user = user.id;
                                            }
                                            userValues.push(user);
                                    });
                                    if(userValues && userValues.length){
                                        $scope.cb.filterComponent.users = userValues;
                                    }
                            }
                            if ($scope.cb.filterComponent.users.length > 0 && !showExcludeText) {
                                if($scope.cb.toggleCheck === "Channel ID"){
                                    payload.filters.channelUIds = $scope.cb.filterComponent.users;
                                }else{
                                    payload.filters.userId = $scope.cb.filterComponent.users;
                                }
                            }else if($scope.cb.filterComponent.users.length > 0 && showExcludeText) {
                                if($scope.cb.toggleCheck === "Channel ID"){
                                    payload.filters.excludeChannelUIds = $scope.cb.filterComponent.users;
                                }else{
                                    payload.filters.excludeUserIds = $scope.cb.filterComponent.users;
                                }
                            }
                            if ($scope.cb.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.cb.filterComponent.languages;
                            }
                            if ($scope.cb.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.cb.filterComponent.tasks;
                            }
                            payload.sort = {'order': $scope.performanceDetails.all.sortBy, 'by': 'timestamp'};
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload).then(function (res) {
                                if (res.data) {
                                    $scope.tasksValue = res.data;
                                    $scope.performanceDetails.all.moreavailable = res.data.moreavailable;
                                    if (fromScroll) {
                                        $scope.performanceCollection = $scope.performanceCollection.concat(res.data.result);
                                    } else {
                                        $scope.performanceCollection = res.data.result;
                                    }
                                    $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                                    $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                                    $scope.components = _.uniq($scope.components.concat(res.data.components ? res.data.components : []));
                                    handleGroupedTasks();
                                }
                                $scope.performanceDetails.all.loading = false;
                            }, function (error) {
                                $scope.performanceDetails.all.loading = false;
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                                }
                            });
                        }
                        function loadSuccessPerformanceData(offset, limit, fromScroll,showExcludeText) {
                            if ($scope.performanceDetails.success.loading) {
                                return;
                            }
                            $scope.performanceDetails.success.loading = true;
                            var payload = {'type': 'performance'};
                            var dateObj = getISOdates($scope.cb.filterComponent.days);
                            payload.filters = {'componentId': [$scope.performanceTask.componentId],'wasSuccessfull': true, 'from': dateObj.from,'to':dateObj.to};
                            if (!$scope.cb.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = false;
                            }
                             if ($scope.cb.filterComponent && $scope.cb.filterComponent.channels && $scope.cb.filterComponent.channels.length) {
                                   payload.filters.channel = $scope.cb.filterComponent.channels ;
                            }
                            if ($scope.cb.filterComponent.users.length > 0 && !showExcludeText) {
                                if($scope.cb.toggleCheck === "Channel ID"){
                                    payload.filters.channelUIds = $scope.cb.filterComponent.users;
                                }else{
                                    payload.filters.userId = $scope.cb.filterComponent.users;
                                }
                            }else if($scope.cb.filterComponent.users.length > 0 && showExcludeText) {
                                if($scope.cb.toggleCheck === "Channel ID"){
                                    payload.filters.excludeChannelUIds = $scope.cb.filterComponent.users;
                                }else{
                                    payload.filters.excludeUserIds = $scope.cb.filterComponent.users;
                                }
                            }
                            if ($scope.cb.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.cb.filterComponent.languages;
                            }
                            if ($scope.cb.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.cb.filterComponent.tasks;
                            }
                            payload.sort = {'order': $scope.performanceDetails.success.sortBy, 'by': 'timestamp'};
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload).then(function (res) {
                                if (res.data) {
                                    $scope.performanceDetails.success.moreavailable = res.data.moreavailable;
                                    if (fromScroll) {
                                        $scope.performanceSuccessCollection = $scope.performanceSuccessCollection.concat(res.data.result);
                                    } else {
                                        $scope.performanceSuccessCollection = res.data.result;
                                    }
                                    $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                                    $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                                    $scope.components = _.uniq($scope.components.concat(res.data.components ? res.data.components : []));
                                    handleGroupedTasks();
                                }
                                $scope.performanceDetails.success.loading = false;
                            }, function (error) {
                                $scope.performanceDetails.success.loading = false;
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                                }
                            });
                        }
                        function loadFailurePerformanceData(offset, limit, fromScroll,showExcludeText) {
                            if ($scope.performanceDetails.failure.loading) {
                                return;
                            }
                            $scope.performanceDetails.failure.loading = true;
                            var payload = {'type': 'performance'};
                            var dateObj = getISOdates($scope.cb.filterComponent.days);
                            payload.filters = {'componentId': [$scope.performanceTask.componentId], 'wasSuccessfull': false, 'from': dateObj.from,'to':dateObj.to};
                            if (!$scope.cb.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = false;
                            }
                             if ($scope.cb.filterComponent && $scope.cb.filterComponent.channels && $scope.cb.filterComponent.channels.length) {
                                   payload.filters.channel = $scope.cb.filterComponent.channels ;
                            }
                            if ($scope.cb.filterComponent.users.length > 0 && !showExcludeText) {
                                if($scope.cb.toggleCheck === "Channel ID"){
                                    payload.filters.channelUIds = $scope.cb.filterComponent.users;
                                }else{
                                    payload.filters.userId = $scope.cb.filterComponent.users;
                                }
                            }else if($scope.cb.filterComponent.users.length > 0 && showExcludeText) {
                                if($scope.cb.toggleCheck === "Channel ID"){
                                    payload.filters.excludeChannelUIds = $scope.cb.filterComponent.users;
                                }else{
                                    payload.filters.excludeUserIds = $scope.cb.filterComponent.users;
                                }
                            }
                            if ($scope.cb.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.cb.filterComponent.languages;
                            }
                            if ($scope.cb.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.cb.filterComponent.tasks;
                            }
                            payload.sort = {'order': $scope.performanceDetails.failure.sortBy, 'by': 'timestamp'};
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload).then(function (res) {
                                if (res.data) {
                                    $scope.performanceDetails.failure.moreavailable = res.data.moreavailable;
                                    if (fromScroll) {
                                        $scope.performanceFailureCollection = $scope.performanceFailureCollection.concat(res.data.result);
                                    } else {
                                        $scope.performanceFailureCollection = res.data.result ? res.data.result : [];
                                    }
                                    $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                                    $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                                    $scope.components = _.uniq($scope.components.concat(res.data.components ? res.data.components : []));
                                    handleGroupedTasks();
                                }
                                $scope.performanceDetails.failure.loading = false;
                            }, function (error) {
                                $scope.performanceDetails.failure.loading = false;
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                                }
                            });
                        }
                        $scope.updateScroll = function (type, currScreen) {
                            $scope.currScreen = currScreen;
                            $scope.closeChatHistoryJsonModal();
                            if (type === 'chatHistory' && $scope.trainBotCB.winningIntentMsgId) {
                                $scope.trainBotCB.scrollCompleted = false;
                                 setTimeout(function () {
                                    setTimeout(function () {
                                        $scope.trainBotCB.scrollCompleted = true;
                                    }, 350);
                                    var container = $('.analyzeEditTask .tab-content .chatHistoryScroll'); 
                                    var scrollTo = $('#' + $scope.originalIntent.messageId); 
                              
                                    // Calculating new position of scrollbar 
                                    var position = scrollTo.offset().top - container.offset().top + container.scrollTop(); 
                              
                                    // Setting the value of scrollbar 
                                    container.scrollTop(position); 
                                }, 250);
                            } else if (type === 'chatHistory' && !$scope.trainBotCB.winningIntentMsgId) {
                                $scope.trainBotCB.scrollCompleted = true;
                            } else {
                                setTimeout(function () {
                                    $('.analyzeEditTask .tab-content').animate({
                                        scrollTop: 2
                                    }, 'slow');
                                }, 150);
                            }
                            updateNLPLines();
                            if(type === 'nlp') {
                                $scope.trainBotCB.reloadLines();
                            }
                           if(type === 'nlp' || type === 'details'){
                                $scope.showUserProfile = false;
                            }
                        };
                        function updateNLPLines() {
                            setTimeout(function () {
                                var analyzeLeftLineHeight = ($('.analyzeTab .eachModel.mlm').height() + 22) + ($('.analyzeTab .eachModel.fmm').height() + 22) + 32;
                                $('head').append('<style>.analyzeTab .intentTitle:before{height:' + analyzeLeftLineHeight + 'px !important;}</style>');
                            }, 500);
                        }
                        $scope.closeChatHistoryJsonModal = function () {
                            $('.jsonResponseContainer').hide();
                        };
                        $scope.getJsonData = function (task, event) {
                            $scope.jsonDataLoading = true;
                            $scope.serviceJsonData = {};
                            BTStreamsService.getAnalysisPerformanceRecordDetails($scope.stream._id, task.requestTransitionRecordId, task.responseTransitionRecordId).then(function (res) {
                                if (res.data) {
                                    if (res.data) {
                                        $scope.serviceJsonData = res.data;
                                        $('#jsonServiceInfo').html('{}');
                                        setTimeout(function () {
                                            $(event.currentTarget.nextElementSibling).find('#jsonServiceInfo').html(JSON.stringify($scope.serviceJsonData, undefined, 2));
                                        }, 500);
                                    }
                                }
                                $scope.jsonDataLoading = false;
                            }, function (error) {
                                $scope.jsonDataLoading = false;
                                NotificationService.notify('Data is not available for this record.', 'error');
                                /*if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify('Unexpected error occured. Please try again.', 'error');
                                }*/
                            });
                        };
                        $scope.scrollUpdate= function(){
                            setTimeout(function(){
                                $("#allContainer").scrollTop(2);
                                $("#successContainer").scrollTop(2);
                                $("#failureContainer").scrollTop(2);
                            },300);
                        };
                        $scope.cb.reloadTask = function (task, type, originalIntent, intentName,recordTags,taskValue,showExcludeText) {
                            $scope.type = type;
                            $scope.originalIntent = originalIntent;
                            if (type === 'performance') {
                                $scope.performanceTask = task;
                                loadPerformanceData(0, 30, false,showExcludeText);
                                loadSuccessPerformanceData(0, 30, false,showExcludeText);
                                loadFailurePerformanceData(0, 30, false,showExcludeText);
                                $scope.scrollUpdate();
                            } else {
                                init(task,intentName,recordTags);
                                $scope.trainBotCB.loadData($scope.nlpData);
                                $scope.trainBotCB.loadChatNLPData(task, $scope.nlpData, originalIntent, $scope.trainBotCB.winningIntentMsgId,taskValue);
                            }
                            sensitiveInfoHandling();
                        };
                        $scope.updatePage = function (type, order) {
                            if (type === "all") {
                                $scope.performanceDetails.all.sortBy = order;
                                loadPerformanceData(0, 30, false);
                            } else if (type === "failure") {
                                $scope.performanceDetails.failure.sortBy = order;
                                loadFailurePerformanceData(0, 30, false);
                            } else if (type === "success") {
                                $scope.performanceDetails.success.sortBy = order;
                                loadSuccessPerformanceData(0, 30, false);
                            }
                        };

                        //dynamic pagination
                        var allContainer = $("#allContainer");
                        allContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.performanceDetails.all.moreavailable) {
                                    loadPerformanceData($scope.performanceCollection.length, 30, true);
                                }
                            }
                        });

                        var successContainer = $("#successContainer");
                        successContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.performanceDetails.success.moreavailable) {
                                    loadSuccessPerformanceData($scope.performanceSuccessCollection.length, 30, true);
                                }
                            }
                        });
                        var failureContainer = $("#failureContainer");
                        failureContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.performanceDetails.failure.moreavailable) {
                                    loadFailurePerformanceData($scope.performanceFailureCollection.length, 30, true);
                                }
                            }
                        });

                        //dynamic pagination ends

                        $scope.closeModal = function () {
                            $scope.trainBotCB.closeEditPanel();
                            $(".analyzeEditTask").modal("hide");
                            $scope.showUserProfile = false;
                            $scope.closeChatHistoryJsonModal();
                            $scope.currScreen = 0;
                            if($(".userProfileMainComponent").length && $(".userProfileMainComponent .img-icons").length){
                                $(".userProfileMainComponent .img-icons").removeClass("active");
                            }
                        };
                        $scope.getDate = function (timestamp) {
                            return moment(timestamp).format('MM-DD-YYYY');
                        };
                        $scope.getTime = function (timestamp) {
                            return moment(timestamp).format('h:mm A');
                        };
                        $scope.getEmail = function (userId) {
                            if ($scope.users.length > 0) {
                                var entry = $scope.users.find(function (e) {
                                    return e._id === userId;
                                });
                                if (entry && entry.emailId) {
                                    return entry.emailId;
                                } else {
                                    return userId;
                                }
                            }
                            return userId;
                        };
                        $scope.trainBotCB = {};
                        $scope.trainBotCB.showTitle = 'false';
                        $scope.trainBotCB.openEditPanel = function (type,expandIndex) {
                            $scope.showNlpEditPanel = true;
                            $scope.trainBotCB.loading = true;
                            $scope.nlpEditData = $scope.nlpData.type;
                            $timeout(function(){
                                $scope.trainBotCB.initEditPanel($scope.nlpData,type,expandIndex);
                            },600);
                        };
                        $scope.trainBotCB.closeEditPanel = function () {
                            $scope.showNlpEditPanel = false;
                            $('.model').removeClass('active');
                        };
                          $scope.UserProfileCB={};
                        $scope.openUserProfile=function(type,$event){
                                if (type === 'utterance' && $scope.trainBotCB.winningIntentMsgId) {
                                    $scope.showUserProfile = false;
                                    $scope.trainBotCB.scrollCompleted = false;
                                    setTimeout(function () {
                                        setTimeout(function () {
                                            $scope.trainBotCB.scrollCompleted = true;
                                        }, 350);
                                        var container = $('.analyzeEditTask .tab-content .chatHistoryScroll'); 
                                        var scrollTo = $('#' + $scope.originalIntent.messageId); 
                                  
                                        // Calculating new position of scrollbar 
                                        var position = scrollTo.offset().top - container.offset().top + container.scrollTop(); 
                                  
                                        // Setting the value of scrollbar 
                                        container.scrollTop(position); 
                                    }, 250);
                                } 
                            if($(".userProfileMainComponent .img-icons").hasClass("active")){
                                $(".userProfileMainComponent .img-icons").removeClass("active");
                            } 
                            $(event.target).parent().addClass("active");
                            if(type === 'profile' || type ==='conversation'){
                                $scope.showUserProfile = true;
                                $scope.UserProfileCB.loading=true;
                            $timeout(function(){
                                $scope.userId = $scope.task.userId;
                                var dateObj={};
                                $scope.filterValues=angular.copy($scope.filterComponent);
                                dateObj.from = $scope.filterValues.startDate;

                                dateObj.to = $scope.filterValues.endDate;
                                dateObj.days =$scope.filterValues.days;
                                var timeStampValue= $scope.originalIntent.timestampValue;
                                   $scope.UserProfileCB.panelType = type;
                                    $scope.UserProfileCB.initPanel(type,dateObj,timeStampValue,$scope.userId);
                                },0);
                            }
                        };
                        $scope.UserProfileCB.closeProfilePanel=function(){
                            $scope.showUserProfile = false;
                            $('.model').removeClass('active');
                            if($(".userProfileMainComponent").length && $(".userProfileMainComponent .img-icons").length){
                                $(".userProfileMainComponent .img-icons").removeClass("active");
                            }
                        };

                        $scope.UserProfileCB.initPanel=function(){
                            console.log("Intializing Panel");
                        };







                        $scope.isEmpty = function (obj) {
                            for (var prop in obj) {
                                if (obj.hasOwnProperty(prop)) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        function handleGroupedTasks() {
                            setTimeout(function () {
                                $('.eachTableRow').click(function (e) {
                                    e.stopImmediatePropagation();
                                    e.stopPropagation();
                                    if ($(this).hasClass('active')) {
                                        $(this).toggleClass('active');
                                        $(this).siblings('.serviceJsonBody').slideToggle("slow","linear");
                                    } else {
                                        $('.eachTableRow.active').siblings('.serviceJsonBody').slideToggle("slow","linear");
                                        $('.eachTableRow.active').toggleClass('active');
                                        $(this).toggleClass('active');
                                        $(this).siblings('.serviceJsonBody').slideToggle("slow","linear");
                                    }
                                });
                            }, 2000);
                        }
                        $scope.prepareCopyClipboard = function (type, e) {
                            e.preventDefault();
                            e.stopPropagation();

                            $scope.success = true;
                            var range = document.createRange(),
                                    selection,
                                    input = JSON.stringify($scope.task);
                                    if(type === 'performance') {
                                        input = JSON.stringify($scope.serviceJsonData);
                                    }
                            // For IE.
                            if (window.clipboardData) {
                                $scope.success = window.clipboardData.setData("Text", input);
                            } else {
                                // Create a temporary element off screen.
                                $scope.tmpElem = $('<div>');
                                $scope.tmpElem.css({
                                    position: "absolute",
                                    left: "-1000px",
                                    top: "-1000px",
                                });
                                // Add the input value to the temp element.
                                $scope.tmpElem.text(input);
                                $("body").append($scope.tmpElem);
                                // Select temp element.
                                range.selectNodeContents($scope.tmpElem.get(0));
                                selection = window.getSelection();
                                selection.removeAllRanges();
                                selection.addRange(range);
                                // Lets copy.

                            }


                        };
                        $scope.copyDebugToClipboard = function (type, e) {
                            e.preventDefault();
                            e.stopPropagation();
                            function copyToClipboardFF(text) {
                                window.prompt("Copy to clipboard: Ctrl C, Enter", text);
                            }
                            if (!window.clipboardData) {
                                try {
                                    $scope.success = document.execCommand("copy", false, null);
                                } catch (e) {
                                    var input = JSON.stringify($scope.task);
                                    if(type === 'performance') {
                                        input = JSON.stringify($scope.serviceJsonData);
                                    }
                                    copyToClipboardFF(input);
                                } finally {
                                    // remove temp element.
                                    $scope.tmpElem.remove();
                                }
                            }

                            if ($scope.success) {
                                NotificationService.notify(i18n.i18nString('json_copied_success'), 'success');
                            }

                        };
                        $scope.getStatusCode = function(code){
                            if(code === 200){
                                return "200(OK)";
                            }else if(code === 202){
                                return "202(Accepted)";
                            }else if(code === 405){
                                return "405(Method Not Allowed)";
                            }else if(code === 404){
                                return "404(Not Found)";
                            }else{
                                return code;
                            }
                        };

                        $scope.updateUserName = function(type){
                            if(type === "koreID"){
                                $scope.cb.toShowKoreID = true;
                            }else{
                                $scope.cb.toShowKoreID = false;
                            }
                        };

                        function getISOdates(days) {
                            var dateObj = {};
                            if(days === -1){
                                if($scope.filterComponent.startDate.toISOString){
                                    dateObj.from = $scope.filterComponent.startDate.toISOString();
                                }else{
                                dateObj.from = $scope.filterComponent.startDate;
                                }
                                if($scope.filterComponent.endDate.toISOString){
                                    dateObj.to = $scope.filterComponent.endDate.toISOString();
                                }else{
                                dateObj.to = $scope.filterComponent.endDate;
                                }
                            }else{
                                dateObj.from = moment().subtract(days, 'd').toISOString();
                                dateObj.to = moment().toISOString();
                            }
                            
                            return dateObj;
                        }

                        function sensitiveInfoHandling(){
                            var filteredAccountId = _.filter($scope.appControls.associatedAccounts,function(data){
                                if(data.accountId === $scope.stream.accountId){
                                    $scope.hideSensitiveInfo = data.enableDebugInfo;
                                }
                            });
                        }
                    }],
                link: function ($scope, $ele, $attrs) {

                }
            };
        }]);

        _module.filter('channelNameDisp', function(){
            return function(input) {
                if(input === 'googleactions') {
                    return 'Google Assistant';
                }
                else if(input === 'hangoutchat') {
                    return 'Hangouts Chat';
                }
                else {
                    return input;
                }
            };
        });

}(angular));


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.directive('btAnalyzeFilter', [function () {

        return {
            restrict: 'EA',
            scope: {
                stream: '=?',
                allTasksData: '=',
                filterComponent: '=',
                components: '=',
                currentTab: '=',
                cb: '=',
                selectedTagsArray: '=',
                moreFilterValues:'='
            },
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-analyze-filter/bt-analyze-filter.html',
            controller: ['$scope', '$workflowService', '$location', '$filter', '_constants_', 'BTStreamsService', '$timeout', '$routeParams', 'env_conf', 'NotificationService', 'uuid4', '$translator', 'form_util', '$modal', '$q', 'AppsDataService', '$applicationService', 'i18n',
                function ($scope, $workflowService, $location, $filter, _constants_, BTStreamsService, $timeout, $routeParams, env_conf, NotificationService, uuid4, $translator, form_util, $modal, $q, AppsDataService, $applicationService, i18n) {
                    $scope.assetsBase = env_conf['assets-url'];
                    $scope.stream = $workflowService.selectedStream();
                    $scope.seedSupportedLanguages = $workflowService.seedData().supportedLanguages;
                    $scope.utterance = {};
                    $scope.utterance.type = "both";
                    $scope.ambiguous = {};
                    $scope.ambiguous.type = "showAll";
                    var _usrInfo = $applicationService.userInfo().koreUserInfo;
                    $scope.selectedLanguages = [];
                    $scope.selectedSession = [];
                    $scope.selectedUsers = [];
                    $scope.selectedChannels = [];
                    $scope.selectedTasks = [];
                    $scope.selectedComponents = [];
                    $scope.customTags = "";
                    $scope.startDate = "";
                    $scope.endDate = "";
                    $scope.days = 7;
                    var daterangepickerInput;
                    $scope.users = [];
                    $scope.channels = [];
                    $scope.supportedLanguages = [];
                    $scope.tasks = [];
                    $scope.scriptComponents = [];
                    $scope.isDeveloper = true;
                    // $scope.sessionType = [{type:"Interactive"},
                    // {type:"Non-interactive"},{type:"Developer Interactions"}];
                    $scope.checkTickIcon = $scope.assetsBase + "headerIcons/checkTickIcon.svg";
                    $scope.caretDown = $scope.assetsBase + "headerIcons/caretDown.svg";
                    $scope.trashIcon = $scope.assetsBase + "icons/trashIcon.svg";
                    $scope.minusIcon = $scope.assetsBase + "icons/minus-icon.svg";
                    $scope.disabledMinusIcon = $scope.assetsBase + "images/left-menu-img/disabledMinus.svg";
                    $scope.andIcon = $scope.assetsBase + "icons/andIcon.svg";
                    $scope.closeCross = env_conf['context-url'] + '/assets/icons/closeCross.png';
                    $scope.searchIconGray = env_conf['context-url'] + '/assets/icons/searchIconGray.svg';
                    $scope.helpIcon = env_conf['context-url'] + '/assets/icons/helpIcon.svg';
                    $scope.selectedTag = "";
                    $scope.customTagsArray = [];
                    $scope.selectedUsersCopy = [];
                    $scope.selectedDefaultFilterObject = {};
                    $scope.selectedTagsArray.push({ name: "", values: [], type: "",isContains:{ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true} });
                    $scope.search = {};
                    $scope.search.nameSearchQuery = "";
                    $scope.togglePattern = false;
                    $scope.cb.toggleCheck = 'Channel ID';
                    $scope.cb.channelNames = [];
                    $scope.sessionTypeList = [{name: i18n.i18nString('all'), value: 'all'}, {name: i18n.i18nString('interactive'), value: 'interactive'}, {name: i18n.i18nString('non_interactive_label'), value: 'noninteractive'}];
                    $scope.sessionType = {name: i18n.i18nString('all'), value: 'all'};
                    $scope.sessionStatusList = [ {name: i18n.i18nString('active_label'), value: 'active'}, {name: i18n.i18nString('closed'), value: 'closed'}];
                    $scope.sessionStatus = {name: i18n.i18nString('closed'), value: 'closed'};
                    $scope.dateDisplayName = i18n.i18nString('24_hours');
                    var continueWithUserId;
                    var cancelWithUserId;
                    $scope.includeExcludeArray = [{
                         "id":"include",
                         "label":i18n.i18nString('include')
                    },{
                        "id":"exclude",
                        "label":i18n.i18nString('exclude')
                    }
                ];
                    $scope.includeExcludeValue = {
                        "id":"include",
                        "label":i18n.i18nString('include')
                    };
                    $scope.selectedContainArray = [
                        {
                            "id":"contain",
                            "label":i18n.i18nString('contain'),
                            "isInclude":true
                        },
                        {
                            "id":"doesNotContain",
                            "label":i18n.i18nString('does_not_contain'),
                            "isInclude":false
                        }
                    ];
                    $scope.showExcludeText= false;
                    $scope.excludeCustomTagValue = false;
                    $scope.tooltipForKoreIds =i18n.i18nString('search_kore_platform');
                    $scope.select = i18n.i18nString('select');
                    $scope.kore = {
                        searchUserId:"",
                        searchUserName:""
                    };
                    $scope.toShowText = false;
                    $scope.resetUserId = function(){
                        $scope.includeExcludeValue = {
                            "id":"include",
                            "label":i18n.i18nString('include')
                        };
                        $scope.showExcludeText= false;
                        $scope.selectedUsers = [];
                        $("#showSwitchToggle").modal("hide");
                    };
                    continueWithUserId = function(){
                        $scope.continueWithUserId();
                    };
                    cancelWithUserId = function(){
                        $scope.cancelWithUserId();
                    };
                    $scope.yesContinueWithUserId = function(){
                        $("#showSwitchToggle").modal("hide");
                    };
                    $scope.continueWithUserId = function(){
                        if($scope.selectedUsers && $scope.selectedUsers.length && $scope.togglePattern){
                        $scope.selectedUsers = [];
                        $scope.cb.toggleCheck = 'Kore ID';
                        }else if($scope.selectedUsers && $scope.selectedUsers.length && !$scope.togglePattern) {
                        $scope.selectedUsers = [];
                        $scope.cb.toggleCheck = 'Channel ID';
                        }
                        $("#showSwitchToggle").modal("hide");
                    };
                    $scope.cancelWithUserId = function(){
                        if($scope.togglePattern){
                            $scope.togglePattern = false;
                            $scope.cb.toggleCheck = 'Channel ID';
                        }else if(!$scope.togglePattern){
                            $scope.togglePattern = true;
                            $scope.cb.toggleCheck = 'Kore ID';
                        }
                        $("#showSwitchToggle").modal("hide");
                    };
                    $scope.filterToggle = function () {
                        $scope.filterComponent.contacts = [];
                        $scope.filterComponent.specficChannelUId = [];
                        $scope.selectedUsersIds = [];
                        if($scope.selectedUsers && $scope.selectedUsers.length && $scope.togglePattern){
                            // $scope.togglePattern = false;
                                $scope.cb.toggleCheck = 'Kore ID';
                            NotificationService.alert("Changing the toggle to Kore User Id will clear the current user selection",
                               
                            [continueWithUserId , cancelWithUserId], {okText: i18n.i18nString('ok')});
                        } else if($scope.selectedUsers && $scope.selectedUsers.length && !$scope.togglePattern) {
                            //  $scope.togglePattern = true;
                            $scope.cb.toggleCheck = 'Channel ID';
                             NotificationService.alert("Changing the toggle to Channel User Id will clear the current user selection", [continueWithUserId , cancelWithUserId],{okText: i18n.i18nString('ok')});
                        } else if ($scope.togglePattern) {
                            // $scope.togglePattern = false;
                            $scope.cb.toggleCheck = 'Kore ID';
                        } else {
                            // $scope.togglePattern = true;
                            $scope.cb.toggleCheck = 'Channel ID';
                        }
                    };
                    function init() {
                        $scope.sumocb = { 'languagescb': { 'changeText': true }, 'userscb': { 'changeText': true }, 'channelscb': { 'changeText': true }, 'taskscb': { 'changeText': true }, 'componentscb': { 'changeText': true }, 'sessionscb': { 'changeText': true } };
                        $scope.channels = [];
                        $scope.supportedLanguages = [];
                        $scope.tasks = [];
                        $scope.scriptComponents = [];
                        $scope.getDefaultFilter(1);
                        /* loading channels */
                        if($scope.stream && $scope.stream.channels){
                        $scope.stream.channels.forEach(function (value, key) {
                            if (value.type.startsWith('ivr') && value.type !== 'ivrVoice') {
                                $scope.channels.push({ 'value': value.displayName + '(Webhook)', 'type': value.type });
                            } else {
                                if("audiocodes" === (value.name ? value.name : value.type)) { 
                                    $scope.channels.push({ 'value': 'IVR - AudioCodes', 'type': value.type });
                                } else {
                                    $scope.channels.push({ 'value': value.name ? value.name : value.type, 'type': value.type });
                                }
                            }
                        });
                    }
                        $scope.cb.channelNames =  $scope.channels;

                        /* loading bot supported languages */
                        $scope.stream.supportedLanguages.forEach(function (value, key) {
                            $scope.supportedLanguages.push({ 'value': getLanguageName(value), 'type': value });
                        });
                    //     $scope.sessionType = [{type:"Interactive"},
                    // {type:"Non-interactive"},{type:"Developer Interactions"}];

                        /* loading bot users  */
                        //$scope.users.push({'value': _usrInfo.emailId, 'id': _usrInfo.id});

                        /* loading bot tasks */
                        $scope.prepareTaskData();
                        /* loading script/service components */
                        if ($scope.components) {
                            $scope.components.forEach(function (value, key) {
                                $scope.scriptComponents.push({ 'value': value.name, 'id': value._id });
                            });
                        }
                        $scope.cb.editFilter();
                    }
                    $scope.excludeUserIds= function(includeExlude){
                        if($scope.selectedUsers && $scope.selectedUsers.length){
                            $("#showSwitchToggle").modal("show");
                        }
                        $scope.includeExcludeValue = includeExlude;
                        if($scope.includeExcludeValue && $scope.includeExcludeValue.id== 'exclude'){
                        $scope.showExcludeText= true;
                        }else{
                            $scope.showExcludeText= false;
                        }
                    };
                    $scope.excludeCustomTags = function(selectedContain,selectedTag){

                            selectedTag.isContains = selectedContain;

                      if(selectedTag && selectedTag.isContains && selectedTag.isContains.id=="doesNotContain"){
                        $scope.excludeCustomTagValue = true;
                      }else{
                        $scope.excludeCustomTagValue = false;
                      }
                    };
                    $scope.saveAsDefaultFilter = function(){
                        var payload = {};
                        var dateObj = getISOdates($scope.days);
                        if($scope.utterance.type === "notTrained"){
                            $scope.utterance.type = "notTrained" ;
                        }
                        payload = {
                        'from': dateObj.from,
                         'to': dateObj.to,
                         'taskNames':$scope.selectedTasks,
                         'channels':$scope.selectedChannels,
                         'tags':prepareTagsPayload($scope.filterComponent),
                         'language':$scope.selectedLanguages,
                         'utterenceType': $scope.utterance.type, 
                         'isDeveloper': $scope.isDeveloper, 
                         'ambiguous': $scope.ambiguous.type, 
                         "filterAt": "NLPMetrics",
                        };
                        if($scope.sessionType && $scope.sessionType.value && $scope.sessionType.value === "all") {
                            payload.sessionCategory = [0,1];
                        }else if($scope.sessionType && $scope.sessionType.value && $scope.sessionType.value === "interactive"){
                            payload.sessionCategory = [1];
                        }else if($scope.sessionType && $scope.sessionType.value && $scope.sessionType.value === "noninteractive"){
                            payload.sessionCategory = [0];
                        }
                        if($scope.sessionStatus && $scope.sessionStatus.value) {
                            payload.sessionStatus = $scope.sessionStatus.value;
                        }
                        if(!payload.channelUIds){
                        payload.channelUIds = [];
                        }
                        if(!payload.koreUIds){
                            payload.koreUIds = [];
                            }
                            if(!payload.excludeChannelUIds){
                                payload.excludeChannelUIds = [];
                                }
                                if(!payload.excludeUserIds){
                                    payload.excludeUserIds = [];
                                    }
                                    $scope.filterComponent.users = [];
                        if ($scope.selectedUsers && $scope.selectedUsers.length && $scope.selectedUsers.length > 0 && !$scope.showExcludeText) {
                            if($scope.cb.toggleCheck === "Channel ID"){
                                _.forEach($scope.selectedUsers,function(selectedUser){
                                    $scope.filterComponent.users.push(selectedUser);
                                });
                                _.forEach($scope.filterComponent.users,function(selectedUser){
                                    if(selectedUser.id){
                                    payload.channelUIds.push(selectedUser.id);
                                    }
                                });
                            }else{
                                _.forEach($scope.selectedUsers,function(selectedUser){
                                    $scope.filterComponent.users.push(selectedUser);
                                });
                                _.forEach($scope.filterComponent.users,function(selectedUser){
                                    if(selectedUser.id){
                                        payload.koreUIds.push(selectedUser.id);
                                    }
                                });
                            }
                        }
                        else if($scope.selectedUsers && $scope.selectedUsers.length && $scope.selectedUsers.length > 0 && $scope.showExcludeText){
                            if($scope.cb.toggleCheck === "Channel ID"){
                                _.forEach($scope.selectedUsers,function(selectedUser){
                                    $scope.filterComponent.users.push(selectedUser);
                                });
                                _.forEach($scope.filterComponent.users,function(selectedUser){
                                    if(selectedUser.id){
                                        payload.excludeChannelUIds.push(selectedUser.id);
                                    }
                                });
                            }else{
                                _.forEach($scope.selectedUsers,function(selectedUser){
                                    $scope.filterComponent.users.push(selectedUser);
                                });
                                _.forEach($scope.filterComponent.users,function(selectedUser){
                                    if(selectedUser.id){
                                        payload.excludeUserIds.push(selectedUser.id);
                                    }
                                });
                            }
                        }
                        $scope.selectedPayloadTags = prepareTagsPayload($scope.filterComponent);
                            if($scope.selectedPayloadTags.and && $scope.selectedPayloadTags.and.length > 0){
                                $scope.selectedPayloadTags.and.forEach(function(payloadTag){
                                    $scope.selectedTagsArray.forEach(function(value, key){
                                        if(value.name == payloadTag.name){
                                            payloadTag.isInclude = value.isContains.isInclude;
                                        }
                                    });
                                    if(!payloadTag.name.length){
                                        var index = $scope.selectedPayloadTags.and.indexOf(payloadTag);
                                        $scope.selectedPayloadTags.and.splice(index, 1);
                                    }
                                });
                            }
                        payload.tags = $scope.selectedPayloadTags.and;
                        if($scope.showExcludeText){
                            $scope.cb.showExcludeText = true;
                          }else{
                              $scope.cb.showExcludeText = false;
                          }if( $scope.selectedComponents.length && $scope.currentTab === "performance" && $scope.scriptComponents.length !== $scope.selectedComponents.length){
                              payload.componentId = $scope.selectedComponents;
                          }else if ($scope.scriptComponents.length === $scope.selectedComponents.length) {
                            payload.componentId = [];
                        }
                        if ($scope.supportedLanguages.length === $scope.selectedLanguages.length) {
                            payload.language = [];
                        }
                        if ($scope.channels.length === $scope.selectedChannels.length) {
                            payload.channels = [];
                        }
                        if ($scope.tasks.length === $scope.selectedTasks.length) {
                            payload.taskNames = [];
                        }
                        $scope.filterComponent.tags.and.forEach(function (value, key) {
                            if (value.name === '') {
                                payload.tags = { 'and': [] };
                                return payload;
                            }
                        });
                        if(Object.keys($scope.selectedDefaultFilterObject).length && $scope.selectedDefaultFilterObject.filterAt){
                            BTStreamsService.analyzeEditDefaultFilter($scope.stream._id,payload).then(function (response) {
                                $scope.cb.saveAsDefaultFilterValue = true;
                                    console.log(response);
                                    $scope.selectedDefaultFilterObject = response.data;
                                    $scope.selectedDefaultFilterObject.days = $scope.days;
                                    $scope.selectedDefaultFilterObject.users = [];
                                    $scope.selectedDefaultFilterObject.users = $scope.filterComponent.users;
                                    $scope.filterComponent.selectedValuesUserids = $scope.selectedUsers;
                                    $scope.cb.selectedValuesUserids = $scope.filterComponent.selectedValuesUserids;
                                    $scope.taskValues = [];
                                    _.forEach($scope.tasks,function(task){
                                        var selectValue = false;
                                        _.forEach($scope.selectedTasks,function(selectedTask){
                                         if(task.id === selectedTask){
                                            selectValue = true;
                                        }
                                        });
                                        if(selectValue){
                                            $scope.taskValues.push(task.value);
                                        }
                                        });
                                        $scope.filterComponent.taskValues = $scope.taskValues;
                                        NotificationService.notify("Saved as Default Filter","success");
                                        setTimeout(function(){
                                            $scope.cb.applyFilter($scope.filterComponent,"",$scope.selectedDefaultFilterObject,false,true);
                                            $(".analyzeFilter").modal("hide");
                                        },200);
                            },function(error){
                               console.log(error);
                               $(".analyzeFilter").modal("hide");
                            });
                        }else{
                        BTStreamsService.analyzeDefaultFilter($scope.stream._id,payload).then(function (response) {
                            $scope.cb.saveAsDefaultFilterValue = true;
                                console.log(response);
                                $scope.showSelectedDefaultObject = true;
                                $scope.selectedDefaultFilterObject = response.data;
                                $scope.selectedDefaultFilterObject.days = $scope.days;
                                $scope.selectedDefaultFilterObject.users = [];
                                $scope.selectedDefaultFilterObject.users = $scope.filterComponent.users;
                                $scope.filterComponent.selectedValuesUserids = $scope.selectedUsers;
                                $scope.cb.selectedValuesUserids =  $scope.filterComponent.selectedValuesUserids;
                                $scope.taskValues = [];
                                _.forEach($scope.tasks,function(task){
                                    var selectValue = false;
                                    _.forEach($scope.selectedTasks,function(selectedTask){
                                     if(task.id === selectedTask){
                                        selectValue = true;
                                    }
                                    });
                                    if(selectValue){
                                        $scope.taskValues.push(task.value);
                                    }
                                    });
                                    $scope.filterComponent.taskValues = $scope.taskValues;
                                    NotificationService.notify("Saved as Default Filter","success");
                                    setTimeout(function(){
                                        $scope.cb.applyFilter($scope.filterComponent,"",$scope.selectedDefaultFilterObject,false,true);
                                        $(".analyzeFilter").modal("hide");
                                    },200);
                        },function(error){
                           console.log(error);
                           $(".analyzeFilter").modal("hide");
                        });
                        }
                        $scope.moreFilterModal = false;
                    };
                    $scope.prepareTaskData = function (){
                        $scope.tasks = [];
                        $scope.allTasksData = [].concat($workflowService.alertTasks(), $workflowService.actionTasks(), $workflowService.dialogTasks(), $workflowService.informationTasks(), $workflowService.knowledgeTasks());
                        if ($scope.allTasksData) {
                            $scope.allTasksData.forEach(function (value, key) {
                                if (value.child) {
                                    value.child.forEach(function (childVal, childKey) {
                                        $scope.tasks.push({ 'value': childVal.name, 'id': childVal._id,'redId':childVal.refId});
                                    });
                                } else {
                                    $scope.tasks.push({ 'value': value.name, 'id': value._id ,'redId':value.refId});
                                }
                            });
                        }
                    };
                    $scope.cb.reConstuctTasks = function (allTasksData) {
                        $scope.tasks = [];
                        $scope.prepareTaskData();
                        if ($scope.components) {
                            $scope.components.forEach(function (value, key) {
                                $scope.scriptComponents.push({ 'value': value.name, 'id': value._id });
                            });
                        }
                    };
                    function getLanguageName(type) {
                        var name = "";
                        if($scope.seedSupportedLanguages && $scope.seedSupportedLanguages.length){
                        for (var i = 0; i < $scope.seedSupportedLanguages.length; i++) {
                            if ($scope.seedSupportedLanguages[i].value === type) {
                                name = $scope.seedSupportedLanguages[i].name;
                                break;
                            }
                        }
                    }
                        return name;
                    }
                    $scope.updateScrollfunction = function () {
                        setTimeout(function () {
                            PerfectScrollbar.update($("#scrollUpdateItems")[0]);
                        }, 750);
                    };
                    $scope.resetDatePicker = function () {
                        $('div[name="daterange"]').data('daterangepicker').maxDate = moment();
                        $('div[name="daterange"]').data('daterangepicker').setStartDate(moment($scope.startDate));
                        $('div[name="daterange"]').data('daterangepicker').setEndDate(moment($scope.endDate));
                        $('div[name="daterange"]').data('daterangepicker').updateView();
                        // $scope.days = $scope.appliedSelectedDays;
                    };
                    $scope.getDefaultFilter = function (days) {
                        $scope.days = days;
                        if(days === 1) {
                            $scope.dateDisplayName = i18n.i18nString('24_hours');
                        } else if(days === 7) {
                            $scope.dateDisplayName = i18n.i18nString('last_seven_days');
                        }
                        if (days !== -1) {
                            $scope.appliedSelectedDays = days;
                        }
                        if (days !== -1) {
                            $scope.endDate = moment().toISOString();
                            $scope.startDate = moment().subtract(days, 'd').toISOString();
                        }
                        if (days == -1) {
                            $scope.resetDatePicker();
                            // if ($scope.appliedSelectedDays == 7) {
                            //     $('div[name="daterange"]').data('daterangepicker').setStartDate(moment().subtract(7, 'days').format('MM-DD-YYYY'));
                            //     $('div[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));

                            // }
                            // else if ($scope.appliedSelectedDays == 1) {
                            //     $('div[name="daterange"]').data('daterangepicker').setStartDate(moment().format('MM-DD-YYYY'));
                            //     $('div[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));

                            // }
                        }
                    };
         /* Conversation session type dropdown Help icon popover */
            $timeout(function () {
                $('.sessionType_help').popover({
                            html: true,
                            content: '<p>'+i18n.i18nString('help_interactive')+'</p><p>'+i18n.i18nString('help_non_interactive')+'</p><p>'+i18n.i18nString('help_developer')+'</p><p><a class="knowmore" target="_blank" href="https://github.com/Koredotcom/chatbot-test-runner">'+i18n.i18nString('knowMore')+'</a></p>',
                            trigger:"hover",
                            delay: { 
                                hide: 1000,
                                show:100                      
                            }
                        });
            });
                    $timeout(function () {
                        daterangepickerInput = $('div[name="daterange"]').daterangepicker({
                            "locale": {
                                "applyLabel": i18n.i18nString('apply'),
                                "cancelLabel": i18n.i18nString('close')
                            },
                            "startDate": moment(new Date($scope.startDate)).startOf('hour').format('MM-DD-YYYY') || moment(),
                            "endDate": moment(new Date($scope.endDate)).startOf('hour').add(32, 'hour').format('MM-DD-YYYY') || moment(),
                            "maxDate": moment(),
                            // "opens": "left",
                            "opens": "right",
                            "drops": 'up',
                            "timePicker": true,
                            "customClass": "nlp-datepicker",
                            // "parentEl": ".newFilters"
                        }
                            // , function (start, end, label) {
                            //     $scope.startDate = moment(new Date(start)).format('MM-DD-YYYY');
                            //     $scope.endDate = moment(new Date(end)).format('MM-DD-YYYY');
                            // }
                        );
                        $('.daterangepicker').addClass('nlp-datepicker');
                        $('div[name="daterange"]').on('apply.daterangepicker', function (ev, picker) {
                            $scope.appliedSelectedDays = -1;
                            if (ev) {
                                $scope.startDate = picker.startDate._d;
                                $scope.endDate = picker.endDate._d;
                            }
                            // if (moment()._d.getDate() === $scope.endDate.getDate() && moment()._d.getDay() === $scope.endDate.getDay() && moment()._d.getYear() === $scope.endDate.getYear()) {
                            //     $scope.endDate = moment()._d;
                            // }
                            if(moment().format() < moment($scope.endDate).format()){
                                $scope.endDate = moment().format();
                                }
                            getCustomMetaTags();
                            var offset;
                            var limit;
                            $scope.dateDisplayName = moment($scope.startDate).format('MMM DD YYYY') + " - "+moment($scope.endDate).format('MMM DD YYYY');
                        });
                        $('div[name="daterange"]').on('cancel.daterangepicker', function () {
                            if ($scope.appliedSelectedDays == 7) {
                                $('div[name="daterange"]').data('daterangepicker').setStartDate(moment().subtract(7, 'days').format('MM-DD-YYYY'));
                                $('div[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                            }
                            else if ($scope.appliedSelectedDays !== -1) {
                                $('div[name="daterange"]').data('daterangepicker').setStartDate(moment().format('MM-DD-YYYY'));
                                $('div[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                            }
                            $scope.days = $scope.appliedSelectedDays;
                        });
                        $('div[name="daterange"]').on('outsideClick.daterangepicker', function () {
                            if ($scope.appliedSelectedDays == 7) {
                                $('div[name="daterange"]').data('daterangepicker').setStartDate(moment().subtract(7, 'days').format('MM-DD-YYYY'));
                                $('div[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                            }
                            else if ($scope.appliedSelectedDays !== -1) {
                                $('div[name="daterange"]').data('daterangepicker').setStartDate(moment().format('MM-DD-YYYY'));
                                $('div[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                            }
                            $scope.days = $scope.appliedSelectedDays;
                        });
                        $('input[name="daterangepicker_start"]').on('click', function (evt) {
                            evt.stopPropagation();
                        });
                        $('input[name="daterangepicker_end"]').on('click', function (evt) {
                            evt.stopPropagation();
                        });
                        $('.daterangepicker_input').on('click', function (evt) {
                            evt.stopPropagation();
                        });
                        $('.calendar-table').on('click', function (evt) {
                            setTimeout(function() {
                                $('.daterangeCustomDropdown').addClass('open');
                            }, 0);
                        });
                        function getCustomMetaTags(){
                            var dateObject = getISOdates($scope.appliedSelectedDays);
                            BTStreamsService.metaTags($scope.stream._id, dateObject.from, dateObject.to).then(function (response) {
                                $scope.customTagsArray= response.data.tags;
                            },function(error){
                                // console.log(error);
                            });
                        }
                    }, 300);
                    $scope.getDate = function (timestamp) {
                        var date = new Date(timestamp);
                        date = moment().format('MM-DD-YYYY');
                        return date;
                        //var date = new Date(timestamp).toLocaleString();
                        //return date.split(", ")[0];
                    };


                    $scope.getTime = function (timestamp) {
                        var dateStr = new Date(timestamp).toLocaleString().split(", ")[1];
                        return dateStr.split(":")[0] + ":" + dateStr.split(":")[1] + " " + dateStr.split(" ")[1];
                    };

                    $scope.resetFilter = function (moreFilters) {
                        $scope.selectedLanguages = [];
                        $scope.selectedSession = [];
                        $scope.selectedUsers = [];
                        $scope.includeExcludeValue = {
                            "id":"include",
                            "label":i18n.i18nString('include')
                        };
                        $scope.selectedUsersIds =[];
                        var dateObj = getISOdates(1);   
                        $scope.selectedDefaultFilterObject ={
                            "filterAt": "NLPMetrics",
                            "koreUIds": [],
                            "channelUIds": [],
                            "taskNames": [],
                            "utterenceType": "both",
                            "channels": [],
                            "language": [],
                            "excludeUserIds": [],
                            "excludeChannelUIds": [],
                            "ambiguous": "showAll",
                            "from": dateObj.from,
                            "to": dateObj.to,
                            "isDeveloper": true,
                            "tags": [],
                            "users":[]
                        };
                        $scope.showExcludeText = false;
                        $scope.selectedChannels = [];
                        $scope.selectedTasks = [];
                        $scope.selectedComponents = [];
                        $scope.utterance.type = "both";
                        $scope.ambiguous.type = "showAll";
                        $scope.customTags = "";
                        $scope.isDeveloper = true;
                        // $scope.filterComponent.tags = {
                        //     'and':[]
                        // };
                        $scope.moreFilterValues = [];
                        $scope.selectedTagsArray = [];
                        $scope.selectedTagsArray.push({ name: "", values: [], type: "",isContains:{ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true} });
                        $scope.invalidValue = false;
                        
                        if(!moreFilters) {
                            $scope.getDefaultFilter(1);
                            $scope.endDate = moment().format('MM-DD-YYYY');
                            $scope.startDate = moment().subtract(1, 'd').format('MM-DD-YYYY');
                            $scope.sessionStatus = {name: 'All', value: 'all'};
                            $scope.sessionType = {name: 'All', value: 'all'};
                        }
                    };
                    $scope.applyFilter = function () {
                        var flag;
                        if ($scope.selectedTagsArray && $scope.selectedTagsArray.length && $scope.selectedTagsArray[0] && $scope.selectedTagsArray[0].name !== "" && checkCustomTagValue()) {
                            NotificationService.notify(i18n.i18nString('check_custom_tag'), 'warning');
                            return false;
                        } else if ($scope.selectedTagsArray && $scope.selectedTagsArray.length && $scope.selectedTagsArray[0] && $scope.selectedTagsArray[0].name !== "") {
                            $scope.tempArray = $scope.selectedTagsArray.filter(function (value, key) {
                                if (value.name === '' || value.name === undefined) {
                                    flag = true;
                                    return false;
                                } else {
                                    return true;
                                }
                            });
                        }
                        if (flag) {
                            $scope.selectedTagsArray = $scope.tempArray;
                            makeAPICall();
                        } else {
                            makeAPICall();
                        }

                    };

                    

                    // $scope.analyzeExport = function(type) {
                    //     if(type === 'debugLog') {
                    //         $scope.cb.geneateDebugLog(type);
                    //     } else {
                    //         $scope.cb.analyzeExport(type);
                    //     }
                    // };


                    $scope.searchValues = function (term, value) {
                        $scope.returnValue = [];
                        var filterValue = value.filter(function (el) {
                            return el !== null && el !== "" && el !== undefined;
                        });
                        if (value) {
                            filterValue.forEach(function (item, index) {
                                if (item && item.toLowerCase().indexOf(term.toLowerCase()) >= 0) {
                                    $scope.returnValue.push(item);
                                }
                            });
                        }
                        return $scope.returnValue;
                    };

                    function checkCustomTagValue() {
                        var valueCheck = false;
                        $scope.selectedTagsArray.forEach(function (value, key) {
                            if (value.name !== '' && value.values.length === 0) {
                                valueCheck = true;
                            }
                        });
                        return valueCheck;
                    }

                    function makeAPICall() {
                        if($scope.selectedUsers.length) {
                            $scope.selectedUsersIds = [];
                            $scope.kore.searchUserName = "";
                            $scope.kore.searchUserId = "";
                            $scope.users = [];
                            $scope.selectedUsersCopy = angular.copy($scope.selectedUsers);
                            $scope.selectedUsers.forEach(function(data){
                                $scope.selectedUsersIds.push(data.id);
                            });
                        }
                        var filterComponent = { 'users': $scope.selectedUsersIds || [], 'components': $scope.selectedComponents, 'startDate': $scope.startDate, 'endDate': $scope.endDate, 'languages': $scope.selectedLanguages, 'channels': $scope.selectedChannels, 'tasks': $scope.selectedTasks, 'utteranceType': $scope.utterance.type, 'isAmbiguous': $scope.ambiguous.type, 'customTags': $scope.customTags, 'days': $scope.days, 'isDeveloper': $scope.isDeveloper, 'tags': prepareTagsPayload($scope.filterComponent), 'tagsObj': $scope.filterComponent.tagsObj,'sessions': $scope.selectedSession, };
                        // if ($scope.users.length === $scope.selectedUsers.length) {
                        //     selectedUsers = [];
                        // }
                        if ($scope.selectedComponents && $scope.scriptComponents && $scope.selectedComponents.length && $scope.scriptComponents.length && $scope.scriptComponents.length === $scope.selectedComponents.length) {
                            filterComponent.components = [];
                        }
                        if ($scope.selectedLanguages && $scope.supportedLanguages && $scope.selectedLanguages.length && $scope.supportedLanguages.length && $scope.supportedLanguages.length === $scope.selectedLanguages.length) {
                            filterComponent.languages = [];
                        }
                        if ($scope.selectedChannels && $scope.channels && $scope.selectedChannels.length && $scope.channels.length && $scope.channels.length === $scope.selectedChannels.length) {
                            filterComponent.channels = [];
                        }
                        if ($scope.selectedTasks && $scope.tasks && $scope.tasks.length && $scope.selectedTasks.length && $scope.tasks.length === $scope.selectedTasks.length) {
                            filterComponent.tasks = [];
                        }
                        $scope.filterComponent.tags.and.forEach(function (value, key) {
                            if (value.name === '') {
                                filterComponent.tags = { 'and': [] };
                                return filterComponent;
                            }
                        });
                        if($scope.showExcludeText){
                          $scope.cb.showExcludeText = true;
                        }else{
                            $scope.cb.showExcludeText = false;
                        }
                        if($scope.excludeCustomTagValue){
                            $scope.cb.excludeCustomTagValue = true;
                        }else{
                            $scope.cb.excludeCustomTagValue = false;
                        }
                        if($scope.cb.toggleCheck === "Kore ID"){
                            $scope.selectedUsersIds = [];
                            $scope.selectedUsers.forEach(function(data){
                                if(data.id && !data.value){
                                    $scope.selectedUsersIds.push(data.id);
                                }else if(data.value){
                                    $scope.selectedUsersIds.push(data.value);
                                }
                            });
                            $scope.selectedDefaultFilterObject.users = $scope.selectedUsersIds;
                        }else{
                        $scope.selectedDefaultFilterObject.users = $scope.selectedUsers;
                        }
                        $scope.selectedDefaultFilterObject.days = $scope.days;
                        var dateObj = getISOdates($scope.days);
                        $scope.selectedDefaultFilterObject.from= dateObj.from;
                        $scope.selectedDefaultFilterObject.to = dateObj.to;
                        $scope.selectedDefaultFilterObject.language = $scope.selectedLanguages;
                        $scope.selectedDefaultFilterObject.channels = $scope.selectedChannels;
                        $scope.selectedDefaultFilterObject.ambiguous=$scope.ambiguous.type;
                        $scope.selectedDefaultFilterObject.isDeveloper=$scope.isDeveloper;
                        $scope.selectedDefaultFilterObject.utterenceType = $scope.utterance.type;
                        $scope.selectedDefaultFilterObject.sessionType = $scope.sessionType.value || 'all';
                        $scope.selectedDefaultFilterObject.sessionStatus = $scope.sessionStatus.value || 'all';

                        if(prepareTagsPayload($scope.filterComponent).and && prepareTagsPayload($scope.filterComponent).and.length && prepareTagsPayload($scope.filterComponent).and[0] && prepareTagsPayload($scope.filterComponent).and[0].values && prepareTagsPayload($scope.filterComponent).and[0].values.length){
                        $scope.selectedDefaultFilterObject.tags = {};
                        // $scope.selectedDefaultFilterObject.tags.and = [];
                        $scope.selectedDefaultFilterObject.tags= prepareTagsPayload($scope.filterComponent).and;
                        }
                        $scope.cb.saveAsDefaultFilterValue = false;
                        filterComponent.selectedValuesUserids = $scope.selectedUsers;
                        filterComponent.sessionType = $scope.sessionType.value || 'all';
                        filterComponent.sessionStatus = $scope.sessionStatus.value || 'all';
                        $scope.cb.selectedValuesUserids = $scope.selectedUsers;
                        $scope.taskValues = [];
                        _.forEach($scope.tasks,function(task){
                            var selectValue = false;
                            _.forEach($scope.selectedTasks,function(selectedTask){
                             if(task.id === selectedTask){
                                selectValue = true;
                            }
                            });
                            if(selectValue){
                                $scope.taskValues.push(task.value);
                            }
                            });
                            filterComponent.taskValues = $scope.taskValues;
                            if($scope.currentTab === "failedTask"){
                                filterComponent.components = [];
                            }
                        $scope.cb.applyFilter(filterComponent,true,{}); //Removed $scope.selectedDefaultFilterObject as param and added empty object
                        $scope.closeModal();
                    }

                    function prepareTagsPayload(filterComponent) {
                        filterComponent.tags = {
                            "and": []
                        };
                        $scope.selectedTagsArray.forEach(function (value, key) {
                            filterComponent.tags.and.push({
                                "name": value.name,
                                "values": value.values,
                                "type": value.type
                            });
                        });
                        return filterComponent.tags;
                    }
                    $scope.filterCustomTags = function (customTag) {
                        var _item = _.find($scope.selectedTagsArray, { 'name': customTag.name });
                        if (_item) {
                            return false;
                        } else {
                            return true;
                        }
                    };
                    $scope.cb.loadFilter = function (res,filterSaveDefaultValue) {
                        if(!res.users){
                            res.users = [];
                        }
                        if(filterSaveDefaultValue.days){
                        $scope.getDefaultFilter(filterSaveDefaultValue.days);
                        }else{
                            $scope.getDefaultFilter(res.days);
                        }
                        $scope.selectedDefaultFilterObject  = filterSaveDefaultValue;
                        if(!$scope.selectedDefaultFilterObject.excludeChannelUIds){
                            $scope.selectedDefaultFilterObject.excludeChannelUIds = [];
                        }
                        if(!$scope.selectedDefaultFilterObject.excludeUserIds){
                            $scope.selectedDefaultFilterObject.excludeUserIds = [];
                        }
                        if(!$scope.selectedDefaultFilterObject.channelUIds){
                            $scope.selectedDefaultFilterObject.channelUIds = [];
                        }
                        if(!$scope.selectedDefaultFilterObject.koreUIds){
                            $scope.selectedDefaultFilterObject.koreUIds=[];
                        }
                        if(res.selectedValuesUserids){
                           $scope.selectedUsersCopy= res.selectedValuesUserids;
                        }else {
                            if(res && res.users && res.users.length){
                                $scope.selectedUsers = [];
                            _.forEach(res.users,function(user){
                                var _selected = {};
                                _selected.id = user.value;
                                if(user.value && user.value.length && typeof(user.value)!=="undefined" && user.value.split('/') && user.value.split('/')[1] && !user.value.split('/')[2]){
                                    _selected.value =  user.value.split('/')[1];
                                }else if(user.value && user.value.length && typeof(user.value)!=="undefined" && user.value.split('/') && user.value.split('/')[1] && user.value.split('/')[2]){
                                    _selected.value =  user.value.split('/')[2];
                                }
                                $scope.selectedUsers.push(_selected);
                           });
                        }
                        }
                        if(Object.keys($scope.selectedDefaultFilterObject) && Object.keys($scope.selectedDefaultFilterObject).length){
                            if(!res.users.length && !$scope.selectedDefaultFilterObject.excludeChannelUIds.length){
                                $scope.cb.toggleCheck = 'Channel ID';
                                $scope.selectedUsers = [];
                            }else if(!res.users.length && !$scope.selectedDefaultFilterObject.excludeUserIds.length){
                            $scope.selectedUsers = [];
                            $scope.cb.toggleCheck = 'Channel ID';
                           }else if(!res.users.length && !$scope.selectedDefaultFilterObject.channelUIds.length){
                            $scope.selectedUsers = [];
                            $scope.cb.toggleCheck = 'Channel ID';
                           }else if(!res.users.length && !$scope.selectedDefaultFilterObject.koreUIds.length){
                            $scope.selectedUsers = [];
                            $scope.cb.toggleCheck = 'Channel ID';
                           }
                           if($scope.cb.toggleCheck == "Channel ID"){
                            $scope.togglePattern = false;
                           }else if($scope.cb.toggleCheck == "Kore ID"){
                            $scope.togglePattern = true;
                           }
                            if(res.users && res.users.length){
                                // $scope.showUserId= true;
                                // $scope.selectedUsers = [];
                                // _.forEach(res.users,function(user){
                                //     if(user.value){
                                //         $scope.selectedUsers.push(user);
                                //     }else{
                                //     var _selected =  {};
                                //         _selected.value = user;
                                //         $scope.selectedUsers.push(_selected);
                                //     }
                                // });
                                if( $scope.filterComponent.exclude){
                                    $scope.includeExcludeValue = {
                                        "id":"exclude",
                                        "label":i18n.i18nString('exclude')
                                    };
                                    $scope.showExcludeText = true;
                                }else{
                                $scope.showExcludeText = false;
                                $scope.includeExcludeValue = {
                                    "id":"include",
                                    "label":i18n.i18nString('include')
                                };
                                }
                            }else{
                                $scope.includeExcludeValue = {
                                    "id":"include",
                                    "label":i18n.i18nString('include')
                                };
                                $scope.showExcludeText = false;
                            }
                        // if($scope.filterComponent.excludeChannelUIds && $scope.filterComponent.excludeChannelUIds.length){
                        //      $scope.includeExcludeValue = {
                        //         "id":"exclude",
                        //         "label":i18n.i18nString('exclude')
                        //     };
                        //     $scope.showExcludeText= true;
                        //     $scope.showUserId= true;
                        // }else if($scope.filterComponent.excludeUserIds && $scope.filterComponent.excludeUserIds.length){
                        //      $scope.includeExcludeValue = {
                        //         "id":"exclude",
                        //         "label":i18n.i18nString('exclude')
                        //     };
                        //     $scope.showExcludeText= true;
                        //     $scope.showUserId= true;
                        // }else {
                        //     $scope.showExcludeText = false;
                        //     $scope.includeExcludeValue = {
                        //         "id":"include",
                        //         "label":i18n.i18nString('include')
                        //     };
                        // }
                        // else if ($scope.selectedDefaultFilterObject.excludeUserIds && $scope.selectedDefaultFilterObject.excludeUserIds.length){
                        //     $scope.selectedUsers = [];
                        //     _.forEach($scope.selectedDefaultFilterObject.excludeUserIds ,function(user){
                        //         var _selected = {};
                        //         _selected.value = user;
                        //         $scope.selectedUsers.push(_selected);
                        //      });
                        //      $scope.showUserId= true;
                        // }else if(!$scope.selectedDefaultFilterObject.excludeChannelUIds.length && $scope.selectedDefaultFilterObject.channelUIds && $scope.selectedDefaultFilterObject.channelUIds.length){
                        //     $scope.selectedUsers = [];
                        //     _.forEach($scope.selectedDefaultFilterObject.channelUIds ,function(user){
                        //         var _selected = {};
                        //         _selected.value = user;
                        //         $scope.selectedUsers.push(_selected);
                        //      });
                        //      $scope.showUserId= true;
                        // }else if(!$scope.selectedDefaultFilterObject.excludeUserIds.length && $scope.selectedDefaultFilterObject.channelUIds && $scope.selectedDefaultFilterObject.koreUIds.length){
                        //     $scope.selectedUsers = [];
                        //     _.forEach($scope.selectedDefaultFilterObject.channelUIds ,function(user){
                        //         var _selected = {};
                        //         _selected.value = user;
                        //         $scope.selectedUsers.push(_selected);
                        //      });
                        //      $scope.showUserId= true;
                        // }
                    }
                        $scope.selectedLanguages = res.languages;
                        $scope.selectedSession = res.sessions;
                        
                        
                        if(res && res.users && res.users.length){
                            if($scope.selectedUsersCopy.length){
                            $scope.selectedUsers = [];
                            res.users.forEach(function(respData){
                                $scope.selectedUsersCopy.forEach(function(user){
                                    if(respData === user.id){
                                        $scope.selectedUsers.push(user);
                                    }else if(respData.id === user.id){
                                        $scope.selectedUsers.push(user);
                                    }
                                });
                            });
                            }
                          
                        } else {
                            $scope.selectedUsersIds = [];
                            $scope.togglePattern = false;
                        }
                       
                        $scope.selectedComponents = res.components;
                        $scope.selectedChannels = res.channels;
                        $scope.selectedTasks = res.tasks;
                        $scope.utterance.type = res.utteranceType;
                        $scope.ambiguous.type = res.isAmbiguous;
                        $scope.customTags = res.customTags;
                        $scope.endDate = res.endDate;
                        $scope.startDate = res.startDate;
                        $scope.days = res.days;
                        $scope.isDeveloper = res.isDeveloper;
                        var dateObject = getISOdates($scope.days);
                        BTStreamsService.metaTags($scope.stream._id, dateObject.from, dateObject.to).then(function (response) {
                            $scope.customTagsArray = response.data.tags;
                        }, function (error) {
                            // console.log(error);
                        });
                        // $scope.customTagsArray = angular.copy(res.tagsObj);
                        _.forEach($scope.customTagsArray, function(customTag){
                               customTag.isContains={ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true};
                        });
                        if(res.tags && res.tags.and && res.tags.and.length){
                        $scope.selectedTagsArray = res.tags.and;
                        _.forEach($scope.selectedTagsArray, function(selectedTag){
                            if(selectedTag.isInclude === false){
                                selectedTag.isContains= {
                                    "id":"doesNotContain",
                                    "label":i18n.i18nString('does_not_contain'),
                                    "isInclude":false
                                };
                            }else if(selectedTag.isInclude === true){
                            selectedTag.isContains={ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true};
                            }
                     });
                    }else{
                        if(!$scope.selectedTagsArray.length){
                            $scope.selectedTagsArray.push({ name: "", values: [], type: "",isContains:{ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true} });
                        }
                    }
                        $scope.appliedSelectedDays = angular.copy($scope.days);
                        setTimeout(function () {
                            if ($scope.selectedLanguages && $scope.selectedLanguages.length === 0) {
                                if($scope.sumocb && $scope.sumocb.languagescb){
                                     $scope.sumocb.languagescb.selectAllByDefault();
                                }
                            }
                            if ($scope.selectedChannels && $scope.selectedChannels.length === 0) {
                                if($scope.sumocb && $scope.sumocb.channelscb){
                                    $scope.sumocb.channelscb.selectAllByDefault();
                               }
                                // $scope.sumocb.channelscb.selectAllByDefault();
                            }
                            if ($scope.selectedTasks && $scope.selectedTasks.length === 0) {
                                if($scope.sumocb && $scope.sumocb.taskscb){
                                    $scope.sumocb.taskscb.selectAllByDefault();
                               }
                                // $scope.sumocb.taskscb.selectAllByDefault();
                            }
                            if ($scope.selectedComponents && $scope.selectedComponents.length === 0) {
                                if($scope.sumocb && $scope.sumocb.componentscb){
                                    $scope.sumocb.componentscb.selectAllByDefault();
                               }
                            }
                            $('.user-chanels-addin-drpdown').on('hide.bs.dropdown', function (e) {
                                $scope.selectedUsersIds = [];
                                $scope.kore.searchUserName = "";
                                $scope.kore.searchUserId = "";
                                $scope.users = [];
                                $scope.selectedUsersCopy = angular.copy($scope.selectedUsers);
                                $scope.selectedUsers.forEach(function(data){
                                    $scope.selectedUsersIds.push(data.id);
                                });
                            });
                            PerfectScrollbar.initialize($('.items-list')[0],{wheelSpeed: 2,wheelPropagation: false});
                            $scope.prepareTaskData();
                        }, 150);
                    };
                    $scope.cb.loadComponents = function (res) {
                        $scope.components = res;
                        $scope.scriptComponents = [];
                        if ($scope.components) {
                            $scope.components.forEach(function (value, key) {
                                $scope.scriptComponents.push({ 'value': value.name, 'id': value._id });
                            });
                        }
                        $scope.scriptComponents = _.uniq($scope.scriptComponents, 'id');
                    };
                    // $scope.cb.loadContacts = function (res, channelUid) {
                    //     $scope.users = [];
                    //     if (res.length) {
                    //         res = $filter('orderBy')(res, 'emailId');
                    //         res.forEach(function (value, key) {
                    //             $scope.users.push({ 'value': value.emailId, 'id': value._id });
                    //         });
                    //     } else {
                    //         channelUid.forEach(function (value, key) {
                    //             $scope.users.push({ 'value': value.id, 'id': value.channelUId });
                    //         });
                    //     }
                    // };
                    $scope.closeModal = function () {
                        $(".analyzeFilter").modal("hide");
                    };
                    $scope.addCustomTags = function (index) {
                        if ($scope.selectedTagsArray.length === index + 1) {
                            $scope.selectedTagsArray.push({ name: "", values: [], type: "",isContains:{ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true} });
                        }
                    };
                    $scope.removeCustomsTags = function (index) {
                        $scope.selectedTagsArray.splice(index, 1);
                        $($(".host .tags input")[index]).val('');
                    };

                    $scope.moreFilterModal = false;
                    $scope.moreFilterToggle = function() {
                        if(!$scope.selectedTagsArray.length){
                            $scope.selectedTagsArray.push({ name: "", values: [], type: "",isContains:{ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true} });
                        }
                        if($scope.selectedLanguages.length === 1){
                            $scope.selectedLanguages = [];
                        }
                        if($scope.selectedChannels.length === 1){
                            $scope.selectedChannels = [];
                        }
                        $scope.moreFilterModal = !$scope.moreFilterModal;
                        $scope.cb.loadFilter($scope.filterComponent,$scope.selectedDefaultFilterObject);
                    };

                    $scope.selectSessionType = function(item) {
                        $scope.sessionType = item;
                    };

                    $scope.selectSessionStatus = function(item) {
                        $scope.sessionStatus = item;
                    };

                    $scope.closeFilterDropdown = function() {
                        $('.advancedFilters').dropdown('toggle');
                        $scope.closeModal();
                    };
            
                    $scope.addAdvancedFilters = function(event) {
                        // Add fitler to save temp data
                        $scope.closeFilterDropdown();
                        $scope.applyFilter();
                    };
                    $scope.dynamicHeight = function (e, selectedTag) {
                        setTimeout(function () {
                            var ele = e.target;
                            ele.style.height = '30px';
                            if ($(ele).hasClass("ng-invalid")) {
                                selectedTag.invalidValue = true;
                                $('.disabledClass').attr('disabled', 'disabled');
                            } else {
                                selectedTag.invalidValue = false;
                                $('.disabledClass').removeAttr('disabled');
                            }
                        }, 150);
                    };
                    $scope.calculateHeight = function (e) {
                        var ele = e.target;
                        ele.style.height = 'auto';
                    };
                    $scope.updatedropDown = function (tag, index) {
                        $scope.search.nameSearchQuery = "";
                        tag.selectedValues = [];
                        tag.selectedValues = tag.values;
                        $scope.selectedTagsArray[index] = tag;
                        $scope.selectedTagsArray[index].values = [];
                        $scope.selectedTagsArray[index].isContains={ "id":"contain","label":i18n.i18nString('contain'),"isInclude":true};
                        $scope.addCustomTags(index);
                    };
                    $scope.searchClick = function (event) {
                        event.preventDefault();
                        event.stopPropagation();
                    };
                    $scope.addingUserAndChannelIds = function (e) {
                        e.stopPropagation();
                    };
                    $scope.saveUserAndChannelIds = function(e){
                        $scope.selectedUsersIds = [];
                        $scope.kore.searchUserId = "";
                        $scope.kore.searchUserName = "";
                        $scope.users = [];
                        $scope.selectedUsersCopy = angular.copy($scope.selectedUsers);
                        $scope.selectedUsers.forEach(function(data){
                            $scope.selectedUsersIds.push(data.id);
                        });
                        $(".user-chanels-addin-drpdown").removeClass('open');
                    };
                    $scope.closeUserAndChannelIds = function (e) {
                        $scope.selectedUsers = [];
                        $scope.users = [];
                        $scope.kore.searchUserId = "";
                        $scope.kore.searchUserName = "";
                        $(".user-chanels-addin-drpdown").removeClass('open');
                    };
                    $scope.addingUserAndChannelIdsToFilter = function(user){
                        $scope.flag = false;
                        if($scope.selectedUsers.length === 0){
                            $scope.selectedUsers.push(user);
                        } else {
                            $scope.selectedUsers.forEach(function(value,key){
                                if(value.id === user.id ){
                                    $scope.flag =  true;    
                                }
                            });
                            if(!$scope.flag){
                                $scope.selectedUsers.push(user);
                            }
                        }
                        if($(".kr-sg-dropdowns.excludeIds .dropdown.dropdown-open.open").length){
                        $(".kr-sg-dropdowns.excludeIds .dropdown.dropdown-open").removeClass("open");
                        }
                    };
                    $scope.removeuserChannelFilterData = function(index,e){
                        e.stopPropagation();
                        $scope.selectedUsers.splice(index,1);
                        $scope.selectedUsersIds = angular.copy($scope.selectedUsers);
                    };

                    $scope.getKoreUserIds = function(e){
                        if($scope.kore.searchUserName.length === 0){
                            $scope.toShowText = false;
                        }
                        $scope.users = [];
                        if(e.keyCode === 13 && $scope.kore.searchUserName.length >= 3){
                            var search = $scope.kore.searchUserName;
                            var dateObj = getISOdates($scope.days);
                            BTStreamsService.getKoreUserIdsOnSearch($applicationService.userInfo().userId,$scope.stream._id,dateObj.from, dateObj.to,search).then(function (response) {
                                _.forEach(response.data.userIds,function(value){
                                    if(value.userId){
                                        $scope.users.push({ 'value': value.emailId, 'id': value.userId });
                                    } else {
                                        $scope.users.push({ 'value': value.emailId, 'id': value._id });
                                    }
                                    if($scope.users.length <= 0){
                                        $scope.toShowText = true;
                                    } else {
                                        $scope.toShowText = false;
                                    }
                                });
                            },function(error){
                                // console.log(error);
                            });
                        }
                    };

                    $scope.getChannelUserIds = function(e){
                        if($scope.kore.searchUserId.length === 0){
                            $scope.toShowText = false;
                        }
                        if(e.keyCode === 13 && $scope.kore.searchUserId.length >= 3){
                            var search = $scope.kore.searchUserId;
                            var dateObj = getISOdates($scope.days);
                            BTStreamsService.getChannelsUserdIdsOnSearch($applicationService.userInfo().userId,$scope.stream._id, dateObj.from, dateObj.to ,search).then(function (response) {
                                $scope.users = [];
                                _.forEach(response.data.channelUIds,function(value){
                                    $scope.users.push({ 'value': value.id, 'id': value.channelUId });
                                });
                                if($scope.users.length){
                                    if(!($(".kr-sg-dropdowns.excludeIds .dropdown.dropdown-open.open").length)){
                                        $(".kr-sg-dropdowns.excludeIds .dropdown.dropdown-open").addClass("open");
                                        }
                                }
                                if($scope.users.length <= 0){
                                    $scope.toShowText = true;
                                } else {
                                    $scope.toShowText = false;
                                }
                            },function(error){
                                // console.log(error);
                            });
                        }
                          
                    };

                    $scope.clearSearchField = function(user){
                        $scope.kore.searchUserId = "";
                        $scope.kore.searchUserName = "";
                         $scope.user = user;
                         $scope.user.id = "";
                         $scope.user.value = "";
                        $scope.toShowText = false;
                    };

                    function getISOdates(days) {
                        var dateObj = {};
                        if(days === -1){
                            dateObj.from = moment(new Date($scope.startDate)).toISOString();
                            dateObj.to = moment(new Date($scope.endDate)).toISOString();
                        }else{
                            dateObj.from = moment().subtract(days, 'd').toISOString();
                            dateObj.to = moment().toISOString();
                        }
                        
                        return dateObj;
                    }

                    init();
                }],
            link: function ($scope, $ele, $attrs) {

            }
        };

    }]);

}(angular));


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btAnalyze', [function () {

            return {
                restrict: 'EA',
                scope: {
                    stream: '=',
                    allTasks: '='
                },
                templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-analyze/bt-analyze.html',
                controller: ['$scope', '$workflowService', '$location', '_constants_', 'BTStreamsService', '$timeout', '$routeParams', 'env_conf', 'NotificationService', 'uuid4', '$translator', 'form_util', '$modal', '$q','$element','AppsDataService','$applicationService','BTFlowtaskService','BTSeedDataService','$rootScope','localstore','i18n','channelsConfig',
                    function ($scope, $workflowService, $location, _constants_, BTStreamsService, $timeout, $routeParams, env_conf, NotificationService, uuid4, $translator, form_util, $modal, $q,$element,AppsDataService,$applicationService,BTFlowtaskService,BTSeedDataService,$rootScope, localstore,i18n, channelsConfig) {
                        $scope.assetsBase = env_conf['assets-url'];
                        $scope.closeCross= env_conf['context-url']+'/assets/landingImages/closeCross.png';
                        $scope.iconContextPath = env_conf['context-url'] + '/img';
                        $scope.checkTickIcon = $scope.assetsBase+"headerIcons/checkTickIcon.svg";
                        $scope.checkTickIconDisabled = $scope.assetsBase+"headerIcons/checkTickIconDisabled.svg";
                        $scope.caretDown = env_conf['context-url']+'/assets/icons/caretDown.svg';
                        $scope.emptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/k-folder.png';
                        $scope.analyzeCB = {};
                        $scope.contacts = [];
                        $scope.defaultFilter = true;
                        $scope.defaultFilterMsg = "";
                        getDefaultFilter(1, "one week");
                        $scope._constants_=_constants_;  
                        $scope.filterTags = [];
                        $scope.moreFilterValues = [];
                        $scope.users = [];
                        $scope.tasksValue={};
                        $scope.tasks = [];
                        $scope.selectedChannels=[];
                        $scope.components = [];
                        $scope.filterSaveDefaultValue = {};  
                        var reloadDockStatusIntent = false;
                        var reloadDockStatusIntentNot = false;
                        var reloadDockStatusIntentFail = false;
                        var reloadDockStatusPerformance = false;
                        var reloadDockStatusPinned = false;
                        $scope.intentFromScroll = false;
                        $scope.intentNotFromScroll = false;
                        $scope.intentFailFromScroll = false;
                        $scope.intentPerformanceFromScroll = false;
                        $scope.intentPinnedFromScroll = false;
                        // $scope.channelList = [];
                        $scope.trainOffset = -17;
                        $scope.currentTrainOpentask = null;
                        $scope.currentTab = 'intentFound';
                        $scope.scriptServiceComponents = [];
                        $scope.requestStatus = {interval: null};
                        $scope.caretDown = $scope.assetsBase + "icons/caretDown.svg";
                        $scope.selectedTagsArray = [];
                        $scope.currentBotLanguage = $workflowService.currentLanguage();
                        $scope.categories = $workflowService.seedData().category;
                        $scope.regroupDone = {
                            'message': false,
                            'progress': false,
                            'error':'',
                            'dockError': false 
                        };
                        var otherNodesClickCount = 0;
                        $scope.isSessionFlowAvail = false;
                        $scope.isRequesting = false;
                         $scope.showTraitsNew= {};
                        $scope.showTraitsNew.isPTE = $workflowService.selectedStream().isPTE;
                        $scope.allTasks = [].concat($workflowService.alertTasks(), $workflowService.actionTasks(), $workflowService.dialogTasks(), $workflowService.informationTasks(), $workflowService.knowledgeTasks());
                        $scope.languageCodes = {'en': "English", 'de': "German", 'es': "Spanish", 'fr': "French",'pt':"Portugese",'it':"Italian",'zh_cn':"Chinese Simiplified",'zh_tw':"Chinese Traditional",'id':"Indonesian",'ko':"Korean",'nl':"Dutch",'ja':"Japanese",'ar':"Arabic",
                        'fi':"Finnish",'ru':"Russian",'pl':"Polish",'uk':"Ukrainian",'sv': "Swedish",'kk' : "Kazakh",'ca':"Catalan",'ge':'MultiLingual'};
                        $scope.filterToggle = {
                            'successIntent': {
                                'utterances': true,
                                'intent': false
                            },
                            'failedintent': {
                                'utterances': true,
                                'intent': false
                            },
                            'failed': {
                                'utterances': true,
                                'intent': false
                            },
                            'performance': {
                                'utterances': true,
                                'intent': false
                            },
                            'pinned': {
                                'utterances': true,
                                'intent': false
                            }
                        };
                        $scope.filterTab = {
                            'intentFound': {
                                'tab_name': 'Intent found',
                            },
                            'intentNotFound': {
                                'tab_name': 'Intent not found',
                            },
                            'failedTask': {
                                'tab_name': 'Failed task',
                            },
                            'performance': {
                                'tab_name': 'Performance',
                            },
                            'pinned': {
                                'tab_name': 'Pinned',
                            },
                            'debugLog': {
                                'tab_name': 'Debug Log',
                            },
                        };
                        $scope.dataAvailble = {
                            'successIntent': {
                                'total': 0,
                                'moreAvailable': true,
                                'fetching': false,
                                'sortby': 'desc'
                            },
                            'failedintent': {
                                'total': 0,
                                'moreAvailable': true,
                                'fetching': false,
                                'sortby': 'desc'
                            },
                            'failed': {
                                'total': 0,
                                'moreAvailable': true,
                                'fetching': false,
                                'sortby': 'desc'
                            },
                            'performance': {
                                'total': 0,
                                'moreAvailable': true,
                                'fetching': false,
                                'sortby': 'desc'
                            },
                            'pinned': {
                                'total': 0,
                                'moreAvailable': true,
                                'fetching': false,
                                'sortby': 'desc'
                            },
                            'logs': {
                                'total': 0,
                                'moreAvailable': true,
                                'fetching': false,
                                'sortby': 'desc'
                            }
                        };
                        channelsConfig.getDynamicChannels($workflowService.selectedStream());
                        $scope.channelsConfig = channelsConfig;
                        // BTSeedDataService.getSeedData().then(function(res){
                        //     if(res.data.channels.length){
                        //         res.data.channels.forEach(function(value,key){
                        //             $scope.channelList.push({
                        //                 type: value.type,
                        //                 name: value.name,
                        //             });
                        //         });
                                
                        //     }
                        // });
                        $scope.editTaskLoading = false;
                        var streamId = $workflowService.selectedStream()._id;
                        $scope.currTask = null;
                        var isClusterDoneToday = false;                        
                        $scope.analyzeCB.toShowKoreID = false;
                        $scope.filterComponent = {'users': [], 'endDate': moment().format('MM-DD-YYYY'), 'startDate': moment().subtract(1, 'd').format('MM-DD-YYYY'), 'languages': [], 'channels': [], 'tasks': [], 'components': [], 'utteranceType': 'both','isAmbiguous':'showAll', 'customTags': "", 'days': 1, 'isDeveloper':true,'tags':{'and':[]},'tagsObj':{},'specficChannelUId':[],'contacts':[],'sessions':[]};
                        var userInform = localstore.getAuthData();
                       
                        if(userInform && userInform.currentAccount && userInform.currentAccount.userInfo && userInform.currentAccount.userInfo.personalInfo && userInform.currentAccount.userInfo.personalInfo.language && userInform.currentAccount.userInfo.personalInfo.language ==="ja"){
                            $scope.defaultFilter = false;
                            $scope.showJapaneseFilter = true;
                            $scope.tooltipValue = $scope.filterComponent.startDate +" - "+ $scope.filterComponent.endDate;
                            $scope.dateValue = i18n.i18nString('last_24_hours');
                        }
                        getCustomMetaTags();
                        if(typeof Array.prototype.find === 'undefined') {
                            Array.prototype.find = function (callback, thisArg) {
                                for (var i = 0; i < this.length; i++) {
                                    if (callback.call(thisArg || window, this[i], i, this)){
                                        return this[i];
                                    }
                                }
                                return undefined;
                            };
                        }
                        function getCustomMetaTags(){
                            var dateObject = getISOdates($scope.filterComponent.days);
                            BTStreamsService.metaTags($scope.stream._id, dateObject.from, dateObject.to).then(function (response) {
                                $scope.filterComponent.tagsObj= response.data.tags;
                            },function(error){
                                // console.log(error);
                            });
                        }
                        function init() {
                            $scope.stream = $workflowService.selectedStream();
                            $scope.users = $scope.users || [];
                            $scope.tasks = $scope.tasks || [];
                            $scope.components = $scope.components || [];
                            $scope.intentFoundCollection = [];
                            $scope.intentNotFoundCollection = [];
                            $scope.failedTaskCollection = [];
                            $scope.performanceCollection = [];
                            $scope.pinnedTasksCollection = [];
                            $scope.debugLogsCollection = [];

                            $scope.statements_label =  i18n.i18nString( 'statements_label');
                            $scope.statement_label =  i18n.i18nString( 'statement_label');
                            /* Feching information starts here */
                            fetchIntentFoundCollection(0, 20, false);
                            fetchIntentNotFoundCollection(0, 20, false);
                            fetchFailedTaskCollection(0, 20, false);
                            fetchPerformanceCollection(0, 20, false);
                            fetchPinnedTaskCollection(0, 20, false);
                            fetchDebugLogCollection(0, 20, false);
                            /* Feching information ends here */
                            //handleGroupedTasks();
                            setTimeout(function () {
                                initiateScrolls();
                             }, 2000);
                        }
                        function initFirstTabData() {
                            $scope.intentFoundCollection = [];
                            // analyzeDefaultFilter();
                            var searchQuery = $workflowService.storeSearchQry();
                            if(searchQuery && searchQuery.navigateTo === 'debugLog') {
                                $workflowService.storeSearchQry({
                                    'userSearchQueryFlag': false,
                                    'searchQry': ''
                                });
                                setTimeout(function(){
                                    $('#debugLogTabSelector').click();
                                },200);
                            }
                        }
                        $scope.stream = $workflowService.selectedStream();
                        if($scope.stream){
                            $scope.linkedBots = ($scope.stream.publishedBots || []).concat($scope.stream.configuredBots || []);
                        }else{
                            $scope.linkedBots = [];
                        }
                        function fetchScriptServiceComponents(type) {
                            BTFlowtaskService.getComponentsByType($scope.stream._id, type).then(function (res) {
                                var _botComponents = [];
                                if (res && res.data && res.data.length > 0) {
                                    $.each(res.data, function (k, comp) {
                                        if (comp.status === 'configured') {
                                            _botComponents.push(comp);
                                        }
                                    });
                                }
                                $scope.scriptServiceComponents = $scope.scriptServiceComponents.concat(_botComponents);
                            }, function (error) {
                                $scope.nodeObjListLoading = false;
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'fetch_error'), 'error');
                                }
                            });
                        }
                        fetchScriptServiceComponents('script');
                        fetchScriptServiceComponents('service');
                        fetchScriptServiceComponents('SDKWebHook');
                        function getDefaultFilter(days, str) {
                            $scope.defaultFilterMsg = i18n.i18nString('last_24_hours');
                            $scope.defaultTag = {};
                            $scope.defaultTag.value = i18n.i18nString('last_24_hours');
                        }
                        function getISOdates(days) {
                            var dateObj = {};
                            if(days === -1){
                                dateObj.from = moment(new Date($scope.filterComponent.startDate)).toISOString();
                                dateObj.to = moment(new Date($scope.filterComponent.endDate)).toISOString();
                            }else{
                                dateObj.from = moment().subtract(days, 'd').toISOString();
                                dateObj.to = moment().toISOString();
                            }
                            
                            return dateObj;
                        }
                        $scope.checkShowTraits = function(e,intentValue){     
                            $scope.categoryIds =[];
                            _.forEach($scope.categories, function(category){
                                $scope.categoryIds.push(category._id);
                            });
                            var _payload = {
                                "name": $workflowService.selectedStream().name,
                                "type": $workflowService.selectedStream().type,
                                "description": $workflowService.selectedStream().description,
                                "color": $workflowService.selectedStream().color,
                                "categoryIds": $scope.categoryIds,
                                "hasTenant":false,
                                "isPTE" :  $scope.showTraitsNew.isPTE, // true by default, if user chooses to hide send it as false
                                "offKoraConfirmation": $workflowService.selectedStream().offKoraConfirmation,
                                "skipMakeEditLinks": $workflowService.selectedStream().skipMakeEditLinks,
                                "purpose": $workflowService.selectedStream().purpose               
                              };
                              BTStreamsService.editStream(streamId, _payload)
                              .then(function(response) { 
                                  if(response && response.data){
                                    $workflowService.selectedStream().isPTE = response.data.isPTE;
                                  }
                                //  $scope.showTraitsNew.isPTE  = response.data.isPTE; 
                                  // success
                              }, function(res) {
                            });
                            $scope.analyzeCB.applyFilter($scope.filterComponent, "" , {});
                              
                              
                        };
                        $scope.statusAnalyze = function()
                        {
                                BTStreamsService.analyzeStatus($applicationService.userInfo().userId, streamId).then(function(response) {
                                    if(response.data.status == 'pending') {
                                        $element.find('.export-analyze-modal-body p')[0].innerHTML =  i18n.i18nString( 'pending_please_wait');
                                    }else if(response.data.status == "success") {
                                        $scope.downloadURL = response.data.downloadURL;
                                        if($scope.downloadURL) {
                                            $element.find('.export-analyze-modal-body p')[0].innerHTML =  i18n.i18nString( 'downloading_please_wait');
                                            setTimeout(function(){
                                                $element.find('#analyzedownloadButton')[0].click();
                                            });
                                            setTimeout(function(){
                                                $element.find('.export-analyze-modal').removeClass('show').addClass('fade');
                                                $element.find('.export-analyze-modal-body p')[0].innerHTML =  i18n.i18nString( 'pleasewait_fetching_label');
                                            },3500);
                                            clearInterval($scope.requestStatus.interval);
                                        } else {
                                            alert('Please allow popups for this website');
                                        }
                                    } else if(response.data.status === "failed") {
                                        $element.find('.export-analyze-modal-body p')[0].innerHTML = "Failed to fetch the data.";
                                        clearInterval($scope.requestStatus.interval);
                                        setTimeout(function(){
                                            $element.find('.export-analyze-modal').removeClass('show').addClass('fade');
                                            $element.find('.export-analyze-modal-body p')[0].innerHTML =  i18n.i18nString( 'pleasewait_fetching_label');
                                        },2000);
                                    }else if(response.data === "" && response.data.status === undefined){
                                         setTimeout(function(){
                                                $element.find('.export-analyze-modal').removeClass('show').addClass('fade');
                                                $element.find('.export-analyze-modal-body p')[0].innerHTML =  i18n.i18nString( 'some_thing_went_wrong');
                                            },2000);
                                         clearInterval($scope.requestStatus.interval);
                                    }
                                }, function(error) {
                                    $element.find('.export-analyze-modal-body p')[0].innerHTML =  i18n.i18nString( 'failed_to_fetch_data');
                                    clearInterval($scope.requestStatus.interval);
                                    setTimeout(function(){
                                        $element.find('.export-analyze-modal').removeClass('show').addClass('fade');
                                        $element.find('.export-analyze-modal-body p')[0].innerHTML =  i18n.i18nString( 'pleasewait_fetching_label');
                                    },2000);                    
                                });
                            };
                        $scope.geneateDebugLog = function(){
                            function startLogExport(){
                                var payload = {};
                                var dateObj = getISOdates($scope.filterComponent.days);
                                payload = {'fromDate': dateObj.from, 'toDate': dateObj.to};
                                payload.streamId = $scope.stream._id;
                                payload.isDeveloper = true;  
                            if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0) {
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    payload.channelUIds = [];
                                    payload.channelUIds = angular.copy($scope.filterComponent.users);
                                }else{
                                    payload.userId = [];
                                    payload.userId = angular.copy($scope.filterComponent.users);
                                }
                            }
                            if ($scope.filterComponent.languages.length > 0) {
                                payload.language = $scope.filterComponent.languages;
                            }
                            if ($scope.filterComponent.channels.length > 0) {
                                payload.channel = $scope.filterComponent.channels;
                            }
                            if ($scope.filterComponent.tasks.length > 0) {
                                payload.taskId = $scope.filterComponent.tasks;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            payload.timezone = moment.tz.guess();
                                BTStreamsService.generateDebugLogRecords($scope.stream._id,payload).then(function (response) {
                                    NotificationService.notify("Exporting Analyze data ... ","success");
                                    if(response.data.status === "IN_PROGRESS" || response.data.status === "SUCCESS") {
                                        $rootScope.$broadcast('getProgressDockStatus'); 
                                        $rootScope.$broadcast('startTimer'); 
                                        $(".trainingProgress").addClass('open');
                                    } else if (response.data.status === "FAILED") {
                                        $rootScope.$broadcast('getProgressDockStatus');
                                    }
                                },function(error){
                                    if(error.data.errors[0].code === 'RequestExists'){
                                        var msg = error.data.errors[0].code;
                                        NotificationService.notify(msg,"warning");
                                    }
                                });
                            }
                            function cancleLogExport(){
                                return;
                            }
                            function checkBoxCb(checkValue){
                              $scope._constants_.updateDownloadPopUppreferance(checkValue);
                            }
                            if($scope._constants_.config.showDownloadPopUps){
                             NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startLogExport, cancleLogExport], {okText:  i18n.i18nString( 'confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined, i18n.i18nString( 'export_Debug_log'));  
                            }else{
                               startExport();
                            }
                        };
                        $scope.analyzeCB.analyzeExport = $scope.geneateDebugLog;
                    

                        $scope.analyzeExport = function(tab){


                            function startExport(){
                                var payload = {};
                            var dateObj = getISOdates($scope.filterComponent.days);
                            payload.type = tab;
                            payload.filters = {'from': dateObj.from, 'to': dateObj.to};
                            // if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0) {
                            //     if($scope.analyzeCB.toggleCheck === "Channel ID"){
                            //         payload.filters.channelUIds = $scope.filterComponent.users;
                            //     }else{
                            //         payload.filters.userId = $scope.filterComponent.users;
                            //     }
                            // }
                            if ($scope.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.filterComponent.languages;
                            }
                            if ($scope.filterComponent.channels.length > 0) {
                                payload.filters.channel = $scope.filterComponent.channels;
                            }
                            if ($scope.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.filterComponent.tasks;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            // if($scope.filterComponent.sessionStatus) {
                            //     payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            // }
                            if($scope.filterComponent.utteranceType === 'notTrained') {
                                payload.filters.trained = false;
                            }
                            if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length > 0) {
                                _.forEach($scope.filterComponent.tags.and, function(payloadTag){
                                    if(payloadTag.isContains){
                                        delete payloadTag.isContains;
                                    }
                                });
                                payload.filters.tags = $scope.filterComponent.tags;
                            }
                            if($scope.filterComponent.utteranceType === 'trained') {
                                payload.filters.trained = true;
                            }
                            if($scope.filterToggle.successIntent.utterances && $scope.currentTab !== "performance") {
                                $scope.filterToggle.successIntent.intent = false;
                                payload.groupby = 'input';
                            } 
                            if($scope.filterToggle.successIntent.utterances && $scope.currentTab === "performance") {
                                $scope.filterToggle.successIntent.intent = false;
                                payload.groupby = 'componentId';
                            } 
                            else if($scope.filterToggle.successIntent.intent) {
                                $scope.filterToggle.successIntent.utterances = false;
                                payload.groupby = 'taskId';
                            }
                            if(tab === 'failintent' && $scope.filterComponent.isAmbiguous === 'hideAmbiguous') {
                                payload.filters.isAmbiguous = false;
                            }
                            else if(tab === 'failintent' && $scope.filterComponent.isAmbiguous === 'showAmbiguous') {
                                payload.filters.isAmbiguous = true;
                            }
                            payload.sort = {'order': $scope.dataAvailble.successIntent.sortby, 'by': 'timestamp'};
                            payload.timezone = moment.tz.guess();
                            if(Object.keys($scope.filterSaveDefaultValue).length && $scope.analyzeCB.saveAsDefaultFilterValue){
                                payload.filters.from = $scope.filterSaveDefaultValue.from;
                                payload.filters.to = $scope.filterSaveDefaultValue.to;
                                if($scope.filterSaveDefaultValue.tags && $scope.filterSaveDefaultValue.tags.length && $scope.filterSaveDefaultValue.tags[0] && $scope.filterSaveDefaultValue.tags[0].values && $scope.filterSaveDefaultValue.tags[0].values.length){
                                payload.filters.tags = {};
                                payload.filters.tags.and = [];
                                payload.filters.tags.and = $scope.filterSaveDefaultValue.tags;
                                }
                                if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length ){
                                    payload.filters.excludeChannelUIds = $scope.filterSaveDefaultValue.excludeChannelUIds;
                                }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length){
                                    payload.filters.excludeUserIds = $scope.filterSaveDefaultValue.excludeUserIds;
                                }else if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length ){
                                    payload.filters.channelUIds = $scope.filterSaveDefaultValue.channelUIds;
                                }else if($scope.filterSaveDefaultValue.koreUIds &&  $scope.filterSaveDefaultValue.koreUIds.length ){
                                    payload.filters.userId = $scope.filterSaveDefaultValue.koreUIds;
                                }else if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && !$scope.analyzeCB.showExcludeText) {
                                    if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                        if(!payload.filters.channelUIds){
                                        payload.filters.channelUIds = [];
                                        }
                                        _.forEach($scope.filterComponent.users,function(selectedUser){
                                            if(selectedUser.value){
                                            payload.filters.channelUIds.push(selectedUser.value);
                                            }else{
                                                payload.filters.channelUIds.push(selectedUser);
                                            }
                                        });
                                    }else{
                                        if(!payload.filters.userId){
                                            payload.filters.userId = [];
                                            }
                                        _.forEach($scope.filterComponent.users,function(selectedUser){
                                            if(selectedUser.value){
                                            payload.filters.userId.push(selectedUser.value);
                                            }else{
                                                payload.filters.userId.push(selectedUser);
                                            }
                                        });
                                    }
                                }
                                 else if($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && $scope.analyzeCB.showExcludeText){
                                    if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                        if(!payload.filters.excludeChannelUIds){
                                            payload.filters.excludeChannelUIds = [];
                                            }
                                        
                                        _.forEach($scope.filterComponent.users,function(selectedUser){
                                            if(selectedUser.value){
                                            payload.filters.excludeChannelUIds.push(selectedUser.value);
                                            }else{
                                                payload.filters.excludeChannelUIds.push(selectedUser);
                                            }
                                        });
                                    }else{
                                        if(!payload.filters.excludeUserIds){
                                            payload.filters.excludeUserIds = [];
                                            }
                                       
                                        _.forEach($scope.filterComponent.users,function(selectedUser){
                                            if(selectedUser.value){
                                            payload.filters.excludeUserIds.push(selectedUser.value);
                                            }else{
                                                payload.filters.excludeUserIds.push(selectedUser);
                                            }
                                        });
                                    }
                                }

                                if ($scope.filterSaveDefaultValue.language && $scope.filterSaveDefaultValue.language.length && $scope.filterSaveDefaultValue.language.length > 0) {
                                    payload.filters.language = $scope.filterSaveDefaultValue.language;
                                }
                                if ($scope.filterSaveDefaultValue.channels && $scope.filterSaveDefaultValue.channels.length && $scope.filterSaveDefaultValue.channels.length > 0) {
                                    payload.filters.channel = $scope.filterSaveDefaultValue.channels;
                                }
                                if ($scope.filterSaveDefaultValue.taskNames && $scope.filterSaveDefaultValue.taskNames.length && $scope.filterSaveDefaultValue.taskNames.length > 0) {
                                    payload.filters.taskId = $scope.filterSaveDefaultValue.taskNames;
                                }
                                if (!$scope.filterSaveDefaultValue.isDeveloper) {
                                    payload.filters.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                                }
                                // if($scope.filterComponent.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                                // }
                                if($scope.filterSaveDefaultValue.utterenceType === 'notTrained') {
                                    payload.filters.trained = false;
                                }
                                else if($scope.filterSaveDefaultValue.utterenceType === 'trained') {
                                    payload.filters.trained = true;
                                }
                                if(tab === 'failintent' && $scope.filterSaveDefaultValue.ambiguous === 'hideAmbiguous') {
                                    payload.filters.isAmbiguous = false;
                                }
                                else if(tab === 'failintent' && $scope.filterSaveDefaultValue.ambiguous === 'showAmbiguous') {
                                    payload.filters.isAmbiguous = true;
                                }
                            }
                            BTStreamsService.analyzeGetRecordsExport($scope.stream._id,payload).then(function (response) {
                                NotificationService.notify( i18n.i18nString( 'exporting_analyze_data'),"success");
                                if(response.data.status === "IN_PROGRESS" || response.data.status === "SUCCESS") {
                                    $rootScope.$broadcast('getProgressDockStatus'); 
                                    $rootScope.$broadcast('startTimer'); 
                                    $(".trainingProgress").addClass('open');
                                } else if (response.data.status === "FAILED") {
                                    $rootScope.$broadcast('getProgressDockStatus');
                                }
                            },function(error){
                                if(error.data.errors[0].code === 'RequestExists'){
                                    var msg = error.data.errors[0].code;
                                    NotificationService.notify(msg,"warning");
                                }
                            });
                            }
                         function cancleExport(){
                             return;
                         }
                         function checkBoxCb(checkValue){
                           console.log(checkValue);
                           $scope._constants_.updateDownloadPopUppreferance(checkValue);
                         }
                         if($scope._constants_.config.showDownloadPopUps){
                          NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startExport, cancleExport], {okText:  i18n.i18nString( 'confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined, i18n.i18nString( 'export_metrics'));  
                         }else{
                            startExport();
                         }


                            
                        };
                        $scope.analyzeCB.analyzeExport = $scope.analyzeExport;
                        function analyzeDefaultFilter(type){
                            BTStreamsService.analyzeGetDefaultFilter($scope.stream._id).then(function (res) {
                                console.log(res);
                                $scope.filterSaveDefaultValue = res.data;
                                if(Object.keys($scope.filterSaveDefaultValue).length){
                                    $scope.analyzeCB.saveAsDefaultFilterValue = true;
                                   $scope.filterComponent.startDate = moment($scope.filterSaveDefaultValue.from).format('MM-DD-YYYY');
                                    $scope.filterComponent.endDate =  moment($scope.filterSaveDefaultValue.to).format('MM-DD-YYYY');
                                    var date1 = new Date($scope.filterComponent.startDate);
                                    var date2 = new Date($scope.filterComponent.endDate);
                                    var Difference_In_Time = date2.getTime() - date1.getTime();
                                    var Difference_In_Days = Difference_In_Time / (1000 * 3600 * 24);
                                    if(Difference_In_Days > 7 || Difference_In_Days === 0){
                                        $scope.filterSaveDefaultValue.days = -1;
                                    }else if(Difference_In_Days === 1){
                                        $scope.filterSaveDefaultValue.days = 1;
                                    }else{
                                        $scope.filterSaveDefaultValue.days = 7;
                                    }
                                    if(!$scope.filterSaveDefaultValue.users){
                                        $scope.filterSaveDefaultValue.users = [];
                                    }
                                    if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length){
                                        $scope.analyzeCB.showExcludeText = false;
                                        _.forEach($scope.filterSaveDefaultValue.channelUIds,function(user){
                                             $scope.filterSaveDefaultValue.users.push(user);
                                        });
                                    }else if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length){
                                        $scope.analyzeCB.showExcludeText = true;
                                        _.forEach($scope.filterSaveDefaultValue.excludeChannelUIds,function(user){
                                             $scope.filterSaveDefaultValue.users.push(user);
                                        });
                                    }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length){
                                        $scope.analyzeCB.showExcludeText = true;
                                        _.forEach($scope.filterSaveDefaultValue.excludeUserIds,function(user){
                                             $scope.filterSaveDefaultValue.users.push(user);
                                        });
                                    }else if($scope.filterSaveDefaultValue.koreUIds && $scope.filterSaveDefaultValue.koreUIds.length){
                                        $scope.analyzeCB.showExcludeText = false;
                                        _.forEach($scope.filterSaveDefaultValue.koreUIds,function(user){
                                             $scope.filterSaveDefaultValue.users.push(user);
                                        });
                                    }
                                }
                                $scope.taskValues = [];
                                _.forEach($scope.allTasks,function(task){
                                    _.forEach($scope.filterSaveDefaultValue.taskNames,function(selectedTask){
                                     if(task._id === selectedTask){
                                        $scope.taskValues.push(task.label?task.label:task.name);
                                    }
                                    });
                                    });
                                    $scope.filterComponent.taskValues = $scope.taskValues;
                                $scope.analyzeCB.loadFilter($scope.filterComponent,$scope.filterSaveDefaultValue);
                                $scope.analyzeCB.applyFilter( $scope.filterComponent, "",$scope.filterSaveDefaultValue,true,true);
                                if(!type){
                                fetchIntentFoundCollection(0, 20, false);
                                }
                                if (type === 'intentFound') {
                                    $scope.intentFoundCollection = [];
                                    $scope.regroupDone.message = false;
                                    $scope.regroupDone.progress = false;
                                    fetchIntentFoundCollection(0, 20, false);
                                } else if (type === 'intentNotFound') {
                                    $scope.intentNotFoundCollection = [];
                                    fetchIntentNotFoundCollection(0, 20, false);
                                } else if (type === 'failedTask') {
                                    $scope.failedTaskCollection = [];
                                    fetchFailedTaskCollection(0, 20, false);
                                } else if (type === 'performance') {
                                    $scope.performanceCollection = [];
                                    fetchPerformanceCollection(0, 20, false);
                                } else if (type === 'pinned') {
                                    $scope.pinnedTasksCollection = [];
                                    fetchPinnedTaskCollection(0, 20, false);
                                } else if (type === 'debugLog') {
                                    $scope.debugLogsCollection = [];
                                    fetchDebugLogCollection(0, 20, false);
                                }
                               },  function (error) {
                                   $scope.dataAvailble.successIntent.fetching = false;
                                   if (error && error.data && error.data.errors) {
                                       var _msg = error.data.errors[0].msg;
                                       NotificationService.notify(_msg, 'error');
                                   } else if (error.errors && _.isArray(error)) {
                                       var msg = error.errors[0].msg;
                                       NotificationService.notify(msg, 'error');
                                   } else {
                                       NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                   }
                               }); 
                        }

                        function catchDockErrorMsg(data) {
                            if(data && data.response && data.response.message) {
                                NotificationService.notify( data.response.message, 'error');
                            }else {
                                NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                            }
                        }

                      
                        $rootScope.$on("onDockStatusIntent", function ($event, data) {
                            if (reloadDockStatusIntent) {
                                if (data.jobType === "SUCCESSINTENT_API") {
                                    if (data && data.status === "IN_PROGRESS") {
                                        $scope.sessionFlowLoading = true;
                                    } else if (data && (data.status === "SUCCESS" && data.percentageComplete === 100) && data.response) {
                                        var response = { data: data.response };
                                        asyncPutRootIntentFlow(response);
                                        reloadDockStatusIntent = false;
                                    } else if (data && (data.status === "FAILURE")) {
                                        $scope.sessionFlowLoading = false;
                                        otherNodesClickCount = 0;
                                        $scope.isSessionFlowAvail = false;
                                        $scope.isRequesting = false;
                                        reloadDockStatusIntent = false;
                                        $scope.dataAvailble.successIntent.fetching = false;
                                        catchDockErrorMsg(data);
                                    }
                                }
                            }
                        });
                        $rootScope.$on("onDockStatusIntentNot", function ($event, data) {
                            if (reloadDockStatusIntentNot) {
                                if (data.jobType === "FAILINTENT_API") {
                                    if (data && data.status === "IN_PROGRESS") {
                                        $scope.sessionFlowLoading = true;
                                    } else if (data && (data.status === "SUCCESS" && data.percentageComplete === 100) && data.response) {
                                        var response = { data: data.response };
                                        asyncPutRootIntentNotFlow(response);
                                        reloadDockStatusIntentNot = false;
                                    } else if (data && (data.status === "FAILURE")) {
                                        $scope.sessionFlowLoading = false;
                                        otherNodesClickCount = 0;
                                        $scope.isSessionFlowAvail = false;
                                        $scope.isRequesting = false;
                                        reloadDockStatusIntentNot = false;
                                        catchDockErrorMsg(data);
                                    }
                                }
                            }
                        });
                        $rootScope.$on("onDockStatusFailTask", function ($event, data) {
                            if (reloadDockStatusIntentFail) {
                                if (data.jobType === "FAILTASK_API") {
                                    if (data && data.status === "IN_PROGRESS") {
                                        $scope.sessionFlowLoading = true;
                                    } else if (data && (data.status === "SUCCESS" && data.percentageComplete === 100) && data.response) {
                                        var response = { data: data.response };
                                        asyncPutRootFailIntentFlow(response);
                                        reloadDockStatusIntentFail = false;
                                    } else if (data && (data.status === "FAILURE")) {
                                        $scope.sessionFlowLoading = false;
                                        otherNodesClickCount = 0;
                                        $scope.isSessionFlowAvail = false;
                                        $scope.isRequesting = false;
                                        reloadDockStatusIntentFail = false;
                                        catchDockErrorMsg(data);
                                    }
                                }
                            }
                        });
                        $rootScope.$on("onDockStatusPerformance", function ($event, data) {
                            if (reloadDockStatusPerformance) {
                                if (data.jobType === "PERFORMANCE_API") {
                                    if (data && data.status === "IN_PROGRESS") {
                                        $scope.sessionFlowLoading = true;
                                    } else if (data && (data.status === "SUCCESS" && data.percentageComplete === 100) && data.response) {
                                        var response = { data: data.response };
                                        asyncPutRootPerformanceFlow(response);
                                        reloadDockStatusPerformance = false;
                                    } else if (data && (data.status === "FAILURE")) {
                                        $scope.sessionFlowLoading = false;
                                        otherNodesClickCount = 0;
                                        $scope.isSessionFlowAvail = false;
                                        $scope.isRequesting = false;
                                        reloadDockStatusPerformance = false;
                                        catchDockErrorMsg(data);
                                    }
                                }
                            }
                        });
                        $rootScope.$on("onDockStatusPinned", function ($event, data) {
                            if (reloadDockStatusPinned) {
                                if (data.jobType === "PINNED_API") {
                                    if (data && data.status === "IN_PROGRESS") {
                                        $scope.sessionFlowLoading = true;
                                    } else if (data && (data.status === "SUCCESS" && data.percentageComplete === 100) && data.response) {
                                        var response = { data: data.response };
                                        asyncPutRootPinnnedFlow(response);
                                        reloadDockStatusPinned = false;
                                    } else if (data && (data.status === "FAILURE")) {
                                        $scope.sessionFlowLoading = false;
                                        otherNodesClickCount = 0;
                                        $scope.isSessionFlowAvail = false;
                                        $scope.isRequesting = false;
                                        reloadDockStatusPinned = false;
                                        catchDockErrorMsg(data);
                                    }
                                }
                            }
                        });
                        $scope.checkDockStatus = function () {
                            $rootScope.$broadcast('getProgressDockStatus');
                            $rootScope.$broadcast('startTimer');
                            // $(".trainingProgress").addClass('open');
                        };
                        function asyncPutRootIntentFlow(res) {
                            $scope.tasksValue = res.data;
                            if (res.data.totalCount) {
                                $scope.dataAvailble.successIntent.total = res.data.totalCount;
                            }else{
                                $scope.dataAvailble.successIntent.total = 0;
                            }
                            $scope.dataAvailble.successIntent.moreAvailable = res.data.moreavailable;
                            var dataSet = res.data.result ? res.data.result : [];
                            if ($scope.intentFromScroll) {
                                $scope.intentFoundCollection = $scope.intentFromScroll ? $scope.intentFoundCollection.concat(dataSet) : dataSet;
                            } else {
                                $scope.intentFoundCollection = dataSet;
                            }
                            $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                            $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                            $scope.dataAvailble.successIntent.fetching = false;
                            handleGroupedTasks();
                            $scope.analyzeCB.intentFoundCollection = $scope.intentFoundCollection;
                        }
                        function asyncPutRootIntentNotFlow(res) {
                            if (res.data.totalCount) {
                                $scope.dataAvailble.failedintent.total = res.data.totalCount;
                            }else {
                                $scope.dataAvailble.failedintent.total = 0;
                            }
                            $scope.dataAvailble.failedintent.moreAvailable = res.data.moreavailable;
                            var dataset = res.data.result ? res.data.result : [];
                            if ($scope.intentNotFromScroll) {
                                $scope.intentNotFoundCollection = $scope.intentNotFromScroll ? $scope.intentNotFoundCollection.concat(dataset) : dataset;
                            } else {
                                $scope.intentNotFoundCollection = dataset;
                            }
                            $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                            $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                            $scope.dataAvailble.failedintent.fetching = false;
                            handleGroupedTasks();
                            $scope.analyzeCB.intentNotFoundCollection = $scope.intentNotFoundCollection;
                        }
                        function asyncPutRootFailIntentFlow(res) {
                            if (res.data.totalCount) {
                                $scope.dataAvailble.failed.total = res.data.totalCount;
                            }else{
                                $scope.dataAvailble.failed.total = 0;
                            }
                            $scope.dataAvailble.failed.moreAvailable = res.data.moreavailable;
                            var dataset = res.data.result ? res.data.result : [];
                            if ($scope.intentFailFromScroll) {
                                $scope.failedTaskCollection = $scope.intentFailFromScroll ? $scope.failedTaskCollection.concat(dataset) : dataset;
                            } else {
                                $scope.failedTaskCollection = dataset;
                            }
                            $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                            $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                            $scope.dataAvailble.failed.fetching = false;
                            handleGroupedTasks();
                            $scope.analyzeCB.failedTaskCollection = $scope.failedTaskCollection;
                        }
                        function asyncPutRootPerformanceFlow(res) {
                            if (res.data.totalCount) {
                                $scope.dataAvailble.performance.total = res.data.totalCount;
                            }else{
                                $scope.dataAvailble.performance.total = 0;
                            }
                            $scope.dataAvailble.performance.moreAvailable = res.data.moreavailable;
                            var dataset = res.data.result ? res.data.result : [];
                            if ($scope.intentPerformanceFromScroll) {
                                $scope.performanceCollection = $scope.intentPerformanceFromScroll ? $scope.performanceCollection.concat(dataset) : dataset;
                            } else {
                                $scope.performanceCollection = dataset;
                            }
                            $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                            $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                            $scope.components = _.uniq($scope.components.concat(res.data.components ? res.data.components : []));
                            $scope.analyzeCB.loadComponents($scope.scriptServiceComponents);
                            $scope.dataAvailble.performance.fetching = false;
                            handleGroupedTasks();
                            $scope.analyzeCB.performanceCollection = $scope.performanceCollection;
                        }
                        function asyncPutRootPinnnedFlow(res) {
                            if (res.data.totalCount) {
                                $scope.dataAvailble.pinned.total = res.data.totalCount;
                            }else{
                                $scope.dataAvailble.pinned.total = 0;
                            }
                            $scope.dataAvailble.pinned.moreAvailable = res.data.moreavailable;
                            var dataset = res.data.result ? res.data.result : [];
                            if ($scope.intentPinnedFromScroll) {
                                $scope.pinnedTasksCollection = $scope.intentPinnedFromScroll ? $scope.pinnedTasksCollection.concat(dataset) : dataset;
                            } else {
                                $scope.pinnedTasksCollection = dataset;
                            }
                            $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                            $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                            $scope.dataAvailble.pinned.fetching = false;
                            handleGroupedTasks();
                        }
                        function fetchIntentFoundCollection(offset, limit, fromScroll) {                         
                            if ($scope.dataAvailble.successIntent.fetching) {
                                return;
                            }
                            $scope.intentFromScroll = fromScroll;
                            $scope.dataAvailble.successIntent.fetching = true;
                            var payload = {};
                            var dateObj = getISOdates($scope.filterComponent.days);
                            payload.type = "successintent";
                            payload.filters = {'from': dateObj.from, 'to': dateObj.to};
                            if ($scope.filterComponent.languages && $scope.filterComponent.languages.length && $scope.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.filterComponent.languages;
                            }
                            if ($scope.filterComponent.channels && $scope.filterComponent.channels.length && $scope.filterComponent.channels.length > 0) {
                                payload.filters.channel = $scope.filterComponent.channels;
                            }
                            /* Task filter is not applicable for intent not found tab */
                            if ($scope.currentTab!== 'intentNotFound' && $scope.filterComponent.tasks && $scope.filterComponent.tasks.length && $scope.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.filterComponent.tasks;
                            }
                            if ($scope.filterComponent.sessions && $scope.filterComponent.sessions.length > 0) {
                                payload.filters.sessions = $scope.filterComponent.sessions;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            if($scope.filterComponent.sessionStatus) {
                                payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            } else {
                                payload.filters.sessionStatus = 'all';
                            }
                            if($scope.filterComponent.sessionType === "all") {
                                payload.filters.sessionCategory = [0,1];
                            }else if($scope.filterComponent.sessionType === "interactive"){
                                payload.filters.sessionCategory = [1];
                            }else if($scope.filterComponent.sessionType === "noninteractive"){
                                payload.filters.sessionCategory = [0];
                            } else {
                                payload.filters.sessionCategory = [0,1];
                            }
                            if($scope.filterComponent.utteranceType === 'notTrained') {
                                payload.filters.trained = false;
                            }
                            else if($scope.filterComponent.utteranceType === 'trained') {
                                payload.filters.trained = true;
                            }
                            if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length > 0){
                                $scope.filterComponent.tags.and.forEach(function(payloadTag){
                                    $scope.selectedTagsArray.forEach(function(value, key){
                                        if(value.name == payloadTag.name){
                                            payloadTag.isInclude = value.isContains.isInclude;
                                        }
                                    });
                                    if(payloadTag.isContains){
                                        delete payloadTag.isContains;
                                    }
                                    if(!payloadTag.name.length){
                                        var index = $scope.filterComponent.tags.and.indexOf(payloadTag);
                                        $scope.filterComponent.tags.and.splice(index, 1);
                                    }
                                });
                              payload.filters.tags = $scope.filterComponent.tags;
                            }
                            if($scope.filterToggle.successIntent.utterances) {
                                $scope.filterToggle.successIntent.intent = false;
                                payload.groupby = 'input';
                            }
                            else if($scope.filterToggle.successIntent.intent) {
                                $scope.filterToggle.successIntent.utterances = false;
                                payload.groupby = 'taskId';
                            }
                            payload.sort = {'order': $scope.dataAvailble.successIntent.sortby, 'by': 'timestamp'};
                            if(Object.keys($scope.filterSaveDefaultValue).length){
                                if($scope.filterSaveDefaultValue.days){
                                dateObj = getISOdates($scope.filterSaveDefaultValue.days);
                                payload.filters.from =dateObj.from;
                                payload.filters.to= dateObj.to;
                                }
                                if($scope.filterSaveDefaultValue.tags &&  $scope.filterSaveDefaultValue.tags.length && $scope.filterSaveDefaultValue.tags[0] && $scope.filterSaveDefaultValue.tags[0].values && $scope.filterSaveDefaultValue.tags[0].values.length && $scope.analyzeCB.saveAsDefaultFilterValue){
                                payload.filters.tags = {};
                                payload.filters.tags.and = [];
                                payload.filters.tags.and = $scope.filterSaveDefaultValue.tags;
                                }
                                if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeChannelUIds = $scope.filterSaveDefaultValue.excludeChannelUIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeUserIds = $scope.filterSaveDefaultValue.excludeUserIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }else if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.channelUIds = $scope.filterSaveDefaultValue.channelUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.koreUIds &&  $scope.filterSaveDefaultValue.koreUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.userId = $scope.filterSaveDefaultValue.koreUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }

                                if ($scope.filterSaveDefaultValue.language && $scope.filterSaveDefaultValue.language.length && $scope.filterSaveDefaultValue.language.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.language = $scope.filterSaveDefaultValue.language;
                                }
                                if($scope.filterSaveDefaultValue.sessionType === "all") {
                                    payload.filters.sessionCategory = [0,1];
                                }else if($scope.filterSaveDefaultValue.sessionType === "interactive"){
                                    payload.filters.sessionCategory = [1];
                                }else if($scope.filterSaveDefaultValue.sessionType === "noninteractive"){
                                    payload.filters.sessionCategory = [0];
                                } else if(!$scope.filterComponent.sessionType){
                                    payload.filters.sessionCategory = [0,1];
                                }
                                if($scope.filterSaveDefaultValue.sessionStatus) {
                                    payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                } else if(!$scope.filterComponent.sessionStatus){
                                    payload.filters.sessionStatus = 'all';
                                }
                                if ($scope.filterSaveDefaultValue.channels && $scope.filterSaveDefaultValue.channels.length && $scope.filterSaveDefaultValue.channels.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.channel = $scope.filterSaveDefaultValue.channels;
                                }
                                /* Task filter is not applicable for intent not found tab */
                                if ($scope.currentTab!== 'intentNotFound' && $scope.filterSaveDefaultValue.taskNames && $scope.filterSaveDefaultValue.taskNames.length && $scope.filterSaveDefaultValue.taskNames.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.taskId = $scope.filterSaveDefaultValue.taskNames;
                                }
                                // if ($scope.filterSaveDefaultValue.sessions && $scope.filterSaveDefaultValue.sessions.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessions = $scope.filterSaveDefaultValue.sessions;
                                // }
                                if (!$scope.filterSaveDefaultValue.isDeveloper && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                                }
                                // if($scope.filterSaveDefaultValue.sessionStatus && $scope.analyzeCB.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }
                                if($scope.filterSaveDefaultValue.utterenceType === 'notTrained' && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.trained = false;
                                }
                                else if($scope.filterSaveDefaultValue.utterenceType === 'trained' && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.trained = true;
                                }
                            }
                            if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && !$scope.analyzeCB.showExcludeText && !$scope.analyzeCB.saveAsDefaultFilterValue) {
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.channelUIds){
                                    payload.filters.channelUIds = [];
                                    }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.channelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.channelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }else{
                                    if(!payload.filters.userId){
                                        payload.filters.userId = [];
                                        }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.userId.push(selectedUser.value);
                                        }else{
                                            payload.filters.userId.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }
                            }
                             else if($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && $scope.analyzeCB.showExcludeText){
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.excludeChannelUIds){
                                        payload.filters.excludeChannelUIds = [];
                                        }
                                    
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeChannelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeChannelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }else{
                                    if(!payload.filters.excludeUserIds){
                                        payload.filters.excludeUserIds = [];
                                        }
                                   
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeUserIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeUserIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }
                            }
                            if(offset === 0){
                                payload.ignoreCount = false;
                            }else{
                                payload.ignoreCount = true;
                            }
                            reloadDockStatusIntent = true;
                            function getAnalyzeIntentRecordsData(){
                                var deferred = $q.defer();
                                var mode = "async";
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload, mode).then(function (res) {
                                deferred.resolve(res);
                            }, function(err) {
                                deferred.reject(err);
                            });
                            return deferred.promise;
                           }
                           getAnalyzeIntentRecordsData().then(function(res){
                                $scope.checkDockStatus();
                            }, function (error) {
                                $scope.dataAvailble.successIntent.fetching = false;
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                }
                            });
                        }
                        function fetchIntentNotFoundCollection(offset, limit, fromScroll) {
                            if ($scope.dataAvailble.failedintent.fetching) {
                                return;
                            }
                            $scope.intentNotFromScroll = fromScroll;
                            $scope.dataAvailble.failedintent.fetching = true;
                            var payload = {};
                            var dateObj = getISOdates($scope.filterComponent.days);
                            payload.filters = {'from': dateObj.from, 'to': dateObj.to};
                            payload.type = "failintent"; 
                            if ($scope.filterComponent.languages && $scope.filterComponent.languages.length && $scope.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.filterComponent.languages;
                            }
                            if ($scope.filterComponent.sessions && $scope.filterComponent.sessions.length > 0) {
                                payload.filters.sessions = $scope.filterComponent.sessions;
                            }
                             /* Task filter is not applicable for intent not found tab */
                            // if ($scope.filterComponent.tasks.length > 0) {
                            //     payload.filters.taskId = $scope.filterComponent.tasks;
                            // }
                            if ($scope.filterComponent.channels && $scope.filterComponent.channels.length && $scope.filterComponent.channels.length > 0) {
                                payload.filters.channel = $scope.filterComponent.channels;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            // if(!$scope.filterComponent.sessionStatus) {
                            //     payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            // }
                            // if($scope.filterComponent.utteranceType === 'nottrained') {
                            //     payload.filters.trained = false;
                            // }
                            // else if($scope.filterComponent.utteranceType === 'trained') {
                            //     payload.filters.trained = true;
                            // }
                            if($scope.filterComponent.sessionStatus) {
                                payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            } else {
                                payload.filters.sessionStatus = 'all';
                            }
                            if($scope.filterComponent.sessionType === "all") {
                                payload.filters.sessionCategory = [0,1];
                            }else if($scope.filterComponent.sessionType === "interactive"){
                                payload.filters.sessionCategory = [1];
                            }else if($scope.filterComponent.sessionType === "noninteractive"){
                                payload.filters.sessionCategory = [0];
                            } else {
                                payload.filters.sessionCategory = [0,1];
                            }
                            if($scope.currentTab === 'intentNotFound' && $scope.filterComponent.isAmbiguous === 'hideAmbiguous') {
                                payload.filters.isAmbiguous = false;
                            }
                            else if($scope.currentTab === 'intentNotFound' && $scope.filterComponent.isAmbiguous === 'showAmbiguous') {
                                payload.filters.isAmbiguous = true;
                            }
                            if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length > 0){
                                $scope.filterComponent.tags.and.forEach(function(payloadTag){
                                    $scope.selectedTagsArray.forEach(function(value, key){
                                        if(value.name == payloadTag.name){
                                            payloadTag.isInclude = value.isContains.isInclude;
                                        }
                                    });
                                    if(payloadTag.isContains){
                                        delete payloadTag.isContains;
                                    }
                                    if(!payloadTag.name.length){
                                        var index = $scope.filterComponent.tags.and.indexOf(payloadTag);
                                        $scope.filterComponent.and.splice(index, 1);
                                    }
                                });
                              payload.filters.tags = $scope.filterComponent.tags;
                            }
                            payload.groupby = $scope.filterToggle.failedintent.utterances ? 'input' : '';
                            payload.sort = {'order': $scope.dataAvailble.failedintent.sortby, 'by': 'timestamp'};
                            if(Object.keys($scope.filterSaveDefaultValue).length){
                                if($scope.filterSaveDefaultValue.days){
                                    dateObj = getISOdates($scope.filterSaveDefaultValue.days);
                                    payload.filters.from =dateObj.from;
                                    payload.filters.to= dateObj.to;
                                    }
                                if($scope.filterSaveDefaultValue.tags &&  $scope.filterSaveDefaultValue.tags.length && $scope.filterSaveDefaultValue.tags[0] && $scope.filterSaveDefaultValue.tags[0].values && $scope.filterSaveDefaultValue.tags[0].values.length && $scope.analyzeCB.saveAsDefaultFilterValue){
                                payload.filters.tags = {};
                                payload.filters.tags.and = [];
                                payload.filters.tags.and = $scope.filterSaveDefaultValue.tags;
                                }
                                if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeChannelUIds = $scope.filterSaveDefaultValue.excludeChannelUIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeUserIds = $scope.filterSaveDefaultValue.excludeUserIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }else if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.channelUIds = $scope.filterSaveDefaultValue.channelUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.koreUIds &&  $scope.filterSaveDefaultValue.koreUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.userId = $scope.filterSaveDefaultValue.koreUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }
                                if ($scope.filterSaveDefaultValue.language && $scope.filterSaveDefaultValue.language.length && $scope.filterSaveDefaultValue.language.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.language = $scope.filterSaveDefaultValue.language;
                                }
                                if($scope.filterSaveDefaultValue.sessionType === "all") {
                                    payload.filters.sessionCategory = [0,1];
                                }else if($scope.filterSaveDefaultValue.sessionType === "interactive"){
                                    payload.filters.sessionCategory = [1];
                                }else if($scope.filterSaveDefaultValue.sessionType === "noninteractive"){
                                    payload.filters.sessionCategory = [0];
                                } else if(!$scope.filterComponent.sessionType){
                                    payload.filters.sessionCategory = [0,1];
                                }
                                if($scope.filterSaveDefaultValue.sessionStatus) {
                                    payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                } else if(!$scope.filterComponent.sessionStatus){
                                    payload.filters.sessionStatus = 'all';
                                }
                                if ($scope.filterSaveDefaultValue.channels && $scope.filterSaveDefaultValue.channels.length && $scope.filterSaveDefaultValue.channels.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.channel = $scope.filterSaveDefaultValue.channels;
                                }
                                /* Task filter is not applicable for intent not found tab */
                                // if ($scope.currentTab!== 'intentNotFound' && $scope.filterSaveDefaultValue.taskNames && $scope.filterSaveDefaultValue.taskNames.length && $scope.filterSaveDefaultValue.taskNames.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.taskId = $scope.filterSaveDefaultValue.taskNames;
                                // }
                                // if ($scope.filterSaveDefaultValue.sessions && $scope.filterSaveDefaultValue.sessions.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessions = $scope.filterSaveDefaultValue.sessions;
                                // }
                                if (!$scope.filterSaveDefaultValue.isDeveloper && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                                }
                                // if($scope.filterSaveDefaultValue.sessionStatus && $scope.analyzeCB.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }
                                // if($scope.filterSaveDefaultValue.utterenceType === 'notTrained' && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.trained = false;
                                // }
                                // else if($scope.filterSaveDefaultValue.utterenceType === 'trained' && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.trained = true;
                                // }
                            }
                            if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && !$scope.analyzeCB.showExcludeText && !$scope.analyzeCB.saveAsDefaultFilterValue) {
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.channelUIds){
                                    payload.filters.channelUIds = [];
                                    }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.channelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.channelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }else{
                                    if(!payload.filters.userId){
                                        payload.filters.userId = [];
                                        }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.userId.push(selectedUser.value);
                                        }else{
                                            payload.filters.userId.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }
                            }
                             else if($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && $scope.analyzeCB.showExcludeText){
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.excludeChannelUIds){
                                        payload.filters.excludeChannelUIds = [];
                                        }
                                    
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeChannelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeChannelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }else{
                                    if(!payload.filters.excludeUserIds){
                                        payload.filters.excludeUserIds = [];
                                        }
                                   
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeUserIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeUserIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }
                            }
                            if(offset === 0){
                                payload.ignoreCount = false;
                            }else{
                                payload.ignoreCount = true;
                            }
                            payload.groupby = $scope.filterToggle.failedintent.utterances ? 'input' : '';
                            payload.sort = {'order': $scope.dataAvailble.failedintent.sortby, 'by': 'timestamp'};
                            reloadDockStatusIntentNot = true;
                            function getAnalyzeIntentNotRecordsData(){
                                var deferred = $q.defer();
                                var mode = "async";
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload, mode).then(function (res) {
                                deferred.resolve(res);
                            }, function(err) {
                                deferred.reject(err);
                            });
                            return deferred.promise;
                           }
                           getAnalyzeIntentNotRecordsData().then(function(res){
                                $scope.checkDockStatus();
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                }
                                $scope.dataAvailble.failedintent.fetching = false;
                            });
                        }
                        function fetchFailedTaskCollection(offset, limit, fromScroll) {                         
                            if ($scope.dataAvailble.failed.fetching) {
                                return;
                            }
                            $scope.intentFailFromScroll = fromScroll;
                            $scope.dataAvailble.failed.fetching = true;
                            var payload = {};
                            var dateObj = getISOdates($scope.filterComponent.days);
                            payload.filters = {'from': dateObj.from, 'to': dateObj.to};
                            payload.type = "failtask";
                            if ($scope.filterComponent.languages && $scope.filterComponent.languages.length && $scope.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.filterComponent.languages;
                            }
                            if ($scope.filterComponent.tasks && $scope.filterComponent.tasks.length && $scope.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.filterComponent.tasks;
                            }
                            if ($scope.filterComponent.channels && $scope.filterComponent.channels.length && $scope.filterComponent.channels.length > 0) {
                                payload.filters.channel = $scope.filterComponent.channels;
                            }
                            if ($scope.filterComponent.sessions && $scope.filterComponent.sessions.length > 0) {
                                payload.filters.sessions = $scope.filterComponent.sessions;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            // if(!$scope.filterComponent.sessionStatus) {
                            //     payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            // }
                            if($scope.filterComponent.sessionStatus) {
                                payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            } else {
                                payload.filters.sessionStatus = 'all';
                            }
                            if($scope.filterComponent.sessionType === "all") {
                                payload.filters.sessionCategory = [0,1];
                            }else if($scope.filterComponent.sessionType === "interactive"){
                                payload.filters.sessionCategory = [1];
                            }else if($scope.filterComponent.sessionType === "noninteractive"){
                                payload.filters.sessionCategory = [0];
                            } else {
                                payload.filters.sessionCategory = [0,1];
                            }
                            if($scope.filterToggle.failed.utterances) {
                                $scope.filterToggle.failed.intent = false;
                                payload.groupby = 'input';
                            }
                             if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length > 0){
                                $scope.filterComponent.tags.and.forEach(function(payloadTag){
                                    $scope.selectedTagsArray.forEach(function(value, key){
                                        if(value.name == payloadTag.name){
                                            payloadTag.isInclude = value.isContains.isInclude;
                                        }
                                    });
                                    if(payloadTag.isContains){
                                        delete payloadTag.isContains;
                                    }
                                    if(!payloadTag.name.length){
                                        var index = $scope.filterComponent.tags.and.indexOf(payloadTag);
                                        $scope.filterComponent.and.splice(index, 1);
                                    }
                                });
                              payload.filters.tags = $scope.filterComponent.tags;
                            }
                            else if($scope.filterToggle.failed.intent) {
                                $scope.filterToggle.failed.utterances = false;
                                payload.groupby = 'taskId';
                            }
                            payload.sort = {'order': $scope.dataAvailble.failed.sortby, 'by': 'timestamp'};
                            if(Object.keys($scope.filterSaveDefaultValue).length){
                                if($scope.filterSaveDefaultValue.days){
                                    dateObj = getISOdates($scope.filterSaveDefaultValue.days);
                                    payload.filters.from =dateObj.from;
                                    payload.filters.to= dateObj.to;
                                    }
                                if($scope.filterSaveDefaultValue.tags &&  $scope.filterSaveDefaultValue.tags.length && $scope.filterSaveDefaultValue.tags[0] && $scope.filterSaveDefaultValue.tags[0].values && $scope.filterSaveDefaultValue.tags[0].values.length && $scope.analyzeCB.saveAsDefaultFilterValue){
                                payload.filters.tags = {};
                                payload.filters.tags.and = [];
                                payload.filters.tags.and = $scope.filterSaveDefaultValue.tags;
                                }
                                if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeChannelUIds = $scope.filterSaveDefaultValue.excludeChannelUIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeUserIds = $scope.filterSaveDefaultValue.excludeUserIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }else if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.channelUIds = $scope.filterSaveDefaultValue.channelUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.koreUIds &&  $scope.filterSaveDefaultValue.koreUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.userId = $scope.filterSaveDefaultValue.koreUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }

                                if ($scope.filterSaveDefaultValue.language && $scope.filterSaveDefaultValue.language.length && $scope.filterSaveDefaultValue.language.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.language = $scope.filterSaveDefaultValue.language;
                                }
                                if($scope.filterSaveDefaultValue.sessionType === "all") {
                                    payload.filters.sessionCategory = [0,1];
                                }else if($scope.filterSaveDefaultValue.sessionType === "interactive"){
                                    payload.filters.sessionCategory = [1];
                                }else if($scope.filterSaveDefaultValue.sessionType === "noninteractive"){
                                    payload.filters.sessionCategory = [0];
                                } else if(!$scope.filterComponent.sessionType){
                                    payload.filters.sessionCategory = [0,1];
                                }
                                if($scope.filterSaveDefaultValue.sessionStatus) {
                                    payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                } else if(!$scope.filterComponent.sessionStatus){
                                    payload.filters.sessionStatus = 'all';
                                }
                                if ($scope.filterSaveDefaultValue.channels && $scope.filterSaveDefaultValue.channels.length && $scope.filterSaveDefaultValue.channels.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.channel = $scope.filterSaveDefaultValue.channels;
                                }
                                if ($scope.filterSaveDefaultValue.taskNames && $scope.filterSaveDefaultValue.taskNames.length && $scope.filterSaveDefaultValue.taskNames.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.taskId = $scope.filterSaveDefaultValue.taskNames;
                                }
                                // if ($scope.filterSaveDefaultValue.sessions && $scope.filterSaveDefaultValue.sessions.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessions = $scope.filterSaveDefaultValue.sessions;
                                // }
                                if (!$scope.filterSaveDefaultValue.isDeveloper && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                                }
                                // if(!$scope.filterSaveDefaultValue.sessionStatus && $scope.analyzeCB.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }
                            }
                             if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && !$scope.analyzeCB.showExcludeText && !$scope.analyzeCB.saveAsDefaultFilterValue) {
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.channelUIds){
                                    payload.filters.channelUIds = [];
                                    }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.channelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.channelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }else{
                                    if(!payload.filters.userId){
                                        payload.filters.userId = [];
                                        }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.userId.push(selectedUser.value);
                                        }else{
                                            payload.filters.userId.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }
                            }
                             else if($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && $scope.analyzeCB.showExcludeText){
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.excludeChannelUIds){
                                        payload.filters.excludeChannelUIds = [];
                                        }
                                    
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeChannelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeChannelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }else{
                                    if(!payload.filters.excludeUserIds){
                                        payload.filters.excludeUserIds = [];
                                        }
                                   
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeUserIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeUserIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }
                            }
                            if(offset === 0){
                                payload.ignoreCount = false;
                            }else{
                                payload.ignoreCount = true;
                            }
                            payload.sort = {'order': $scope.dataAvailble.failed.sortby, 'by': 'timestamp'};
                            reloadDockStatusIntentFail = true;
                            function getAnalyzeFailIntentRecordsData(){
                                var deferred = $q.defer();
                                var mode = "async";
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload, mode).then(function (res) {
                                deferred.resolve(res);
                            }, function(err) {
                                deferred.reject(err);
                            });
                            return deferred.promise;
                           }
                           getAnalyzeFailIntentRecordsData().then(function(res){
                                $scope.checkDockStatus();
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                }
                                $scope.dataAvailble.failed.fetching = false;
                            });
                        }
                        function fetchPerformanceCollection(offset, limit, fromScroll) {                        
                            if ($scope.dataAvailble.performance.fetching) {
                                return;
                            }
                            $scope.intentPerformanceFromScroll = fromScroll;
                            $scope.dataAvailble.performance.fetching = true;
                            var payload = {};
                            var dateObj = getISOdates($scope.filterComponent.days);
                            payload.filters = {'from': dateObj.from, 'to': dateObj.to};
                            payload.type = "performance";
                            if ($scope.filterComponent.components && $scope.filterComponent.components.length > 0) {
                                payload.filters.componentId = $scope.filterComponent.components;
                            }
                            // if ($scope.filterComponent.languages.length && $scope.filterComponent.languages.length > 0) {
                            //     payload.filters.language = $scope.filterComponent.languages;
                            // }
                            if ($scope.filterComponent.channels && $scope.filterComponent.channels.length && $scope.filterComponent.channels.length > 0) {
                                payload.filters.channel = $scope.filterComponent.channels;
                            }
                            if ($scope.filterComponent.sessions && $scope.filterComponent.sessions.length > 0) {
                                payload.filters.sessions = $scope.filterComponent.sessions;
                            }
                            if ($scope.filterComponent.tasks && $scope.filterComponent.tasks.length && $scope.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.filterComponent.tasks;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            // if(!$scope.filterComponent.sessionStatus) {
                            //     payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            // }
                            if($scope.filterToggle.performance.utterances) {
                                $scope.filterToggle.performance.intent = false;
                                payload.groupby = 'componentId';
                            }
                             if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length > 0){
                                $scope.filterComponent.tags.and.forEach(function(payloadTag){
                                    $scope.selectedTagsArray.forEach(function(value, key){
                                        if(value.name == payloadTag.name){
                                            payloadTag.isInclude = value.isContains.isInclude;
                                        }
                                    });
                                    if(payloadTag.isContains){
                                        delete payloadTag.isContains;
                                    }
                                    if(!payloadTag.name.length){
                                        var index = $scope.filterComponent.tags.and.indexOf(payloadTag);
                                        $scope.filterComponent.and.splice(index, 1);
                                    }
                                });
                              payload.filters.tags = $scope.filterComponent.tags;
                            }
                            else if($scope.filterToggle.performance.intent) {
                                $scope.filterToggle.performance.utterances = false;
                                payload.groupby = 'taskId';
                            }
                            payload.sort = {'order': $scope.dataAvailble.performance.sortby, 'by': 'avg_res'};
                            if(Object.keys($scope.filterSaveDefaultValue).length){
                                if($scope.filterSaveDefaultValue.days){
                                    dateObj = getISOdates($scope.filterSaveDefaultValue.days);
                                    payload.filters.from =dateObj.from;
                                    payload.filters.to= dateObj.to;
                                    }
                                if($scope.filterSaveDefaultValue.tags &&  $scope.filterSaveDefaultValue.tags.length && $scope.filterSaveDefaultValue.tags[0] && $scope.filterSaveDefaultValue.tags[0].values && $scope.filterSaveDefaultValue.tags[0].values.length && $scope.analyzeCB.saveAsDefaultFilterValue){
                                payload.filters.tags = {};
                                payload.filters.tags.and = [];
                                payload.filters.tags.and = $scope.filterSaveDefaultValue.tags;
                                }
                                if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeChannelUIds = $scope.filterSaveDefaultValue.excludeChannelUIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeUserIds = $scope.filterSaveDefaultValue.excludeUserIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }else if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.channelUIds = $scope.filterSaveDefaultValue.channelUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.koreUIds &&  $scope.filterSaveDefaultValue.koreUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.userId = $scope.filterSaveDefaultValue.koreUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }

                                // if ($scope.filterSaveDefaultValue.language && $scope.filterSaveDefaultValue.language.length && $scope.filterSaveDefaultValue.language.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.language = $scope.filterSaveDefaultValue.language;
                                // }
                                // if($scope.filterSaveDefaultValue.sessionType === "all") {
                                //     payload.filters.sessionCategory = [0,1];
                                // }else if($scope.filterSaveDefaultValue.sessionType === "interactive"){
                                //     payload.filters.sessionCategory = [1];
                                // }else if($scope.filterSaveDefaultValue.sessionType === "noninteractive"){
                                //     payload.filters.sessionCategory = [0];
                                // } else {
                                //     payload.filters.sessionCategory = [0,1];
                                // }
                                // if($scope.filterSaveDefaultValue.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // } else {
                                //     payload.filters.sessionStatus = 'closed';
                                // }
                                if ($scope.filterSaveDefaultValue.componentId && $scope.filterSaveDefaultValue.componentId.length > 0) {
                                    payload.filters.componentId = $scope.filterSaveDefaultValue.componentId;
                                }
                                if ($scope.filterSaveDefaultValue.channels && $scope.filterSaveDefaultValue.channels.length && $scope.filterSaveDefaultValue.channels.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.channel = $scope.filterSaveDefaultValue.channels;
                                }
                                if ($scope.filterSaveDefaultValue.taskNames && $scope.filterSaveDefaultValue.taskNames.length && $scope.filterSaveDefaultValue.taskNames.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.taskId = $scope.filterSaveDefaultValue.taskNames;
                                }
                                // if ($scope.filterSaveDefaultValue.sessions && $scope.filterSaveDefaultValue.sessions.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessions = $scope.filterSaveDefaultValue.sessions;
                                // }
                                if (!$scope.filterSaveDefaultValue.isDeveloper && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                                }
                                // if(!$scope.filterSaveDefaultValue.sessionStatus && $scope.analyzeCB.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }
                            }
                             if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && !$scope.analyzeCB.showExcludeText && !$scope.analyzeCB.saveAsDefaultFilterValue) {
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.channelUIds){
                                    payload.filters.channelUIds = [];
                                    }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.channelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.channelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }else{
                                    if(!payload.filters.userId){
                                        payload.filters.userId = [];
                                        }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.userId.push(selectedUser.value);
                                        }else{
                                            payload.filters.userId.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }
                            }
                             else if($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && $scope.analyzeCB.showExcludeText){
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.excludeChannelUIds){
                                        payload.filters.excludeChannelUIds = [];
                                        }
                                    
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeChannelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeChannelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }else{
                                    if(!payload.filters.excludeUserIds){
                                        payload.filters.excludeUserIds = [];
                                        }
                                   
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeUserIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeUserIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }
                            }
                            if(offset === 0){
                                payload.ignoreCount = false;
                            }else{
                                payload.ignoreCount = true;
                            }
                            payload.sort = {'order': $scope.dataAvailble.performance.sortby, 'by': 'avg_res'};
                            reloadDockStatusPerformance = true;
                            function getAnalyzePerfomanceIntentRecordsData(){
                                var deferred = $q.defer();
                                var mode = "async";
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload, mode).then(function (res) {
                                deferred.resolve(res);
                            }, function(err) {
                                deferred.reject(err);
                            });
                            return deferred.promise;
                           }
                           getAnalyzePerfomanceIntentRecordsData().then(function(res){
                                $scope.checkDockStatus();
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                }
                                $scope.dataAvailble.performance.fetching = false;
                            });
                        }
                        function fetchPinnedTaskCollection(offset, limit, fromScroll) {                         
                            if ($scope.dataAvailble.pinned.fetching) {
                                return;
                            }
                            $scope.intentPinnedFromScroll = fromScroll;
                            $scope.dataAvailble.pinned.fetching = true;
                            var payload = {};
                            var dateObj = getISOdates($scope.filterComponent.days);
                            payload.filters = {'from': dateObj.from, 'to': dateObj.to};
                            payload.type = "pinned";
                            if ($scope.filterComponent.languages && $scope.filterComponent.languages.length && $scope.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.filterComponent.languages;
                            }
                            if ($scope.filterComponent.channels && $scope.filterComponent.channels.length && $scope.filterComponent.channels.length > 0) {
                                payload.filters.channel = $scope.filterComponent.channels;
                            }
                            if ($scope.filterComponent.tasks && $scope.filterComponent.tasks.length && $scope.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.filterComponent.tasks;
                            }
                            if ($scope.filterComponent.sessions && $scope.filterComponent.sessions.length > 0) {
                                payload.filters.sessions = $scope.filterComponent.sessions;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            // if(!$scope.filterComponent.sessionStatus) {
                            //     payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            // }
                            if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length > 0){
                                $scope.filterComponent.tags.and.forEach(function(payloadTag){
                                    $scope.selectedTagsArray.forEach(function(value, key){
                                        if(value.name == payloadTag.name){
                                            payloadTag.isInclude = value.isContains.isInclude;
                                        }
                                    });
                                    if(payloadTag.isContains){
                                        delete payloadTag.isContains;
                                    }
                                    if(!payloadTag.name.length){
                                        var index = $scope.filterComponent.tags.and.indexOf(payloadTag);
                                        $scope.filterComponent.and.splice(index, 1);
                                    }
                                });
                              payload.filters.tags = $scope.filterComponent.tags;
                            }
                            var currentUser = localstore.getAuthData().currentAccount;
                            payload.filters.pinnedBy = [];
                            payload.filters.pinnedBy.push(currentUser.userInfo.id);
                            if($scope.filterToggle.pinned.utterances) {
                                $scope.filterToggle.pinned.intent = false;
                                payload.groupby = 'input';
                            }
                            else if($scope.filterToggle.pinned.intent) {
                                $scope.filterToggle.pinned.utterances = false;
                                payload.groupby = 'taskId';
                            }
                            payload.sort = {'order': $scope.dataAvailble.pinned.sortby, 'by': 'timestamp'};
                            if(Object.keys($scope.filterSaveDefaultValue).length){
                                if($scope.filterSaveDefaultValue.days){
                                    dateObj = getISOdates($scope.filterSaveDefaultValue.days);
                                    payload.filters.from =dateObj.from;
                                    payload.filters.to= dateObj.to;
                                    }
                                if($scope.filterSaveDefaultValue.tags &&  $scope.filterSaveDefaultValue.tags.length && $scope.filterSaveDefaultValue.tags[0] && $scope.filterSaveDefaultValue.tags[0].values && $scope.filterSaveDefaultValue.tags[0].values.length && $scope.analyzeCB.saveAsDefaultFilterValue){
                                payload.filters.tags = {};
                                payload.filters.tags.and = [];
                                payload.filters.tags.and = $scope.filterSaveDefaultValue.tags;
                                }
                                if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeChannelUIds = $scope.filterSaveDefaultValue.excludeChannelUIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeUserIds = $scope.filterSaveDefaultValue.excludeUserIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }else if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.channelUIds = $scope.filterSaveDefaultValue.channelUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.koreUIds &&  $scope.filterSaveDefaultValue.koreUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.userId = $scope.filterSaveDefaultValue.koreUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }

                                 if ($scope.filterSaveDefaultValue.language && $scope.filterSaveDefaultValue.language.length && $scope.filterSaveDefaultValue.language.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.language = $scope.filterSaveDefaultValue.language;
                                }
                                // if($scope.filterSaveDefaultValue.sessionType === "all") {
                                //     payload.filters.sessionCategory = [0,1];
                                // }else if($scope.filterSaveDefaultValue.sessionType === "interactive"){
                                //     payload.filters.sessionCategory = [1];
                                // }else if($scope.filterSaveDefaultValue.sessionType === "noninteractive"){
                                //     payload.filters.sessionCategory = [0];
                                // } else {
                                //     payload.filters.sessionCategory = [0,1];
                                // }
                                // if($scope.filterSaveDefaultValue.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }else {
                                //     payload.filters.sessionStatus = 'closed';
                                // }
                                if ($scope.filterSaveDefaultValue.channels && $scope.filterSaveDefaultValue.channels.length && $scope.filterSaveDefaultValue.channels.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.channel = $scope.filterSaveDefaultValue.channels;
                                }
                                if ($scope.filterSaveDefaultValue.taskNames && $scope.filterSaveDefaultValue.taskNames.length && $scope.filterSaveDefaultValue.taskNames.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.taskId = $scope.filterSaveDefaultValue.taskNames;
                                }
                                // if ($scope.filterSaveDefaultValue.sessions && $scope.filterSaveDefaultValue.sessions.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessions = $scope.filterSaveDefaultValue.sessions;
                                // }
                                if (!$scope.filterSaveDefaultValue.isDeveloper && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                                }
                                // if(!$scope.filterSaveDefaultValue.sessionStatus && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }
                            }
                             if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && !$scope.analyzeCB.showExcludeText && !$scope.analyzeCB.saveAsDefaultFilterValue) {
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.channelUIds){
                                    payload.filters.channelUIds = [];
                                    }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.channelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.channelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }else{
                                    if(!payload.filters.userId){
                                        payload.filters.userId = [];
                                        }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.userId.push(selectedUser.value);
                                        }else{
                                            payload.filters.userId.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }
                            }
                             else if($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && $scope.analyzeCB.showExcludeText){
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.excludeChannelUIds){
                                        payload.filters.excludeChannelUIds = [];
                                        }
                                    
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeChannelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeChannelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }else{
                                    if(!payload.filters.excludeUserIds){
                                        payload.filters.excludeUserIds = [];
                                        }
                                   
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeUserIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeUserIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }
                            }
                            if(offset === 0){
                                payload.ignoreCount = false;
                            }else{
                                payload.ignoreCount = true;
                            }
                            payload.sort = {'order': $scope.dataAvailble.pinned.sortby, 'by': 'timestamp'};
                            reloadDockStatusPinned = true;
                            function getAnalyzePinnedIntentRecordsData(){
                                var deferred = $q.defer();
                                var mode = "async";
                            BTStreamsService.getAnalyzeRecords($scope.stream._id, offset, limit, payload, mode).then(function (res) {
                                deferred.resolve(res);
                            }, function(err) {
                                deferred.reject(err);
                            });
                            return deferred.promise;
                           }
                           getAnalyzePinnedIntentRecordsData().then(function(res){
                                $scope.checkDockStatus();
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                }
                                $scope.dataAvailble.pinned.fetching = false;
                            });
                        }
                        function fetchDebugLogCollection(offset, limit, fromScroll) {                          
                            if ($scope.dataAvailble.logs.fetching) {
                                return;
                            }
                            $scope.dataAvailble.logs.fetching = true;
                            var payload = {};
                            var dateObj = getISOdates($scope.filterComponent.days);
                            payload.filters = {'fromDate': dateObj.from, 'toDate': dateObj.to};
                            payload.filters.isDeveloper = true;  
                            if ($scope.filterComponent.languages && $scope.filterComponent.languages.length && $scope.filterComponent.languages.length > 0) {
                                payload.filters.language = $scope.filterComponent.languages;
                            }
                            if ($scope.filterComponent.channels && $scope.filterComponent.channels.length && $scope.filterComponent.channels.length > 0) {
                                payload.filters.channel = $scope.filterComponent.channels;
                            }
                            if ($scope.filterComponent.sessions && $scope.filterComponent.sessions.length > 0) {
                                payload.filters.sessions = $scope.filterComponent.sessions;
                            }
                            if ($scope.filterComponent.tasks && $scope.filterComponent.tasks.length && $scope.filterComponent.tasks.length > 0) {
                                payload.filters.taskId = $scope.filterComponent.tasks;
                            }
                            if (!$scope.filterComponent.isDeveloper) {
                                payload.filters.isDeveloper = $scope.filterComponent.isDeveloper;
                            }
                            // if($scope.filterComponent.sessionStatus) {
                            //     payload.filters.sessionStatus = $scope.filterComponent.sessionStatus;
                            // }
                             /* Custom Tag filter is not applicable for debug log tab */
                            // else if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length > 0) {
                            //     payload.filters.tags = $scope.filterComponent.tags;
                            // }
                            var currentUser = localstore.getAuthData().currentAccount;
                            payload.filters.sort = {'order': $scope.dataAvailble.logs.sortby, 'by': 'timestamp'};
                            if(Object.keys($scope.filterSaveDefaultValue).length){
                                if($scope.filterSaveDefaultValue.days){
                                    dateObj = getISOdates($scope.filterSaveDefaultValue.days);
                                    payload.filters.from =dateObj.from;
                                    payload.filters.to= dateObj.to;
                                    }
                                if($scope.filterSaveDefaultValue.excludeChannelUIds && $scope.filterSaveDefaultValue.excludeChannelUIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeChannelUIds = $scope.filterSaveDefaultValue.excludeChannelUIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.excludeUserIds && $scope.filterSaveDefaultValue.excludeUserIds.length && $scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.excludeUserIds = $scope.filterSaveDefaultValue.excludeUserIds;
                                    $scope.filterComponent.exclude = true;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }else if($scope.filterSaveDefaultValue.channelUIds && $scope.filterSaveDefaultValue.channelUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.channelUIds = $scope.filterSaveDefaultValue.channelUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Channel ID';
                                }else if($scope.filterSaveDefaultValue.koreUIds &&  $scope.filterSaveDefaultValue.koreUIds.length && !$scope.analyzeCB.showExcludeText && $scope.analyzeCB.saveAsDefaultFilterValue){
                                    payload.filters.userId = $scope.filterSaveDefaultValue.koreUIds;
                                    $scope.filterComponent.exclude = false;
                                    $scope.analyzeCB.toggleCheck = 'Kore ID';
                                }

                                if ($scope.filterSaveDefaultValue.language && $scope.filterSaveDefaultValue.language.length && $scope.filterSaveDefaultValue.language.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.language = $scope.filterSaveDefaultValue.language;
                                }
                                // if($scope.filterSaveDefaultValue.sessionType === "all") {
                                //     payload.filters.sessionCategory = [0,1];
                                // }else if($scope.filterSaveDefaultValue.sessionType === "interactive"){
                                //     payload.filters.sessionCategory = [1];
                                // }else if($scope.filterSaveDefaultValue.sessionType === "noninteractive"){
                                //     payload.filters.sessionCategory = [0];
                                // }else {
                                //     payload.filters.sessionCategory = [0,1];
                                // }
                                // if($scope.filterSaveDefaultValue.sessionStatus) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }else {
                                //     payload.filters.sessionStatus = 'closed';
                                // }
                                if ($scope.filterSaveDefaultValue.channels && $scope.filterSaveDefaultValue.channels.length && $scope.filterSaveDefaultValue.channels.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.channel = $scope.filterSaveDefaultValue.channels;
                                }
                                if ($scope.filterSaveDefaultValue.taskNames && $scope.filterSaveDefaultValue.taskNames.length && $scope.filterSaveDefaultValue.taskNames.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.taskId = $scope.filterSaveDefaultValue.taskNames;
                                }
                                // if ($scope.filterSaveDefaultValue.sessions && $scope.filterSaveDefaultValue.sessions.length > 0 && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessions = $scope.filterSaveDefaultValue.sessions;
                                // }
                                if (!$scope.filterSaveDefaultValue.isDeveloper && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                    payload.filters.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                                }
                                // if(!$scope.filterSaveDefaultValue.sessionStatus && $scope.analyzeCB.saveAsDefaultFilterValue) {
                                //     payload.filters.sessionStatus = $scope.filterSaveDefaultValue.sessionStatus;
                                // }
                            }
                             if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && !$scope.analyzeCB.showExcludeText && !$scope.analyzeCB.saveAsDefaultFilterValue) {
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.channelUIds){
                                    payload.filters.channelUIds = [];
                                    }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.channelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.channelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }else{
                                    if(!payload.filters.userId){
                                        payload.filters.userId = [];
                                        }
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.userId.push(selectedUser.value);
                                        }else{
                                            payload.filters.userId.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = false;
                                }
                            }
                             else if($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0 && $scope.analyzeCB.showExcludeText){
                                if($scope.analyzeCB.toggleCheck === "Channel ID"){
                                    if(!payload.filters.excludeChannelUIds){
                                        payload.filters.excludeChannelUIds = [];
                                        }
                                    
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeChannelUIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeChannelUIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }else{
                                    if(!payload.filters.excludeUserIds){
                                        payload.filters.excludeUserIds = [];
                                        }
                                   
                                    _.forEach($scope.filterComponent.users,function(selectedUser){
                                        if(selectedUser.value){
                                        payload.filters.excludeUserIds.push(selectedUser.value);
                                        }else{
                                            payload.filters.excludeUserIds.push(selectedUser);
                                        }
                                    });
                                    $scope.filterComponent.exclude = true;
                                }
                            }
                            BTStreamsService.getDebugLogRecords($scope.stream._id, offset, limit, payload).then(function (res) {
                                $scope.dataAvailble.logs.totalCount = res.data.totalCount;
                                $scope.dataAvailble.logs.moreAvailable = res.data.hasMore;
                                var dataset = res.data.logs ? res.data.logs : [];
                                $scope.debugLogsCollection = fromScroll ? $scope.debugLogsCollection.concat(dataset) : dataset;
                                $scope.users = _.uniq($scope.users.concat(res.data.users ? res.data.users : []));
                                $scope.tasks = _.uniq($scope.tasks.concat(res.data.tasks ? res.data.tasks : []));
                                $scope.dataAvailble.logs.fetching = false;
                                handleGroupedTasks();
                                $scope.analyzeCB.debugLogsCollection = $scope.debugLogsCollection;
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                }
                                $scope.dataAvailble.logs.fetching = false;
                            });
                        }
                        function fetchBotDevelopersList() {
                            var offset = 0;
                            var limit = 300;
                            BTStreamsService.getbotSpecficUsers($scope.stream._id,moment(new Date($scope.filterComponent.startDate)).toISOString(), moment(new Date($scope.filterComponent.endDate)).toISOString(),offset,limit)
                            .then(function (res) {
                                if(res.data.userIds.length){
                                    res.data.userIds.forEach(function(value,key){
                                        $scope.filterComponent.contacts.push({
                                            _id: value._id,
                                            emailId: value.emailId,
                                        });
                                    });
                                    $scope.analyzeCB.loadContacts($scope.filterComponent.contacts);
                                }
                            });
                        }
                        // $timeout(function(){
                        //     fetchBotDevelopersList();
                        // },750);
                        $scope.initPopover = function(tag,moreFilter){
                            var dateTooltip = false;
                            if(tag.type === "date" || tag.type === "utteranceType" || tag.type === "isDeveloper"){
                                dateTooltip = true;
                            }
                            var filterTagPopoverNew = '#filterTagPopover'+tag.type;
                            setTimeout(function(){
                                $("#popOverEvent"+tag.type).popover({
                                    html: !dateTooltip,
                                    trigger: 'hover',
                                    placement:moreFilter?"left":"bottom",
                                    content: function () {
                                        if (dateTooltip && $scope.filterComponent.days === 7) {
                                            if(moment($scope.filterComponent.startDate).format('MM-DD-YYYY') === "Invalid date" && moment($scope.filterComponent.endDate).format('MM-DD-YYYY') === "Invalid date"){
                                               tag.tooltipValue=$scope.filterComponent.startDate +" - "+ $scope.filterComponent.endDate;
                                               return tag.tooltipValue;
                                            }else{
                                                tag.tooltipValue= moment($scope.filterComponent.startDate).format('MM-DD-YYYY, hh:mm A') +"  to  "+ moment($scope.filterComponent.endDate).format('MM-DD-YYYY, hh:mm A');
                                                return tag.tooltipValue;
                                            }
                                        } else if(dateTooltip && $scope.filterComponent.days === -1){
                                            tag.tooltipValue= moment(new Date($scope.filterComponent.startDate)).format('MM-DD-YYYY, hh:mm A')+"  to  "+ moment(new Date($scope.filterComponent.endDate)).format('MM-DD-YYYY, hh:mm A');
                                            return tag.tooltipValue;
                                        } 
                                        else if(dateTooltip){
                                            tag.tooltipValue= moment($scope.filterComponent.startDate).format('MM-DD-YYYY, hh:mm A') +"  to  "+ moment($scope.filterComponent.endDate).format('MM-DD-YYYY, hh:mm A');
                                            return tag.tooltipValue;
                                        }
                                       else{
                                        return $(filterTagPopoverNew).html();
                                        }
                                    }
                                });
                            },100);      
                        };
                        $scope.handleDropdownClose = function (e) {
                            if (e.currentTarget.className.indexOf('analyze-dropdown') !== -1 && e.target.parentElement.className.indexOf('filterIcon') !== -1) {
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                e.stopPropagation();
                            }
                        };
                        $scope.getDate = function (timestamp) {
                            return moment(timestamp).format('MM-DD-YYYY');
                        };
                        $scope.getTime = function (timestamp) {
                            return moment(timestamp).format('h:mm:ss A');
                        };
                        $scope.editFilter = function () {   
                            analyzeDefaultFilter();  
                            if($scope.scriptServiceComponents && $scope.scriptServiceComponents.length>0) {
                                $scope.analyzeCB.loadComponents($scope.components);
                            }
                            $timeout(function(){
                                if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length === 0){
                                    $scope.selectedTagsArray = [];
                                    $scope.selectedTagsArray.push({name:"",values:[],type:"",isContains:{ "id":"contain","label":"Contain","isInclude":true}});
                                }else{
                                    $scope.selectedTagsArrayCopy = angular.copy($scope.selectedTagsArray);
                                    $scope.selectedTagsArray = [];
                                    if($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length){
                                    $scope.filterComponent.tags.and.forEach(function(value,key){
                                        //var valueIndex=_.findIndex($scope.selectedTagsArrayCopy,{name:value.name});
                                        var forAutoSuggestionValues = _.findIndex($scope.filterComponent.tagsObj,{name:value.name});
                                        $scope.selectedTagsArray.push({
                                            name:value.name,
                                            values:value.values,
                                            type:value.type,
                                            selectedValues:$scope.filterComponent.tagsObj[forAutoSuggestionValues].values,
                                            isContains:value.isContains
                                        });
                                    });
                                  }
                                    $scope.selectedTagsArray.push({ name: "", values: [],type:"",isContains:{ "id":"contain","label":"Contain","isInclude":true} });
                                }
                            },350);
                            
                            $(".analyzeFilter").modal("show");
                            $('.customTagsDivScroll').click(function(event){
                                event.preventDefault();
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                            });
                        };

                        $scope.analyzeCB.editFilter = $scope.editFilter;

                        $rootScope.$on('scheduleClusterDone', function(){
                            if(!isClusterDoneToday) {
                                $scope.regroupDone.message = true;
                                $scope.regroupDone.progress = false;
                                isClusterDoneToday = true;
                            }
                        });

                        $rootScope.$on('scheduleClusterFailed', function(){
                            if(!isClusterDoneToday) {
                                $scope.regroupDone.progress = false;
                                $scope.regroupDone.dockError = true;
                                $scope.regroupDone.error =  i18n.i18nString( 'regrouping_of_utterences_failed');
                            }
                        });

                        $('.clustering-progress').popover({
                          trigger: 'hover'
                        });

                        $scope.scheduleCluster = function () {
                            $scope.regroupDone.dockError = false;
                            $scope.regroupDone.error = '';
                            BTStreamsService.scheduleCluster($workflowService.selectedStream()._id, {})
                            .then(function(res){
                                $rootScope.$broadcast('startTimer');
                                $scope.regroupDone.progress = true;
                            }, function(err){
                                if(err && err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) {
                                    if(err.data.errors[0].code === 1001) {
                                        $scope.regroupDone.progress = true;
                                        $rootScope.$broadcast('startTimer');
                                    }
                                    else if(err.data.errors[0].code === 1002) {
                                        isClusterDoneToday = true;
                                    }
                                    else if(err.data.errors[0].code === 1003) {
                                        $scope.regroupDone.progress = false;
                                        $scope.regroupDone.message = false;
                                        $scope.regroupDone.error =  i18n.i18nString( 'regrouping_has_failed');
                                    }
                                }
                            });
                        };

                        $scope.scheduleCluster();


                        $scope.pinTask = function (task, e) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            e.stopPropagation();
                            if (!task.pinned) {
                                task.pinned = true;
                            } else {
                                task.pinned = false;
                            }
                            var payload = {'pinned': task.pinned, 'index': task._index};
                            BTStreamsService.updateAnalyzeRecord($scope.stream._id, task._id, payload).then(function (res) {
                                if(task.pinned) {
                                    NotificationService.notify( i18n.i18nString( 'record_pinned_sucess'), 'success');
                                }
                                else {
                                    NotificationService.notify(i18n.i18nString( 'record_unpinned_sucess'), 'success');
                                }
                                if(!$scope.pinnedTasksCollection) {
                                    $scope.pinnedTasksCollection = [];
                                }
                                $scope.pinnedTasksCollection.push(task);
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify( i18n.i18nString( 'error_handle'), 'error');
                                }
                            });
                        };
                        $scope.testTrainCB = {};
                        $scope.testTrainCB.onTasksLoaded=function(){
                            $scope.allTasks = [].concat($workflowService.alertTasks(), $workflowService.actionTasks(), $workflowService.dialogTasks(), $workflowService.informationTasks(), $workflowService.knowledgeTasks());
                            $timeout(function(){
                                $scope.analyzeCB.reConstuctTasks($scope.allTasks);
                            },500);
                        };
                        $scope.showTrainModal = false;
                        $scope.trainTask = function (e, task) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            e.stopPropagation();
                            $scope.currentTrainOpentask = task;
                            $scope.showTrainModal = true;
                            $workflowService.nlpTrainInput({});
                            var params = {'input': [task.input]};
                            $workflowService.nlpTrainInput({log: params});
                            $scope.testTrainCB.initMethod();
                            $(".analyzeTrain").modal("show");
                            setTimeout(function () {
                                var analyzeLeftLineHeight = ($('.analyzeTrain .eachModel.mlm').height() + 22) + ($('.analyzeTrain .eachModel.fmm').height() + 22) + 52;
                                $('head').append('<style>.analyzeTrain .intentTitle:before{height:' + analyzeLeftLineHeight + 'px !important;}</style>');
                            }, 350);
                        };
                        $scope.closeTestTrainModal = function () {
                            $(".analyzeTrain").modal("hide");
                            $workflowService.nlpTrainInput({});
                            $scope.testTrainCB.initMethod();
                        };
                        $scope.analyzeCB.applyFilter = function (comp,nochangeTraits,saveForDefault,showDefaultFilterValue,noDefaultfilterApplied) {
                            $scope.filterComponent = angular.copy(comp);
                            if(Object.keys(saveForDefault) && Object.keys(saveForDefault).length && noDefaultfilterApplied){
                            $scope.filterSaveDefaultValue=saveForDefault;
                            $scope.filterComponent.startDate = $scope.filterSaveDefaultValue.from;
                            $scope.filterComponent.endDate =  $scope.filterSaveDefaultValue.to;
                            $scope.filterComponent.tags.and = $scope.filterSaveDefaultValue.tags;
                            if($scope.filterSaveDefaultValue.days){
                             $scope.filterComponent.days =$scope.filterSaveDefaultValue.days;
                            }
                            $scope.filterComponent.tasks = $scope.filterSaveDefaultValue.taskNames;
                            $scope.filterComponent.languages = $scope.filterSaveDefaultValue.language;
                            $scope.filterComponent.isAmbiguous = $scope.filterSaveDefaultValue.ambiguous;
                            $scope.filterComponent.isDeveloper = $scope.filterSaveDefaultValue.isDeveloper;
                            if($scope.filterSaveDefaultValue.componentId){
                            $scope.filterComponent.components = $scope.filterSaveDefaultValue.componentId;
                            }
                            if($scope.filterSaveDefaultValue.utterenceType === "notTrained"){
                                $scope.filterSaveDefaultValue.trained = false;
                                $scope.filterSaveDefaultValue.utterenceType = "notTrained" ;
                            }
                            $scope.filterComponent.utteranceType= $scope.filterSaveDefaultValue.utterenceType;
                            $scope.filterComponent.channels = $scope.filterSaveDefaultValue.channels;
                            if(showDefaultFilterValue){
                                _.forEach($scope.filterSaveDefaultValue.users,function(user){
                                    var _selected = {};
                                    _selected.value = user;
                                    $scope.filterComponent.users.push(_selected);
                                });
                            }else{
                                $scope.filterComponent.users = $scope.filterSaveDefaultValue.users;
                            }
                            }else{
                                $scope.filterSaveDefaultValue = {}; 
                            }
                            $scope.defaultFilter = false;
                            $scope.showJapaneseFilter = false;
                            if(nochangeTraits){
                                $scope.showTraitsNew.isPTE  = true;

                            }
                            if(!showDefaultFilterValue){
                            if($scope.currentTab === "intentFound"){
                                // if( $scope.showTraitsNew.isPTE  && !nochangeTraits){
                                //      $scope.showTraitsNew.isPTE  = false;
                                // }else if(!nochangeTraits){
                                //      $scope.showTraitsNew.isPTE  = true;
                                // }
                                fetchIntentFoundCollection(0, 20, false);
                            } else if($scope.currentTab === "intentNotFound"){
                                // if( $scope.showTraitsNew.isPTE  && !nochangeTraits){
                                //      $scope.showTraitsNew.isPTE  = false;
                                // }else if(!nochangeTraits){
                                //      $scope.showTraitsNew.isPTE  = true;
                                // }
                                fetchIntentNotFoundCollection(0, 20, false);
                            }else if($scope.currentTab === "failedTask"){
                                fetchFailedTaskCollection(0, 20, false);
                            }else if($scope.currentTab === "performance"){
                                fetchPerformanceCollection(0, 20, false);
                            }else if($scope.currentTab === "pinned"){
                                fetchPinnedTaskCollection(0, 20, false);
                            }else if($scope.currentTab === "debugLog"){
                                fetchDebugLogCollection(0, 20, false);
                            }
                           }
                            //init();
                            $scope.filterTags = [];
                            $scope.moreFilterValues = [];
                            var sD = new Date($scope.filterComponent.startDate);
                            var eD = new Date($scope.filterComponent.endDate);
                            var timeDiff =  eD.getTime() - sD.getTime();
                            var countDays = timeDiff/ (1000*60*60*24);
                            var daysCount;
                           if(countDays && countDays.toString() && typeof(countDays.toString().split)!=="undefined" && countDays.toString().split(".") && countDays.toString().split(".")[0] && countDays.toString().split(".")[0].length){
                            if(countDays && countDays.toString() && typeof(countDays.toString().split)!=="undefined" &&  countDays.toString().split(".") && countDays.toString().split(".")[1] && countDays.toString().split(".")[1].length){
                                countDays = countDays + 1;
                                daysCount = countDays.toString().split(".")[0];
                            }else{
                                daysCount = countDays.toString().split(".")[0];
                            }
                            }else{
                                daysCount = countDays;
                            }
                            var showCount;
                            if(daysCount && daysCount === "1"){
                             showCount =   daysCount + " Day";
                            }else{
                                showCount =   daysCount + " Days";
                            }
                            // filter tag date
                            if ($scope.filterComponent.days === 7) {
                                if(moment($scope.filterComponent.startDate).format('MM-DD-YYYY') === "Invalid date" && moment($scope.filterComponent.endDate).format('MM-DD-YYYY') === "Invalid date"){
                                    $scope.filterTags.push({'value': i18n.i18nString('last7_days'), 'type': 'date','tooltipValue':$scope.filterComponent.startDate +" - "+ $scope.filterComponent.endDate});
                                }else{
                                    $scope.filterTags.push({'value': i18n.i18nString('last7_days'), 'type': 'date','tooltipValue':moment($scope.filterComponent.startDate).format('MM-DD-YYYY, hh:mm A') +"  to  "+ moment($scope.filterComponent.endDate).format('MM-DD-YYYY, hh:mm A')});
                                }
                            } else if($scope.filterComponent.days === -1){
                                $scope.filterTags.push({'value': i18n.i18nString('custom'), 'type': 'date','tooltipValue':moment(new Date($scope.filterComponent.startDate)).format('MM-DD-YYYY, hh:mm A')+"  to  "+ moment(new Date($scope.filterComponent.endDate)).format('MM-DD-YYYY, hh:mm A'), count:  showCount});
                            } 
                            else {
                                $scope.filterTags.push({'value': i18n.i18nString('last_24_hours'), 'type': 'date','tooltipValue':moment($scope.filterComponent.startDate).format('MM-DD-YYYY, hh:mm A') +"  to  "+ moment($scope.filterComponent.endDate).format('MM-DD-YYYY, hh:mm A')});
                            }

                            //filter tag lanaguage
                            if ($scope.filterComponent.languages && $scope.filterComponent.languages.length && $scope.filterComponent.languages.length > 0) {
                                $scope.filterComponent.selectedLanguagesDisplay = [];
                                var languageCount = 0;
                                _.forEach($scope.filterComponent.languages,function(language){
                                 var lang =$scope.getLanguage(language);
                                 if(languageCount < 5){
                                    $scope.filterComponent.selectedLanguagesDisplay.push(lang);
                                    languageCount++;
                                    }
                                });
                               
                                if($scope.currentTab!== 'performance') {
                                $scope.filterTags.push({'value': i18n.i18nString('Bot_Languages'), 'type': 'language','tooltipValue':$scope.filterComponent.selectedLanguagesDisplay, 'count': $scope.filterComponent.languages.length});
                                $scope.moreFilterValues.push({'value': i18n.i18nString('Bot_Languages'), 'type': 'language','tooltipValue':$scope.filterComponent.selectedLanguagesDisplay, 'count': $scope.filterComponent.languages.length});   
                            }
                                else{
                                    NotificationService.notify(i18n.i18nString('filter_not_applicable_lang')+$scope.filterTab[$scope.currentTab].tab_name+i18n.i18nString('records'),"warning");
                                }
                                
                            }


                            //filter tag userId
                            if ($scope.filterComponent.users && $scope.filterComponent.users.length && $scope.filterComponent.users.length > 0) {
                                $scope.filterComponent.selectedUsersDisplay = [];
                                var userCount = 0;
                                _.forEach($scope.filterComponent.users, function(user){
                                    var  _selected = "";
                                    if(user.value && user.value.length && typeof(user.value.split)!=="undefined" && user.value.split('/') && user.value.split('/').length && user.value.split('/')[1] && user.value.split('/')[1].length){
                                    _selected =  user.value.split('/')[1];
                                    }else if(user && typeof(user.split)!=="undefined" && user.split('/') && user.split('/').length && user.split('/')[1] && user.split('/')[1].length &&  !user.split('/')[2]){
                                        _selected =  user.split('/')[1];
                                    }else if(user && typeof(user.split)!=="undefined" && user.split('/') && user.split('/').length && user.split('/')[1] && user.split('/')[1].length &&  user.split('/')[2]){
                                        _selected =  user.split('/')[2];
                                    }else if(user.id && user.id.length){
                                        _selected =  user.id;
                                    }else if(user.value && user.value.length){
                                        _selected = user.value;
                                    }else{
                                        _selected = user;
                                    }
                                    if(userCount < 5){
                                    $scope.filterComponent.selectedUsersDisplay.push(_selected);
                                    userCount++;
                                    }
                                });
                                $scope.filterTags.push({'value': i18n.i18nString('users'), 'type': 'user', 'count': $scope.filterComponent.users.length,'tooltipValue': $scope.filterComponent.selectedUsersDisplay});
                                $scope.moreFilterValues.push({'value': i18n.i18nString('users'), 'type': 'user', 'count': $scope.filterComponent.users.length,'tooltipValue': $scope.filterComponent.selectedUsersDisplay});
                            }

                            // filter tag tasks
                             /* Task filter is not applicable for intent not found tab */
                            if ($scope.filterComponent.tasks && $scope.filterComponent.tasks.length && $scope.filterComponent.tasks.length > 0) {
                                var taskCount=0;
                                $scope.filterComponent.selectedTasksDisplay = [];
                                _.forEach($scope.filterComponent.taskValues, function(task){
                                    if(taskCount < 5){
                                        $scope.filterComponent.selectedTasksDisplay.push(task);
                                        taskCount++;
                                    }
                                });
                                if($scope.currentTab!== 'intentNotFound') {
                                    $scope.filterTags.push({'value': i18n.i18nString('Tasks_and_languages_label'), 'type': 'task', 'count': $scope.filterComponent.tasks.length, 'tooltipValue':$scope.filterComponent.selectedTasksDisplay});
                                    $scope.moreFilterValues.push({'value': i18n.i18nString('Tasks_and_languages_label'), 'type': 'task', 'count': $scope.filterComponent.tasks.length, 'tooltipValue':$scope.filterComponent.selectedTasksDisplay});
                                }
                                else {
                                    NotificationService.notify(i18n.i18nString('filter_not_applicable_taskname')+$scope.filterTab[$scope.currentTab].tab_name+i18n.i18nString('records'),"warning");
                                }

                            }

                            // filter tag tasks
                            if ($scope.filterComponent.channels && $scope.filterComponent.channels.length && $scope.filterComponent.channels.length > 0) {
                               /* For displaying channel name in tooltip */ 
                               $scope.selectedChannels=[];
                               $scope.filterComponent.selectedChannelsDisplay = [];
                                $scope.filterComponent.channels.forEach(function(value){
                                    $scope.analyzeCB.channelNames.find(function (e) {
                                        if(e.type === value){
                                            $scope.selectedChannels.push(e.value);
                                        }
                                    });                                                         
                                });
                                var channelCount=0;
                                _.forEach($scope.selectedChannels, function(channel){
                                    if(channelCount < 5){
                                        $scope.filterComponent.selectedChannelsDisplay.push(channel);
                                        channelCount++;
                                        }
                                });
                                $scope.filterTags.push({'value': i18n.i18nString('channel_name'), 'type': 'channel','tooltipValue':$scope.filterComponent.selectedChannelsDisplay,'count': $scope.filterComponent.channels.length});
                                $scope.moreFilterValues.push({'value': i18n.i18nString('channel_name'), 'type': 'channel','tooltipValue':$scope.filterComponent.selectedChannelsDisplay,'count': $scope.filterComponent.channels.length});
                            }
                            // filter tag components
                            if ($scope.filterComponent.components && $scope.filterComponent.components.length && $scope.filterComponent.components.length > 0) {
                                if ($scope.currentTab === 'performance'){
                                    $scope.filterComponent.componentsService = [];
                                    $scope.filterComponent.componentsToDisplay= [];
                                    _.forEach($scope.scriptServiceComponents,function(servicecomponent){
                                        _.forEach($scope.filterComponent.components,function(component){
                                            if(servicecomponent._id === component){
                                                $scope.filterComponent.componentsService.push(servicecomponent.name);
                                            }
                                        });
                                    });
                                    var componentCount=0;
                                    _.forEach($scope.filterComponent.componentsService, function(componentService){
                                        if(componentCount < 5){
                                            $scope.filterComponent.componentsToDisplay.push(componentService);
                                            componentCount++;
                                        }
                                    });
                                    $scope.filterTags.push({'value':  i18n.i18nString('Components'), 'type': 'component','count': $scope.filterComponent.components.length, 'tooltipValue':$scope.filterComponent.componentsToDisplay});
                                    $scope.moreFilterValues.push({'value':  i18n.i18nString('Components'), 'type': 'component','count': $scope.filterComponent.components.length, 'tooltipValue':$scope.filterComponent.componentsToDisplay});
                                }
                                else {
                                    NotificationService.notify(i18n.i18nString('filter_not_applicable_component')+$scope.filterTab[$scope.currentTab].tab_name+i18n.i18nString('records'),"warning");
                                }
                            }

                            // filter session Type components
                             if ($scope.filterComponent.sessions && $scope.filterComponent.sessions.length > 0) {
                                $scope.filterTags.push({'value':  i18n.i18nString('Session_type'), 'type': 'sessions','tooltipValue':$scope.filterComponent.sessions,'count': $scope.filterComponent.sessions.length});
                                $scope.moreFilterValues.push({'value':  i18n.i18nString('Session_type'), 'type': 'sessions','tooltipValue':$scope.filterComponent.sessions,'count': $scope.filterComponent.sessions.length});
                            }
                            
                            // filter tag utteranceType
                             /* Utterance  filter is applicable only for intent found tab */
                            if ($scope.filterComponent.utteranceType === 'notTrained' || $scope.filterComponent.utteranceType === 'trained') {
                                if ($scope.currentTab === 'intentFound'){
                                    var tooltip = $scope.filterComponent.utteranceType;
                                    if($scope.filterComponent.utteranceType === 'notTrained') {
                                        tooltip = i18n.i18nString('not_trained');
                                    } else if($scope.filterComponent.utteranceType === 'trained') {
                                        tooltip = i18n.i18nString('trained_label');
                                    }
                                $scope.filterTags.push({'value': i18n.i18nString('utterance_type'), 'type': 'utteranceType','tooltipValue':tooltip});
                                $scope.moreFilterValues.push({'value': i18n.i18nString('utterance_type'), 'type': 'utteranceType','tooltipValue':tooltip});  
                            }
                                else{
                                    NotificationService.notify(i18n.i18nString('filter_not_applicable_utterance')+$scope.filterTab[$scope.currentTab].tab_name+i18n.i18nString('records'),"warning");
                                }
                            }

                            // filter tag ambiguousType
                             /* Ambiguous filter is applicable only for intent not found tab */
                            if ($scope.filterComponent.isAmbiguous === 'hideAmbiguous'|| $scope.filterComponent.isAmbiguous === 'showAmbiguous') {                     
                                    if ( $scope.currentTab === 'intentNotFound'){
                                    $scope.filterTags.push({'value': i18n.i18nString('ambiguous_type'), 'type': 'ambiguousType','tooltipValue':$scope.filterComponent.isAmbiguous});
                                    $scope.moreFilterValues.push({'value': i18n.i18nString('ambiguous_type'), 'type': 'ambiguousType','tooltipValue':$scope.filterComponent.isAmbiguous});
                                } 
                                else{
                                    NotificationService.notify(i18n.i18nString('filter_not_applicable_ambiguous')+$scope.filterTab[$scope.currentTab].tab_name+i18n.i18nString('records'),"warning");
                                }
                            } 
                            // filter developer interactions
                            if (!$scope.filterComponent.isDeveloper && typeof($scope.filterComponent.isDeveloper) !== "undefined") {
                                $scope.filterTags.push({'value': i18n.i18nString('Developer_Interactions'), 'type': 'isDeveloper', 'tooltipValue': 'Excluded'});
                                $scope.moreFilterValues.push({'value': i18n.i18nString('Developer_Interactions'), 'type': 'isDeveloper', 'tooltipValue': 'Excluded'});
                            }
                            // filter custom tags
                             /* Custom tag  filter is not applicable for Debug log tab */
                            if ($scope.filterComponent.tags && $scope.filterComponent.tags.and && $scope.filterComponent.tags.and.length) {                               
                                if($scope.currentTab !== 'debugLog') {
                                    $scope.selectedFilterTags = [];
                                    $scope.selectedFilterTagsValues = [];
                                    var tagsCount = 0;
                                    _.forEach($scope.filterComponent.tags.and, function(tag){
                                        var _selectedTagName = "";
                                        var selectedTagValue = "";
                                        selectedTagValue = tag.values;
                                        _selectedTagName= tag.name;
                                        if(tagsCount < 5){
                                            $scope.selectedFilterTags.push(_selectedTagName+":"+selectedTagValue);
                                            tagsCount++;
                                            }
                                    });
                                $scope.filterTags.push({'value': i18n.i18nString('custom_tags'), 'type': 'customTags','count': $scope.filterComponent.tags.and.length, 'tooltipValue': $scope.selectedFilterTags});
                                $scope.moreFilterValues.push({'value': i18n.i18nString('custom_tags'), 'type': 'customTags','count': $scope.filterComponent.tags.and.length, 'tooltipValue': $scope.selectedFilterTags});
                            }
                                else{
                                    NotificationService.notify(i18n.i18nString('filter_not_applicable_custom')+$scope.filterTab[$scope.currentTab].tab_name+i18n.i18nString('records'),"warning");
                                }
                            }

                        };
                        $scope.removeFilterTag = function (index, tag) {                          
                            if (tag.type === "date") {               
                                $scope.filterComponent.endDate = moment().format('MM-DD-YYYY');
                                $scope.filterComponent.startDate = moment().subtract(1, 'd').format('MM-DD-YYYY');
                                $scope.filterComponent.days = 1;
                                $scope.filterSaveDefaultValue.days = 1;

                                /* To automatically apply default 7 days filter in filter tag */
                                if (tag.type === "date" && tag.value !== "last 7 days") {               
                                    $scope.filterTags.push({'value': i18n.i18nString('last_24_hours'), 'type': 'date','tooltipValue':moment($scope.filterComponent.startDate).format('MM-DD-YYYY, hh:mm A') +"  to  "+ moment($scope.filterComponent.endDate).format('MM-DD-YYYY, hh:mm A')});                              
                                }
                            } else if (tag.type === "language") {
                                $scope.filterComponent.languages = [];
                            } else if (tag.type === "user") {
                                $scope.filterComponent.users = [];
                                $scope.filterSaveDefaultValue.excludeChannelUIds = [];
                                $scope.filterSaveDefaultValue.excludeUserIds = [];
                                $scope.filterSaveDefaultValue.channelUIds = [];
                                $scope.filterSaveDefaultValue.koreUIds = [];
                            } else if (tag.type === "task") {
                                $scope.filterComponent.tasks = [];
                            } else if (tag.type === "channel") {
                                $scope.filterComponent.channels = [];
                            } else if (tag.type === "sessions") {
                                $scope.filterComponent.sessions = [];
                            } else if (tag.type === "component") {
                                $scope.filterComponent.components = [];
                            } else if(tag.type === "utteranceType") {
                                $scope.filterComponent.utteranceType = "both";
                            } else if(tag.type === "isDeveloper") {
                                $scope.filterComponent.isDeveloper = true;
                            } else if(tag.type === "customTags") {
                                $scope.selectedTagsArray = [];
                                $scope.selectedTagsArray.push({name:"",values:[],type:"",isContains:{ "id":"contain","label":"Contain","isInclude":true}});
                                $scope.filterComponent.tags.and = [];
                                $scope.filterSaveDefaultValue.tags = [];
                            } else if(tag.type === "ambiguousType"){
                                $scope.filterComponent.isAmbiguous = "showAll";
                            }
                            /* To show toast message for removing default 7 days filter from filter tag */
                            if (tag.value && tag.value === "last 7 days"){
                                NotificationService.notify(i18n.i18nString( 'date_filter_warning'),"warning");
                            }
                            else
                            {
                            $scope.filterTags.splice(index, 1);
                            $scope.moreFilterValues.splice(index, 1);
                            if($scope.filterTags.length === 0 || $scope.moreFilterValues.length === 0) {
                                $scope.clearFilterTags();
                            }
                            init();
                           
                            }
                            
                            
                        };
                        $scope.clearFilterTags = function () {               
                            $scope.filterTags = [];
                            $scope.moreFilterValues = [];
                            $scope.filterComponent = {'users': [], 'endDate': moment().format('MM-DD-YYYY'), 'components': [], 'startDate': moment().subtract(1, 'd').format('MM-DD-YYYY'), 'languages': [], 'channels': [], 'tasks': [], 'utteranceType': 'both','isAmbiguous':'showAll', 'customTags': "", 'days': 7,'isDeveloper':true,'tags':{'and':[]},'tagsObj':$scope.filterComponent.tagsObj,'sessions':[]};
                            $scope.selectedTagsArray = [];
                            $scope.filterSaveDefaultValue = {};
                            var dateObj = getISOdates(7);   
                            $scope.filterSaveDefaultValue ={
                                "filterAt": "NLPMetrics",
                                "koreUIds": [],
                                "channelUIds": [],
                                "taskNames": [],
                                "utterenceType": "both",
                                "channels": [],
                                "language": [],
                                "excludeUserIds": [],
                                "excludeChannelUIds": [],
                                "ambiguous": "showAll",
                                "from": dateObj.from,
                                "to": dateObj.to,
                                "isDeveloper": true,
                                "tags": [],
                            };
                            $scope.filterSaveDefaultValue.days = 7;
                            $scope.selectedTagsArray.push({name:"",values:[],type:"",isContains:{ "id":"contain","label":"Contain","isInclude":true}});
                            $scope.defaultFilter = true;
                            if(userInform && userInform.currentAccount && userInform.currentAccount.userInfo && userInform.currentAccount.userInfo.personalInfo && userInform.currentAccount.userInfo.personalInfo.language && userInform.currentAccount.userInfo.personalInfo.language ==="ja"){
                                $scope.defaultFilter = false;
                                $scope.showJapaneseFilter = true;
                                $scope.tooltipValue = $scope.filterComponent.startDate +" - "+ $scope.filterComponent.endDate;
                                $scope.dateValue = i18n.i18nString('last_24_hours');
                            }  
                            init();
                        };
                        $scope.getEmail = function (userId) {
                            // if ($scope.users.length > 0) {
                            //     var entry = $scope.users.find(function (e) {
                            //         return e._id === userId;
                            //     });
                            //     if (entry && entry.emailId) {
                            //         return entry.emailId;
                            //     } else if(entry && entry._id) {
                            //         return entry._id;
                            //     }else{
                            //         return userId || "---";
                            //     }
                            // }
                            return userId || "---";
                        };
                        $scope.getLanguage = function (code) {
                            if (!code) {
                                return "---";
                            }
                            code = code.toLowerCase();
                            if ($scope.languageCodes[code] && $scope.languageCodes[code] !== "") {
                                return $scope.languageCodes[code];
                            } else {
                                return "---";
                            }
                        };
                        $scope.getTaskName = function (taskId,task) {
                            if(task && task.resourceInfo && task.resourceInfo.type === 'SMALLTALK'){
                                    return task.resourceInfo.name;
                            }
                            if(!taskId || !task){
                                return "---";
                            }
                            var linkedBotName = "";
                            if ($scope.tasks.length > 0) {
                                var currentLanguage = $workflowService.currentLanguage();
                                $scope.currentBotLanguage = $workflowService.currentLanguage();
                                var entry;
                                if(task && ( task.taskType==='alert' || task.taskType==='action' || task.taskType==='information')){
                                    entry = $scope.tasks.find(function (e) {
                                        return e._id === taskId;
                                         });
                                } else if (task && task.taskType !=='FAQ' && taskId.indexOf('dg-')=== -1){
                                    entry = $scope.tasks.find(function (e) {
                                    return e.refId === taskId;
                                });
                                }else {
                                    entry = $scope.tasks.find(function (e) {
                                    return e._id === taskId;
                                     });
                                }
                                if(!entry && !task.linkedBotId){
                                    if(task.taskType=='FAQ'){
                                        return i18n.i18nString('deleted_faq',{dyn: taskId});
                                    }else {
                                        return i18n.i18nString('deleted_task',{dyn: taskId});
                                    }
                                }
                                
                                if(task && task.taskType=='FAQ'){    //universal bot will not have FAQs so we can directly takee the question 
                                    if($scope.stream.type === 'universalbot' && task && task.linkedBotId) {
                                        var faQresult = $.grep($scope.linkedBots, function(e){ return e._id === task.linkedBotId; });
                                        if(faQresult && faQresult.length>0) {
                                            linkedBotName += faQresult[0].botName+" : ";
                                        }
                                        else if(task.linkedBotId === $scope.stream._id) {
                                            linkedBotName += $scope.stream.name+" : ";
                                        }
                                        return linkedBotName+""+((entry && entry.questionPayload)? entry.questionPayload.question: i18n.i18nString('deleted_faq',{dyn: taskId}));
                                    }else if (entry && entry._id && entry.questionPayload && entry.questionPayload.question){
                                        return entry.questionPayload.question || "---";
                                    }
                                }else if (entry && entry._id && entry.localeData && entry.localeData[currentLanguage]) {
                                    if($scope.stream.type === 'universalbot' && task && task.linkedBotId) {
                                        var result = $.grep($scope.linkedBots, function(e){ return e._id === task.linkedBotId; });
                                        if(result && result.length>0) {
                                            linkedBotName += result[0].botName+" : ";
                                        }
                                        else if(task.linkedBotId === $scope.stream._id) {
                                            linkedBotName += $scope.stream.name+" : ";
                                        }
                                    }
                                    return linkedBotName+""+((entry && entry.localeData && entry.localeData[currentLanguage].name) || i18n.i18nString('deleted_task',{dyn: taskId}));
                                } else {
                                    if(task && task.taskType=='FAQ'){
                                        return i18n.i18nString('deleted_faq',{dyn: taskId});
                                    }else if (task && (task.taskType == 'dialog' || task.taskType == 'action' || task.taskType == 'alert')){
                                        return  i18n.i18nString('deleted_task',{dyn: taskId});
                                    } else {
                                        return "---";
                                    }
                                }
                            } else {
                                if($scope.stream.type === 'universalbot' && task && task.linkedBotId){
                                    var result1 = $.grep($scope.linkedBots, function(e){ return e._id === task.linkedBotId; });
                                        if(result1 && result1.length>0) {
                                            linkedBotName = result1[0].botName+" : ";
                                        }
                                        else if(task.linkedBotId === $scope.stream._id) {
                                            linkedBotName = $scope.stream.name+" : ";
                                        }
                                    if(task && task.taskType=='FAQ'){
                                        return (linkedBotName || "")+i18n.i18nString('deleted_faq',{dyn: taskId});
                                    }else if ( task && (task.taskType == 'dialog' || task.taskType == 'action' || task.taskType == 'alert')){
                                        return (linkedBotName || "")+i18n.i18nString('deleted_task',{dyn: taskId});
                                    } else {
                                        return "---";
                                    }
                                }
                                if(task && task.taskType=='FAQ'){
                                    return i18n.i18nString('deleted_faq',{dyn: taskId});
                                }else if ( task && (task.taskType == 'dialog' || task.taskType == 'action' || task.taskType == 'alert')){
                                    return i18n.i18nString('deleted_task',{dyn: taskId});
                                } else {
                                    return "---";
                                }
                                
                            }
                        };
                        $scope.getComponentName = function (compId) {
                            if ($scope.components.length > 0) {
                                var entry = $scope.components.find(function (e) {
                                    return e._id === compId;
                                });
                                if (entry && entry._id) {
                                    return entry.name;
                                } else {
                                    return "---";
                                }
                            } else {
                                return "---";
                            }
                        };
                        $scope.getSuccessRatio = function (total, successCount) {
                            if (!total || !successCount) {
                                return 0;
                            }
                            if (successCount > 0) {
                                return (total * 100.0) / successCount;
                            } else {
                                return 0;
                            }
                        };
                        $scope.getTaskErrorTitle = function (records) {
                            if (!records) {
                                return "";
                            }
                            var count = 0;
                            records.records.forEach(function (obj) {
                                if (!obj.wasSuccessfull) {
                                    count++;
                                }
                            });
                            if (count >= 3) {
                                return "" + count +  i18n.i18nString( 'sucessive_failure_uccurred');
                            } else {
                                return "---";
                            }
                        };
                        function initFirstTab(classname) {
                            setTimeout(function () {
                                var ele = $('.' + classname + ' ul li').first();
                                ele.find('a').trigger('click');
                            }, 350);
                        }
                        $scope.editTask = function (task, type, e) {
                            if($scope.showTraitsNew.isPTE){
                                $scope.editTaskLoading = false;
                            }
                            if (type === 'performance') {
                                $scope.analyzeCB.filterComponent = angular.copy($scope.filterComponent);
                                $scope.analyzeCB.reloadTask(task, type, null,"---","","", $scope.analyzeCB.showExcludeText);
                                $(".analyzeEditTask").modal("show");
                                initFirstTab('serviceContainer');
                                if(task.logType === "script" || task.logType === "webhook" ){
                                    $(".statusCode").hide();
                                    $(".getStatusCode").hide();
                                }else{
                                    $(".statusCode").show();
                                    $(".getStatusCode").show();
                                }
                            } else if(type === 'debugLog') {
                                $scope.analyzeCB.filterComponent = angular.copy($scope.filterComponent);
                                task.input = "debuglog";
                                task.resourceInfo = {type: 'debuglog', name: 'testdebug'};
                                task.messageId = task.messageStoreId;
                                if(!task.hasOwnProperty('flow')) {
                                    task.flow = [];
                                }
                                task.language = $scope.getLanguage(task.botLanguage);
                                $scope.analyzeCB.reloadTask(task, type, task,$scope.getTaskName(task.taskId,task),task, $scope.tasksValue);
                                $(".analyzeEditTask").modal("show");
                                initFirstTab('editTaskBody');
                            }else {
                                setTimeout(function(){
                                if($(".traits .kr-sg-dropdowns .dropdown.dropdown-open.open").length){
                                    $(".analyzeEditTask").modal("hide");
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    return false;
                                }else{
                                $scope.editTaskLoading = true;
                                var payload = {};
                                payload.botAnalyticsId = task._id;
                                $q.all([BTStreamsService.getAnalysisDetails($scope.stream._id, task.koralogstatusId), BTStreamsService.analyzeRecordTags($scope.stream._id,payload)]).then(function (res) {
                                    $scope.currTask = task;
                                    $scope.analyzeCB.reloadTask(res[0].data, type, task,$scope.getTaskName(task.taskId,task),res[1].data, $scope.tasksValue);
                                    $scope.editTaskLoading = false;
                                    $(".analyzeEditTask").modal("show");
                                    initFirstTab('editTaskBody');
                                }, function (error) {
                                    $scope.loading = false;
                                    $scope.editTaskLoading = false;
                                });
                                }
                               },0);
                            }
                        };
                        $scope.updatePage = function (tab, type) {
                            $timeout(function () {
                                if (tab === 'successIntent') {
                                    if (type !== 'toggle') {
                                        $scope.dataAvailble.successIntent.sortby = type;
                                    }
                                    fetchIntentFoundCollection(0, 20, false);
                                } else if (tab === 'failedIntent') {
                                    if (type !== 'toggle') {
                                        $scope.dataAvailble.failedintent.sortby = type;
                                    }
                                    fetchIntentNotFoundCollection(0, 20, false);
                                } else if (tab === 'failed') {
                                    if (type !== 'toggle') {
                                        $scope.dataAvailble.failed.sortby = type;
                                    }
                                    fetchFailedTaskCollection(0, 20, false);
                                } else if (tab === 'performance') {
                                    if (type !== 'toggle') {
                                        $scope.dataAvailble.performance.sortby = type;
                                    }
                                    fetchPerformanceCollection(0, 20, false);
                                } else if (tab === 'pinned') {
                                    if (type !== 'toggle') {
                                        $scope.dataAvailble.pinned.sortby = type;
                                    }
                                    fetchPinnedTaskCollection(0, 20, false);
                                } else if (tab === 'debugLog') {
                                    if (type !== 'toggle') {
                                        $scope.dataAvailble.logs.sortby = type;
                                    }
                                    fetchDebugLogCollection(0, 20, false);
                                }
                            }, 350);
                        };
                        $scope.updateUserName = function(type){
                            if(type === "koreID"){
                                $scope.analyzeCB.toShowKoreID = true;
                            }else{
                                $scope.analyzeCB.toShowKoreID = false;
                            }
                        };
                        $scope.updateCurrentTab = function (type) {                           
                            $scope.currentTab = type;
                            if(type == 'intentFound') {
                                $scope.regroupDone.message = false;
                            }
                     /* Added logic to retain applicable filter and remove non applicable filter while changing tab by calling applyFilter()  */
                            if(!$scope.defaultFilter) {  
                            $scope.analyzeCB.applyFilter($scope.filterComponent,false,$scope.filterSaveDefaultValue);
                            }
                            // else if(Object.keys($scope.filterSaveDefaultValue).length){
                            //     analyzeDefaultFilter(type);
                            // }
                            else {
                            if (type === 'intentFound') {
                                $scope.intentFoundCollection = [];
                                $scope.regroupDone.message = false;
                                $scope.regroupDone.progress = false;
                                fetchIntentFoundCollection(0, 20, false);
                            } else if (type === 'intentNotFound') {
                                $scope.intentNotFoundCollection = [];
                                fetchIntentNotFoundCollection(0, 20, false);
                            } else if (type === 'failedTask') {
                                $scope.failedTaskCollection = [];
                                fetchFailedTaskCollection(0, 20, false);
                            } else if (type === 'performance') {
                                $scope.performanceCollection = [];
                                fetchPerformanceCollection(0, 20, false);
                            } else if (type === 'pinned') {
                                $scope.pinnedTasksCollection = [];
                                fetchPinnedTaskCollection(0, 20, false);
                            } else if (type === 'debugLog') {
                                $scope.debugLogsCollection = [];
                                fetchDebugLogCollection(0, 20, false);
                            }
                            // $scope.analyzeCB.toShowKoreID = false;
                            }
                        };
                        function handleGroupedTasks() {
                            setTimeout(function () {
                                $('.groupByTask').click(function (e) {
                                    e.stopImmediatePropagation();
                                    e.stopPropagation();
                                    if($scope.performanceCollection){
                                        if($(this).closest('.parentGroupDivBlock').attr('parentindex') && $scope.performanceCollection[$(this).closest('.parentGroupDivBlock').attr('parentindex')]){
                                            $scope.performanceCollection[$(this).closest('.parentGroupDivBlock').attr('parentindex')].isOpen = true;
                                        }
                                    }
                                    $(this).closest('.parentGroupDivBlock').toggleClass('active');
                                    $(this).closest('.eachTableRow').siblings('.grouped').toggleClass('groupedElements');
                                    $(this).closest('.eachTableRow').siblings('.grouped').slideToggle();
                                });
                                $('.fa-compress').click(function (e) {
                                    e.stopImmediatePropagation();
                                    e.stopPropagation();
                                    if($scope.performanceCollection){
                                        if( $(this).closest('.parentGroupDivBlock').attr('parentindex') && $scope.performanceCollection[$(this).closest('.parentGroupDivBlock').attr('parentindex')]){
                                            $scope.performanceCollection[$(this).closest('.parentGroupDivBlock').attr('parentindex')].isOpen = false;
                                        }
                                    }
                                    $(this).closest('.parentGroupDivBlock').toggleClass('active');
                                    $(this).closest('.parentGroupDivBlock').find('.grouped').toggleClass('groupedElements');
                                    $(this).closest('.parentGroupDivBlock').find('.grouped').slideToggle();
                                });
                            }, 1500);
                        }

                        var formContainerEle = $("#intentFoundContainer");
                        formContainerEle.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.dataAvailble.successIntent.moreAvailable) {
                                    fetchIntentFoundCollection($scope.intentFoundCollection.length, 20, true);
                                }
                            }
                        });
                        var intentNotFoundContainer = $("#intentNotFoundContainer");
                        intentNotFoundContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.dataAvailble.failedintent.moreAvailable) {
                                    fetchIntentNotFoundCollection($scope.intentNotFoundCollection.length, 20, true);
                                }
                            }
                        });
                        var failedTaskContainer = $("#failedTaskContainer");
                        failedTaskContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.dataAvailble.failed.moreAvailable) {
                                    fetchFailedTaskCollection($scope.failedTaskCollection.length, 20, true);
                                }
                            }
                        });
                        var performanceContainer = $("#performanceContainer");
                        performanceContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.dataAvailble.performance.moreAvailable) {
                                    fetchPerformanceCollection($scope.performanceCollection.length, 20, true);
                                }
                            }
                        });
                        var pinnedContainer = $("#pinnedContainer");
                        pinnedContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.dataAvailble.pinned.moreAvailable) {
                                    fetchPinnedTaskCollection($scope.pinnedTasksCollection.length, 20, true);
                                }
                            }
                        });
                        var debugLogsContainer = $("#debugLogsContainer");
                        debugLogsContainer.on("scroll", function (event) {
                            if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                                if ($scope.dataAvailble.logs.moreAvailable) {
                                    fetchDebugLogCollection($scope.debugLogsCollection.length, 20, true);
                                }
                            }
                        });
                        function initiateScrolls() {
                            $("#intentFoundContainer").scrollTop(2);
                            $("#intentNotFoundContainer").scrollTop(2);
                            $("#failedTaskContainer").scrollTop(2);
                            $("#performanceContainer").scrollTop(2);
                            $("#pinnedContainer").scrollTop(2);
                            $("#debugLogsContainer").scrollTop(2);
                        }
                        //init();
                        initFirstTabData();
                                  //used while builder is resuming//
                                $scope.$emit('nestedComponentLoaded', { 'id': 'analyze', 'flag': false });

                    }],
                link: function ($scope, $ele, $attrs) {

                }
            };
        }]);
}(angular));


;(function(ng) {

	'use strict';

    var _module = ng.module('bt-app-create',[]);

	_module.controller('BTAppCreateCtrl', ['$scope','$translator','$modalInstance','avalSreams','config','$filter','$rootScope', '$routeParams', '$timeout', '$location', '$workflowService', 'BTSeedDataService', 'NotificationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService','$applicationService','i18n', 'env_conf',
	function($scope,$translator,$modalInstance,avalSreams,config,$filter,$rootScope, $routeParams, $timeout, $location, $workflowService, BTSeedDataService, NotificationService, BTAlertsService, BTActionsService, BTStreamsService,$applicationService,i18n, env_conf) {
            $scope.config=config;
            $scope.categoryConfig = {
                allowclear: true,
                multiple: true,
                placeholder: 'Select Bots'
            };

            $scope.edit      = i18n.i18nString('edit');
            $scope.createNew = i18n.i18nString('create_new');
            $scope.stream = $workflowService.selectedStream();
            $scope.algthms = [
                {
                    id: 'RS256',
                    label: 'RS256'
                }, {
                    id: 'HS256',
                    label: 'HS256'
                }];
            $scope.assetsBase = env_conf['assets-url'];
            $scope.jweEnforce = {isJtiEnforced: false, isJweEnforced: false};


            $scope.init = function () {
                var clipB=new Clipboard('[data-clipboard-target]');
                $scope.selectedBots = [];
                $scope.availableBots = avalSreams;
                $scope.anonyChat = true;
                $scope.newUser = true;
                $scope.headerTitle = config.type;
                //$scope.confirmApp = true;               
                if (config.type === 'Edit') {
                    $scope.loadApp(config.app);
                }

                if (config.context && config.context === 'addChannel') {
//                    var _botIndex = _.findIndex($scope.selectedBots, function (item) {
//                        return item._id === config.bot._id;
//                    });
//                    
                     var _botIndex=$scope.selectedBots.indexOf(config.bot._id);
                    if (_botIndex < 0) {
                        $scope.selectedBots.push(config.bot._id);
                    }
                }
            };


            $scope.createApplication = function () {

                var _params={},_urlParams={streamId:$workflowService.selectedStream()._id};

                _params.appName=$scope.appName;

                _params.algorithm=$scope.selectedAlg.id;

                if(_params.algorithm==='RS256'){
                  _params.key=$scope.publicKey;
                }

                _params.scope=[];

                if($scope.anonyChat){
                    _params.scope.push('anonymouschat');
                }

                if($scope.newUser){
                    _params.scope.push('registration');
                }
                _params.bots = $scope.selectedBots;
                
                _params.pushNotifications = {enable: false, webhookUrl: ''};
                if ($scope.pushNotification) {
                    _params.pushNotifications.enable = true;
                    _params.pushNotifications.webhookUrl = $scope.pushUrl;
                }
                 
                $scope.saveInProgress=true;

                var svcname = 'bt.apps.create';
                if ($applicationService.userInfo().appControls && $applicationService.userInfo().appControls.isManaged) {
                    svcname = 'bt.org.apps.create';
                }
                if (config.type === 'Edit') {
                    svcname = 'bt.apps.edit';
                    if ($applicationService.userInfo().appControls && $applicationService.userInfo().appControls.isManaged) {
                        svcname = 'bt.org.apps.edit';
                    }
                    _urlParams.appId = config.app.clientId;
                    _urlParams.streamId = $scope.stream._id;
                }

                if($scope.jweEnforce.isJtiEnforced) {
                    _params.isJtiEnforced =  true;
                } else {
                    _params.isJtiEnforced =  false;
                }
                if($scope.jweEnforce.isJweEnforced) {
                    _params.isJweEnforced =  true;
                } else {
                    _params.isJweEnforced =  false;
                }

                $translator.translate(svcname, _urlParams, _params).then(
                        function (res) {
                            if (res && res.data && res.status === 200) {
                                $scope.saveInProgress = false;
                                
                                var botsMap = _.indexBy($scope.availableBots,'_id');                              
                                var bots = [];
                                res.data.bots.forEach(function (botId) {
                                    bots.push(botsMap[botId]);
                                });                              
                                res.data.bots=bots;
                                
                                $scope.appNameConfirm = res.data.appName;
                                $scope.clientId = res.data.clientId;
                                $scope.secretKey =res.data.clientSecret;
                                $scope.secretKeyUI = maskStr($scope.secretKey);
                                $rootScope.$emit('app.created');
                                if (config.context && config.context === 'addChannel') {
                                    var _msg = 'app.created';
                                    if (config.type === 'Edit') {
                                        _msg = 'app.edited';
                                    }
                                    config.cb(_msg, res.data);
                                    $scope.closeModal();
                                } else {
                                    $scope.confirmApp = true;
                                }                              
                            } else {
                                $scope.saveInProgress = false;
                                NotificationService.notify(i18n.i18nString('App_Already_Exists'),'error');
                            }


                        }, function (errRes) {
                            $scope.saveInProgress = false;
                            if(errRes && errRes.data && errRes.data.errors){
                                if(errRes.data.errors.length && errRes.data.errors[0].code==="AppAlreadyExists"){
                                    NotificationService.notify(i18n.i18nString('App_Already_Exists'),'error');
                                } else {
                                    NotificationService.notify(errRes.data.errors[0].msg,'error');
                                }
                            } else {
                                NotificationService.notify(i18n.i18nString('error_alert'),'error');
                            }
                            // alert(i18n.i18nString('error_alert'));

                }
                );


            };

            $scope.loadApp = function (app) {
                $scope.appName=app.appName;
                $scope.jweEnforce = {isJtiEnforced: app.isJtiEnforced, isJweEnforced: app.isJweEnforced};
                if(app.scope.indexOf('anonymouschat')<0){
                    $scope.anonyChat=false;
                }
                if(app.scope.indexOf('registration')<0){
                    $scope.newUser=false;
                }

                $scope.selectedAlg = {id: app.algorithm, label: app.algorithm};
                $timeout(function () {
                    if (app.algorithm === 'RS256') {
                        $scope.publicKey = app.key;
                    }
                }, 100);
                if (app.pushNotifications) {
                    $scope.pushNotification = app.pushNotifications.enable;
                    $timeout(function () {
                        if (app.pushNotifications.enable) {
                            $scope.pushUrl = app.pushNotifications.webhookUrl;
                        }
                    }, 100);
                }
                $scope.selectedBots=_.pluck(app.bots, '_id');

            };


            $scope.closeModal = function () {
                 $modalInstance.close();
            };

            $scope.showHideSecret=function(){
                $scope.secretKeyUI=$scope.secretKey;
                $scope.secretKeyShown=true;
            };
            $scope.refreshSecretToken=function(){
                $scope.secretKeyInProgress=true;
                $scope.secretKeyShown=false;

                var svcname = 'bt.apps.regenerate.key';
                if ($applicationService.userInfo().appControls && $applicationService.userInfo().appControls.isManaged) {
                    svcname = 'bt.org.apps.regenerate.key';
                }

                $translator.translate(svcname, {appId:$scope.clientId,streamId:$workflowService.selectedStream()._id}, {}).then(
                        function (res) {
                            if (res && res.data && res.status === 200) {
                              $scope.secretKey=res.data.clientSecret;
                              $scope.secretKeyUI = maskStr($scope.secretKey);
                              $scope.secretKeyInProgress=false;
                              $rootScope.$emit('app.updated');

                            } else {
                                 $scope.secretKeyInProgress=false;
                                // alert(i18n.i18nString('error_alert'));
                                NotificationService.notify(i18n.i18nString('error_alert'),'error');
                            }


                        }, function (errRes) {
                            $scope.secretKeyInProgress=false;
                    // alert(i18n.i18nString('error_alert'));
                            if(errRes && errRes.data && errRes.data.errors.length){
                                NotificationService.notify( errRes.data.errors[0].msg, 'error');
                        }else{
                            NotificationService.notify(i18n.i18nString('error_alert'),'error');
                        }
                }
                );
            };

            function maskStr(str){
                return Array(str.length).join('*');
            }

             $scope.init();

	}]);

})(angular);


;(function (ng) {

    'use strict';

    var _module = ng.module('bt-app-view',[]);


    _module.controller('BTAppViewCtrl', ['$scope', '$modalInstance','config',
        function ($scope,$modalInstance,config) {
            $scope.app = config.app;
            $scope.closeModal = function () {
                $modalInstance.close();
            };
        }]);

})(angular);


;(function (ng) {

    var _mod = ng.module('bt-bot-publish', []);
    _mod.directive('btBotPublish', [function () {

            return {
                restrict: 'EA',
                templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-bot-publish/bt-bot-publish.html',
                controller: 'BTBotPublishCtrl',
                scope:{
                    onClose:'='
                }

            };

        }]);

    _mod.controller('BTBotPublishCtrl',
            ['$scope', '$rootScope', '$q', 'env_conf', '$routeParams', '$location', '$applicationService', '$translator', 'BTAlertsService', 'BTActionsService', 'BTFlowtaskService', 'BTStreamsService', 'BTTeamsService', 'NotificationService', 'BTParamMapService', 'form_util', '$workflowService', 'flowsUtil', '$timeout', 'BTIdpService', 'BTFileUploadService','$element','localstore','i18n',
                function ($scope, $rootScope, $q, env_conf, $routeParams, $location, $applicationService, $translator, BTAlertsService, BTActionsService, BTFlowtaskService, BTStreamsService, BTTeamsService, NotificationService, BTParamMapService, form_util, $workflowService, flowsUtil, $timeout, BTIdpService, BTFileUploadService,$element,localstore,i18n) {

                    $scope._constants_ = $rootScope._constants_;
                    $scope.stream = $workflowService.selectedStream();

                    $scope.seedSupportedLanguages = $workflowService.seedData().supportedLanguages;

                    $scope.selectedStream = $scope.stream;
                    $scope.stream.showInMp = $scope.stream.showInMp || false;
                    $scope.authLists = null;
                    $scope.dataloaded = false;
                    // $scope.enableTryMode = _.isUndefined($scope.stream.canTryOut) ? false : $scope.stream.canTryOut;
                    $scope.needAuth = false;
                    //$scope.$apply();
                    $scope.isTryModeUpdated = false;
                    $scope.account = [];
                    $scope.trymodecallback = {};

                    $scope.currentStep = 0;
                    $scope.steps = [];
                    $scope.tryMode = false;
                    $scope.alertDialogMappingsToPublish = [];
                    $scope.publishInProgress=false;
                    var currentUser = localstore.getAuthData().currentAccount;

                    $scope.alertTasks =i18n.i18nString('alertTasks_ready_for_deployment');
                    $scope.actionTasks = i18n.i18nString('actionTasks_ready_for_deployment');
                    $scope.dialogTasks = i18n.i18nString('dialogTasks_ready_for_deployment');
                    $scope.taskFlows  =i18n.i18nString('tasks_and_flows');
                    $scope.upgradeLabel = i18n.i18nString('upgrade');
                    $scope.new_deployment_label = i18n.i18nString('new_deployment_label');
                    $scope.smart_bot_desc_label = i18n.i18nString('smart_bot_desc_label');
                    $scope.sample_bot_desc_label = i18n.i18nString('sample_bot_desc_label');
                    $scope.configuration_instructions_label = i18n.i18nString('configuration_instructions_label');
                    $scope.configuration_instructions_url =i18n.i18nString('configuration_instructions_url');
                    $scope.enabled = i18n.i18nString('enabled');
                    $scope.disabled = i18n.i18nString('disabled');
                    $scope.saving = i18n.i18nString('saving');  
                    $scope.save   = i18n.i18nString('save'); 
                    $scope.smartBotDesc  = i18n.i18nString('enter_desc_for_smartBot_placeholder');
                    $scope.sampleBotDesc = i18n.i18nString('sample_bot_desc_placeholder');
                    
                    $scope.isDomainKore = currentUser.domain.split('.')[0] === 'kore';

                    $scope.showVisibilty = function () {
                        return ($rootScope.wfAdmin) &&
                                ($scope.stream.purpose === 'customer') &&
                                ($scope.stream.publishType === "standardbot") &&
                                (!$scope.stream.isInMarket);
                    };
                    
                    $scope.showVisibiltyForSmartBot = function () {
                        return ($rootScope.wfAdmin) &&
                                ($scope.stream.publishType === "smartbot") &&
                                (!$scope.stream.isInMarket) &&
                                ($scope.isDomainKore);
                    };

                    function isUpgrade() {
                        var istasksUpgraded = false;
                        for (var i = 0; i < $scope.tasks.length; i++) {
                            if ($scope.tasks[i].parentId) {
                                istasksUpgraded = true;
                                break;
                            }
                        }
                        return istasksUpgraded;
                    }
                    $scope.changeVisibility = function () {
                        BTStreamsService.editStream($scope.stream._id, {showInMp: $scope.stream.showInMp})
                                .then(function (response) { // success
                                    $workflowService.selectedStream(angular.extend($scope.stream, response.data));
                                }, function (res) { // error
                                    NotificationService.notify(res.data.errors[0].msg, 'error');
                                });
                    };
                    
                    $scope.bulbSvg = env_conf['context-url']+'/assets/images/bulbicon.svg';

                    function stepObject(id, name, active) {
                        this.name = name;
                        this.id = id;
                        this.active = active;
                    }

                    prepareStepsAndViews();
                    $scope.btTestFormApi = {};
                    $scope.btTestStatus = {};

                    if (Object.keys($scope.stream).length === 0) {
                        $location.path(window.appConfig.CONTEXT_PATH);
                        return;
                    }

                    // BTStreamsService.getAuthinfo($workflowService.selectedStream()._id)
                    //         .then(function (res) {
                    //             $scope.authLists = res.data;
                    //             $scope.idpConfigs = [];
                    //             if ($scope.authLists) {
                                    
                    //                 $.each($scope.authLists, function(i, authData){
                    //                     BTIdpService.getIdpByName(authData.idpName,$workflowService.selectedStream()._id)
                    //                         .then(function (res) {
                    //                            // $scope.idpConfig = res.data;
                    //                            $scope.idpConfigs.push(res.data);
                    //                         }, function (err) {
                    //                            // $scope.idpConfig = {};
                    //                            $scope.idpConfigs = $scope.idpConfigs || [];
                    //                         });
                    //                 });

                    //                 getAccountForStream();
                                    
                    //             }
                    //             $scope.dataloaded = true;
                    //             $scope.needAuth = true;
                    //         }, function (res) {
                    //             $scope.authLists = null;
                    //             $scope.dataloaded = true;
                    //             $scope.needAuth = false;
                    //             //NotificationService.notify("Failed to get idp list ", "error");
                    //         });

                    // $scope.testIdp = function (index) {

                    //     $scope.btTestFormApi.afterInit = function afterInit() {
                    //         $scope.btTestFormApi.test();
                    //     };

                    //     $scope.btTestFormApi.afterTest = function afterTest(success) {

                    //         if (success) {

                    //             NotificationService.notify("Authorization test successful", "success");

                    //         } else {

                    //             NotificationService.notify("Authorization test failed", "error");

                    //         }

                    //         $scope.btTestFormApi.close();

                    //     };

                    //     $scope.btTestFormApi.onNewAccounts = function onNewAccounts(accounts) {
                    //         $scope.account = accounts;
                    //         updateIDPData();
                    //         console.log(index);
                    //     };

                    //     $scope.btTestFormApi.init({
                    //         _id: $scope.idpConfigs[index]._id,//$scope.idpConfig._id, //$scope.authLists.idpName,
                    //         type: 'idp',
                    //         testFor: 'idp',
                    //         isTryOutUserConnection: "true"
                    //                 //definition:$scope.authLists
                    //     });

                    // };

                    // function getAccountForStream(accountDetails) {

                    //     BTStreamsService.getAccounts($workflowService.selectedStream()._id, "true", "true")
                    //             .then(function (res) {
                    //                 $scope.account = res.data;
                    //                 updateIDPData(accountDetails);

                    //             });

                    // }


                    // var updateIDPData = function(accountDetails) {
                    //     var idpDetails = angular.copy($scope.idpConfigs);

                    //     if(accountDetails){
                    //         $.each(idpDetails, function(j, idpData){
                    //             if(idpData.name === accountDetails.idp){
                    //                 idpDetails[j].account = [];
                    //             }
                    //         });
                    //     }else{
                    //        $.each($scope.account, function(i, accountData){
                    //         $.each(idpDetails, function(j, idpData){
                    //             if(idpData.name === accountData.idp){
                    //                 idpDetails[j].account = [accountData];
                    //             }
                    //         });
                    //     });

                    //     }

                       
                    //     $scope.idpConfigs = angular.copy(idpDetails);
                    // }

                    // $scope.deleteAccount = function (account) {

                    //     BTIdpService.deleteStreamUserAccount(account.streamAccountId)
                    //             .then(function () {
                    //                 //$scope.account = [];
                    //                 getAccountForStream(account);
                    //                 $scope.isTryModeUpdated = false;
                    //                 NotificationService.notify("account deleted successfully", "success");
                    //             });

                    // };

                    $scope.upgrade = {
                        description: $scope.stream.botDesc,
                        instructions: $scope.stream.configInst,
                        instructionsURL: $scope.stream.configInstURL,
                        botType: $scope.stream.botType || 'solution',
                        isChat: true,
                        isMention: true
                                //deploymentComments : $scope.stream.deploymentComments
                    };


                    function prepareStepsAndViews() {
                        $scope.steps.push(new stepObject(1, "Define Deployment", true));
                        //    $scope.steps.push(new stepObject(2, "Variable Setup",false));
                        if ($scope.stream.publishType === "smartbot" && $scope.stream.publishType !== "samplebot") {
                            $scope.steps.push(new stepObject(3, "Enable Try Mode", false));
                        }
                        $scope.steps.push(new stepObject(4, "Review & Confirm", false));
                    }

                    $scope.streamPublishInfo = {
                        published: false,
                        visibility: $scope.stream.visibility,
                        enterprise: ($scope.stream.visibility.namespace == "enterprise" || $scope.stream.visibility.namespace == "enterpriseNpublic")
                    };

                    $scope.streamPublishInfo.published = $rootScope.hasPublishedAlerts || $rootScope.hasPublishedActions || $rootScope.hasPublishedFlowtasks;

                    $scope.isAuthorized = function () {
                        return $rootScope.wfAdmin || window.localStorage.enablePublish;
                    };

                    function hideAll() {
                        $scope.steps.map(function (step) {
                            step.active = false;
                        });
                    }

                    function showStep(stepNo) {

                        if (!tasksSelected()) {
                            NotificationService.notify(i18n.i18nString('please_select_atleast_oneTask'), 'warning');
                            stepNo = $scope.currentStep;
                        }

                        $scope.currentStep = stepNo;

                        $scope.steps.map(function (step, index) {
                            if (index === $scope.currentStep) {
                                step.active = true;
                            } else {
                                step.active = false;
                            }
                        });

                        collectSelectedTasks();

                    }

                    $scope.trymodecallback.showStep = showStep;

                    function checkUpgrade(task) {

                        if (task._id[0] === 'l') {
                            BTAlertsService.checkUpgrade(task._id)
                                    .then(function (res) {
                                        task.upgradeInfo = res.data;
                                        task.versionType = task.upgradeInfo.versionChange === 'selectable' ? 'minor' : task.upgradeInfo.versionChange;
                                        task.upgradeType = 'mandatory';
                                    }, function (err) {
                                        console.log(err);
                                    });
                        } else if (task._id[0] === 'a') {
                            BTActionsService.checkUpgrade(task._id)
                                    .then(function (res) {
                                        task.upgradeInfo = res.data;
                                        task.versionType = task.upgradeInfo.versionChange === 'selectable' ? 'minor' : task.upgradeInfo.versionChange;
                                        task.upgradeType = 'mandatory';
                                    }, function (err) {
                                        console.log(err);
                                    });
                        } else if (task._id[0] === 'd') {
                            console.log('d');
                        }

                    }

                    $scope.stepClick = function stepClick(step) {
                        //hideAll();

                        if (step - 1 > 1 && !$scope.isTryModeUpdated && $scope.stream.publishType === "smartbot") {
                            $scope.trymodecallback.updateTryMode(step - 1);
                        } else {
                            showStep(step - 1);
                        }

                    };

                    $scope.helpLink = $rootScope.helpLinks.DEPLOYMENTTAB_HELP;

                    $scope.next = function () {

                        var step = $scope.currentStep + 1;
                        $scope.helpLink = $rootScope.helpLinks.CONFIRMTAB_HELP;

                        if ($scope.currentStep === 1 && step > 1) {
                            $scope.trymodecallback.updateTryMode(step);
                        } else {
                            showStep(step);
                        }

                    };

                    // $scope.updateTryMode = function (step) {
                    //     if ($scope.authLists && $scope.account.length !== $scope.idpConfigs.length && $scope.enableTryMode) {
                    //         NotificationService.notify("Please add an account to enable try mode", 'warning');
                    //     } else {

                    //         var payLoad = {
                    //             "canTryOut": $scope.enableTryMode
                    //         };

                    //         BTStreamsService.updateTryMode($scope.stream._id, payLoad).then(function (res) {
                    //             $scope.isTryModeUpdated = true;
                    //             showStep(step);
                    //         }, function (err) {
                    //             console.log(err);
                    //         });
                    //     }
                    // };

                    $scope.back = function () {
                        $scope.currentStep--;
                    };

                    $scope.cancel = function () {
                       $scope.onClose(false);
                    };

                    $scope.getType = function (id) {
                        return id[0] === "l" ? "Alert Task" : id[0] === "d" ? "Dialog Task" : "Action Task";
                    };

                    $scope.assignDefaultPublishDestination = function () {
                        if ($scope.stream.publishType == "smartbot" || $scope.stream.publishType == "samplebot") {
                            $scope.streamPublishInfo.namespaceTo = "public";
                            $scope.streamPublishInfo.namespaceHide = true;
                        } else if (($scope.stream.publishType != "smartbot" && $scope.stream.publishType !== "samplebot") && $rootScope.isManaged && !$rootScope.wfAdmin) {
                            $scope.streamPublishInfo.namespaceTo = "enterprise";
                            $scope.streamPublishInfo.namespaceHide = true;
                        } else if ($scope.streamPublishInfo.published) {
                            $scope.streamPublishInfo.namespaceHide = true;
                            $scope.streamPublishInfo.namespaceTo = $scope.streamPublishInfo.visibility.namespace;
                        }
                        //overrides everything to enterprise
                        $scope.streamPublishInfo.namespaceTo = "enterprise";
                        $scope.tasks.map(function (task) {
                            task.namespaceTo = $scope.streamPublishInfo.namespaceTo;
                        });
                    };

//		$scope.views     = {
//			'deployment'    : true,
//			'variablesetup' : false,
//                        'enabletrymode' : false,
//			'reviewconfirm' : false
//		};

                    $scope.allTasks = [];
                    $scope.alerts = [];
                    $scope.actions = [];
                    $scope.dialogtask = [];
                    $scope.mappings = [];
                    $scope.alertLoading = true;
                    $scope.actionLoading = true;
                    $scope.dialogLoading = true;
                    $scope.loadingFlows = true;

                    $q.all
                            ([
                                BTAlertsService.getAlerts($scope.stream._id),
                                BTActionsService.getActions($scope.stream._id),
                                BTFlowtaskService.getFlowtaks($scope.stream._id),
                                BTStreamsService.getMappings($scope.stream._id)
                            ])
                            .then(function (results) {

                                $scope.allTasks = $scope.allTasks.concat(results[0].data);
                                $scope.allTasks = $scope.allTasks.concat(results[1].data);
                                $scope.allTasks = $scope.allTasks.concat(results[2].data);
                                $scope.alerts = results[0].data.filter(function (alert) {
                                    alert.supportedLanguages = _.map(_.union($scope.selectedStream.supportedLanguages, alert.approvedLanguages || []), 
                                    function (each){
                                        var slObject = {};
                                        alert.approvedLanguages = alert.approvedLanguages || [];
                                         if(alert.approvedLanguages.length ===  0){
                                            slObject.selected = true;
                                        }
                                        else{
                                            slObject.selected = false;
                                        }
                                        if(_.indexOf(alert.approvedLanguages, each) !== -1){
                                            slObject.selected = true;
                                            slObject.disable = true;
                                        }

                                         slObject.value =  each;

                                        return slObject;
                                        
                                    });

                                    alert.supportedLanguages = _.sortBy(alert.supportedLanguages, 'selected');

                                    alert.approvedLanguagesCopy = [];
                                    _.map(alert.supportedLanguages, function (lang){
                                        if(lang.selected){
                                            alert.approvedLanguagesCopy.push(lang.value); 
                                        }
                                        
                                    });
                                    alert.approvedLanguages = angular.copy(alert.approvedLanguagesCopy);
                                    alert.approvedLangString = convertToString(alert.approvedLanguagesCopy);
                                    return alert.state === "configured";
                                });

                                $scope.actions = results[1].data.filter(function (action) {
                                    action.supportedLanguages = _.map(_.union($scope.selectedStream.supportedLanguages, (action.approvedLanguages || [])), function (each){
                                        // return {selected: true, value: each};
                                         var slObject = {};
                                         action.approvedLanguages= action.approvedLanguages || [];
                                         if(action.approvedLanguages.length ===  0){
                                            slObject.selected = true;
                                        }
                                        else{
                                            slObject.selected = false;
                                        }
                                        if(_.indexOf(action.approvedLanguages, each) !== -1){
                                            slObject.selected = true;
                                            slObject.disable = true;
                                        }

                                         slObject.value =  each;

                                        return slObject;
                                    });

                                    action.supportedLanguages = _.sortBy(action.supportedLanguages, 'selected');

                                    action.approvedLanguagesCopy = [];
                                    _.map(action.supportedLanguages, function (lang){
                                         if(lang.selected){
                                             action.approvedLanguagesCopy.push(lang.value);
                                            }
                                    });
                                    action.approvedLanguages = angular.copy(action.approvedLanguagesCopy);
                                    action.approvedLangString = convertToString(action.approvedLanguagesCopy);
                                    return action.state === "configured";
                                });

                                $scope.dialogs = results[2].data.filter(function (dialog) {
                                    dialog.supportedLanguages = _.map(_.union($scope.selectedStream.supportedLanguages, dialog.approvedLanguages), function (each){
                                        // return {selected: true, value: each};
                                        var slObject = {};
                                        dialog.approvedLanguages = dialog.approvedLanguages || [];
                                        if(dialog.approvedLanguages.length ===  0){
                                            slObject.selected = true;
                                        }
                                        else{
                                            slObject.selected = false;
                                        }
                                        if(_.indexOf(dialog.approvedLanguages, each) !== -1){
                                            slObject.selected = true;
                                            slObject.disable = true;
                                        }

                                         slObject.value =  each;

                                        return slObject;
                                    });

                                    dialog.supportedLanguages = _.sortBy(dialog.supportedLanguages, 'selected');

                                    dialog.approvedLanguagesCopy = [];
                                    _.map(dialog.supportedLanguages, function (lang){
                                         if(lang.selected){
                                             dialog.approvedLanguagesCopy.push(lang.value);
                                            }
                                    });
                                    dialog.approvedLanguages = angular.copy(dialog.approvedLanguagesCopy);
                                    dialog.approvedLangString = convertToString(dialog.approvedLanguagesCopy);
                                    return dialog.state === "configured";
                                });
                                $scope.mappings = results[3].data;
                                $scope.mappings = flowsUtil.arrangeFlows($scope.mappings);
                                
                                assignFlowsToTask();

                                $scope.alertLoading = false;
                                $scope.actionLoading = false;
                                $scope.dialogLoading = false;
                                $scope.loadingFlows = false;
                                $timeout(function () {
                                    PerfectScrollbar.update($element.find('.bot-publish[perfect-scroll]')[0]);
                                }, 300);
                                
                            }, function (err) {

                                $scope.alerts = [];
                                $scope.actions = [];
                                $scope.mappings = [];
                                $scope.alertLoading = false;
                                $scope.actionLoading = false;
                                $scope.loadingFlows = false;

                            });

                    function fetchFlows(task) {

                        var taskInfo;

                        taskInfo = $scope.allTasks.filter(function (item) {
                            return item._id == task.parentId;
                        })[0];

                        if (!taskInfo) {
                            return;
                        }

                        if (task._id[0] === 'l') {
                            $q.all
                            ([
                                BTParamMapService.getMappedAlerts(task._id, taskInfo.version),
                                BTParamMapService.getMappedDialogs(task._id, taskInfo.version)
                            ])
                            .then(function (res) {
                                task.flows = flowsUtil.arrangeFlows(res[0].data);
                                task.flows = task.flows.concat(flowsUtil.arrangeFlows(res[1].data)); 

                            }, function (err) {
                                task.flows = [];
                            });
                            /*BTParamMapService.getMappedAlerts(task._id, taskInfo.version)
                                    .then(function (res) {
                                        task.flows = flowsUtil.arrangeFlows(res.data);
                                    }, function (err) {
                                        task.flows = [];
                                    });*/
                        } else if (task._id[0] === 'a') {
                            BTParamMapService.getMappedActions(task._id, taskInfo.version)
                                    .then(function (res) {
                                        task.flows = flowsUtil.arrangeFlows(res.data);
                                    }, function (err) {
                                        task.flows = [];
                                    });
                        }
                        else if (task._id[0] === 'd') {
                            BTParamMapService.getMappedDialogs(task.parentId, taskInfo.version)
                                    .then(function (res) {
                                        task.flows = flowsUtil.arrangeFlows(res.data);
                                    }, function (err) {
                                        task.flows = [];
                                    });
                        }

                    }

                    function assignFlowsToTask() {

                        $scope.alerts = $scope.alerts || [];
                        $scope.actions = $scope.actions || [];
                        $scope.dialogs = $scope.dialogs || [];
                        
                        $scope.alerts.map(function (alert) {
                            alert._selected = true;
                            if (alert.parentId) {
                                fetchFlows(alert);
                                checkUpgrade(alert);
                            }
                        });

                        $scope.actions.map(function (action) {
                            action._selected = true;
                            if (action.parentId) {
                                fetchFlows(action);
                                checkUpgrade(action);
                            }
                        });

                        $scope.dialogs.map(function (dialog) {
                            dialog._selected = true;
                            if (dialog.parentId) {
                                $scope.configuredDialogFlowId = dialog._id; 
                                fetchFlows(dialog);
                                //checkUpgrade(dialog);
                            }
                        });
                    }

                    function tasksSelected() {
                        collectSelectedTasks();
                        return $scope.tasks.length > 0;
                    }

                    function collectSelectedTasks() {
                        $scope.tasks = [];

                        $scope.alerts = $scope.alerts || [];
                        $scope.actions = $scope.actions || [];
                        $scope.dialogs = $scope.dialogs || [];

                        $scope.alerts.map(function (alert) {
                            alert.approvedLanguages = angular.copy(alert.approvedLanguagesCopy);
                            alert.approvedLangString = convertToString(alert.approvedLanguages);
                            if (alert._selected) {
                                if ($scope.streamPublishInfo.published) {
                                    alert.namespaceTo = $scope.streamPublishInfo.visibility && $scope.streamPublishInfo.visibility.namespace;
                                }
                                $scope.tasks.push(angular.copy(alert));
                            }
                        });
                        $scope.actions.map(function (action) {
                            action.approvedLanguages = angular.copy(action.approvedLanguagesCopy);
                            action.approvedLangString = convertToString(action.approvedLanguages);
                            if (action._selected) {
                                if ($scope.streamPublishInfo.published) {
                                    action.namespaceTo = $scope.streamPublishInfo.visibility && $scope.streamPublishInfo.visibility.namespace;
                                }
                                $scope.tasks.push(angular.copy(action));
                            }
                        });
                        $scope.dialogs.map(function (dialog) {
                            dialog.approvedLanguages = angular.copy(dialog.approvedLanguagesCopy);
                            dialog.approvedLangString = convertToString(dialog.approvedLanguages);
                            if (dialog._selected) {
                                if ($scope.streamPublishInfo.published) {
                                    dialog.namespaceTo = $scope.streamPublishInfo.visibility && $scope.streamPublishInfo.visibility.namespace;
                                }
                                $scope.tasks.push(angular.copy(dialog));
                            }
                        });

                        $scope.partialLanguageTasks = $scope.getPartialLanguageTasks($scope.tasks) || [];
                    }

                    var taskMap = {};

                    $scope.confirm = function () {
                       
                        verifyFlowsStatus(triggerPublish);

                        function triggerPublish() {
                            $scope.publishInProgress = true;
                            var payload = {
                                resources: []
                            };

                            $scope.tasks.map(function (task) {

                                var parent;

                                if (task.parentId) {
                                    parent = $scope.allTasks.filter(function (item) {
                                        return item._id === task.parentId;
                                    })[0] || {};
                                }

                                if(task.approvedLanguagesCopy){
                                    delete task.approvedLanguagesCopy;
                                }

//                                if(task.approvedLangString){
//                                    delete task.approvedLangString;
//                                }

                                var taskUpgradeInfo = {
                                    namespace: task.parentId ? (parent.visibility.namespace == "enterpriseNpublic" ? "enterprise" : task.namespaceTo) : (task.namespaceTo == "enterpriseNpublic" ? "enterprise" : task.namespaceTo),
                                    resourceId: task._id,
                                    namespaceIds: task.parentId ? parent.visibility.namespaceIds : task.namespaceIds || [],
                                    resourceType: getType(task._id),
                                    upgradeShortMsg: task.upgradeShortMessage,
                                    upgradeLongMsg: task.upgradeLongMessage,
                                    versionComment: task.upgradeVersionComment,
                                    approvalRequestedLanguages: task.approvedLanguages
                                };

                                if (taskUpgradeInfo.namespace === "enterprise") {
                                    taskMap[task._id] = task.name;
                                } else {
                                    taskMap[task.parentId ? task.parentId : task._id] = task.name;
                                    taskMap[task._id] = task.name;//maintaining both parent task name and child task name in else now.Condition can be removed
                                }

                                if (task.parentId) {
                                    taskUpgradeInfo.versionType = task.versionType;
                                    _.addProps(task.upgradeInfo && task.upgradeInfo.upgrade !== 'automatic', taskUpgradeInfo, {upgradeType: task.upgradeType});
                                }

                                payload.resources.push(taskUpgradeInfo);

                            });

                            if ($scope.stream.publishType == "smartbot"  || $scope.stream.publishType == "samplebot") {

                                if ($scope.upgrade.description) {
                                    payload.botDesc = $scope.upgrade.description;
                                }

                                if ($scope.stream.publishType == "samplebot" && $scope.upgrade.instructions ) {
                                    payload.configInstFileId = $scope.upgrade.instructions;
                                } else {
                                    payload.configInst = $scope.upgrade.instructions;                                    
                                }

                                if ($scope.stream.publishType == "smartbot" && $scope.upgrade.instructionsURL) {
                                    payload.configInstURL = $scope.upgrade.instructionsURL;
                                }

                            }
                            
                            if ($scope.stream.publishType == "smartbot") {
                                payload.botType = $scope.upgrade.botType;
                                if(!$scope.isDomainKore){
                                     payload.botType='enterprise';
                                }
                                if ($scope.upgrade.botType === 'workplacefb') {
                                    payload.isChat = $scope.upgrade.isChat;
                                    payload.isMention = $scope.upgrade.isMention;
                                }   
                            }
                            publishTasks(payload);


                        }

                        function getType(id) {
                            return id[0] == 'l' ? "alert" : id[0] == 'd' ? "dialog" : "action";
                        }

                    };
                    function publishBotTasks(payload){
                        $scope.messages = [];

                        var service = $scope.stream.publishType == "smartbot" ? BTStreamsService.solutionPublish : BTStreamsService.standardPublish;
                        
                        if($scope.stream.publishType === 'samplebot'){
                            service = BTStreamsService.sampleBotPublish;
                        }

                        service($scope.stream._id, payload)
                                .then(function (res) {
                                    $scope.publishInProgress = false;
                                    var messages = [];

                                    var successMsg = [], errorMsg = [];
                                    function processTasks() {
                                        res.data.map(function (message) {
                                            var _msg = taskMap[message.resourceId];
                                            if (_msg === undefined) {
                                                if (message.result && message.result.name) {
                                                    _msg = message.result.name;
                                                }
                                            }
                                            if (message.status === 'SUCCESS') {
                                                messages.push({
                                                    type: 'success',
                                                    message: $scope.streamPublishInfo.enterprise ? _msg : (_msg +' '+i18n.i18nString('published_success'))
                                                });
                                            } else if (message.status === 'FAILURE') {
                                                messages.push({
                                                    type: 'error',
                                                    error: getErrorMsg(message.result),
                                                    message: _msg +' '+i18n.i18nString('publish_Failed'),
                                                    context: getResource(payload, message.resourceId),
                                                    taskId: message.resourceId
                                                });
                                            }
                                        });

                                        $scope.messages = messages;

                                        $scope.openModal();
                                    }
                                    processTasks();

                                }, function (err) {
                                    $scope.publishInProgress=false;
                                    var msg = err.data.errors[0].msg || i18n.i18nString('error_handle_msg');
                                    NotificationService.notify(msg, 'error');

                                });
                    }
                    function publishTasks(payload) {
                        if (!$scope.showVisibiltyForSmartBot()) {
                            delete payload.isChat;
                            delete payload.isMention;
                        }
                        if($scope.alertDialogMappingsToPublish.length){
                            var alertDialogMappingPayloadPromise = [];
                            $scope.alertDialogMappingsToPublish = _.uniq($scope.alertDialogMappingsToPublish);
                             $.each($scope.alertDialogMappingsToPublish, function (i,flow) {
                                var promise =  BTStreamsService.publishAlertDialogFlow(flow);

                                alertDialogMappingPayloadPromise.push(promise);
                            });
                            $q.all
                            (alertDialogMappingPayloadPromise)
                            .then(function (results) {
                                publishBotTasks(payload);
                            }, function (err) {
                                publishBotTasks(payload);
                            });
                        }
                        else{
                            publishBotTasks(payload);
                        }
                    }

                    function getErrorMsg(message) {
                        var msg = (message && message.errors && message.errors[0].msg) || i18n.i18nString('error_handle_msg');
                        return msg;
                    }

                    function getResource(publishInfo, id) {

                        var payload = {};

                        var resource = publishInfo.resources.filter(function (resource) {
                            return resource.resourceId === id;
                        });

                        if ($scope.stream.publishType == "smartbot") {

                            payload = {
                                botDesc: publishInfo.botDesc,
                                configInst: publishInfo.configInst,
                                configInstURL: publishInfo.configInstURL
                            };

                        }

                        payload.resources = resource;

                        return payload;

                    }

                    function verifyFlowsStatus(callback) {

                        var ok = true, allFilled = true, namespaceTo = true;

                        var messages = {
                            flow: i18n.i18nString('please_verify_all_the_flows'),
                            upgrade: i18n.i18nString('please_Fill_upgradecomments'),
                            namespace: i18n.i18nString('please_select_the_destination')
                        };

                        var errorMsg;

                        ($scope.tasks || []).map(function (task) {
                            if (task._id[0] === 'l') {
                                if (task.parentId && task.upgradeInfo.upgrade === 'manual') {
                                    if (task.parentId && (!task.upgradeShortMessage || !task.upgradeLongMessage || !task.upgradeVersionComment)) {
                                        allFilled = false;
                                        errorMsg = messages.upgrade;
                                        if (task.upgradeVersionComment) {
                                            errorMsg = i18n.i18nString('please_fill_up_short_and_long');
                                        }
                                    }
                                } else if (task.parentId && task.upgradeInfo.upgrade === 'automatic') {
                                    if (task.parentId && (!task.upgradeShortMessage || !task.upgradeVersionComment)) {
                                        allFilled = false;
                                        errorMsg = messages.upgrade;
                                        if (task.upgradeVersionComment) {
                                            errorMsg = i18n.i18nString('please_fill_up_short_msg');
                                        }
                                    }

                                }

                            } else {
                                if (task.parentId && (!task.upgradeVersionComment)) {
                                    allFilled = false;
                                    errorMsg = messages.upgrade;
                                }
                            }
                            
                            if (!task.namespaceTo && !task.parentId) {
                                namespaceTo = task.namespaceTo;
                                errorMsg = messages.namespace;
                            }

                            (task.flows || [])
                                    .map(function (flow) {

                                        if (flow.state != "active") {
                                            ok = false;
                                        }

                                    });

                        });

                        if (!ok) {
                            NotificationService.notify(messages.flow, 'warning');
                        } else if (!allFilled) {
                            NotificationService.notify(errorMsg, 'warning');
                        } else if (!namespaceTo) {
                            NotificationService.notify(errorMsg, 'warning');
                        } else {
                            checkForMandatoryFieldsOfSolutionBot(callback);
                        }

                    }

                    function checkForMandatoryFieldsOfSolutionBot(callback) {

                        var ok = true;

                        if ($scope.stream.publishType === "smartbot") {
                            ok = $scope.upgrade.description;// && $scope.upgrade.deploymentComments;
                        }

                        if (!ok) {
                            NotificationService.notify(i18n.i18nString('please_fill_up_all_required_fields'), 'warning');
                            return;
                        }

                        checkForVersionTypeAndUpgrade(callback);

                    }


                    $scope.getTextIncludingTags = function(name) {
                   return name.escapeHTML();
                };

                String.prototype.escapeHTML = function () {
                    //'&': '&amp;',
                    var escapeTokens = {
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#x27;'
                    };
                    var htmlTags = /[<>"']/g;
                    return ('' + this).replace(htmlTags, function (match) {
                        return escapeTokens[match];
                    });
                };

                    function checkForVersionTypeAndUpgrade(callback) {

                        var ok = true;

                        ($scope.tasks || [])
                                .map(function (task) {
                                    if (!(task._id && task._id.indexOf('dg-') === 0)) {
                                        if (task.parentId && (!task.upgradeType || !task.versionType)) {
                                            ok = false;
                                        }
                                    }
                                });

                        if (!ok) {
                            NotificationService.notify(i18n.i18nString('please_upgrade_version_type_details'), 'warning');
                            return;
                        }

                        if($scope.stream.publishType == "smartbot"){
                            callback();
                            return;
                        }

                        if($scope.selectedStream.publishType !== "smartbot" && $scope.selectedStream.publishType !== "samplebot" && $scope.streamPublishInfo.namespaceTo === "public" && !$scope.streamPublishInfo.botStoreSettingsCheck && $rootScope.wfAdmin){
                            NotificationService.notify(i18n.i18nString('please_check_to_confirm_bot_store_settings'), 'warning');
                            return;
                        }

                        if($scope.selectedStream.publishType === 'samplebot'){
                            if(!$scope.upgrade.description){
                                 NotificationService.notify(i18n.i18nString('please_add_bot_description'), 'warning');
                                 return;
                            } 
                            // else if (!$scope.upgrade.instructions && !$scope.streamPublishInfo.published){
                            //     NotificationService.notify('Please upload the bot instructions file', 'warning');
                            //     return;
                            // }
                        }

                        var confirmationMessage = "";
                        var botVisbilityMessage = "";

                        if ($scope.stream.purpose === "employee") {
                            //botVisbilityMessage = "The bot can only be visible to your employee's.";
                            botVisbilityMessage = i18n.i18nString('you_are_about_to_publish')+" <b>" + $scope.getTextIncludingTags($scope.stream.name) + "</b> "+i18n.i18nString('for_use_by_selected_users');
                        
                        }else if($scope.stream.purpose === "customer"){
                            botVisbilityMessage = i18n.i18nString('you_are_about_to_publish')+" <b>" + $scope.getTextIncludingTags($scope.stream.name) + "</b> "+i18n.i18nString('for_use_by_anonymous_users');
                        }

                        if ($scope.streamPublishInfo.namespaceTo === "enterprise") {
                            confirmationMessage = botVisbilityMessage;
                        } else {
                            confirmationMessage = i18n.i18nString('you_are_about_to_publish')+" <b>" + $scope.getTextIncludingTags($scope.stream.name) + "</b> "+i18n.i18nString('into_kore_ai_bots_store');
                        }

                        window.bootbox.dialog({
                                message: confirmationMessage,
                                title: $scope.publishPageTitle(),
                                className: "alert-modal",
                                buttons: {
                                    success: {
                                        label: i18n.i18nString('no'),
                                        className: "btn-primary",
                                        callback: function () {
                                            
                                        }
                                    },
                                    main: {
                                        label: i18n.i18nString('yes'),
                                        className: "btn-primary",
                                        callback: function () {
                                            callback();
                                        }
                                    }
                                },
                                onEscape: function () {
                                    
                                }
                            });

                        //callback();

                    }

                    $scope.openModal = function () {
                        $('#errorMsgStatus').modal({
                            backdrop: 'static',
                            show: true
                        });
                    };

                    $scope.closeModal = function () {
                        $('#errorMsgStatus').modal('hide');
                        $timeout(function () {
                            $('body').removeClass('modal-open');
                        });
                        $scope.onClose(true);
                      //  $location.path(window.appConfig.CONTEXT_PATH);
                    };

                    $scope.retry = function (payload) {

                        var service = $scope.stream.publishType == "smartbot" ? BTStreamsService.solutionPublish : BTStreamsService.standardPublish;

                        service($scope.stream._id, payload.context)
                                .then(function (res) {

                                    var messages = [];
                                    res.data.map(function (message) {
                                        var _msg = taskMap[message.resourceId];
                                        if (_msg === undefined) {
                                            if (message.result && message.result.name) {
                                                _msg = message.result.name;
                                            }
                                        }
                                        if (message.status === 'SUCCESS') {
                                            messages.push({
                                                type: 'success',
                                                taskId: message.resourceId,
                                                message: _msg +' '+i18n.i18nString('published_success')
                                            });
                                        } else if (message.status === 'FAILURE') {
                                            messages.push({
                                                type: 'error',
                                                error: getErrorMsg(message.result),
                                                message: _msg +' '+i18n.i18nString('publish_Failed'),
                                                context: getResource(payload.context, message.resourceId),
                                                taskId: message.resourceId
                                            });
                                        }
                                    });

                                    messages.map(function (message) {

                                        var msgIndex = _.findIndex($scope.messages, {taskId: message.taskId});

                                        if (msgIndex !== -1) {
                                            $scope.messages[msgIndex] = message;
                                        }
                                    });
                                }, function (err) {
                                    var msg = err.data.errors[0].msg || i18n.i18nString('error_handle_msg');
                                    NotificationService.notify(msg, 'error');
                                });
                    };

                    $scope.showBTStoreSettingsModal = false;
                    $scope.bssCallback = {};

                    $scope.openBotStoreSettingsModal = function() {
                        $scope.showBTStoreSettingsModal = true;
                        $(".botStoreSettingsModal").modal("show");
                        $timeout(function(){
                            $scope.bssCallback.loadGeneralSettings();
                        });
                    };

                    $scope.closeBotStoreSettingsModal = function() {
                        $scope.showBTStoreSettingsModal = false;
                        $(".botStoreSettingsModal").modal("hide");
                    };

                    $scope.retryAll = function () {

                        var payload = {
                            resources: []
                        };
                        var publishInfo = $scope.messages.filter(function (message) {
                            return message.type === 'error';
                        });

                        if ($scope.stream.publishType == "smartbot") {

                            payload = {
                                botDesc: publishInfo[0].context.botDesc,
                                configInst: publishInfo[0].context.configInst,
                                configInstURL: publishInfo[0].context.configInstURL,
                                resources: []
                            };

                        }

                        publishInfo.map(function (info) {
                            payload.resources.push(info.context.resources[0]);
                        });

                        publishTasks(payload);

                    };

                    $scope.deleteMapping = function () {
                        NotificationService.alert( i18n.i18nString('you_really_want_to_delete_this_flow'), deleteMapping, arguments);
                    };

                    function deleteMapping(flow, index, task) {
                        if (flow.targetResourceId) {
                            BTParamMapService.deleteMappedAlertDialog(flow.mapId).then(function (res) {
                                task.flows.splice(index, 1);
                                NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('flow_deleted_sucess'), "success");
                            }, function (err) {
                                NotificationService.alertNotify(i18n.i18nString('delete_failure'), i18n.i18nString('flow_deletion_failed'), "error");
                            });
                        } else {
                            BTParamMapService.deleteMappedAlertAction(flow.mapId).then(function (res) {
                                task.flows.splice(index, 1);
                                NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('flow_deleted_sucess'), "success");
                            }, function (err) {
                                NotificationService.alertNotify(i18n.i18nString('delete_failure'), i18n.i18nString('flow_deletion_failed'), "error");
                            });
                        }
                    }

                    $scope.updateMapping = function (flow) {
                        if (flow.targetResourceId) {
                            BTStreamsService.validateAlertDialogFlow(flow.mapId,$scope.configuredDialogFlowId)
                                    .then(function (res) {
                                        $scope.alertDialogMappingsToPublish.push(flow.mapId);
                                    }, function (err) {
                                        console.log(err);
                                        flow.state = false;
                                    });
                        } else {
                            BTStreamsService.publishFlow(flow.mapId)
                                    .then(function (res) {
                                    }, function (err) {
                                        console.log(err);
                                        flow.state = false;
                                    });
                        }
                    };
                    
                    function isAnyCommunicationModeSelected() {
                        return $scope.upgrade.isChat || $scope.upgrade.isMention;
                    }
                    $scope.$watch('upgrade.isChat', function (newVal, oldVal) {
                        if (!isAnyCommunicationModeSelected()) {
                            NotificationService.notify(i18n.i18nString('atleast_one_communication_mode'), "warning");
                            $scope.upgrade.isChat = oldVal;
                        }
                    });
                    $scope.$watch('upgrade.isMention', function (newVal, oldVal) {
                        if (!isAnyCommunicationModeSelected()) {
                            NotificationService.notify(i18n.i18nString('atleast_one_communication_mode'), "warning");
                            $scope.upgrade.isMention = oldVal;
                        }
                    });


                    $scope.changeWorkPlaceCommunication = function () {

                    };
                    $scope.publishPageTitle = function() {
                        if($scope.selectedStream.publishType === 'smartbot'){
                            return i18n.i18nString('deploySmartBot');
                        } else if ($scope.selectedStream.publishType === 'samplebot'){
                            return i18n.i18nString('deploySampleBot');
                        } else {
                            return i18n.i18nString('deployStandardBot');
                        }
                    };
                    $scope.updateFooterHeader = function () {
                        $scope.footerInfoTitle = i18n.i18nString('publishing_tasks');
                        $scope.footerHeaderId = "bt-botpublish";
                        $scope.footerPanelId = "bt-botpublish-panel";
                        $scope.nameDescription = i18n.i18nString('after_you_have_defined_and_saved');
                        return true;
                    };
                    $scope.uploadInstructionsDocument = function (){
                        if ($scope.upgrade.instructionsFile.name) {
                                var _ext = $scope.upgrade.instructionsFile.name.substring($scope.upgrade.instructionsFile.name.lastIndexOf('.'));
                                if (_ext !== '.pdf') {
                                    NotificationService.notify(i18n.i18nString('upload_only_pdf_files'), "error");
                                    $scope.fileExtensionError = true;
                                    return;
                                }
                            }

                            $scope.fileExtensionError = false;
                            $scope.upgrade.instructionsFileName = $scope.upgrade.instructionsFile.name;
                            var data = new FormData();
                            data.append('file', $scope.upgrade.instructionsFile);
                            data.append('fileContext', 'workflows');
                            data.append('fileExtension', 'pdf');

                            $scope.fileUploading = true;

                            BTFileUploadService.uploadFile(data)
                                    .then(function (response) {
                                        // var fileUploaded = {
                                        //     fileName: $scope.upgrade.instructionsFile.name,
                                        //     fileId: response.data.fileId
                                        // };

                                        $scope.upgrade.instructions = response.data.fileId;

                                        NotificationService.notify($scope.upgrade.instructionsFile.name + i18n.i18nString('uploaded_label_spaced'), "success");

                                        $scope.fileUploading = false;
                                    }, function (response) {
                                        NotificationService.notify(i18n.i18nString('oops_label') + response.data.errors[0].msg, "error");
                                        $scope.fileUploading = false;
                                    });
                        };
                    $scope.addLanguage = function (e, language, task){
                        if(!language.selected){
                            language.selected = false;
                            task.approvedLanguagesCopy.splice(_.indexOf(task.approvedLanguagesCopy, language.value),1);
                            task.approvedLanguages.splice(_.indexOf(task.approvedLanguages, language.value),1);
                        } else {
                            language.selected = true;
                            task.approvedLanguagesCopy.push(language.value);   
                            task.approvedLanguages.push(language.value);   
                        }
                        task.approvedLangString = convertToString(task.approvedLanguages);
                        //getting objects which are selected
                        task._selected = true;
                        var _selectedLanguages = task.supportedLanguages.filter(function(lang){return lang.selected;});
                        var _defaultApprovedLanguages = task.supportedLanguages.filter(function(lang){return lang.disable;});
                        if(_selectedLanguages && _selectedLanguages.length === 0 && task.state !== 'published' && _defaultApprovedLanguages.length === 0) {
                            task._selected = false;
                        }
                    };
                    $scope.editTask = function(e,task) {
                        var _defaultApprovedLanguages = task.supportedLanguages.filter(function(lang){return lang.disable;});
                        if(task._selected && task.state !== 'published' && _defaultApprovedLanguages.length === 0) {
                            for(var i=0; i<task.supportedLanguages.length;i++) {
                                task.supportedLanguages[i].selected = true;
                                $scope.addLanguage(e,task.supportedLanguages[i],task);
                            }
                        }
                        else if(task.state !== 'published' && _defaultApprovedLanguages.length === 0) {
                            for(var j=0; j<task.supportedLanguages.length;j++) {
                                task.supportedLanguages[j].selected = false;
                                $scope.addLanguage(e,task.supportedLanguages[j],task);
                            }
                        }
                    };

                    $scope.getNameByValue = function(langValueString, task){

                        if(!langValueString){
                            return "";
                        }

                        var langvalueArray = task.approvedLanguages;//langValueString.split(", ");
                        var langNames = _.map(langvalueArray, function(langValue){
                            var langObject = _.find($scope.seedSupportedLanguages, {value: langValue});
                            return langObject.name;
                        });

                        return langNames;

                    }; 

                    $scope.getPartialLanguageTasks = function(tasks){
                        var filteredTasks = _.filter(tasks, function(task){
                            return task.approvedLanguages.length !== task.supportedLanguages.length;
                        });

                        return filteredTasks;
                    };

                    function convertToString (approvedLanguages) {
                        if(!approvedLanguages || !approvedLanguages.length){
                            return "";
                        }
                        return approvedLanguages.length <= 2 ? approvedLanguages.join(", ") : approvedLanguages[0] + ", " + approvedLanguages[1] + "<span class='ovalcountcircle'>+" + (approvedLanguages.length - 2)+"</span>";
                    }

                }]);

})(angular);


;(function(ng) {

	'use strict';

	var _module = ng.module('bt-changelog', []);

	_module.controller('BTChangeLogCtrl', ['$scope','_constants_','$workflowService','$location','$timeout','BTStreamsService','i18n',
		function($scope,_constants_,$workflowService,$location,$timeout,BTStreamsService,i18n) {

			$scope._constants_ = _constants_;
			$scope.stream      = $workflowService.selectedStream();
			$scope.logs        = [];
			$scope.loading     = false;
			$scope.currentPage = 1;

			if(Object.keys($scope.stream).length === 0){
				$location.path(window.appConfig.CONTEXT_PATH);
				return;
			}

			$scope.getChanageLogs = function(){
				$scope.loading  = true;
				BTStreamsService.getChangeLog($scope.stream._id)
				.then(function(res){
				    $scope.logs = res.data.btlogs.map(function(log){
				    	log.created  = new Date(log.createdOn).toLocaleString();
				    	log.username = _.isObject(log.userId) ? (log.userId.firstName + ' ' + log.userId.lastName) : log.userId;
				    	return log;
				    });
				    $scope.loading = false;
				},function(err){
					$scope.logs = [];
					$scope.loading = false;
				});
			};

			$scope.getChanageLogs();

			$scope.exit = function exit(){
				$location.path(window.appConfig.CONTEXT_PATH);
			};


	}]);


}(angular));

;(function(ng) {

	'use strict';

	var _module = ng.module('bt-chat-settings', []);

	_module.controller('BTChatSettings', ['$scope','_constants_','$workflowService','$location','$timeout','BTStreamsService',
		function($scope,_constants_,$workflowService,$location,$timeout,BTStreamsService) {

			$scope._constants_ = _constants_;

                        $scope.views = {
                            utterances: false,
                            chatVerify: false,
                            intentEntity: true,
                            settings: false,
                            synonyms: false,
                            patterns: false,
                            chatResponse: false,
                            chatHistory: false,
                            logs: false,
                            failedScenarios: false
                        };
                        if ($scope._constants_.config.UTTERANCES) {
                            $scope.views.utterances = true;
                            $scope.views.intentEntity = false;
                        }
                        $scope.stream = $workflowService.nlpStream();
                        $scope.tasks = [];

			if(!_.isObject($scope.stream) || (_.isObject($scope.stream) && Object.keys($scope.stream).length === 0)){
			    goBack();
			    return;
			}

			$scope.navigate = function (view){

				Object.keys($scope.views).map(function(view){
					$scope.views[view] = false;
				});

				$scope.views[view] = true;

			};

			function goBack(){
				$location.path(window.appConfig.CONTEXT_PATH);
			}

            $scope.exit = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            $scope.goBack = goBack;
            if ($scope._constants_.config.UTTERANCES) {
                $scope.navigate('utterances');
            } else {
                $scope.navigate('intentEntity');
            }
			
	}]);


}(angular));

;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btContainmentDashboard', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-containment-dashboard/bt-containment-dashboard.html',
            controller: 'btContainmentDashBoardController'
        };
    });
    _module.controller("btContainmentDashBoardController", ['$scope', '$window', '$workflowService', '$element', '$location', '$sce',
        function ($scope, $window, $workflowService, $element, $location, $sce) {
            $scope.stream = $workflowService.selectedStream();
            if (window.location.href && (window.location.href.includes('dev.kore') || window.location.href.includes('localhost'))) {
                $scope.containmentDashBoadUrl = $sce.trustAsResourceUrl('http://localhost:4200/analytics/containment/' + $scope.stream._id);
            } else {
                $scope.containmentDashBoadUrl = window.appConfig.API_SERVER_URL + '/analytics/containment/'+$scope.stream._id;
            }
            // $scope.containmentDashBoadUrl = window.appConfig.API_SERVER_URL + '/analytics/containment/'+$scope.stream._id;
            var iframe = $("#containmentDashBoardFrame");
            iframe.on("load", function () { 
                //Make sure it is fully loaded
                iframe.contents().click(function (event) {
                    iframe.trigger("click");
                    $("body").trigger("click");
                });
            });
        }]);

}(angular));



;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btCustomDashboard', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-custom-dashboard/bt-custom-dashboard.html',
            controller: 'btCustomDashBoardController'
        };
    });
    _module.controller("btCustomDashBoardController", ['$scope', '$window', '$workflowService', '$element', '$location', '$sce',
        function ($scope, $window, $workflowService, $element, $location, $sce) {
            //$scope.customDashBoadUrl="http://dev.kore.ai:4200/analytics/dashboard";  
            $scope.stream = $workflowService.selectedStream();
            if (window.location.href && (window.location.href.includes('dev.kore') || window.location.href.includes('localhost'))) {
                $scope.customDashBoadUrl = $sce.trustAsResourceUrl('http://localhost:4200/analytics/customdashboard/' + $scope.stream._id);
            } else {
                $scope.customDashBoadUrl = window.appConfig.API_SERVER_URL + '/analytics/customdashboard/'+$scope.stream._id;
            }
            // $scope.customDashBoadUrl = window.appConfig.API_SERVER_URL + '/analytics/customdashboard/'+$scope.stream._id;
            var iframe = $("#customDashBoardFrame");
            iframe.on("load", function () { 
                //Make sure it is fully loaded
                iframe.contents().click(function (event) {
                    iframe.trigger("click");
                    $("body").trigger("click");
                });
            });
        }]);

}(angular));



;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btDashboard', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-dashboard/bt-dashboard.html',
            controller: 'botDashBoardController'
        };
    });
    _module.controller("botDashBoardController", ['$scope', '$window', '$workflowService', '$element', '$location', '_constants_', 'BTStreamsService', '$timeout', '$routeParams', 'NotificationService', '$modal', 'env_conf', '$q', 'BTSeedDataService', '$filter', 'BTIdpService', '$translator', '$rootScope', '$applicationService', '$endpoints','channelsConfig','i18n',
        function ($scope, $window, $workflowService, $element, $location, _constants_, BTStreamsService, $timeout, $routeParams, NotificationService, $modal, env_conf, $q, BTSeedDataService, $filter, BTIdpService, $translator, $rootScope, $applicationService, $endpoints,channelsConfig,i18n) {
            var daterangepickerInput;
            $scope.selectedChannels = [];
            $scope.assetsBase = env_conf['assets-url'];
            $scope._channelConfig = channelsConfig;            
            $scope.tasksStats = {'alertsTotal':0,'actionsTotal':0,'chatsTotal':0,'tasksTotal':0,'queriesTotal':[],'tasksPerformedTotal':0,'alertsConTotal':0,'taskBarGraph':[]};
            $scope.tasksCount={'actionsTotal':0,'actionsConTotal':0,'queriesTotal':0,'queriesConTotal':0,'dialogsTotal':0,'dialogsConTotal':0};
            $scope.stream = $workflowService.selectedStream();
            $scope.selectedAccount = $workflowService.selectedAccount();
            $scope._constants_=_constants_;
            $scope.topBotsCompleteList=[];
            $scope.scount=0;
            $scope.agentTransferCount=0;
            $scope.topAgentTransferCompleteList=[];
            $scope.piechartTooltipMsg = "Intent Recognised";
            $scope.selectedChartData = {'type':0,'data':''};
            $scope.dashboardLoading = false;
            $scope.groupbarChartLoading = false;
            $scope.taskCompletionLoading = false;
            $scope.barGraphAvailable=true;
            $scope.topPerformingBots = 0;
            $scope.emptyIllustration = env_conf['context-url']+'/img/empty-illustration.png';
            $scope.closeCross = env_conf['context-url']+'/assets/icons/closeCross.png';
            $scope.caretRight = env_conf['context-url']+'/assets/icons/caretRight.svg';
            $scope.caretRightGreen = env_conf['context-url']+'/assets/icons/caretDown.svg';
            $scope.arrowAngle = env_conf['context-url']+'/assets/icons/arrowAngle.svg';
            $scope.caretDownWhit = env_conf['context-url']+'/assets/icons/caretDownWhit.svg';
            $scope.refreshIconGreen = env_conf['context-url']+'/assets/icons/refreshGray.svg';
            $scope.timeIcon = env_conf['context-url']+'/assets/icons/time.svg';
            $scope.checkTickIcon = env_conf['context-url']+'/assets/icons/checkTickIcon.svg';
            $scope.chatsConversation = env_conf['context-url']+'/assets/dashboardEmptyStateImgs/chatsConversation.svg';
            $scope.tasksPerformance = env_conf['context-url']+'/assets/dashboardEmptyStateImgs/tasksPerformance.svg';
            $scope.intentRecognised = env_conf['context-url']+'/assets/dashboardEmptyStateImgs/intentRecognised.svg';
            $scope.tasks = env_conf['context-url']+'/assets/dashboardEmptyStateImgs/tasks.svg';
            $scope.agentTransfer = env_conf['context-url']+'/assets/dashboardEmptyStateImgs/agentTransfer.svg';
            $scope.channels = env_conf['context-url']+'/assets/dashboardEmptyStateImgs/channels.svg';
            $scope.helpDarkIcon = env_conf['context-url']+'/assets/icons-new/help/help-dark.svg';
            $scope.emptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/k-folder.png';
            $scope.realTime = moment().format('HH:mm:ss');
            $scope.realTimeZone = moment.tz(moment.tz.guess()).format('z');
            $scope.realTimeDashboardInterval = [10000,30000,60000,120000,300000,600000];
            $scope.maintainTimeInterval = parseInt(localStorage.dashboardRefreshInterval) || 30000;
            $scope.realTimeSessionData = true;
            $scope.realTimeChannelData = true;
            $scope.realTimeUsersData = true;
            $scope.checkTickIcon = $scope.assetsBase+"headerIcons/checkTickIcon.svg";
            $scope.caretDown = $scope.assetsBase+"headerIcons/caretDown.svg";
            $scope.trashIcon = $scope.assetsBase + "icons/trashIcon.svg";
            $scope.minusIcon = $scope.assetsBase + "icons/minus-circle.svg";
            $scope.disabledMinusIcon = $scope.assetsBase+"images/left-menu-img/disabledMinus.svg";
            $scope.andIcon = $scope.assetsBase+"icons/andIcon.svg";
            $scope.closeCross = env_conf['context-url']+'/assets/icons/closeCross.png';
            $scope.searchIconGray = env_conf['context-url']+'/assets/icons/searchIconGray.svg';
            $scope.helpIcon = env_conf['context-url']+'/assets/icons/helpIcon.svg';
            $scope.bulbIcon = env_conf['context-url']+'/assets/icons-new/bulb/bulb-blue.svg';
            $scope.selectedTag = "";
            $scope.selectedTagsArray = [];
            $scope.selectedTagsArray.push({name:"",values:[],type:""});
            $scope.filterComponent = [];
            $scope.filterComponent.tags = {};
            $scope.noofmsgs = i18n.i18nString('noofmsgs');
            $scope.filterComponent.tags.and = [];
            $scope.sessionTypes = [{type:"Interactive"},{type:"Non-interactive"}];
            $scope.conversationFilter = {selectedSession : [], selectedChannel: []};
            $scope.selectedSessionFilter = [];
            $scope.select_label= i18n.i18nString('select');
            $scope.tasksAndFaqData = [
                {
                    title: i18n.i18nString('tasks'),
                    data: []
                },
            ];
            $scope.coversionOfTime = function(time){
                var timeInterval;
                if(time === 10000){
                    timeInterval = i18n.i18nString('10_seconds');
                }else if(time === 30000){
                    timeInterval = i18n.i18nString('30_seconds');
                }else if(time === 60000){
                    timeInterval = i18n.i18nString('1_minute');
                }else if(time === 120000){
                    timeInterval = i18n.i18nString('2_minutes');
                }else if(time === 300000){
                    timeInterval =i18n.i18nString('5_minutes') ;
                }else if(time === 600000){
                    timeInterval = i18n.i18nString('10_minutes');
                }
                return timeInterval;
            };
            $scope.updateTimeInterval = function(time,e){
                if(window.dashboardRefreshIntervalTimer){
                    clearInterval(window.dashboardRefreshIntervalTimer);
                }
                $scope.maintainTimeInterval = time;
                localStorage.setItem('dashboardRefreshInterval',$scope.maintainTimeInterval);
                window.dashboardRefreshIntervalTimer = setInterval(function(){
                    realTimeDashboardData();
                    $scope.realTimeDashboardChannelData();
                    $scope.realTime = moment().format('HH:mm:ss');
                    $scope.realTimeZone = moment.tz(moment.tz.guess()).format('z');
                },$scope.maintainTimeInterval);
            };
            if(window.dashboardRefreshIntervalTimer){
                clearInterval(window.dashboardRefreshIntervalTimer);
            }
            window.dashboardRefreshIntervalTimer = setInterval(function(){
                realTimeDashboardData();
                $scope.realTimeDashboardChannelData();
                $scope.realTime = moment().format('HH:mm:ss');
                $scope.realTimeZone = moment.tz(moment.tz.guess()).format('z');
            },$scope.maintainTimeInterval);

            $scope.sessionsGraphData=[];
            var sessionInterval = 'date_day';
            $scope.botName = "";
            //var sessionInterval = 'date_day_hour';
            var date_type_chart ="";
            var type_chart="";
            $scope.languagesAndChannelsData = [
                {
                    title: i18n.i18nString('channels'),
                    data: [],
                    isLinkedBotSelected: false
                }
            ];
            $scope.isLinkedBotSelectedClone = false;
            $scope.search = {};
            $scope.search.nameSearchQuery = "";

            /* Below code for Filter Slider */

            $scope.modalSlider = {};
            $scope.rightClass = 'right500';

            $scope.isFilterDisabled = function() {
                return $element.find('#universalBotDashSlider input[type="checkbox"]:checked').length === 0;
            };
            $scope.isAllSelected = function(name) {
                return $element.find('input[name='+name+']').length === $element.find('input[name='+name+']:checked').length;
            };
            function importModalSliderOpen () {
                $timeout(function(){
                    $scope.modalSlider.open("#universalBotDashSlider");
                },500);
            }

            function importModalSliderClose() {
                $timeout(function(){
                    $scope.modalSlider.close("#universalBotDashSlider");
                },500);
            }

            $scope.resetFilter = function() {
                $scope.selectedLangauges = [];
                $scope.selectedChannels = [];
                $scope.selectedLinkedBots = [];
                $scope.conversationFilter.selectedSession = [];
                $scope.conversationFilter.selectedChannel = [];
                $scope.selectedSessionFilter = [];
                /* To select all channels by default on reset*/
                $('.channel-filter [name="langauge"], .channel-filter [name="channels"], .channel-filter [name="linkedBot"],' +
                    '#all-channels, #all-langauge, #all-linkedbot, #uniBotInteraction').each(function () {
                    $(this).prop('checked', true);
                });      
                $scope.selectedTagsArray = [];
                $scope.selectedTagsArray.push({name:"",values:[],type:""});  
                if ($scope.conversationFilter.selectedSession.length === 0) {
                    $scope.sumocb.sessioncb.selectAllByDefault();
                }     
                if ($scope.conversationFilter.selectedChannel.length === 0) {
                    $scope.sumocb.channelcb.selectAllByDefault();
                }       
            };

            $scope.closeSliderDashboard = function(){
                importModalSliderClose();
            };

            $scope.selectAllClick = function (e) {
                var t = e.currentTarget.checked?
                $('[name='+e.currentTarget.id.slice(4)+']:not(:checked)').trigger('click'):
                $('[name='+e.currentTarget.id.slice(4)+']:checked').trigger('click');
            };
 
            function getStream () {
                BTStreamsService.getBTStream($workflowService.selectedStream()._id).then(function (res) {
                    $scope.botName = res.data.name;
                   // $element.find('.csvClass').attr('filename', $scope.botName+".csv");
                }, function(error) {
                    console.error('getStreams Failed', error);
                });
            }
            getStream();
            $scope.downloadCSV = function() {
                var channels = $scope.selectedChannels.toString();
                var languages = $scope.selectedLangauges.toString();
                return BTStreamsService.tasksMetricsExport($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),"organization,task",channels,"", $scope.selectedLinkedBots.toString(),languages,"-1").then(function(res) {
                    $.each(res.data.results,function(i,result){
                        delete result.organization;
                        delete result.id;
                        delete result.createdOn;
                        delete result.icon;
                        delete result.createdBy;
                        delete result.state;
                    });
                    return res.data.results;
                }, function(err) {
                    console.log('Error ', err);
                });
            };

            $scope.triggerDownloadCSV = function(){
                if($scope._constants_.config.showDownloadPopUps){
                    NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined,i18n.i18nString('export_task'));  
                }else{
                    startExport();
                }
                function startExport(){
                    $timeout(function(){
                        $('.downloadCSVHide').trigger('click');
                    },350);
                }
                function cancleExport(){
                    return;
                }
                function checkBoxCb(checkValue){
                    console.log(checkValue);
                    $scope._constants_.updateDownloadPopUppreferance(checkValue);
                }

            };

            function tasksMetrics(){
                var channels = $scope.selectedChannels.toString();
                var languages = $scope.selectedLangauges.toString();
                var payload= {};
                payload.filters = {};
                payload.filters.tags = $scope.filterComponent.tags;
                payload.filters.sessionCategory = $scope.selectedSessionFilter;
                
                var errorHandle = function (error) {
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                    }
                };
                if($scope.stream.type === 'universalbot') {
                    BTStreamsService.tasksMetricsUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),"organization,task",channels,"", $scope.selectedLinkedBots.toString(),languages,"-1",payload).then(function(res) {$scope.checkDockStatus();}, errorHandle);                   
                }
                else {
                    BTStreamsService.tasksMetrics($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),"organization,task",channels,"",languages,"-1",payload).then(function(res) {$scope.checkDockStatus();}, errorHandle);
                }
                
            }
            var taskResponseHandle = function (res) {
                if(res && res.data){
                   $scope.topBotsCompleteList=[];
                    var dialogsTotal = 0;
                    var dialogsConTotal = 0;
                    var actionsTotal = 0;
                    var queriesTotal = 0;
                    var queriesConTotal = 0;
                    var actionsConTotal =0;
                    var tasksMetricsCount=0;
                    $.each(res.data.results, function(index, result) {
                        var obj = {};
                        obj.tasksCount={'actionsEntTotal':0,'actionsConTotal':0,'queriesEntTotal':0,'queriesConTotal':0,'dialogsEntTotal':0,'dialogsConTotal':0};
                        actionsTotal += ((result.noOfEntUserActions || result.noOfUserActions) === undefined)?0:(result.noOfEntUserActions || result.noOfUserActions);
                        actionsConTotal += result.noOfConUserActions || 0;
                        queriesTotal += ((result.noOfEntFaqSuccess || result.noOfFaqSuccess) === undefined)?0:(result.noOfEntFaqSuccess || result.noOfFaqSuccess);
                        queriesConTotal += result.noOfConFaqSuccess || 0;
                        dialogsTotal += ((result.noOfEntDialogSuccess || result.noOfDialogSuccess1) === undefined)?0:(result.noOfEntDialogSuccess || result.noOfDialogSuccess1);
                        dialogsConTotal += result.noOfConDialogSuccess || 0;
                        tasksMetricsCount= dialogsTotal + dialogsConTotal + actionsTotal + actionsConTotal + queriesTotal + queriesConTotal;
                        obj.name=result.name;
                        obj.icon=result.icon;
                        obj.id=result.id;
                        obj.tasksCount.tasksMetricsCount= result.total;
                        $scope.topBotsCompleteList.push(obj);
                    });
                   
                }
            };
            function agentTransferMetrics(){
                var channels = $scope.selectedChannels.toString();
                var languages = $scope.selectedLangauges.toString();
                var dimension =  "task";
                var payload= {};
                payload.filters = {};
                payload.filters.tags = $scope.filterComponent.tags;
                payload.filters.sessionCategory = $scope.selectedSessionFilter;

                var errorHandle = function (error) {
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                    }
                };

                if($scope.stream.type === 'universalbot') {
                    BTStreamsService.agentTransferMetricsUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),dimension,channels,"", $scope.selectedLinkedBots.toString(),languages,payload).then(function(res) {$scope.checkDockStatus();}, errorHandle);
                }
                else {
                    BTStreamsService.agentTransferMetrics($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),dimension,channels,"",languages,payload).then(function(res) {$scope.checkDockStatus();}, errorHandle);
                }
            } 

            var agentTransferResponseHandle = function (res) {
                if(res && res.data ){
                    var totalCount = 0;
                    $scope.topAgentTransferCompleteList =res.data;
                    for(var i=0;i<res.data.results.length;i++){
                        totalCount += res.data.results[i].noOfAgentTransfers;
                    }
                    $scope.agentTransferCount=totalCount;
                }
            };

            $scope.dashboardCounts = [];
            function fetchDataFromServer() {
                var dimension= "organization,date_day";
                if($scope.selectedRange === '24hours'){
                    dimension = "organization,date_hour";
                }
                var channels = $scope.selectedChannels.toString();
                var languages = $scope.selectedLangauges.toString();
                var payload= {};
                payload.filters = {};
                payload.filters.tags = $scope.filterComponent.tags;
                payload.filters.sessionCategory = $scope.selectedSessionFilter;
                $scope.dashboardLoading = true;
                $scope.groupbarChartLoading = true;
                $scope.taskCompletionLoading = true;
                

                var errorHandleDashboardCount = function (error) {
                    $scope.dashboardLoading = false;
                    $scope.groupbarChartLoading = false;
                    $scope.taskCompletionLoading = false;
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                    }
                };

                if($scope.stream.type === 'universalbot') {
                    // BTStreamsService.dashboardCountUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),dimension,channels,"", $scope.selectedLinkedBots.toString(),languages,payload).then(function(res) { responseHandleDashboardCount(res);$scope.checkDockStatus();}, errorHandleDashboardCount);
                    BTStreamsService.dashboardChatsUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),dimension,channels,"", $scope.selectedLinkedBots.toString(),languages,payload).then(function(res) { $scope.checkDockStatus(); }, errorHandleDashboardCount);
                }
                else {
                    BTStreamsService.dashboardCharts($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),dimension,channels,"",languages,payload).then(function(res) {$scope.checkDockStatus();}, errorHandleDashboardCount);                   
                    BTStreamsService.dashboardCount($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),dimension,channels,"",languages,payload).then(function(res) {$scope.checkDockStatus();} , errorHandleDashboardCount);
                }

                var errorHandleSessionsCount = function (error) {
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                    }
                };

                if($scope.stream.type === 'universalbot') {
                    BTStreamsService.sessionsCountUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),channels, $scope.selectedLinkedBots.toString(),languages,payload).then(function(res) {responseHandleSessionsCount(res);}, errorHandleSessionsCount);
                }
                else {
                    BTStreamsService.sessionsCount($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),channels,languages,payload).then(function(res) {responseHandleSessionsCount(res);}, errorHandleSessionsCount);                   
                }

                var errorHandleChannelsMetrics = function (error) {
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                    }
                };

                if($scope.stream.type === 'universalbot') {
                    BTStreamsService.channelsMetricsUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,"channels",$scope.start.toISOString(),$scope.end.toISOString(), $scope.selectedLinkedBots.toString(),payload).then(function(res) {$scope.checkDockStatus();}, errorHandleChannelsMetrics);
                }
                else {
                    BTStreamsService.channelsMetrics($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,"channels",$scope.start.toISOString(),$scope.end.toISOString(),payload).then(function(res) {$scope.checkDockStatus();}, errorHandleChannelsMetrics);
                }
            }

            var responseHandleDashboardCount = function (res) {
                if(res && res.data) {
                    $scope.dashboardLoading = false;
                    $scope.taskCompletionLoading = false;
                 //   $scope.dashboardCounts = res.data;
                    var alertsTotal = 0;
                    var alertsConTotal = 0;
                    var actionsTotal = 0;
                    var actionsConTotal = 0;
                    var reportsTotal = 0;
                    var chatsTotal = 0;
                    var tasksTotal = 0;
                    var dialogsTotal = 0;
                    var dialogsConTotal = 0;
                    var tasksPerformedTotal = 0;
                    var queriesTotal = 0;
                    var queriesConTotal = 0;
                    var alertSuccess=0;
                    var alertConSuccess=0;
                    var actionSuccess=0;
                    var actionConSuccess=0;
                    var dialogFail=0;
                    var dialogConFail=0;
                    var queriesSuccess=0;
                    var queriesConSuccess=0;
                    var queriesFail =0;
                    var queriesConFail=0;
                    var alertFail=0;
                    var alertConFail=0;
                    var actionFail=0;
                    var actionConFail=0;
                    var taskBarGraph =0;
                    var queriesTotalEach =0;
                    var queriesConTotalEach =0;
                    $scope.tasksStats = {'alertsTotal':0,'actionsTotal':0,'chatsTotal':0,'tasksTotal':0,'queriesTotal':[],'barGraphDate':[],'tasksPerformedTotal':0,'alertsConTotal':0,'taskBarGraph':[]};
                    $.each(res.data.results, function(index, result) {
                        alertsTotal += ((result.noOfEntUserAlerts || result.noOfUserAlerts) === undefined)?0:(result.noOfEntUserAlerts || result.noOfUserAlerts);
                        alertsConTotal += result.noOfConUserAlerts || 0;
                        actionsTotal += ((result.noOfEntUserActions || result.noOfUserActions) === undefined)?0:(result.noOfEntUserActions || result.noOfUserActions);
                        actionsConTotal += result.noOfConUserActions || 0;
                        queriesTotal += ((result.noOfEntFaqSuccess || result.noOfFaqSuccess) === undefined)?0:(result.noOfEntFaqSuccess || result.noOfFaqSuccess);
                        queriesConTotal += result.noOfConFaqSuccess || 0;
                        queriesTotalEach = ((result.noOfEntFaqSuccess || result.noOfFaqSuccess) === undefined)?0:(result.noOfEntFaqSuccess || result.noOfFaqSuccess);
                        queriesConTotalEach = result.noOfConFaqSuccess || 0;
                        dialogsTotal += ((result.noOfEntDialogSuccess || result.noOfDialogSuccess1) === undefined)?0:(result.noOfEntDialogSuccess || result.noOfDialogSuccess1);
                        dialogsConTotal += result.noOfConDialogSuccess || 0;
                        result.noOfChats = Number(((result.noOfEntChatRequest || result.noOfChatRequest)===undefined)?0:(result.noOfEntChatRequest || result.noOfChatRequest)) + Number(result.noOfConChatRequest || 0) + Number(((result.noOfEntChatResponse || result.noOfChatResponse)===undefined)?0:(result.noOfEntChatResponse || result.noOfChatResponse)) + Number(result.noOfConChatResponse || 0);
                        chatsTotal += result.noOfChats;
                        result.taskGraph = Number(((result.noOfEntUserActions || result.noOfUserActions)===undefined)?0:(result.noOfEntUserActions || result.noOfUserActions)) + Number(result.noOfConUserActions || 0) + Number(((result.noOfEntDialogSuccess || result.noOfDialogSuccess1)===undefined)?0:(result.noOfEntDialogSuccess || result.noOfDialogSuccess1)) + Number(result.noOfConDialogSuccess || 0) + Number(((result.noOfEntUserAlerts || result.noOfUserAlerts)===undefined)?0:(result.noOfEntUserAlerts || result.noOfUserAlerts)) + Number(result.noOfConUserAlerts || 0);
                        taskBarGraph = result.taskGraph;
                        $scope.tasksStats.taskBarGraph.push(result.taskGraph);
                        $scope.tasksStats.queriesTotal.push(queriesTotalEach + queriesConTotalEach);
                        $scope.tasksStats.barGraphDate.push(result.date_day || result.date_hour);
                        alertSuccess += ((result.noOfEntAlertSuccess || result.noOfAlertSuccess)===undefined)?0:(result.noOfEntAlertSuccess || result.noOfAlertSuccess);
                        alertConSuccess += result.noOfConAlertSuccess || 0;
                        actionSuccess += ((result.noOfEntActionSuccess || result.noOfActionSuccess)===undefined)?0:(result.noOfEntActionSuccess || result.noOfActionSuccess);
                        actionConSuccess +=result.noOfConActionSuccess || 0;
                        dialogFail += ((result.noOfEntDialogFail || result.noOfDialogFail)===undefined)?0:(result.noOfEntDialogFail || result.noOfDialogFail);
                        dialogConFail +=result.noOfConDialogFail || 0;
                        queriesSuccess +=((result.noOfEntFaqSuccess || result.noOfFaqSuccess)===undefined)?0:(result.noOfEntFaqSuccess || result.noOfFaqSuccess);
                        queriesConSuccess +=result.noOfconFaqSuccess || 0;
                        queriesFail +=((result.noOfEntFaqFail || result.noOfFaqFail)===undefined)?0:(result.noOfEntFaqFail || result.noOfFaqFail);
                        queriesConFail +=result.noOfconFaqFail || 0;
                        alertFail +=((result.noOfEntAlertFail || result.noOfAlertFail)===undefined)?0:(result.noOfEntAlertFail || result.noOfAlertFail);
                        alertConFail +=result.noOfconAlertFail || 0;
                        actionFail +=((result.noOfEntActionFail || result.noOfActionFail)===undefined)?0:(result.noOfEntActionFail || result.noOfActionFail);
                        actionConFail +=result.noOfConActionFail || 0; 
                    });
                    tasksTotal = alertsTotal + alertsConTotal + actionsTotal + actionsConTotal + chatsTotal;
                    tasksPerformedTotal = actionsTotal + actionsConTotal + dialogsTotal + dialogsConTotal + queriesTotal + queriesConTotal;
                    $scope.tasksStats.alertsConTotal = alertsTotal + alertsConTotal;
                    $scope.tasksStats.alertsTotal = alertsTotal + alertsConTotal;
                    $scope.tasksStats.actionsTotal = actionsTotal + actionsConTotal;
                    $scope.tasksStats.chatsTotal = chatsTotal;
                    $scope.tasksStats.tasksTotal = tasksTotal;
                    tasksPerformedTotal = actionsTotal + actionsConTotal + dialogsTotal + dialogsConTotal + queriesTotal + queriesConTotal;
                    //$scope.tasksStats.intentSucess = dialogsTotal + dialogsConTotal + queriesTotal + queriesConTotal + alertSuccess + alertConSuccess + actionSuccess + actionConSuccess;
                    //$scope.tasksStats.intentFailed = dialogFail + dialogConFail + queriesFail + queriesConSuccess + actionConFail + actionFail + alertConFail + alertFail;
                    //$scope.tasksStats.queriesTotal = queriesTotal + queriesConTotal;
                    $scope.tasksStats.tasksPerformedTotal = tasksPerformedTotal;
                    //$scope.tasksStats.taskBarGraph=taskBarGraph;
                    drawBarGraph();
                    //drawLineGraph();
                    //drawPieChart();
                }
            };

            var responseHandleDashboardChats = function (res) {
                if(res && res.data) {
                    $scope.dashboardLoading = false;
                    // $scope.groupbarChartLoading = false;
                    $scope.dashboardCounts = res.data;
                    var alertsTotal = 0;
                    var alertsConTotal = 0;
                    var actionsTotal = 0;
                    var actionsConTotal = 0;
                    var reportsTotal = 0;
                    var chatsTotal = 0;
                    var tasksTotal = 0;
                    var dialogsTotal = 0;
                    var dialogsConTotal = 0;
                    var tasksPerformedTotal = 0;
                    var queriesTotal = 0;
                    var queriesConTotal = 0;
                    var alertSuccess=0;
                    var alertConSuccess=0;
                    var actionSuccess=0;
                    var actionConSuccess=0;
                    var dialogFail=0;
                    var dialogConFail=0;
                    var queriesSuccess=0;
                    var queriesConSuccess=0;
                    var queriesFail =0;
                    var queriesConFail=0;
                    var alertFail=0;
                    var alertConFail=0;
                    var actionFail=0;
                    var actionConFail=0;
                    var taskBarGraph =0;
                    var queriesTotalEach =0;
                    var queriesConTotalEach =0;
                    $scope.tasksStats = {'alertsTotal':0,'actionsTotal':0,'chatsTotal':0,'tasksTotal':0,'queriesTotal':[],'barGraphDate':[],'tasksPerformedTotal':0,'alertsConTotal':0,'taskBarGraph':[]};
                    $.each(res.data.results, function(index, result) {
                        alertsTotal += ((result.noOfEntUserAlerts || result.noOfUserAlerts) === undefined)?0:(result.noOfEntUserAlerts || result.noOfUserAlerts);
                        alertsConTotal += result.noOfConUserAlerts || 0;
                        actionsTotal += ((result.noOfEntUserActions || result.noOfUserActions) === undefined)?0:(result.noOfEntUserActions || result.noOfUserActions);
                        actionsConTotal += result.noOfConUserActions || 0;
                        queriesTotal += ((result.noOfEntFaqSuccess || result.noOfFaqSuccess) === undefined)?0:(result.noOfEntFaqSuccess || result.noOfFaqSuccess);
                        queriesConTotal += result.noOfConFaqSuccess || 0;
                        queriesTotalEach = ((result.noOfEntFaqSuccess || result.noOfFaqSuccess) === undefined)?0:(result.noOfEntFaqSuccess || result.noOfFaqSuccess);
                        queriesConTotalEach = result.noOfConFaqSuccess || 0;
                        dialogsTotal += ((result.noOfEntDialogSuccess || result.noOfDialogSuccess1) === undefined)?0:(result.noOfEntDialogSuccess || result.noOfDialogSuccess1);
                        dialogsConTotal += result.noOfConDialogSuccess || 0;
                        result.noOfChats = Number(((result.noOfEntChatRequest || result.noOfChatRequest)===undefined)?0:(result.noOfEntChatRequest || result.noOfChatRequest)) + Number(result.noOfConChatRequest || 0) + Number(((result.noOfEntChatResponse || result.noOfChatResponse)===undefined)?0:(result.noOfEntChatResponse || result.noOfChatResponse)) + Number(result.noOfConChatResponse || 0);
                        chatsTotal += result.noOfChats;
                        result.taskGraph = Number(((result.noOfEntUserActions || result.noOfUserActions)===undefined)?0:(result.noOfEntUserActions || result.noOfUserActions)) + Number(result.noOfConUserActions || 0) + Number(((result.noOfEntDialogSuccess || result.noOfDialogSuccess1)===undefined)?0:(result.noOfEntDialogSuccess || result.noOfDialogSuccess1)) + Number(result.noOfConDialogSuccess || 0) + Number(((result.noOfEntUserAlerts || result.noOfUserAlerts)===undefined)?0:(result.noOfEntUserAlerts || result.noOfUserAlerts)) + Number(result.noOfConUserAlerts || 0);
                        taskBarGraph = result.taskGraph;
                        $scope.tasksStats.taskBarGraph.push(result.taskGraph);
                        $scope.tasksStats.queriesTotal.push(queriesTotalEach + queriesConTotalEach);
                        $scope.tasksStats.barGraphDate.push(result.date_day || result.date_hour);
                        alertSuccess += ((result.noOfEntAlertSuccess || result.noOfAlertSuccess)===undefined)?0:(result.noOfEntAlertSuccess || result.noOfAlertSuccess);
                        alertConSuccess += result.noOfConAlertSuccess || 0;
                        actionSuccess += ((result.noOfEntActionSuccess || result.noOfActionSuccess)===undefined)?0:(result.noOfEntActionSuccess || result.noOfActionSuccess);
                        actionConSuccess +=result.noOfConActionSuccess || 0;
                        dialogFail += ((result.noOfEntDialogFail || result.noOfDialogFail)===undefined)?0:(result.noOfEntDialogFail || result.noOfDialogFail);
                        dialogConFail +=result.noOfConDialogFail || 0;
                        queriesSuccess +=((result.noOfEntFaqSuccess || result.noOfFaqSuccess)===undefined)?0:(result.noOfEntFaqSuccess || result.noOfFaqSuccess);
                        queriesConSuccess +=result.noOfconFaqSuccess || 0;
                        queriesFail +=((result.noOfEntFaqFail || result.noOfFaqFail)===undefined)?0:(result.noOfEntFaqFail || result.noOfFaqFail);
                        queriesConFail +=result.noOfconFaqFail || 0;
                        alertFail +=((result.noOfEntAlertFail || result.noOfAlertFail)===undefined)?0:(result.noOfEntAlertFail || result.noOfAlertFail);
                        alertConFail +=result.noOfconAlertFail || 0;
                        actionFail +=((result.noOfEntActionFail || result.noOfActionFail)===undefined)?0:(result.noOfEntActionFail || result.noOfActionFail);
                        actionConFail +=result.noOfConActionFail || 0; 
                    });
                    tasksTotal = alertsTotal + alertsConTotal + actionsTotal + actionsConTotal + chatsTotal;
                    tasksPerformedTotal = actionsTotal + actionsConTotal + dialogsTotal + dialogsConTotal + queriesTotal + queriesConTotal;
                    $scope.tasksStats.alertsConTotal = alertsTotal + alertsConTotal;
                    $scope.tasksStats.alertsTotal = alertsTotal + alertsConTotal;
                    $scope.tasksStats.actionsTotal = actionsTotal + actionsConTotal;
                    $scope.tasksStats.chatsTotal = chatsTotal;
                    $scope.tasksStats.tasksTotal = tasksTotal;
                    tasksPerformedTotal = actionsTotal + actionsConTotal + dialogsTotal + dialogsConTotal + queriesTotal + queriesConTotal;
                    $scope.tasksStats.tasksPerformedTotal = tasksPerformedTotal;
                    // drawLineGraph();
                    groupBarChart();
                }
            };

            var responseHandleChannelsMetrics = function (res) {
                var payload= {};
                payload.filters = {};
                // payload.filters.tags = $scope.filterComponent.tags;
                payload.filters.sessionCategory = $scope.selectedSessionFilter;
                if(res && res.data) {
                    var channelName ="";
                    $scope.channelsData=res.data;
                    var channelsData = [];
                    for(var i=0;i<res.data.results.length;i++){
                        var obj = {};
                        obj.name = $scope._channelConfig.channelsObject[res.data.results[i].channel].name;
                        obj.count = res.data.results[i].noOfChatRequest +  res.data.results[i].noOfChatResponse;
                        obj.icon =$scope._channelConfig.channelsObject[res.data.results[i].channel].icon;
                        channelsData.push(obj);
                    }
                    $scope.languagesAndChannelsData[0].data = channelsData;
                    if($scope.selectedLinkedBots && $scope.selectedLinkedBots.length !== 0) {
                        $scope.languagesAndChannelsData[0].isLinkedBotSelected = true;  
                        $scope.isLinkedBotSelectedClone = true; 
                    }
                    else {
                        $scope.languagesAndChannelsData[0].isLinkedBotSelected = false;
                        $scope.isLinkedBotSelectedClone = false;
                    }
                }
            };

            var responseHandleSessionsCount = function (res) {
                if(res && res.data) {
                    var sum=0;
                    for(var i=0;i<res.data.sessionBuckets.length;i++){
                        sum = sum + res.data.sessionBuckets[i].sessions;
                    }
                    $scope.scount=sum;
                }
            };

            function performingBotsDashboard () {
                var dimension= "organization,linkedbot";
                var channels = $scope.selectedChannels.toString();
                var languages = $scope.selectedLangauges.toString();
                BTStreamsService.performingBotsUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),dimension,channels,"", $scope.selectedLinkedBots.toString(),languages).then(
                    function(res){
                        // $scope.topPerformingBots = res;
                        // drawUniPieChart(res);
                        $scope.checkDockStatus();
                    }, function(err){console.log(err);});
            }

            function sessionsGraph(){
                var channels = $scope.selectedChannels.toString();
                var languages = $scope.selectedLangauges.toString();
                var payload= {};
                payload.filters = {};
                payload.filters.tags = $scope.filterComponent.tags;
                payload.filters.sessionCategory = $scope.selectedSessionFilter;
                $scope.dashboardLoading = true;

                var responseHandle = function (res) {
                    if(res && res.data) {
                        $scope.dashboardLoading = false;
                        $scope.sessionsGraphData=res.data;
                    }
                    // drawLineGraph(); Not using 
                    // groupBarChart();
                };

                var errorHandle = function (error) {
                    $scope.dashboardLoading = false;
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify( i18n.i18nString('error_handle'), 'error');
                    }
                };
                if($scope.stream.type === 'universalbot') {
                    BTStreamsService.sessionsGraphUniversal($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),sessionInterval,channels, $scope.selectedLinkedBots.toString(),languages,payload).then(responseHandle, errorHandle);
                }
                else {
                    BTStreamsService.sessionsGraph($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id,$scope.start.toISOString(),$scope.end.toISOString(),sessionInterval,channels,languages,payload).then(responseHandle, errorHandle);
                }
            }
            function intentGraphData(){
                var payload = {};
                var payload1 ={};
                var channels = $scope.selectedChannels.toString();
                var languages = $scope.selectedLangauges.toString();
                payload.type = "successintent";
                payload.filters = {'from':$scope.start.toISOString(), 'to': $scope.end.toISOString(), 'isDeveloper': false};
                if(channels && channels.length){
                    payload.filters.channel = channels;
                }
                if(languages && languages.length){
                    payload.filters.language = [];
                    payload.filters.language = $scope.selectedLangauges;
                }
                if($scope.selectedLinkedBots.toString() !== "") {
                    $element.find('.pieGraphContainer').css('visibility', 'hidden');
                    payload.filters.linkedBotId = angular.copy($scope.selectedLinkedBots);
                }
                else {
                    $element.find('.pieGraphContainer').css('visibility', 'visible');
                }
                payload1 = angular.copy(payload);
                payload1.type = "failintent";
                payload.filters.tags = $scope.filterComponent.tags;
                payload1.filters.tags = $scope.filterComponent.tags;
                payload.filters.sessionCategory = $scope.selectedSessionFilter;
                payload1.filters.sessionCategory = $scope.selectedSessionFilter;
                $q.all([$translator.translate('bt.post.getRecordsCount', {streamId: $workflowService.selectedStream()._id, offset: 0, limit: 10},payload),$translator.translate('bt.post.getRecordsCount', {streamId: $workflowService.selectedStream()._id, offset: 0, limit: 10},payload1)])
                    .then(function(res) {
                        $scope.pieChartSucess = res[0].data.totalCount;
                        $scope.pieChartFailed = res[1].data.totalCount;
                        $scope.tasksStats.intentSucess = res[0].data.totalCount;
                        $scope.tasksStats.intentFailed = res[1].data.totalCount;
                        drawPieChartNew();
                    }, function (error) {
                        if (error && error.data && error.data.errors) {
                            var _msg = error.data.errors[0].msg;
                            NotificationService.notify(_msg, 'error');
                        } else if (error.errors && _.isArray(error)) {
                            var msg = error.errors[0].msg;
                            NotificationService.notify(msg, 'error');
                        } else {
                            NotificationService.notify( i18n.i18nString('error_handle'), 'error');
                        }
                    });
            }
            $scope.selectRange = function (selectedRange) {
                if (!$scope.fakeDataUI) {
                    $scope.selectedRange = selectedRange;
                    if ($scope.selectedRange === 'custom') {
                        if($scope.appliedSelectedRange=="7days"){
                            $('input[name="daterange"]').data('daterangepicker').setStartDate(moment().subtract(7,'days').format('MM-DD-YYYY'));
                            $('input[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                         
                         }
                         else if($scope.appliedSelectedRange=="24hours"){
                             $('input[name="daterange"]').data('daterangepicker').setStartDate(moment().format('MM-DD-YYYY'));
                             $('input[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                          
                         }
                        daterangepickerInput.click();
                    } else if ($scope.selectedRange === '7days') {
                        getDashboardData();
                    } else if ($scope.selectedRange === '24hours') {
                        getDashboardData();
                    }
                }

            };

            var reloadDockStatus = true;
            $rootScope.$on("usageMetricsStatus", function ($event, data, type) {
                if(reloadDockStatus) {
                    if(data && data.status === "IN_PROGRESS") {
                        console.log(data);
                    } else if(data && (data.status === "SUCCESS" && data.percentageComplete === 100) && data.response) {
                        if(type === 'DASHBOARDREPORT_API') {
                            if($scope.stream.type === 'universalbot') {
                                responseHandleDashboardCount({data: data.response});
                                responseHandleDashboardChats({data: data.response});
                            } else {
                                responseHandleDashboardCount({data: data.response});// Successful Tasks bar chart
                            }
                        }else if(type === 'CHATSDASHBOARDREPORT_API') { 
                            responseHandleDashboardChats({data: data.response});// Message & Conversation grp chart
                        } else if(type === 'ENTERPRISEACTIONREPORT_API') { 
                            taskResponseHandle({data: data.response});// Success full tasks metrics
                        } else if(type === 'CHANNELREPORT_API') { 
                            responseHandleChannelsMetrics({data: data.response});// Channels metrics
                        } else if(type === 'ENTERPRISEDASHBOARDREPORT_API') { // UB bot: Pie chart
                            drawUniPieChart({data: data.response});
                        } else if(type === 'SESSIONCOUNTFORCHART_API') { // All chat session records
                            responseHandleSessionsCount({data: data.response});
                        } else if(type === 'AGENTTRANSFERREPORT_API') {
                            agentTransferResponseHandle({data: data.response}); // Agent transfer metrics
                        }
                    } else if(data && (data.status === "FAILURE" && data.percentageComplete === 100)) {
                        console.log(data);
                    }
                    // reloadDockStatus = false;
                    // setTimeout(function(){
                    //     reloadDockStatus = true;
                    // },100);
                }
            });

            $scope.checkDockStatus = function () {
                $rootScope.$broadcast('getProgressDockStatus');
                $rootScope.$broadcast('startTimer');
            };

            //Stacked Bar Graph
            function drawBarGraph(graphData){
                $scope.barGraphAvailable=false;
                setTimeout(function(){
                    var margin = {top: 20, right: 20, bottom: 30, left: 60};
                var width = $element.find('.bar-graph').width() - margin.left - margin.right,
                    height = 320 - margin.top - margin.bottom;
                var parseDate = d3.timeParse("%d-%b-%y %H:%M:%S");
                $element.find('.bar-graph').html('');
                var svg = d3.select(".bar-graph")
                  .append("svg")
                  .attr("width", width + margin.left + margin.right)
                  .attr("height", height + margin.top + margin.bottom)
                  .append("g")
                  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var barDate="";
                var dateFormat ="";
                var dataset = [];
                var dataset1 = [];
                var dataset2 = [];
                var obj={};
                if (!graphData) {
                    var i;
                    for (i = 0; i < $scope.tasksStats.taskBarGraph.length; i++) {
                        // dateFormat = new Date($scope.tasksStats.barGraphDate[i].toUpperCase());
                        dateFormat = $scope.tasksStats.barGraphDate[i].toUpperCase();
                        barDate = ($scope.selectedRange === "7days" || $scope.selectedRange === "custom" ) ? moment.parseZone(dateFormat).format('DD-MMM') : moment(dateFormat).format('HH:mm');
                        obj = {"x": barDate, "y": $scope.tasksStats.taskBarGraph[i], "y0": 0};
                        dataset1.push(obj);
                    }
                    for (i = 0; i < $scope.tasksStats.queriesTotal.length; i++) {
                        // dateFormat = new Date($scope.tasksStats.barGraphDate[i].toUpperCase());
                        dateFormat = $scope.tasksStats.barGraphDate[i].toUpperCase();
                        barDate = ($scope.selectedRange === "7days" || $scope.selectedRange === "custom") ? moment.parseZone(dateFormat).format('DD-MMM') : moment(dateFormat).format('HH:mm');
                        obj = {"x": barDate, "y0": $scope.tasksStats.taskBarGraph[i], "y": $scope.tasksStats.queriesTotal[i]};
                        dataset2.push(obj);
                    }
                    dataset.push(dataset1);
                    dataset.push(dataset2);
                }else{
                    dataset=graphData;
                }
              
                if((dataset[0].length===0 && dataset[1].length===0) || $scope.tasksStats.tasksPerformedTotal === 0){
                    $scope.barGraphAvailable=true;
                    dataset = [];
                }
                else {
                    var x = d3.scaleBand().range([30,width]).padding(0.1);
                    x.domain(dataset[0].map(function(d) { return d.x; }));
                    var y = d3.scaleLinear()
                        .domain([0, d3.max(dataset, function(d) {
                            return d3.max(d, function(d) { 
                                return d.y0 + d.y; 
                            });  
                        })])
                        .range([height, 0]);
                    
                    var colors = ["#28A745","#E4E5E7"];
                    // Define and draw axes
                    var yAxis = d3.axisLeft()
                    .scale(y)
                    .ticks(5)
                    .tickSize(-width, 0, 0)
                    .tickFormat( function(d) { return d; } );
                    var xAxis = null;
                    if($scope.selectedRange === '7days'){
                        xAxis = d3.axisBottom()
                        .scale(x);
                    }else if($scope.selectedRange === '24hours'){
                        xAxis = d3.axisBottom()
                        .tickValues(x.domain().filter(function(d,i){ 
                            return (i%2 === 0);
                        }))
                        .scale(x);
                    }
                    else{
                        var xAxisDataLength = x.domain().length;
                        // xAxis = d3.axisBottom()
                        // .tickValues(x.domain().filter(function(d,i){ 
                        //     return xAxisDataLength < 17?true:xAxisDataLength < 35?i%2:i%6===0;
                        // }))
                        // .scale(x);
                        if(xAxisDataLength>16 && xAxisDataLength<33){
                            xAxis = d3.axisBottom()
                            .tickValues(x.domain().filter(function(d,i){ 
                                return i%4 === 0;
                            }))
                            .scale(x);
                        }
                        else if(xAxisDataLength>32 && xAxisDataLength<49){
                            xAxis = d3.axisBottom()
                            .tickValues(x.domain().filter(function(d,i){ 
                                return i%5 === 0;
                            }))
                            .scale(x);
                        }
                        else if(xAxisDataLength>48 && xAxisDataLength<65){
                            xAxis = d3.axisBottom()
                            .tickValues(x.domain().filter(function(d,i){ 
                                return i%6 === 0;
                            }))
                            .scale(x);
                        }
                        else if(xAxisDataLength>64 && xAxisDataLength<90){
                            xAxis = d3.axisBottom()
                            .tickValues(x.domain().filter(function(d,i){ 
                                return i%7 === 0;
                            }))
                            .scale(x);
                        }
                        else if(xAxisDataLength>89){
                            xAxis = d3.axisBottom()
                            .tickValues(x.domain().filter(function(d,i){ 
                                return i%8 === 0;
                            }))
                            .scale(x);
                        } else {
                            xAxis = d3.axisBottom().scale(x);
                        }
                    }


                    var div = d3.select('.bar-graph').append("div");
                    svg.append("g")
                    .attr("class", "y axis")
                    .call(yAxis);
                    
                    svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0,0)")
                    .attr("transform", "translate(0," + (height+5) + ")")
                    .call(xAxis);
                    
                    var divTooltip = d3.select(".bar-graph").append("div").attr("class", "barTooltip");
                    // Create groups for each series, rects for each segment 
                    var groups = svg.selectAll("g.cost")
                    .data(dataset)
                    .enter().append("g")
                    .attr("class", "cost")
                    .style("fill", function(d, i) { return colors[i]; });
                    //var div = d3.select('.bar-graph').append("div");
                    var rect = groups.selectAll("rect")
                    .data(function(d) { return d; })
                    .enter()
                    .append("rect")
                    .attr("x", function(d) { return x(d.x); })
                    .attr("y", function(d) { return y(d.y0 + d.y); })
                    .attr("height", function(d) { return y(d.y0) - y(d.y0 + d.y); })
                    .attr("width", x.bandwidth()-2)
                    .on("mousemove", function(d){
                        var _condition;
                        var _color=d3.select(this).style("fill");
                        if(_color === "rgb(228, 229, 231)"){
                            _condition ="faq";
                        }else if(_color === "rgb(40, 167, 69)"){
                            _condition ="tasks";
                        }
                        var _calValue,_calName;
                        if(_condition==="faq"){
                            var postiveVal = d.y;
                            _calValue = postiveVal;
                            if(postiveVal < 0){
                                _calValue = -1*postiveVal;
                            }else{
                                _calValue=postiveVal;
                            }
                            _calName=i18n.i18nString('faqs');
                        }else{
                            _calValue=d.y - d.y0;
                            _calName=i18n.i18nString('Tasks_and_languages_label');
                        }
                        divTooltip.style("opacity", 0.9);
                        divTooltip.style("display","inline-block"); 
                        divTooltip.html("<div class='title tasksAndFaqTooltipData'>"+_calName+"<div/>" + "<div class='sub-title' style='color:#009dab'>" + _calValue+"</div>")
                        .style("left", (d3.event.pageX - $('.bar-graph').offset().left + 25) + "px")     // move it in the x direction
                        .style("top", (d3.event.pageY - $('.bar-graph').offset().top  - 60) + "px"); 
                    })
                    .on("mouseout", function(d) {
                        divTooltip.style("opacity", 0);	
                    });
                }
                },0);
            }
            //Y2 Line Graph - OLD
            function drawLineGraph(graphData) {
                var margin = {top: 30, right: 40, bottom: 30, left: 50},
                    width = $element.find('.graph-container').width() - margin.left - margin.right,
                    height = 350 - margin.top - margin.bottom;                  
                //var parseDate = d3.timeParse("%d-%b-%y %H:%M:%S");
                var x = d3.scaleTime().range([0, width]);
                var y0 = d3.scaleLinear().range([height, 0]);
                var y1 = d3.scaleLinear().range([height, 0]);
                var xAxis;
                var xAxisTicks = $scope.dashboardCounts.results.length;
                // if(xAxisTicks > 12){
                //     xAxisTicks = 8;
                // }
                // if(xAxisTicks === 3){
                //     xAxisTicks = 2;
                // }
                var xCount = 1;
                if(xAxisTicks < 14){
                    xCount = 1;
                }
                else if(xAxisTicks < 27){
                    xCount = 2;
                }
                else if(xAxisTicks < 40){
                    xCount = 3;
                }
                else if(xAxisTicks < 53){
                    xCount = 4;
                }
                else if(xAxisTicks < 66){
                    xCount = 5;
                }
                else if(xAxisTicks < 79){
                    xCount = 6;
                }
                else{
                    xCount = 7;
                }

                if($scope.selectedRange === "24hours"){
                    xAxis = d3.axisBottom()
                        .scale(x)
                        .ticks(8);
                }
                else{
                    xAxis = d3.axisBottom()
                        .scale(x)
                        //.ticks(xAxisTicks)
                        .ticks(d3.timeDay.every(xCount))
                        .tickFormat(d3.timeFormat("%b %d"));
                }
                var yAxisLeft = d3.axisLeft()
                    .scale(y0)
                    .tickSizeInner(-width)
                    .tickSizeOuter(0)
                    .tickPadding(5);
                var yAxisRight = d3.axisRight()
                    .scale(y1)
                    .tickSizeInner(-width)
                    .tickSizeOuter(0)
                    .tickPadding(5);
                var valueline = d3.line()
                    .x(function (d) { return x(d.date); })
                    .y(function (d) { return y0(d.close); });
                    //valueline.curve(d3.curveCardinal.tension(0.3));
                    valueline.curve(d3.curveMonotoneX);
                var valueline2 = d3.line()
                    .x(function (d) { return x(d.date); })
                    .y(function (d) { return y1(d.open); });
                    //valueline2.curve(d3.curveCardinal.tension(0.3));
                    valueline2.curve(d3.curveMonotoneX);
                $element.find('.graph-container').html('');
                var svg = d3.select(".graph-container")
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform","translate(" + margin.left + "," + margin.top + ")");
                $scope.linechartAvailable = true;
                // Get the data
                var data = [];
                if (!graphData) {
                    var sessionObj = {};
                    if (($scope.selectedRange === '24hours')) {
                        date_type_chart = "date_hour";
                        $scope.sessionsGraphData.modifiedResult.forEach(function (val, ind) {
                            var currDate = new Date(val.date.toUpperCase());
                            sessionObj[currDate.getTime()] = val.botSessions;
                        });
                    } else {
                        date_type_chart = "date_day";
                        $scope.sessionsGraphData.modifiedResult.forEach(function (val, ind) {
                            var currDate = moment(new Date(val.date)).format('DD-MMM-YY');
                            sessionObj[currDate] = val.botSessions;
                        });
                    }
                    $scope.dashboardCounts.results = $scope.dashboardCounts.results || [];
                    var dateFormat1;
                    var currDate2;
                    $scope.dashboardCounts.results.forEach(function (res, ind) {
                        if($scope.selectedRange === '24hours'){
                            date_type_chart = "date_hour";
                            dateFormat1 = new Date(res[date_type_chart].toUpperCase());
                            currDate2 = dateFormat1.getTime();
                                data.push({
                                    date: dateFormat1,
                                    close: Number(res.noOfChats),
                                    open: Number((sessionObj[currDate2] === undefined) ? 0 : sessionObj[currDate2])
                                });
                        }else{
                            dateFormat1 = new Date(res[date_type_chart]);
                            currDate2 = moment(dateFormat1).format('DD-MMM-YY');
                            dateFormat1.setHours('00');
                            dateFormat1.setMinutes('00');
                            data.push({
                                date: dateFormat1,
                                close: Number(res.noOfChats),
                                open: Number((sessionObj[moment(dateFormat1).format('DD-MMM-YY')] === undefined) ? 0 : sessionObj[moment(dateFormat1).format('DD-MMM-YY')])
                            });
                        }
                    });
                    var chatObj = {};
                    $scope.dashboardCounts.results.forEach(function(stat,ind){
                        var dateFormat2 = new Date(stat[date_type_chart].toUpperCase());
                        var date2 = ($scope.selectedRange === "24hours") ? dateFormat2.getTime() : moment(dateFormat2).format('DD-MMM-YY');
                        chatObj[date2] = stat.noOfChats;
                    });
                    if($scope.selectedRange === "24hours"){
                        $scope.sessionsGraphData.modifiedResult.forEach(function(val,ind){
                            var dateFormat1 = new Date(val.date.toUpperCase());
                            var currDate2 = dateFormat1.getTime();
                            if(!chatObj.hasOwnProperty(currDate2)){
                                data.push({
                                    date: dateFormat1,
                                    close: Number(0),
                                    open: Number(val.botSessions)
                                });
                            }
                        });
                    }else{
                        $scope.sessionsGraphData.modifiedResult.forEach(function(val,ind){
                            var dateFormat1 = new Date(val.date.toUpperCase());
                            var currDate2 = moment(dateFormat1).format('DD-MMM-YY');
                            if($scope.selectedRange !== "24hours"){
                                dateFormat1.setHours('00');
                                dateFormat1.setMinutes('00');
                            }
                            if(!chatObj.hasOwnProperty(currDate2)){
                                data.push({
                                    date: dateFormat1,
                                    close: Number(0),
                                    open: Number(val.botSessions)
                                });
                            }
                        });
                    }
                    data.sort(function(x,y){var date1 = new Date(x.date),date2 = new Date(y.date); return date1-date2; });
                }else{
                    data=graphData;
                }
                if(data.length===0){
                    $scope.linechartAvailable=false;
                }
                if(data.length){
                    data.forEach(function (d) {
                        d.date = d.date;
                        d.close = +d.close;
                        d.open = +d.open;
                    });

                    // Scale the range of the data
                    x.domain(d3.extent(data, function (d) { return d.date; }));
                    var y0Max = d3.max(data, function (d) { return Math.max(d.close); });
                    y0.domain([0, y0Max]);
                    var y1Max = d3.max(data, function (d) { return Math.max(d.open); });
                    y1.domain([0, y1Max]);
                    yAxisLeft.tickValues([0, (y0Max * 1/5), (y0Max * 2/5), (y0Max * 3/5),(y0Max * 4/5),(y0Max * 5/5)]);
                    yAxisRight.tickValues([0, (y1Max * 1/5), (y1Max * 2/5), (y1Max * 3/5),(y1Max * 4/5),(y1Max * 5/5)]);
                    svg.append("g")                                                         // Add the X Axis
                        .attr("class", "xAxis")
                        .attr("transform", "translate(0," + height + ")")
                        .call(xAxis);
                    svg.append("g")
                        .attr("class", "ySideLeft")
                        .call(yAxisLeft);
                    svg.append("g")
                        .attr("class", "ySideRight")
                        .attr("transform", "translate(" + width + " ,0)")
                        .call(yAxisRight);
                    var path0 = svg.append("path")                                         // Add the valueline path.
                        .data([data])
                        .style("stroke","#009dab")
                        .style("fill","none")
                        .style("stroke-width","4px")
                        .attr("class", "chartsLine")
                        .attr("d", valueline);
                    var totalLength0 = path0.node().getTotalLength();
                    path0
                        .attr("stroke-dasharray", totalLength0 + " " + totalLength0)
                        .attr("stroke-dashoffset", totalLength0)
                        .transition()
                        .duration(1000)
                        .attr("stroke-dashoffset", 0);
                    var path1 = svg.append("path")
                        .data([data])                                          // Add the valueline2 path.
                        .style("stroke","#f97300")
                        .style("fill","none")
                        .style("stroke-width","2px")
                        .attr("class", "sessionsLine")
                        .attr("d", valueline2);
                    var totalLength1 = path1.node().getTotalLength();
                    path1
                        .attr("stroke-dasharray", totalLength1 + " " + totalLength1)
                        .attr("stroke-dashoffset", totalLength1)
                        .transition()
                        .duration(1000)
                        .attr("stroke-dashoffset", 0);
                    setTimeout(function () {
                        var div = d3.select('.graph-container').append("div");
                        var circles0 = svg.selectAll("g1.dot")
                            .data(data)
                            .enter().append("g");
                        circles0.append("circle")
                        .attr("cx", function (d, i) {
                            return x(d.date);
                        })
                        .attr("cy", function (d, i) {
                            return y0(d.close);
                        })
                        .attr("r", 5)
                        .attr("class", "chartsCircle")
                        .style("fill", "#fff");

                        // Add inner circle.
                        circles0.append("circle")
                            .attr("cx", function (d, i) {
                                return x(d.date);
                            })
                            .attr("cy", function (d, i) {
                                return y0(d.close);
                            })
                            .attr("r", 4)
                            .attr("class", "chartsCircle")
                            .style("fill", "#009dab")
                            .on("mouseover", function (d) {                             // when the mouse goes over a circle, do the following
                                div.transition()                                        // declare the transition properties to bring fade-in div
                                .duration(200)                                          // it shall take 200ms
                                .style("opacity", 0.9)                                   // and go all the way to an opacity of .9
                                .style("position","absolute");
                                div.html("<div class='title chartsAndSessionsTooltipData'>"+i18n.i18nString('noofmsgs')+"<div/>" + "<div class='sub-title' style='color:#009dab'>" + d.close+"</div>")  // add the text of the tooltip as html 
                                .style("left", (d3.event.pageX - $('g').offset().left) + "px")     // move it in the x direction
                                .style("top", (d3.event.pageY - $('g').offset().top - 45) + "px");  // move it in the y direction
                            })
                            .on("mouseout", function(d) {		
                             div.transition()		
                             .duration(500)		
                             .style("opacity", 0);	
                            });         
                        var circles1 = svg.selectAll("g1.dot")
                                .data(data)
                                .enter().append("g");
                        circles1.append("circle")
                        .attr("cx", function (d, i) {
                            return x(d.date);
                        })
                        .attr("cy", function (d, i) {
                             return y1(d.open);
                        })
                        .attr("r", 5)
                        .attr("class", "sessionsCircle")
                        .style("fill", "#fff");
                        // Add inner circle.
                        circles1.append("circle")
                        .attr("cx", function (d, i) {
                            return x(d.date);
                        })
                        .attr("cy", function (d, i) {
                            return y1(d.open);
                        })
                        .attr("r", 4)
                        .attr("class", "sessionsCircle")
                        .style("fill", "#eaa724")
                        .on("mouseover", function (d) {                             // when the mouse goes over a circle, do the following
                            div.transition()                                        // declare the transition properties to bring fade-in div
                            .duration(1000)                                         // it shall take 200ms
                            .style("opacity", 0.9)   
                            .style("display","inline-block")                                // and go all the way to an opacity of .9
                            .style("position","absolute");
                            div.html("<div class='title chartsAndSessionsTooltipData'>No.of Conversations<div/>" + "<div class='sub-title' style='color:#b47700'>" + d.open + "</div>")
                            .style("left", (d3.event.pageX - $('g').offset().left - 10) + "px")     // move it in the x direction
                            .style("top", (d3.event.pageY - $('g').offset().top) - 45 + "px");  // move it in the y direction
                        })
                        .on("mouseout", function(d) {		
                         div.transition()		
                         .duration(200)		
                         .style("opacity", 0);	
                        });
                    },1000);
                }
            }

            // Groupbar chart - Messages & Conversation Sessions
            function groupBarChart() {
                $element.find('.groupbar-chart').html('');
                $scope.linechartAvailable = true;
                var data = [];
                var sessionObj = {};
                var chatObj = {};
                var chatData = $scope.dashboardCounts.results;
                if($scope.selectedRange === "24hours"){
                    date_type_chart = "date_hour";
                    if($scope.sessionsGraphData.modifiedResult) {
                        $scope.sessionsGraphData.modifiedResult.forEach(function(val,ind){
                            var currDate = val.date.toUpperCase();
                            sessionObj[currDate] = {'a':val.noOfInteractiveSessions,'b':val.noOfNonInteractiveSessions};
                        });
                    }
                }
                else{
                    date_type_chart = "date_day";
                    if($scope.sessionsGraphData.modifiedResult) {
                        $scope.sessionsGraphData.modifiedResult.forEach(function(val,ind){
                            var currDate = val.date.toUpperCase();
                            sessionObj[currDate] = {'a':val.noOfInteractiveSessions,'b':val.noOfNonInteractiveSessions};
                        });
                    }
                }
                chatData.forEach(function(stat,ind){
                    var dateFormat = stat[date_type_chart].toUpperCase();
                    data.push({
                        date: dateFormat,
                        close: Number(stat.noOfChats),
                        open: sessionObj[dateFormat] === undefined ? {'a':0,'b':0} : sessionObj[dateFormat]
                    });
                });

                chatData.forEach(function(stat,ind){
                    var dateFormat = stat[date_type_chart].toUpperCase();
                    chatObj[dateFormat] = stat.noOfChats;
                });

                if($scope.selectedRange === "24hours"){
                    if($scope.sessionsGraphData.modifiedResult) {
                        $scope.sessionsGraphData.modifiedResult.forEach(function(val,ind){
                            var dateFormat = val.date.toUpperCase();
                            if(!chatObj.hasOwnProperty(dateFormat)){
                                data.push({
                                    date: dateFormat,
                                    close: Number(0),
                                    open: {'a':val.noOfInteractiveSessions,'b':val.noOfNonInteractiveSessions}
                                });
                            }
                        });
                    }
                } else{
                    if($scope.sessionsGraphData.modifiedResult) {
                        $scope.sessionsGraphData.modifiedResult.forEach(function(val,ind){
                            var dateFormat13 = val.date.toUpperCase();
                            if(!chatObj.hasOwnProperty(dateFormat13)){
                                data.push({
                                    date: dateFormat13,
                                    close: Number(0),
                                    open: {'a':val.noOfInteractiveSessions,'b':val.noOfNonInteractiveSessions}
                                });
                            }
                        });
                    }
                }
                data.sort(function(x,y){var date1 = new Date(x.date),date2 = new Date(y.date); return date1-date2; });
                var noDataFound = data.every(function(res) { return res.close === 0;});
                if(data.length===0 || noDataFound){ // check if contains all zeros in count & open
                    $scope.linechartAvailable=false;
                    $scope.groupbarChartLoading = false;
                    return;
                }

                if(data.length){
                    if($scope.selectedRange === "24hours"){
                        data.shift();
                        data.map(function(d) { d.date =  moment(d.date).format("h:mm a");});
                    }
                    else{
                        data.map(function(d) { d.date =  moment.parseZone(d.date).format("Do MMM");});
                    }
                    var AllData = [];
                    data.forEach(function(val,ind){
                        AllData.push({
                            date: val.date,
                            values: [
                                {name:"nicCount", value:val.open.b, yoffset:val.open.b, yscale:0, total:val.open.a+val.open.b, msgCount: val.close, sessionT: val.open.a+val.open.b, icTotal: val.open.a, nicTotal:val.open.b, tipdate: val.date},
                                {name:"icCount", value: val.open.a, yoffset:val.open.a+val.open.b, yscale:0, total:val.open.a+val.open.b, msgCount: val.close, sessionT: val.open.a+val.open.b, icTotal: val.open.a, nicTotal:val.open.b, tipdate: val.date},
                                {name:"msgCount", value:val.close, yoffset:val.close, yscale:1, total:val.close, msgCount: val.close, sessionT: val.open.a+val.open.b, icTotal: val.open.a, nicTotal:val.open.b, tipdate: val.date}
                            ]
                        });
                    });
                    
                    var stack_key_mapping={
                        "icCount":"converse",
                        "nicCount":"converse",
                        "msgCount":"message"
                    };
                    
                    var _barStacked = function() {
                        // Define main variables
                        var d3Container = d3.select(".groupbar-chart");
                        var margin = {top: 40, right: 30, bottom: 30, left: 80};
                        var width = $element.find('.groupbar-chart').width() - margin.left - margin.right;
                        var height = 350 -  margin.top - margin.bottom;
                    
                        var container = d3Container.append("svg");
                        //var timeFormat = d3.timeFormat("%b %d");
                    
                        // Add SVG group
                        var svg = container
                                .attr("width", width + margin.left + margin.right)
                                .attr("height", height + margin.top + margin.bottom)
                                .append("g")
                                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                        var color = d3.scaleOrdinal().range(["#135423", "#28A745", "#0D6EFD"]);
                           
                        var x0 = d3.scaleBand().rangeRound([90, width]).padding([0.2]);
                        var x1 = d3.scaleBand();
                    
                        var y0 = d3.scaleLinear().rangeRound([height, 0]);
                        var y1 = d3.scaleLinear().rangeRound([height, 0]);
                    
                        // var xAxis = d3.axisBottom(x0).scale(x0).ticks(5).tickFormat(d3.timeFormat("%b %d"));
                        var xAxis = d3.axisBottom(x0).scale(x0).tickSizeOuter(0);
                        var yAxisLeft = d3.axisLeft(y0).scale(y0).tickPadding(30);
                        var yAxisRight = d3.axisLeft(y1).scale(y1).tickSizeInner(-width+70).tickSizeOuter(0).tickPadding(15);
                    
                        x0.domain(AllData.map(function(d) { return d.date; }));
                        x1.domain(['converse','message']).rangeRound([0, x0.bandwidth()]).padding([0.05]);
                        
                        if(AllData.length>16 && AllData.length<33){
                            xAxis.tickValues(x0.domain().filter(function(d,i){
                                return i%2 === 0 ? d : '';
                            }));
                        }
                        else if(AllData.length>32 && AllData.length<49){
                            xAxis.tickValues(x0.domain().filter(function(d,i){
                                return i%3 === 0 ? d : '';
                            }));
                        }
                        else if(AllData.length>48 && AllData.length<65){
                            xAxis.tickValues(x0.domain().filter(function(d,i){
                                return i%4 === 0 ? d : '';
                            }));
                        }
                        else if(AllData.length>64 && AllData.length<90){
                            xAxis.tickValues(x0.domain().filter(function(d,i){
                                return i%5 === 0 ? d : '';
                            }));
                        }
                        else if(AllData.length>89){
                            xAxis.tickValues(x0.domain().filter(function(d,i){
                                return i%6 === 0 ? d : '';
                            }));
                        }
                    
                        y0.domain([0, d3.max(AllData, function(d) { return d.values[0].value+d.values[1].value; })]);
                        y1.domain([0, d3.max(AllData, function(d) { return Math.max(d.values[2].value);})]);
    
                        var maxY0axis = d3.max(AllData, function(d) { return d.values[0].value+d.values[1].value; });
                        var maxY1axis = d3.max(AllData, function(d) { return Math.max(d.values[2].value);});
    
                        if(maxY0axis < 8){
                            yAxisLeft.tickValues(d3.range(0, maxY0axis+1)).tickFormat(d3.format(",.0f"));
                        }
                        else{
                            yAxisLeft.tickValues([0, (maxY0axis * 1/6), (maxY0axis * 2/6), (maxY0axis * 3/6),(maxY0axis * 4/6),(maxY0axis * 5/6),(maxY0axis * 6/6)]);
                        }
                        if(maxY1axis < 8){
                            yAxisRight.tickValues(d3.range(0, maxY1axis+1)).tickFormat(d3.format(",.0f"));
                        }
                        else{
                            yAxisRight.tickValues([0, (maxY1axis * 1/6), (maxY1axis * 2/6), (maxY1axis * 3/6),(maxY1axis * 4/6),(maxY1axis * 5/6),(maxY1axis * 6/6)]);
                        }
                    
                        // Ticks on x-axis and y-axis
                        svg.append("g").attr("class", "x axis")
                            .attr("transform", "translate(0," + height + ")")
                            .call(xAxis)
                            .selectAll("text");
                        // if(AllData.length<19){
                        //     svg.append("g").attr("class", "x axis")
                        //     .attr("transform", "translate(0," + height + ")")
                        //     .call(xAxis)
                        //     .selectAll("text");
                        // }
                        // else if(AllData.length<31){
                        //     svg.append("g").attr("class", "x axis")
                        //     .attr("transform", "translate(0," + height + ")")
                        //     .call(xAxis)
                        //     .selectAll("text")
                        //     .attr("transform", "translate(-5,2)rotate(-25)");
                        // }
                        // else{
                        //     svg.append("g").attr("class", "x axis")
                        //     .attr("transform", "translate(0," + height + ")")
                        //     .call(xAxis)
                        //     .selectAll("text")
                        //     .attr("transform", "translate(-12,25)rotate(-90)");
                        // }
                        
                    
                        var y0SideList = svg.append("g").attr("class", "y0 axis")
                        .call(yAxisLeft);
                        
                        y0SideList.append("text").attr("class", "ySideLeft").attr("transform", "translate(-42,0)")
                        .attr("y", -40)
                        .attr("x", -15)
                        .attr("dy", ".91em")
                        .text("Total")
                        .style("fill", "#28A745")
                        .style('font-size', '12px')
                        .style('font-weight', 'normal')
                        .style('font-family', 'Inter')
                        .style("text-anchor", "middle");
                        y0SideList.append("text").attr("class", "ySideLeft").attr("transform", "translate(-15,0)")
                        .attr("y", -25)
                        .attr("x", -15)
                        .attr("dy", ".91em")
                        .text("Conversations")
                        .style("fill", "#28A745")
                        .style('font-size', '12px')
                        .style('font-weight', 'normal')
                        .style('font-family', 'Inter')
                        .style("text-anchor", "middle");
                        
                    
                        svg.select('.y0.axis').selectAll('.tick').attr("class", "ySideLeft");
                    
                        var y1SideList = svg.append("g").attr("class", "y1 axis").attr("transform", "translate(" + 80 + ",0)")
                        .call(yAxisRight);
                        
                        y1SideList.append("text").attr("class", "ySideRight")
                        .attr("transform", "translate(-28,0)")
                        .attr("y", -40)
                        .attr("x", -15)
                        .attr("dy", ".91em")
                        .style("fill", "#0D6EFD")
                        .style('font-size', '12px')
                        .style('font-weight', 'normal')
                        .style('font-family', 'Inter')
                        .style("text-anchor", "middle")
                        .text("Total");
                        y1SideList.append("text").attr("class", "ySideRight")
                        .attr("transform", "translate(-15,0)")
                        .attr("y", -25)
                        .attr("x", -15)
                        .attr("dy", ".91em")
                        .style("fill", "#0D6EFD")
                        .style('font-size', '12px')
                        .style('font-weight', 'normal')
                        .style('font-family', 'Inter')
                        .style("text-anchor", "middle")
                        .text("Messages");
                    
                        svg.select('.y1.axis')
                        .selectAll('.tick').attr("class", "ySideRight");
                        // End ticks
    
    
                        svg.append("g")
                        .selectAll("g")
                        .data(AllData)
                        .enter().append("g")
                        .attr("class", "g")
                        .attr("transform", function(d) { return "translate(" + x0(d.date) + ",0)"; })
                        
                        .selectAll("rect")
                        .data(function(d) { return d.values; })
                        .enter()
                        .append("rect")
                        .attr("width", x1.bandwidth())
                        .attr("x", function(d) { return x1(stack_key_mapping[d.name]); })
                        .attr("y", function(d) { return d.yscale===0 ? y0(d.yoffset) : y1(d.yoffset); })
                        .attr("height", function(d) { return height - (d.yscale===0 ? y0(d.value) : y1(d.value)); })
                        .style("fill", function(d) { return color(d.name); })
                        .on("mouseover", function(d) {
                            tooltip
                              .html('<div class="rowdata">' + '<span class="value">' +  d.tipdate +'</span>' + '</div>' +
                                '<div class="rowdata"><span class="bg-color total-msg"></span>' + 'Total  Messages : ' + '<span class="value">' +d.msgCount +'</span></div>' +
                                '<div class="rowdata"><span><div class="total"><div class="self"></div><div class="drp"></div></div></span>' + 'Total Conversations : ' + '<span class="value">' +d.sessionT +'</span></div>' +
                                '<div class="rowdata"><span class="bg-color ic-conv"></span>' + 'Interactive Conversations : ' + '<span class="value">' + d.icTotal + '</span></div>' +
                                '<div class="rowdata"><span class="bg-color nic-conv"></span>' + 'Non- interactive Conversations : ' +'<span class="value">'+ d.nicTotal+ '</span>'+'</div>')
                              .style("opacity", 1)
                              .style("display",'block');
                        })
                        .on("mousemove", function(d) {
                            tooltip
                                .style("left", (d3.event.pageX - 230) + "px") // It is important to put the +90: other wise the tooltip is exactly where the point is an it creates a weird effect
                                .style("top", (d3.mouse(this)[1] - 60) + "px");
                        })
                        .on("mouseleave", function(d) {
                            tooltip
                              .style("opacity", 0).style('display', 'none');
                        });
    
    
                        var tooltip = d3Container
                        .append("div")
                        .attr("class", "toolTip")
                        .style("opacity", 0);
                    };
                    
                    _barStacked();
                    $scope.groupbarChartLoading = false;
                }      
            }

            //PIE CHART FOR UNIVERSAL DASHBOARD
            

            
            function drawUniPieChart(res) {
                $scope.topPerformingBots = res;
                $element.find('#performingPieChart').html('');
                var svgPre = d3.select("#performingPieChart")
                  .append("svg").attr('class', 'topPerformUniBot');

                var svg = d3.select("svg.topPerformUniBot"),
                    width = +600,
                    height = +260,
                    radius = Math.min(width, height) / 2,
                    g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height / 1.625 + ")");

                var labels = d3.select("#labels");

                var color = d3.scaleOrdinal(
                    ["#66c4cc", "#ff5d5d", "#ff8d8d", "#f9c97b", "#ff7d7d", "#f7b74e", "#32b0bb", "#95d16e", 
                     "#009dab", "#afdc92", "#4cbac4", "#19a6b3", "#ff6d6d", "#f8c065", "#f6ae38", "#f5a623", 
                     "#a2d780", "#88cb5c", "#7bc64a", "#ff9d9d"]);

                var pie = d3.pie()
                    .sort(null)
                    .value(function(d) {
                        return d.noOfDialogFAQSuccess;
                    });

                var path = d3.arc()
                    .outerRadius(radius-20)
                    .innerRadius(0);

                var outerArc = d3.arc()
                    .innerRadius((radius-20) * 1.33)
                    .outerRadius((radius-20) * 1.33);

                var label = d3.arc()
                    .outerRadius(radius-40)
                    .innerRadius(radius-40);

                var csvData = "streamName,noOfDialogFAQSuccess\n";
                for(var i =0; i<res.data.results.length; i++) {
                    var dialogFAQSuccess = res.data.results[i].noOfDialogSuccess1 + res.data.results[i].noOfFaqSuccess + res.data.results[i].noOfActionSuccess;
                    csvData += res.data.results[i].streamName + " (" + dialogFAQSuccess.toString() + ")" +","+ dialogFAQSuccess.toString() +"\n";
                }
                var data = d3.csvParse(csvData); // csv Parsing
                data.forEach(function(d) {
                    d.noOfDialogFAQSuccess = +d.noOfDialogFAQSuccess;
                    return d;
                });

                function removePerfTooltip () {
                    $('.tooltipPerfBots').remove();
                }

                function showTooltip(e, d, i) {
                    var html = '<span class="tooltipPerfBots" style="width: 175px; background-opacity:.5">' +
                        '<span class="header1">'+ e.data.streamName.slice(0,e.data.streamName.indexOf('(')) +
                        '</span></span>';
                    var x = d3.event.pageX,
                        y = d3.event.pageY;
                    if($('.tooltipViz').length === 0) {
                        d3.select(".topPerformingBotsDiv")
                            .append("div")
                            .attr("class", "vz-weighted_tree-tip")
                            .style("position", "absolute")
                            .style("left", (x - $('.topPerformingBotsDiv').offset().left) + "px")     // move it in the x direction
                            .style("top", (y - $('.topPerformingBotsDiv').offset().top - 45) + "px")  // move it in the y direction
                            .style("opacity", 0)
                            .html(html)
                            .transition().style("opacity", 1);
                    }
                }

                var arc = g.selectAll(".arc")
                    .data(pie(data))
                    .enter().append("g")
                    .attr("class", "arc");

                var labelPositions = [];
                arc.append("path")
                    .attr("d", path)
                    .attr("fill", function(d) {
                        return color(d.data.streamName);
                    });
                arc.append("text")
                    .attr("transform", function(d, i) {
                        var pos = outerArc.centroid(d);
                        var percent = (d.endAngle - d.startAngle) / (2 * Math.PI) * 100;
                      /*  if (percent < 5) {
                            pos[1] += i * 15;
                        } */
                        labelPositions.push(angular.copy(pos));
                        if(midAngle(d) < 0.5*Math.PI) {
                            pos[1] = pos[1]-20;
                        }
                        else if(midAngle(d) > 1.5*Math.PI) {
                            pos[0] = pos[0] - 25;
                            pos[1] = pos[1] - 25;
                        }
                        return "translate(" + pos + ")";
                    })
                    .attr("fill", function(d, i) {
                        return "#8a959f";
                    })
                    .attr("text-anchor", 'left')
                    .attr("dx", function(d) {
                        // var ac = midAngle(d) < Math.PI ? 0 : -50;
                        var ac = 0;
                        if(midAngle(d) < Math.PI) {
                            if(d.value < 5) { // labels overlap issue
                                ac = -60;
                            }
                        } else {
                            ac = -50;
                        }
                        return ac;
                    })
                    .attr("dy", 5)
                    .append('tspan').attr('x', '0').attr('dy', '1.2em').text(function(d) {
                        var strName;
                        if((d.endAngle - d.startAngle) / (2 * Math.PI) * 100 > 4) {
                            strName = d.data.streamName.replace(/[(][0-9]*?[)]/g, '');
                            if(strName.length > 14) {
                                return d.data.streamName.replace(/[(][0-9]*?[)]/g, '').slice(0,12) + '...'; 
                            }
                            else {
                                return d.data.streamName.replace(/[(][0-9]*?[)]/g, '');
                            }
                        }
                        else {
                            if((d.endAngle - d.startAngle) / (2 * Math.PI) * 100 < 4) {
                                strName = d.data.streamName.replace(/[(][0-9]*?[)]/g, '');
                                if(d.value < 10 && strName.length > 14) {
                                    return d.data.streamName.replace(/[(][0-9]*?[)]/g, '').slice(0,8) + '...'; 
                                }
                            }
                            // return null;
                        }
                    })
                    .on('mouseover', showTooltip)
                    .on('mouseout', removePerfTooltip)
                    .append('tspan').attr('x', function(d) {
                        return midAngle(d) < Math.PI ? '20' : '-30';
                    }).attr('dy', '1.2em').text(function(d) {
                        if((d.endAngle - d.startAngle) / (2 * Math.PI) * 100 > 4) {
                            return d.data.streamName.match(/[(][0-9]*?[)]/g)[0]; 
                        }
                        else {
                            return null; 
                        }
                    });

                function midAngle(d) {
                    return d.startAngle + (d.endAngle - d.startAngle) / 2;
                }

                var polyline = g.selectAll("polyline")
                    .data(pie(data), function(d) {
                        return d.data.streamName;
                    })
                    .enter()
                    .append("polyline")
                    .attr("points", function(d, i) {
                        var pos = label.centroid(d);
                        var o = outerArc.centroid(d);
                        var percent = (d.endAngle - d.startAngle) / (2 * Math.PI) * 100;
                        if(percent < 0) {
                            return [0, 0];
                        }
                        else {
                            return [[pos[0], pos[1]], [labelPositions[i][0], labelPositions[i][1]]];
                        }
                    })
                    .style("fill", "none")
                    .attr("stroke", function(d, i) {
                        return "#8a959f";
                    })
                    .style("stroke-width", "1px");
            }
            //pie chart - updated
            function drawPieChartNew(graphData) {
                //Width and height
                var w = 260;
                var h = 260;
                var r = 130;
                var dataset = [];
                $scope.pieGraphAvailable=true;    
                var pieObj = {};
                if($scope.tasksStats.intentSucess > 0 || $scope.tasksStats.intentFailed > 0){
                    pieObj['Intent Recognized'] = $scope.tasksStats.intentSucess;
                    pieObj['Intent Failed'] = $scope.tasksStats.intentFailed;
                }else{
                    $scope.pieGraphAvailable=false;
                }
                if(!graphData && ($scope.tasksStats.intentFailed || $scope.tasksStats.intentSucess )){
                    dataset=[($scope.tasksStats.intentFailed),($scope.tasksStats.intentSucess)];
                }
                else if($scope.tasksStats.intentFailed || $scope.tasksStats.intentSucess) {
                    dataset=graphData;
                }
                else{
                    $scope.pieGraphAvailable=false;
                }
                if(dataset[0] && dataset[0].length < 0){
                    $scope.pieGraphAvailable=false;
                }
                $element.find('.pie-chart').html('');
                var svg = d3.select(".pie-chart")
                    .append("svg")
                    .attr('width', w)
                    .attr('height', h);
                var g = svg.append("g")
                    .attr("transform", "translate(" + w / 2 + "," + h/ 2 + ")");

                g.append("g").attr("class", "slices");
                g.append("g").attr("class", "labelName");

                var pie = d3.pie()
                    .sort(null)
                    .value(function (d) {
                        return d['value'];
                    });

                var arc = d3.arc()
                    .outerRadius(r * 1)
                    .innerRadius(r * 0);

                var colorRange = d3.scaleOrdinal().range(["#28A745","#7027E5"]);
                var color = d3.scaleOrdinal()
                    .range(colorRange.range());

                var data_ready = pie(d3.entries(pieObj));

                var slice = g.select(".slices").selectAll("path.slice")
                    .data(data_ready);

                slice.enter()
                    .append("path")
                    .attr('d', arc)
                    .style("fill", function (d) {
                      return color(d['data']['key']);
                    })
                    .attr("class", "slice")
                    .on('mouseover', function (d) {
                        d3.select("#tooltip")
                          .html((d['data']['value'] + " " + d['data']['key']))
                          .style("opacity", 1)
                          .style("display", 'block');                
                    })
                    .on('mousemove', function () {
                        d3.select("#tooltip")
                            .style("left", (d3.event.pageX - 50)  + "px")
                            .style("top", (d3.event.pageY - 50) + "px");
                    })
                    .on("mouseleave", function () {
                        // Hide the tooltip
                        d3.select("#tooltip")
                        .style("opacity", 0).style('display', 'none');
                    });

                if(data_ready && data_ready.length) {
                    data_ready[0].data['text'] = Math.round(data_ready[0].data['value']*100/(data_ready[0].data['value']+data_ready[1].data['value']));
                    data_ready[1].data['text'] = Math.round(data_ready[1].data['value']*100/(data_ready[0].data['value']+data_ready[1].data['value']));
          
                    g
                    .selectAll('mySlices')
                    .data(data_ready)
                    .enter()
                    .append('text')
                    .text(function(d){ if(d['data']['text']){return d['data']['text']+'%';}})
                    .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")";  })
                    .style("text-anchor", "middle")
                    .style("fill","#ffffff")
                    .style("font-size", 14);   
                }

                slice.exit().remove();                    
                   
            }
            //pie chart - Old code
            function drawPieChart(graphData) {
                //Width and height
                var w = 350;
                var h = 350;
                var r =100;
                var colors = ["#e04e4c", "#009dab"];
                var dataset = [];
                var intentData=[];
                $scope.pieGraphAvailable=true;
                if($scope.tasksStats.intentSucess > 0 || $scope.tasksStats.intentFailed > 0){
                    $scope.tasksStats.intentFailed = Math.round($scope.tasksStats.intentFailed/($scope.tasksStats.intentSucess + $scope.tasksStats.intentFailed)*100);
                    $scope.tasksStats.intentSucess = 100 - $scope.tasksStats.intentFailed;
                }else{
                    $scope.pieGraphAvailable=false;
                }
                if(!graphData && ($scope.tasksStats.intentFailed || $scope.tasksStats.intentSucess )){
                    dataset=[($scope.tasksStats.intentFailed),($scope.tasksStats.intentSucess)];
                }
                else if($scope.tasksStats.intentFailed || $scope.tasksStats.intentSucess) {
                    dataset=graphData;
                }
                else{
                    $scope.pieGraphAvailable=false;
                }
                if(dataset[0] && dataset[0].length < 0){
                    $scope.pieGraphAvailable=false;
                }

                //remove zero value if consists "0" in dataset
                var _zeroDataIndex=dataset.indexOf(0);
                if(_zeroDataIndex > -1){
                    dataset.splice(_zeroDataIndex,1);
                }

                var outerRadius = w/2-20;
                var innerRadius = 0;
                var arc = d3.arc()
                 .innerRadius(innerRadius)
                 .outerRadius(outerRadius);
                var pie = d3.pie();
                // Easy colors accessible via a 10-step ordinal scale
                var color = d3.scaleOrdinal(d3.schemeCategory10);
                // Create SVG element
                $element.find('.pie-chart').html('');
                var svg = d3.select(".pie-chart")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
                    // Set up groups
                var arcs = svg.selectAll("g.arc")
                    .data(pie(dataset))
                    .enter()
                    .append("g")
                    .attr("class", "arc")
                    .attr("transform", "translate(" + outerRadius + "," + outerRadius + ")")
                    .on("mouseover", function (d) {
                        if(d.index === 1) {
                            $scope.piechartTooltipMsg = $scope.pieChartFailed + " Intent Failed";
                        }
                        else{
                            $scope.piechartTooltipMsg = $scope.pieChartSucess + " Intent Recognized";
                        }
                        // if(d.index === 0) {
                        //     $scope.piechartTooltipMsg = " Intent Failed" + "<br />" + $scope.pieChartFailed;
                        // }
                        // else{
                        //     $scope.piechartTooltipMsg = " Intent Recognised" + "<br />" + $scope.pieChartSucess;
                        // }
                    d3.select("#tooltip")
                        .html( $scope.piechartTooltipMsg )
                        .style("opacity", 1)
                        .style("display", 'block');
                        //.select("#value")
                        //.text(d.value);
                    })
                    .on('mousemove', function () {
                        d3.select("#tooltip")
                            .style("left", d3.event.pageX+10  + "px")
                            .style("top", d3.event.pageY+10 + "px");
                    })
                    .on("mouseleave", function () {
                        // Hide the tooltip
                        d3.select("#tooltip")
                        .style("opacity", 0).style('display', 'none');
                    })
                    .on("click", function (d,type) {
                        $scope.selectedChartData.data = d;
                        $scope.selectedChartData.type = type;
                    });
                    // Draw arc paths
                     arcs.append("path")
                     .attr("fill", function (d, i) {
                         if(d.index === 1) {
                            return colors[0];
                         }else{
                            return colors[1];
                         }
                    })
                    .attr("d", arc);
                    // Labels
                    arcs.append("text")
                    .attr("transform", function (d) {
                        return "translate(" + arc.centroid(d) + ")";
                    })
                    .attr("text-anchor", "middle")
                    .style("fill","#ffffff")
                    .text(function (d) {
                        return d.value + "%";
                    });
            }
            function getDashboardData() {
                var start, end;
                if ($scope.selectedRange === 'custom') {
                    start = $scope.startDate;
                    if(moment()._d.getDate() === $scope.endDate._d.getDate() && moment()._d.getDay() === $scope.endDate._d.getDay() && moment()._d.getYear() === $scope.endDate._d.getYear()) {
                        end = moment();
                    }
                    else {
                        end = $scope.endDate;
                    }
                    sessionInterval = 'date_day';
                } else if ($scope.selectedRange === '7days') {
                    start = moment().subtract({days: 7});
                    end = moment();
                    sessionInterval = 'date_day';
                    //getDashboardData();
                } else if ($scope.selectedRange === '24hours') {
                    start = moment().subtract({hours: 24});
                    end = moment();
                    sessionInterval = 'date_day_hour';
                    //getDashboardData();
                }

                $scope.appliedSelectedRange=angular.copy($scope.selectedRange);

                $scope.filterStatement = generateFilterString(start, end);
                if($scope.selectedRange === '7days' || $scope.selectedRange === '24hours') {
                    $scope.start = start;
                    $scope.end = end;
                    if($scope.stream.type == 'universalbot') {
                        performingBotsDashboard();
                    }
                    fetchDataFromServer();
                    agentTransferMetrics();
                    tasksMetrics();
                    sessionsGraph();
                    intentGraphData();
                }else{
                    if(end.diff(start,'days') > 90 && $scope.selectedAccount.accountType !== 1){
                        return;
                    } else{
                        $scope.start = start;
                        $scope.end = end;
                        if($scope.stream.type == 'universalbot') {
                            performingBotsDashboard();
                        }
                        fetchDataFromServer();
                        agentTransferMetrics();
                        tasksMetrics();
                        sessionsGraph();
                        intentGraphData();
                    }
                }
                
            }
            function realTimeDashboardData(){
                BTStreamsService.realTimeDashboard($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id)
                .then(function (res) {
                    $scope.realTimeUsers = res.data.nUsers;
                    $scope.realTimeChannels = res.data.aChannels;
                    $scope.realTimeSessions = res.data.nSessions;
                    $scope.realTimeAgentSessions = res.data.nAgentSessions;
                    if($scope.realTimeUsers === 0){
                        $scope.realTimeUsersData = false;
                        $scope.realTimeUsers = i18n.i18nString('real_time_user');
                    }else{
                        $scope.realTimeUsersData = true;
                    }
                    if($scope.realTimeChannels.length === 0){
                        $scope.realTimeChannelData = false;
                        $scope.realTimeChannnel = i18n.i18nString('real_time_channel');
                    }else{
                        $scope.realTimeChannelData = true;
                    }
                    if($scope.realTimeSessions === 0 && $scope.realTimeAgentSessions === 0){
                        $scope.realTimeSessions = i18n.i18nString('real_time_session');
                        $scope.realTimeSessionData = false;
                    }else{
                        $scope.realTimeSessionData = true;
                    }
                });
            }
            $scope.realTimeDashboardChannelData = function(){
                BTStreamsService.realTimeDashboardChannels($applicationService.userInfo().userId,$applicationService.userInfo().orgId,$workflowService.selectedStream()._id)
                .then(function (res) {
                    $scope.realTimeChannelsData = res.data;
                });
            };
            $scope.refreshRealTimeData = function(){
                realTimeDashboardData();
                $scope.realTimeDashboardChannelData();
                $scope.realTime = moment().format('HH:mm:ss');
                $scope.realTimeZone = moment.tz(moment.tz.guess()).format('z');
            };
            $scope.filterTags = [];
            function generateFilterString(start, end) {
                var str = '<strong>'+i18n.i18nString('all')+'</strong>'+i18n.i18nString('chat_sessions')+' ';
                if (start && end) {
                    var _format = 'MM-DD-YYYY';
                    var startStr = start.format(_format);
                    var endStr = end.format(_format);


                    
                    if (startStr === endStr) {
                        str += ''+i18n.i18nString('on')+' ' + startStr;
                    } else {
                        str += ''+i18n.i18nString('between')+' <strong>' + startStr + '</strong> '+i18n.i18nString('to_label')+' <strong>' + endStr + '</strong>';
                    }
                }
                var _selectedChannels=_.pluck($scope.channels.filter(function(channel){return ($scope.selectedChannels.indexOf(channel.id)>-1);}),'name');
                var _selectedLangauges=_.pluck($scope.langauges.filter(function(langauge){return ($scope.selectedLangauges.indexOf(langauge.value)>-1);}),'name');
                $scope.channelsStr = commaSeperatedStr(_selectedChannels);
                $scope.langaugesStr = commaSeperatedStr(_selectedLangauges);
                // if ($scope.channelsStr || $scope.langaugesStr) {
                //     if ($scope.channelsStr) {
                //         str += ' using ';
                //         str += $scope.channelsStr;
                //     }
                //     if ($scope.langaugesStr) {
                //         str += ' in ';
                //         str += $scope.langaugesStr;
                //     }
                //     // if($scope.langaugesStr || $scope.channelsStr){
                //     //     str += '<span class="clearAllFilters addRedColor"><i class ="fa fa-close"></i>Clear all</span>';
                //     //     setTimeout(function(){
                //     //         $(".filter-info .clearAllFilters").click(function(){
                //     //             $scope.resetFilter();
                //     //             $scope.selectedRange = '24hours';
                //     //             $('.center a').trigger('click');
                //     //         });
                //     //     },350);
                //     // }
                // }
                return str;
            }
            $scope.clearFilterTags = function () {
                $scope.filterTags = [];
                $scope.resetFilter();
                $scope.doneChannelFilter();
            };
            // remove filter tag
            $scope.removeFilterTag = function (index, tag) {
                if (tag.type === "channel") {
                    $scope.conversationFilter.selectedChannel.splice(index, 1);
                }
                $scope.filterTags.splice(index, 1);
                $scope.doneChannelFilter();
            };
            function generateFilterTags() {
                $scope.filterTags = [];
                var _selectedChannels=_.pluck($scope.channels.filter(function(channel){return ($scope.selectedChannels.indexOf(channel.id)>-1);}),'name');
                var _selectedLangauges=_.pluck($scope.langauges.filter(function(langauge){return ($scope.selectedLangauges.indexOf(langauge.value)>-1);}),'name');
                $scope.channelsStr = commaSeperatedStr(_selectedChannels);
                $scope.langaugesStr = commaSeperatedStr(_selectedLangauges);
                if(_selectedChannels && _selectedChannels.length && $scope.enabledChannelsFilterDetails.length !== $scope.selectedChannels.length) {
                    $scope.filterTags.push({ 'value': i18n.i18nString('channel_name'), 'type': 'channel', 'tooltipValue': $scope.channelsStr, 'count': _selectedChannels.length });
                }
                if(_selectedLangauges && _selectedLangauges.length) {
                    $scope.filterTags.push({ 'value': i18n.i18nString('Language'), 'type': 'language', 'tooltipValue': $scope.langaugesStr, 'count': _selectedLangauges.length });
                }
            }
            function commaSeperatedStr(arr) {
                var str = '';
                if (arr.length) {
                    if (arr.length === 1) {
                        str += arr.join(',');
                    } else if (arr.length === 2) {
                        str += arr.join(' and ');
                    } else {
                        //var lastItems = arr.splice(-1, 1);
                        str += arr.join(',') ;
                    }
                }
                return str;
            }
            function loadChannelFilter() {
                var seedData = $workflowService.seedData();
                $scope.sumocb = { 'sessioncb': { 'changeText': true }, 'channelcb': { 'changeText': true }};
                channelsConfig.getDynamicChannels($workflowService.selectedStream());
                $scope.channels = Object.values(channelsConfig.channelsObject);
                $scope.langauges = seedData.supportedLanguages;
                if($scope.stream && $scope.stream.channels){
                $scope.enabledChannelsFilter = $scope.stream.channels.map(function(v){ return v.type;});
                }
                $scope.enabledChannelsFilterDetails = [];
                $scope.enabledLangsFilterDetails = [];
                $scope.sessionTypes = [{type:i18n.i18nString('interactive')},{type:i18n.i18nString('non_interactive')}];
                var temp;
                if($scope.enabledChannelsFilter && $scope.enabledChannelsFilter.length){
                for(var i=0; i< $scope.enabledChannelsFilter.length; i++) {
                    temp = $scope.channels.filter(function(v){
                        return v.id === $scope.enabledChannelsFilter[i];
                    });
                    $scope.enabledChannelsFilterDetails.push(temp[0]);
                }
            }
                for(var j=0; j<$scope.stream.supportedLanguages.length; j++) {
                    if($workflowService.seedData().nluSupportedLanguages){
                    temp = $workflowService.seedData().nluSupportedLanguages.filter(function(v) {
                        return $scope.stream.supportedLanguages[j] === v.value;
                    });
                    $scope.enabledLangsFilterDetails.push(temp[0]);
                   }
                }
                $scope.selectedChannels = [];
                $scope.selectedLangauges = [];
                $scope.selectedLinkedBots = [];
                $element.on('click', '.dropdown-menu input, .dropdown-menu label', function (e) {
                    e.stopPropagation();
                });
                $element.find('.channel-filter.dropdown').on('show.bs.dropdown', function (e) {
                    e.stopPropagation();
                });
                setTimeout(function () {
                    if ($scope.conversationFilter.selectedSession.length === 0 && $scope.sumocb.sessioncb && $scope.sumocb.sessioncb.selectAllByDefault) {
                        $scope.sumocb.sessioncb.selectAllByDefault();
                    }
                    if ($scope.conversationFilter.selectedChannel.length === 0) {
                        $scope.sumocb.channelcb.selectAllByDefault();
                    }
                }, 150);

                function dispSelectedFilterOpt(name) {
                    var $select = '$scope.selected'+name.charAt(0).toUpperCase()+name.slice(1);
                    $select = ($select.lastIndexOf('s') == $select.length-1)?$select:$select+"s";
                    var $selectorEach = $('.channel-filter [name='+name+']');
                    $selectorEach.each(function () {
                        var t=(eval($select).indexOf($(this).val()) > -1)?$(this).prop('checked', true):$(this).prop('checked', false);
                    });                    
                }

                $scope.toggled = function (open) {
                    if (open) {
                        importModalSliderOpen();
                        getCustomMetaTags();
                        $timeout(function(){
                    /* To show only selected channel checked after reset if reset is not applied */
                            if($scope.selectedChannelsCopy && $scope.selectedChannelsCopy.length){
                                $('.channel-filter [name="langauge"], .channel-filter [name="channels"], .channel-filter [name="linkedBot"],' +
                                '#all-langauge, #all-linkedbot, #uniBotInteraction').each(function () {
                                $(this).prop('checked', false);
                            }); 
                                $scope.selectedChannels = angular.copy($scope.selectedChannelsCopy);
                                $scope.selectedChannels.forEach(function(data){
                                    $(".checkWithTitle #" + data).prop('checked',true);
                                });
                            }
                            if($scope.filterComponent.tags.and.length === 0){
                                $scope.selectedTagsArray = [];
                                $scope.selectedTagsArray.push({name:"",values:[],type:""});
                            }else{
                                $scope.selectedTagsArrayCopy = angular.copy($scope.selectedTagsArray);
                                $scope.selectedTagsArray = [];
                                $scope.filterComponent.tags.and.forEach(function(value,key){
                                    //var valueIndex=_.findIndex($scope.selectedTagsArrayCopy,{name:value.name});
                                    var forAutoSuggestionValues = _.findIndex($scope.customTagsArray,{name:value.name});
                                    $scope.selectedTagsArray.push({
                                        name:value.name,
                                        values:value.values,
                                        type:value.type,
                                        selectedValues:$scope.customTagsArray[forAutoSuggestionValues].selectedValues
                                    });
                                });
                                $scope.selectedTagsArray.push({ name: "", values: [],type:"" });
                            }
                      
                        });
                    }              
               /* To show only selected session checked after reset if reset is not applied */
                    if($scope.selectedSessionFilterCopy && $scope.selectedSessionFilterCopy.length){
                        $scope.conversationFilter.selectedSession = angular.copy($scope.selectedSessionFilterCopy);

                    }
                    if($scope.selectedChannelsCopy && $scope.selectedChannelsCopy.length){
                        $scope.conversationFilter.selectedChannel = angular.copy($scope.selectedChannelsCopy);

                    }

                    setTimeout(function () {   
                /* To show all session checked bydefault if no one is selected */                   
                        if ($scope.conversationFilter.selectedSession.length === 0) {
                            $scope.sumocb.sessioncb.selectAllByDefault();
                        }               
                        if ($scope.conversationFilter.selectedChannel.length === 0) {
                            $scope.sumocb.channelcb.selectAllByDefault();
                        }       
                        if($scope.stream.type === 'universalbot') {
                            if($scope.selectedLinkedBotsCopy && $scope.selectedLinkedBotsCopy.length){
                                $scope.selectedLinkedBots = angular.copy($scope.selectedLinkedBotsCopy);
                                $scope.selectedLinkedBotsCopy.forEach(function(streamId) {
                                    $element.find('input[id="'+streamId+'"]').prop('checked', true);
                                });
                            }
                        }

                    }, 200);
                };

                $scope.doneChannelFilter = function () {
                    // $scope.selectedChannels = $element.find('.channel-filter [name="channels"]:checked').map(function (_, el) {
                    //     return $(el).val();
                    // }).get();
                    $scope.selectedLangauges = $element.find('.channel-filter [name="langauge"]:checked').map(function (_, el) {
                        return $(el).val();
                    }).get();
                    $scope.selectedLinkedBots = $element.find('.channel-filter [name="linkedBot"]:checked').map(function (_, el) {
                        return $(el).val();
                    }).get();
                    // $scope.selectedChannelsCopy = angular.copy($scope.selectedChannels);
                    $scope.selectedLangaugesCopy = angular.copy($scope.selectedLangauges);
                    $scope.selectedLinkedBotsCopy = angular.copy($scope.selectedLinkedBots);
                    $scope.selectedSessionFilter = [];
                    $scope.selectedChannels = [];
                    //$scope.selectedSessionCopy = angular.copy($scope.conversationFilter.selectedSession);
                    $scope.conversationFilter.selectedSession.map(function(ses){
                        $scope.selectedSessionFilter.push(ses === 'Interactive'? 1 : 0);
                    });
                    $scope.conversationFilter.selectedChannel.map(function(ch){
                        $scope.selectedChannels.push(ch);
                    });
                    $scope.selectedSessionFilterCopy = angular.copy($scope.conversationFilter.selectedSession);
                    $scope.selectedChannelsCopy = angular.copy($scope.selectedChannels);
                    generateFilterTags();
                    prepareTagsPayload();
                    getDashboardData();
                };
            }
            function load() { 
                if ($workflowService.selectedStream().visibility.namespace !== 'private') {
                    $timeout(function () {
                    daterangepickerInput = $('input[name="daterange"]').daterangepicker({
                        "startDate": $scope.startDate || moment(),
                        "endDate": $scope.endDate || moment(),
                        "maxDate":moment(new Date()).format('MM-DD-YYYY'),
                        "opens": "left",
                        customClass: "bot-dash-datepicker",
                        locale:{
                        applyLabel: i18n.i18nString('apply'),
                        cancelLabel: i18n.i18nString('cancel'),
                    }
                    });
                    $('input[name="daterange"]').on('apply.daterangepicker', function (ev, picker) {
                        if(ev){
                            var timezone = moment.tz.guess();
                            if(timezone === "America/Los_Angeles") { // Check PST timezone addition by 1hour
                                $scope.startDate = moment(picker.startDate, timezone).add({hour:1, day: 0});
                            } else {
                                $scope.startDate = moment(picker.startDate, timezone);
                            }
                            // $scope.endDate = moment(picker.endDate, timezone);
                            $scope.endDate = picker.endDate;
                            if($scope.endDate.diff($scope.startDate,'days') > 90 && $scope.selectedAccount.accountType !== 1){
                                NotificationService.notify(i18n.i18nString('custom_date'),'warning');
                            }else{
                                getDashboardData();   
                                // getCustomMetaTags(); 
                            }
                           
                        }
                    });
                 
                    $('input[name="daterange"]').on('cancel.daterangepicker', function(){
                       if($scope.appliedSelectedRange=="7days"){
                           $('input[name="daterange"]').data('daterangepicker').setStartDate(moment().subtract(7,'days').format('MM-DD-YYYY'));
                           $('input[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                           $(".filer-btns .nav-pills li.left a").click();
                        }
                        else if($scope.appliedSelectedRange=="24hours"){
                            $('input[name="daterange"]').data('daterangepicker').setStartDate(moment().format('MM-DD-YYYY'));
                            $('input[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                            $(".filer-btns .nav-pills li.center a").click();
                        }
                   });
                   $('input[name="daterange"]').on('outsideClick.daterangepicker', function(){
                        if($scope.appliedSelectedRange=="7days"){
                            $('input[name="daterange"]').data('daterangepicker').setStartDate(moment().subtract(7,'days').format('MM-DD-YYYY'));
                            $('input[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                            $(".filer-btns .nav-pills li.left a").click();
                        }
                        else if($scope.appliedSelectedRange=="24hours"){
                        $('input[name="daterange"]').data('daterangepicker').setStartDate(moment().format('MM-DD-YYYY'));
                        $('input[name="daterange"]').data('daterangepicker').setEndDate(moment().format('MM-DD-YYYY'));
                        $(".filer-btns .nav-pills li.center a").click();
                      }
                   });
                //    function getCustomMetaTags(){
                //     BTStreamsService.metaTags($scope.stream._id, $scope.startDate.toISOString(), $scope.endDate.toISOString()).then(function (response) {
                //        $scope.customTagsArray= response.data.tags;
                //     },function(error){
                //         // console.log(error);
                //     });
                // }
                }, 300);
                    $(".rightPanel.paddingRightPanel").addClass('realTimeDashboardDiv');
                    loadChannelFilter();
                    $scope.selectRange('24hours');
                    //getDashboardData();
                    realTimeDashboardData();
                    // getCustomMetaTags();
                } else {
                    $(".rightPanel.paddingRightPanel").addClass('fakeDataDivChild');
                    $scope.fakeDataUI=true;
                    $scope.tasksStats.tasksPerformedTotal= null;
                    $scope.tasksStats.alertsTotal= null;
                    $scope.scount= null;
                }

            }
        load();
        
        angular.element($window).on('resize', function (e) {
            if($scope.activeType=='dashboard'){
                //getDashboardData();
                // drawLineGraph();
                groupBarChart();
                drawBarGraph();
                drawPieChartNew();
                //fetchDataFromServer();
            }
        });
        $timeout(function () {
            angular.element($window).trigger('resize');
        }, 350);

        $scope.hideSessionsGraph = function(){
            if($(".legend-label.sessions").hasClass('sessionsOpacity')){
                $(".ySideRight").css("display","block");
                $(".sessionsLine").css("display","block");
                $(".sessionsCircle").css("display","block");
                $(".legend-label.sessions").removeClass('sessionsOpacity');
            }else{
                $(".ySideRight").css("display","none");
                $(".sessionsLine").css("display","none");
                $(".sessionsCircle").css("display","none");
                $(".legend-label.sessions").addClass('sessionsOpacity');
            }
        };
        
        $scope.hideChartsGraph = function(){
            if($(".legend-label.bot-chats").hasClass('sessionsOpacity')){
                $(".ySideLeft").css("display","block");
                $(".chartsLine").css("display","block");
                $(".chartsCircle").css("display","block");
                $(".legend-label.bot-chats").removeClass('sessionsOpacity');
            }else{
                $(".ySideLeft").css("display","none");
                $(".chartsLine").css("display","none");
                $(".chartsCircle").css("display","none");
                $(".legend-label.bot-chats").addClass('sessionsOpacity');
            }
        };

        function getCustomMetaTags(){
            BTStreamsService.metaTags($scope.stream._id, $scope.start.toISOString(),$scope.end.toISOString()).then(function (response) {
               $scope.customTagsArray= response.data.tags;
            },function(error){
                // console.log(error);
            });
        }

        $scope.updatedropDown = function(tag,index){
            $scope.search.nameSearchQuery = "";
            tag.selectedValues = [];
            tag.selectedValues = tag.values;
            $scope.selectedTagsArray[index]=tag;
            $scope.selectedTagsArray[index].values = [];
            $scope.addCustomTags(index);
        };

        $scope.addCustomTags = function (index) {
            if ($scope.selectedTagsArray.length === index + 1) {
                $scope.selectedTagsArray.push({ name: "", values: [],type:"" });
            }
        };

        $scope.removeCustomsTags = function(index){
            $scope.selectedTagsArray.splice(index,1);
            $($(".host .tags input")[index]).val('');
        };

        $scope.searchValues = function(term,value){
            $scope.returnValue = [];
            var filterValue = value.filter(function(el){
                return el !== null && el !== "" && el !== undefined;
            });
            if(value) {
                filterValue.forEach(function(item,index){
                    if(item && item.toLowerCase().indexOf(term.toLowerCase()) >= 0){
                        $scope.returnValue.push(item);
                    }
                });
            }
            return $scope.returnValue;
        };

        $scope.dynamicHeight = function(e,selectedTag){
            setTimeout(function(){
                var ele= e.target;
                ele.style.height = '30px';
                if($(ele).hasClass("ng-invalid")){
                  selectedTag.invalidValue = true;
                  $('.disabledClass').attr('disabled','disabled');
                }else{
                  selectedTag.invalidValue = false;
                  $('.disabledClass').removeAttr('disabled');
                }
            },150);
        };
        $scope.migrationBanner = true;
        $scope.closeMigrationBanner = function(){
            $scope.migrationBanner = false;
        };

        $scope.calculateHeight = function(e){
            var ele= e.target;
            ele.style.height = 'auto';
        };

        $scope.searchClick = function(event){
            event.preventDefault();
            event.stopPropagation();
        };

        $scope.filterCustomTags = function(customTag){
            var _item = _.find($scope.selectedTagsArray,{'name':customTag.name});
            if(_item){
                return false;
            }else{
                return true;
            }
        };

        function prepareTagsPayload(){
            if(checkCustomTagValue()){
                NotificationService.notify(i18n.i18nString('check_custom_tag'), 'warning');
                return false;
            }else{
                $scope.filterComponent.tags.and = [];
                $scope.selectedTagsArray.forEach(function(value,key){
                    if(value.name !== ''){
                        $scope.filterComponent.tags.and.push({
                            "name":value.name,
                            "values":value.values,
                            "type":value.type
                        });
                    } else if($scope.selectedTagsArray[0].name === ""){
                        $scope.filterComponent.tags.and = [];
                    }
                });
                importModalSliderClose();
                return $scope.filterComponent.tags;
            }
        }

        function checkCustomTagValue(){
            var valueCheck = false;
            $scope.selectedTagsArray.forEach(function(value,key){
                if(value.name !== '' && value.values.length === 0){
                    valueCheck =  true;
                }
            });
            return valueCheck;
        }

        $scope.$emit('nestedComponentLoaded',{'id':'dashboard','flag':false});
        //Add below whenever nestedComponentLoaded is FINALLY emitted.
        $timeout(function(){
            $scope.$emit('gSearchLoad');
        });
        $scope.$on("$destroy", function() {
            if (window.dashboardRefreshIntervalTimer) {
                clearInterval(window.dashboardRefreshIntervalTimer);
            }
            $(".rightPanel.paddingRightPanel").removeClass('realTimeDashboardDiv');
        });
    }]);
    _module.filter('slice', function () {
        return function (arr, start, end) {
            return (arr || []).slice(start, end);
        };
    });
    _module.filter('patternChange', function() {
        return function (input) {
            return input.replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&Lt;/g, '<').replace(/&Gt;/g, '>');
        };
    });
}(angular));


;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btDatatableService', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-datatable-service/bt-datatable-service.html',
            controller: 'btDatatableServiceController'
        };
    });
    _module.controller("btDatatableServiceController", ['$scope', '$window', '$workflowService', '$element', '$location',
        function ($scope, $window, $workflowService, $element, $location) {
            //$scope.DaasUrl="http://dev.kore.ai:4200/analytics/dashboard";  
            //$scope.stream = $workflowService.selectedStream();
            $scope.DaasUrl = window.appConfig.API_SERVER_URL + '/analytics/tables';
            var iframe = $("#DaasFrame");
            iframe.on("load", function () { 
                //Make sure it is fully loaded
                iframe.contents().click(function (event) {
                    iframe.trigger("click");
                    $("body").trigger("click");
                });
            });
        }]);

}(angular));



;(function (ng) {

    'use strict';

    var _module = ng.module('bt-kore-components');

    _module.controller('BTDialogReportsCtrl', ['$scope', '$translator', '$modalInstance','$modal', 'config', '$filter', '$rootScope', '$routeParams', '$timeout', '$location', '$workflowService', 'BTSeedDataService', 'NotificationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService', '$applicationService','form_util','i18n',
        function ($scope, $translator, $modalInstance,$modal, config, $filter, $rootScope, $routeParams, $timeout, $location, $workflowService, BTSeedDataService, NotificationService, BTAlertsService, BTActionsService, BTStreamsService, $applicationService,form_util,i18n) {
         
            $scope.config = config;
            $scope.reportCb = {};
            $scope.reportCb.editTemplateOpened = function () {
                $scope.showEditReportTemplate=true;
                //$('.bt-dialog-reports-modal').addClass('modalSmall');
            };
            $scope.reportCb.editTemplateClosed = function () {
                $scope.showEditReportTemplate=false;
                //$('.bt-dialog-reports-modal').removeClass('modalSmall');
            };
            $scope.reportCb.onDialogReportSaved = function (dialog) {
                $scope.config.component=dialog;
                $scope.config.dialogReportCB.onDialogReportSave(dialog);
                $scope.closeModal();
            };

            $scope.editReportText = i18n.i18nString('bt_dialog_report_editReport');
            $scope.generateReport = i18n.i18nString('bt_dialog_report_generateReport');
            
            //fix for IE 11 edit Report: placeholder text is not getting cleared 
            $modalInstance.opened.then(function () {
                $timeout(function () {
                    $('.bt-dialog-reports-modal').modal({
                        show:true,
                        backdrop:'static'
                    });
                }, 300);
            });

           
            $scope.sampleResponseKeys = [];
            

            $scope.init = function () {
                $scope.component=$scope.config.component;
                $scope.editReport=$scope.config.editReport;
                $scope.displayMode=$scope.config.displayMode;
            };

            $scope.closeModal = function () {
                $modalInstance.close();
                $scope.savingReport =  false;    
            };
            
            $scope.saveReport=function(){
                if ($scope.reportCb.getReportForm().$invalid) {
                     form_util.touch($scope.reportCb.getReportForm());
                } else {
                    $scope.savingReport =  true;
                }
                setTimeout( function() {
                    $scope.savingReport =  false;    
                },10000);
                $rootScope.$on('confSaveTriggerStatus', function(e,status) {
                    $scope.savingReport =  false;   
                    console.log('report saved');
                });
                $rootScope.$broadcast('confSaveTrigger', {
                    callback: function testCB(res){
                        $scope.savingReport =  false; 
                    }
                });
            };

            $scope.init();

        }]);

})(angular);


;(function (ng) {

    'use strict';

    var _module = ng.module('bt-kore-components');

    _module.directive("btExportBot", function(){
        return {
            restrict: "EA",
            templateUrl: window.appConfig.TMPLT_PRE_PATH + "js/modules/bt-export/bt-exportBot.html",
            controller: "BTExportBotCtrl"
        };
    });

    _module.controller('BTExportBotCtrl', ['$scope', '$translator', '$filter', '$rootScope', '$routeParams', '$timeout', '$location', '$workflowService', 'NotificationService',  '$applicationService','BTFlowtaskService','env_conf','accessControlService','_constants_','BTStreamsService','i18n','mixPanel',
        function ($scope, $translator, $filter, $rootScope, $routeParams, $timeout, $location, $workflowService, NotificationService, $applicationService,BTFlowtaskService,env_conf,accessControlService,_constants_,BTStreamsService,i18n,mixPanel) {
            $scope.displayMode = accessControlService.getAccessRight('BOTBUILDER_BOT_SETTINGS');
            $scope.bot={};
            $scope.taskToLoad =  300;
            $scope.bot.exportType = 'published';
            $scope.selectedAccount=$workflowService.selectedAccount();
            $scope.partialImportAllowed = !($scope.selectedAccount.platformVersion) ||  !$scope.selectedAccount.accountType;
            $scope.callback.exporting = "initial";
            $scope.reloadpng = env_conf['context-url'] + '/assets/images/reload.png';
            $scope.help = env_conf['context-url']+"/assets/icons-new/help/help-dark.svg";
            $scope._exportStatusInit = null;
            $scope.callback.downloadUrl = null;
            $scope._constants_ = _constants_;  
            $scope.callback.downloadFlag = false;
            var _selectedStream = $workflowService.selectedStream();
            $scope.botType = _selectedStream.type;
            $scope.allTasksSortedData = $workflowService.allTasksSortedData();
            $scope.selectedState = "published";
            $scope.allTasksSelectedPublished = true;
            $scope.allTasksSelectedIndevelopment = true;     
            $scope.allFormsSelectedPublished = true;
            $scope.allFormsSelectedIndevelopment = true;            
            $scope.bot.independentTasks = true;
            $scope.bot.independentForms = true;
            $scope.allTasksDataPublishedCopy = [];
            $scope.allFormsDataPublishedCopy = [];
            $scope.allTasksDataIndevelopmentCopy = [];
            $scope.allFormsDataIndevelopmentCopy = [];
            $scope.suspendedCheck = [];
            $scope.rejectedCheck = [];
            $scope.suspendedFormsCheck = [];
            $scope.rejectedFormsCheck = [];
            $scope.manageCollectionVarEnable = false;
            $scope.btCollectionVariables = {};
            $scope.btCollectionVariables.collectionList = [];
            $scope.btCollectionVariables.useCollections = false;
            $scope.btCollectionVariables.collectionType = 'EXPORT';
            $scope.tasksLoaded =  false;
            $scope.formsNoded =  false;
            $scope.prepareFormsData = function() {
                if($scope.formsNoded){
                    return;
                }
                $scope.formsNoded =  true;
                $scope.allTasksSortedData = $workflowService.allTasksSortedData();
                if ($scope.allTasksSortedData && $scope.allTasksSortedData.uiForms && $scope.allTasksSortedData.uiForms.published) {
                    $scope.allTasksSortedData.uiForms.published.forEach(function (task) {
                        task.selected = true;
                    });
                }
                if ($scope.allTasksSortedData && $scope.allTasksSortedData.uiForms && $scope.allTasksSortedData.uiForms.published) {
                    $scope.allFormsDataPublished = $scope.allFormsDataPublished.concat($scope.allTasksSortedData.uiForms.published);
                }
                if ($scope.allTasksSortedData && $scope.allTasksSortedData.uiForms) {
                    $scope.suspendedFormsCheck = _.filter($scope.allTasksSortedData.uiForms, function (data) {
                        return data.state == 'suspended';
                    });
                }
                if ($scope.allTasksSortedData && $scope.allTasksSortedData.uiForms && $scope.allTasksSortedData.uiForms.indevelopment) {
                    $scope.allTasksSortedData.uiForms.indevelopment.forEach(function (task) {
                        task.selected = true;
                    });
                }
                if ($scope.allTasksSortedData.uiForms && $scope.allTasksSortedData.uiForms.indevelopment) {
                    $scope.allFormsDataIndevelopment = $scope.allFormsDataIndevelopment.concat($scope.allTasksSortedData.uiForms.indevelopment);
                }
                if ($scope.allTasksSortedData && $scope.allTasksSortedData.uiForms) {
                    $scope.rejectedFormsCheck = _.filter($scope.allTasksSortedData.uiForms, function (data) {
                        return data.state == "rejected";
                    });
                }
            };
            $scope.prepareTasksData = function(){
                $scope.allTasksSortedData = $workflowService.allTasksSortedData();
                if($scope.allTasksSortedData && $scope.allTasksSortedData.dialogTasks && $scope.allTasksSortedData.dialogTasks.published){
                    $scope.allTasksSortedData.dialogTasks.published.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.actionTasks && $scope.allTasksSortedData.actionTasks.published){ 
                    $scope.allTasksSortedData.actionTasks.published.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.alertTasks && $scope.allTasksSortedData.alertTasks.published){ 
                    $scope.allTasksSortedData.alertTasks.published.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.informationTasks && $scope.allTasksSortedData.informationTasks.published){ 
                    $scope.allTasksSortedData.informationTasks.published.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    


                if($scope.allTasksSortedData && $scope.allTasksSortedData.actionTasks && $scope.allTasksSortedData.actionTasks.published){
                    $scope.allTasksDataPublished = $scope.allTasksDataPublished.concat($scope.allTasksSortedData.actionTasks.published);
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.informationTasks && $scope.allTasksSortedData.informationTasks.published){
                    $scope.allTasksDataPublished = $scope.allTasksDataPublished.concat($scope.allTasksSortedData.informationTasks.published);
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.alertTasks && $scope.allTasksSortedData.alertTasks.published){
                    $scope.allTasksDataPublished = $scope.allTasksDataPublished.concat($scope.allTasksSortedData.alertTasks.published);
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.dialogTasks && $scope.allTasksSortedData.dialogTasks.published){
                    $scope.allTasksDataPublished = $scope.allTasksDataPublished.concat($scope.allTasksSortedData.dialogTasks.published);
                    }
                    
                    $scope.suspendedCheck = _.filter($scope.allTasksDataPublished,function(data){
                        return data.state == 'suspended';
                    });
                    
                    $scope.allTasksDataPublished = _.filter($scope.allTasksDataPublished,function(data){
                        return data.state == 'published';
                    });
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.dialogTasks && $scope.allTasksSortedData.dialogTasks.indevelopment){
                    $scope.allTasksSortedData.dialogTasks.indevelopment.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.actionTasks && $scope.allTasksSortedData.actionTasks.indevelopment){
                    $scope.allTasksSortedData.actionTasks.indevelopment.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.alertTasks && $scope.allTasksSortedData.alertTasks.indevelopment){
                    $scope.allTasksSortedData.alertTasks.indevelopment.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    if($scope.allTasksSortedData && $scope.allTasksSortedData.informationTasks && $scope.allTasksSortedData.informationTasks.indevelopment){
                    $scope.allTasksSortedData.informationTasks.indevelopment.forEach(function(task){
                        task.selected = true;
                    });
                    }
                    if($scope.allTasksSortedData.actionTasks && $scope.allTasksSortedData.actionTasks.indevelopment){
                        $scope.allTasksDataIndevelopment = $scope.allTasksDataIndevelopment.concat($scope.allTasksSortedData.actionTasks.indevelopment);
                        }
                        if($scope.allTasksSortedData.informationTasks && $scope.allTasksSortedData.informationTasks.indevelopment){
                            $scope.allTasksDataIndevelopment = $scope.allTasksDataIndevelopment.concat($scope.allTasksSortedData.informationTasks.indevelopment);
                         }
                         if($scope.allTasksSortedData.alertTasks && $scope.allTasksSortedData.alertTasks.indevelopment){
                            $scope.allTasksDataIndevelopment = $scope.allTasksDataIndevelopment.concat($scope.allTasksSortedData.alertTasks.indevelopment);
                         }
                         if($scope.allTasksSortedData.dialogTasks && $scope.allTasksSortedData.dialogTasks.indevelopment){
                          $scope.allTasksDataIndevelopment = $scope.allTasksDataIndevelopment.concat($scope.allTasksSortedData.dialogTasks.indevelopment);
                         }
                        $scope.allTasksDataIndevelopment = _.filter($scope.allTasksDataIndevelopment,function(data){
                            return data.state == "configured" || data.state == "inProgress" || data.state == "awaitingApproval" || data.state == "published";
                        });
                        $timeout(function(){
                            $scope.tasksLoaded =  true;
                        },300);
            };
            $scope.getTasks =  function() {
                $scope.callback.getAllTasks().then(function (res) {
                    $scope.prepareTasksData();
                    $scope.prepareSliderData();
                   },function error(params) {
                  });
            };
            // $scope.getTasks();
            $scope.tasksSelectionLengthIndevelopment = i18n.i18nString('bt_export_all_tasks');
            $scope.formsSelectionLengthIndevelopment = i18n.i18nString('bt_export_all_forms');
            $scope.formsSelectionLengthPublished = i18n.i18nString('bt_export_all_forms');
            $scope.tasksSelectionLengthPublished = i18n.i18nString('bt_export_all_tasks');
            $scope.allTasksDataPublished = [];
            $scope.allFormsDataPublished = [];
            $scope.allTasksDataIndevelopment = [];
            $scope.allFormsDataIndevelopment = [];
            $scope.orderType='-lMod';
            $scope.taskName = {
                'actionTasks':i18n.i18nString('action_tasks_uppercase'),
                'alertTasks':i18n.i18nString('alert_tasks_uppercase'),
                'dialogTasks':i18n.i18nString('dialog_tasks_uppercase'),
                'informationTasks':i18n.i18nString('information_tasks_uppercase'),
                'forms':i18n.i18nString('uiForms_uppercase'),
            };
            $scope.isSmartBot = function(){
                if(_selectedStream.type === "solution"){
                    return true;
                }else{
                    return false;
                }
            };
            $scope.isSampleBot = function(){
                if(_selectedStream.type === "sample"){
                    return true;
                }else{
                    return false;
                }
            };
            if(_selectedStream.type == "universalbot"){
                 $scope.linkedBots = [{task:"Linked Bots",value:"linkedBots",selected:true,name:i18n.i18nString('linked_bots')},
                    {task:"Small Talk",value:"smallTalk",selected:true,name:i18n.i18nString('small_talk')}
                ];
                $scope.settings = [{task:"Bot Settings",value:"botSettings",selected:true,name:i18n.i18nString('bot_settings')},
                    {task:"Bot Variables",value:"botVariables",selected:true,name:i18n.i18nString('bot_variables')},
                    {task:"Voice Call Properties",value:"ivrSettings",selected:true,name:i18n.i18nString('ivr_properties_normal')}
                ];

                $scope.nlp = _selectedStream['universalBotVersion'] === 2?[{task:"Training Data",value:"training_data",selected:true,name:i18n.i18nString('training_data')},
                    {task:"Bot Synonyms",value:"bot_synonyms",selected:true,name:i18n.i18nString('ddval_synonyms')},
                    {task:"Settings",value:"nlpSettings",selected:true,name:i18n.i18nString('settings')},
                    {task:"Default Dialog",value:"defaultDialog",selected:true,name:i18n.i18nString('default_dialog')},
                    {task:"Standard Responses",value:"standardResponses",selected:true,name:i18n.i18nString('ddval_standard')}
                ]:[{task:"NLP Settings",value:"nlpSettings",name:i18n.i18nString('nlp_settings'),selected:true},
                    {task:"Default Dialog",value:"defaultDialog",name:i18n.i18nString('default_dialog'),selected:true},
                    {task:"Standard Responses",name:i18n.i18nString('default_dialog'),value:"standardResponses",selected:true}
                    ];
                $scope.categories = [ {key:"Bot Components",list:$scope.linkedBots,selected:true,name:i18n.i18nString('botComponents')},
                    {key:"NLP Data",list:$scope.nlp,selected:true,name:i18n.i18nString('nlp_data')},
                    {key:"Settings",list:$scope.settings,selected:true,name:i18n.i18nString('settings')},
                    {key:"Custom Dashboards",selected:true,name:i18n.i18nString('custonDashboards')}
                ];
            }else{
                $scope.tasks = [{task:"Tasks",value:"botTask",selected:true,name:i18n.i18nString('Tasks_label')},
                    {task:"Knowledge Graph",value:"knowledgeGraph",selected:true,name:i18n.i18nString('knowledge_graph')},
                    {task:"Small Talk",value:"smallTalk",selected:true,name:i18n.i18nString('small_talk')},
                ];
                // if(!$scope.isSmartBot() && !$scope.isSampleBot()){
                    $scope.tasks.push({task:'Digital Forms',value:"forms",selected:true,name:i18n.i18nString('ui_forms_label')});
                // }
                $scope.settings = [{task:"Bot Settings",value:"botSettings",selected:true,name:i18n.i18nString('bot_settings')},
                    {task:"Bot Variables",value:"botVariables",selected:true,name:i18n.i18nString('bot_variables')},
                    {task:"Voice Call Properties",value:"ivrSettings",selected:true,name:i18n.i18nString('ivr_properties_normal')}
                ];
                $scope.nlp = [{task:"NLP Settings",value:"nlpSettings",selected:true,name:i18n.i18nString('nlp_settings')},
                    {task:"Utterances",value:"utterances",selected:true,name:i18n.i18nString('Utterances')},
                    {task:"Patterns",value:"patterns",selected:true,name:i18n.i18nString('Patterns')},
                    {task:"Standard Responses",value:"standardResponses",selected:true,name:i18n.i18nString('ddval_standard')}
                ];
                $scope.categories = [ {key:"Bot Tasks",list:$scope.tasks,selected:true,name:i18n.i18nString('task_name')},
                    {key:"NLP Data",list:$scope.nlp,selected:true,name:i18n.i18nString('nlp_data')},
                    {key:"Settings",list:$scope.settings,selected:true,name:i18n.i18nString('settings')},
                    {key:"Custom Dashboards",selected:true,name:i18n.i18nString('custonDashboards')}
                ];
            }
            $scope.showNameSearch = false;
            $scope.search ={};
            $scope.latestcategories = $workflowService.cloneData($scope.categories);

            var saveByteArray = (function () {
                return function (data, name) {
                    var blob = null,url="";
                    if (navigator.msSaveBlob) {
                        blob = new Blob(data, { type: 'octet/stream' });
                        return window.navigator.msSaveOrOpenBlob(blob, name);
                    }
                    else{
                        var a = document.createElement("a");
                        document.body.appendChild(a);
                        a.style = "display: none";
                        blob = new Blob(data, {type: "octet/stream"});
                        url = window.URL.createObjectURL(blob);
                        a.href = url;
                        a.download = name;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                };
            }());
            function writeAndDownloadDialog(fileName, data) {
               saveByteArray([data], fileName);
            }

            function startPollExportStatus(timeout) {
                return setInterval(function() {
                    //$rootScope.$broadcast('startTimer');
                    BTFlowtaskService.exportStatusBot(_selectedStream._id)
                    .then(function(res) {
                        if (res && res.data) {
                            $rootScope.$broadcast('getProgressDockStatus');
                            $scope.bot.exportType = res.data.exportType;
                            if (res.data.status === 'success') {
                                $scope.callback.exporttype = res.data.exportType.charAt(0).toUpperCase() + res.data.exportType.substr(1);
                                $scope.callback.downloadFlag = false;
                                $scope.createdOn = res.data.createdOn;
                                $scope.downloadFileId = res.data.fileId;
                                $scope.storeParams= res.data.store.urlParams;
                                stopExportBotPolling('success');
                            } else if (res.data.status === 'failed') {
                                stopExportBotPolling('failed');
                            }
                        }
                    },
                    function(err) {

                        if(err.status == 400) {
                            $rootScope.$broadcast('getProgressDockStatus');
                        }

                        stopExportBotPolling();
                        var _msg = i18n.i18nString('error_on_fetching_bot_export_status');
                        if (err.data && err.data.errors && err.data.errors.length > 0) {
                            _msg = err.data.errors[0].msg;
                        }
                        NotificationService.notify(_msg, "error");
                    });
                }, timeout);
            }

            $scope.callback.downloadFile = function(evt){
                evt.preventDefault();
                $scope.url = $scope.storeParams;
                BTStreamsService.downloadProgressDockExportFile($scope.downloadFileId).then(function(res){
                    if(res && res.data){
                        $scope.callback.downloadUrl = res.data.fileUrl + $scope.url;
                        var xyz = "#downloadFile";
                        $(xyz).attr('href', $scope.callback.downloadUrl);
                        $timeout(function() {
                            $(xyz).get(0).click(function(e){
                                e.stopPropagation();
                            });
                        },450);
                    }
                });
            };


            $scope.exportBot = function() {
                var _botInfo = {
                    streamId:$workflowService.selectedStream()._id,
                    BotName:$workflowService.selectedStream().name,
                 };
                 mixPanel.postEvent('Export Bot',_botInfo);
               function startExport(){
                
               
                NotificationService.notify(i18n.i18nString('bt_export_export_in_progress_noty'),"success");
                if($scope._exportStatusInit) {
                    clearTimeout($scope._exportStatusInit);
                }
                $scope.callback.exporting = 'pending';
                var payload = {"exportOptions":{},"exportType": $scope.bot.exportType};
                var taskResult,nlpdata,showFailedErrors;
                payload.IncludeDependentTasks = $scope.bot.independentTasks;
                if($scope.btCollectionVariables.selectedCollection && $scope.btCollectionVariables.useCollections) { 
                    payload.activeCollectionRefId = $scope.btCollectionVariables.selectedCollection.refId;// if useCollections is enabled
                }
                if(_selectedStream.type == "universalbot"){
                    payload.exportOptions.botComponents=[];
                    payload.exportOptions.nlpData=[];
                    payload.exportOptions.settings=[];
                    if($scope.bot.exportType === 'published'){
                        taskResult = $scope.categories[0].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.botComponents.push(key.value);
                            }
                        });
                        nlpdata = $scope.categories[1].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.nlpData.push(key.value);
                            }
                        });
                        showFailedErrors = $scope.categories[2].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.settings.push(key.value);
                            }
                        });
                        if($scope.categories[3].key === "Custom Dashboards" && $scope.categories[3].selected){
                            payload.customDashboards = true;
                        }else{
                            payload.customDashboards = false;
                        }
                    }else if($scope.bot.exportType === 'latest'){
                        taskResult = $scope.latestcategories[0].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.botComponents.push(key.value);
                            }
                        });
                        nlpdata = $scope.latestcategories[1].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.nlpData.push(key.value);
                            }
                        });
                        showFailedErrors = $scope.latestcategories[2].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.settings.push(key.value);
                            }
                        });
                        if($scope.latestcategories[3].key === "Custom Dashboards" && $scope.latestcategories[3].selected){
                            payload.customDashboards = true;
                        }else{
                            payload.customDashboards = false;
                        }
                    }
                }else{
                    payload.exportOptions.tasks=[];
                    payload.exportOptions.nlpData=[];
                    payload.exportOptions.settings=[];
                    if($scope.bot.exportType === 'published'){
                        taskResult = $scope.categories[0].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.tasks.push(key.value);
                            }
                        });
                        nlpdata = $scope.categories[1].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.nlpData.push(key.value);
                            }
                        });
                        showFailedErrors = $scope.categories[2].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.settings.push(key.value);
                            }
                        });
                        if($scope.categories[3].key === "Custom Dashboards" && $scope.categories[3].selected){
                            payload.customDashboards = true;
                        }else{
                            payload.customDashboards = false;
                        }
                    }else if($scope.bot.exportType === 'latest'){
                        taskResult = $scope.latestcategories[0].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.tasks.push(key.value);
                            }
                        });
                        nlpdata = $scope.latestcategories[1].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.nlpData.push(key.value);
                            }
                        });
                        showFailedErrors = $scope.latestcategories[2].list.forEach(function(key,value){
                            if(key.selected === true){
                                payload.exportOptions.settings.push(key.value);
                            }
                        });
                        if($scope.latestcategories[3].key === "Custom Dashboards" && $scope.latestcategories [3].selected){
                            payload.customDashboards= true;
                        }else{
                            payload.customDashboards = false;
                        }
                    }
                    if(payload.exportOptions.tasks[0] === "botTask"){
                        payload.subTasks = $scope.saveTasksID($scope.bot.exportType);
                    }else{
                        payload.subTasks = {};
                    }
                    if(payload.exportOptions.tasks.indexOf('forms') > -1){
                        payload.IncludeFormDependentTasks = $scope.bot.independentForms;
                      var subForms = $scope.saveFormsID($scope.bot.exportType);
                      if($('#formSelectionSlider .tableContainer .checkbox input:checked').length === $('#formSelectionSlider .tableContainer .checkbox input').length){
                        payload.allForms = true;
                      } else {
                        payload.allForms = false;
                        payload.subTasks.forms = subForms || {};
                      }
                    }
                    if(payload.exportOptions.tasks[0] === "botTask" && $('#taskSelectionSlider .tableContainer .checkbox input:checked').length === $('#taskSelectionSlider .tableContainer .checkbox input').length){
                        payload.allTasks = true;
                    }else{
                        payload.allTasks = false;
                    }
                }
                
                           
            BTFlowtaskService.exportBot(_selectedStream._id, payload).then(function(res) {
                if (res && res.data) {
                    $scope.bot.exportType = res.data.exportType;
                    $scope.streamRefId = res.data._id || "";
                    $scope.statusLogs = res.data.statusLogs || [];
                    if (res.data.status === 'pending') {
                        $scope.callback.exporting = res.data.status;
                        $rootScope.$broadcast('getProgressDockStatus');
                        $(".trainingProgress").addClass('open');
                        $scope._exportStatusInit = startPollExportStatus(3000);
                    } else if (res.data.status === 'success') {
                        $rootScope.$broadcast('getProgressDockStatus');
                        $(".trainingProgress").addClass('open');
                        $scope.callback.exporttype = res.data.exportType.charAt(0).toUpperCase() + res.data.exportType.substr(1);
                        stopExportBotPolling('success');
                    } else {
                        stopExportBotPolling('failed');
                    }
                    if(res.data && res.data.store && res.data.store.timeoutMessage){
                        var msg = res.data.store.timeoutMessage;
                        NotificationService.notify(msg,"warning");
                    }
                }
            }, function(error) {
                if (error && error.data && error.data.errors) {
                    var _msg = error.data.errors[0].msg;
                    NotificationService.notify(_msg, 'error');
                } else if (error.errors && _.isArray(error)) {
                    var msg = error.errors[0].msg;
                    NotificationService.notify(msg, 'error');
                } else {
                    NotificationService.notify(i18n.i18nString('bt_export_unexpected_err_while_exporting'), 'error');
                }
                if(error.data.errors[0].code === 'RequestExists'){
                    var _msg1 = error.data.errors[0].code;
                    NotificationService.notify(_msg1,"warning");
                }
                $scope.callback.exporting = "failed";
            });
               }
               function cancleExport(){
                   return;
               }
               function checkBoxCb(checkValue){
                 console.log(checkValue);
                 $scope._constants_.updateDownloadPopUppreferance(checkValue);
               }
               if($scope._constants_.config.showDownloadPopUps){
                NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined,i18n.i18nString('export_bot'));  
               }else{
                   startExport();
               }
        };


         function stopExportBotPolling(_status) {
            if($scope._exportStatusInit) {
                clearTimeout($scope._exportStatusInit);
                $scope._exportStatusInit = null;
            }
            if(_status === 'success') {
                finishedExport();
            }
            else{
                $scope.callback.exporting = "failed";
            }
        }

        function finishedExport() {
            if($scope._exportStatusInit){
                    clearTimeout($scope._exportStatusInit);      
            }
            $scope.callback.exporting = "finished";
            
        }

        $scope.callback.setToInitial = function(){
            $scope.callback.exporting = "initial";
         };

         $scope.getExportBotStatus = function(){
            console.log("called");
            BTFlowtaskService.exportStatusBot(_selectedStream._id).then(function(res){
               if(res && res.data){
                    $scope.bot.exportType = res.data.exportType;
                    if(res.data.status === "pending"){
                    $scope.callback.exporting = res.data.status;
                    $scope._exportStatusInit = startPollExportStatus(3000);
                }else if (res.data.status === 'success') {
                        $scope.createdOn = res.data.createdOn;
                        $scope.callback.exporttype = res.data.exportType.charAt(0).toUpperCase() + res.data.exportType.substr(1);
                        $scope.callback.downloadFlag = true;
                        $scope.downloadFileId = res.data.fileId;
                        $scope.storeParams= res.data.store.urlParams;
                        stopExportBotPolling('success');
                } else if(res.data === ""){
                    $scope.callback.exporting = "initial";
                }
                else {
                        stopExportBotPolling('failed');
                    }
               }
                

            });
         };

         $scope.callback.getDate = function()
         {
            var timestamp = $scope.createdOn;
            if (timestamp === undefined){
              return '--';  
            }
            return moment(timestamp).format('MM-DD-YYYY');
         };

        $scope.callback.getTime = function()
         {
            var timestamp = $scope.createdOn;
             if (timestamp === undefined){
              return '--';  
            }
            return moment(timestamp).format('h:mm A');
         };

         $scope.clickerTask = function(task,e,index){
            e.stopPropagation();
            if(angular.element('#componentExport'+index).parent().hasClass('intermediate')){
                angular.element('#componentExport'+index).parent().removeClass('intermediate');  
            }
            task.list.forEach(function(key,value){
                key.selected = task.selected;

            });
        };
        
        $scope.clickerTaskSelection = function(state,e,id){
            e.stopPropagation();
            if($(id+' .tableHeaderRow input:checked').length === 0){
                if(state === 'published'){
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsDataPublishedCopy.forEach(function(key,value){
                            key.selected = false;
                        });
                    }else{
                        $scope.allTasksDataPublishedCopy.forEach(function(key,value){
                            key.selected = false;
                        }); 
                    }
                   
                }else{
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsDataIndevelopmentCopy.forEach(function(key,value){
                            key.selected = false;
                        });
                    }else{
                        $scope.allTasksDataIndevelopmentCopy.forEach(function(key,value){
                            key.selected = false;
                        });
                    }
                   
                }
            }else{
                if(state === 'published'){
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsDataPublishedCopy.forEach(function(key,value){
                            key.selected = true;
                        });
                    }else{
                        $scope.allTasksDataPublishedCopy.forEach(function(key,value){
                            key.selected = true;
                        });
                    }
                   
                }else{
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsDataIndevelopmentCopy.forEach(function(key,value){
                            key.selected = true;
                        });
                    }else{
                        $scope.allTasksDataIndevelopmentCopy.forEach(function(key,value){
                            key.selected = true;
                        });
                    }
                   
                }
            }
        };

        $scope.clickerSubTaskSelection = function(e,selectedState,id){
            e.stopPropagation();
            if(selectedState === 'published'){
                if($(id+' .tableContainer .checkbox input.check:checked').length === $(id+' .tableContainer .checkbox input.check').length){                
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsSelectedPublished = true;
                    }else{
                        $scope.allTasksSelectedPublished = true;
                    }
                    
                }else{
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsSelectedPublished = false;
                    }else{
                        $scope.allTasksSelectedPublished = false;
                    }
                    
                } 
            }else{
                if($(id+' .tableContainer .checkbox input.check:checked').length === $(id+' .tableContainer .checkbox input.check').length){                
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsSelectedIndevelopment = true;
                    }else{
                        $scope.allTasksSelectedIndevelopment = true;
                    }
                    
                }else{
                    if(id==='#formSelectionSlider'){
                        $scope.allFormsSelectedIndevelopment = false;
                    }else{
                        $scope.allFormsSelectedIndevelopment = false;
                    }
                } 
            }      
        };

        $scope.clickerSubTask = function(task,e,index){
            e.stopPropagation();
            var count = 0;
            task.list.forEach(function(key,value){
                if(key.selected){
                    count ++;
                }
            });
            if(count === task.list.length){
                task.selected = true;
                angular.element('#componentExport'+index).parent().removeClass('intermediate');
            }else if(count === 0){
                task.selected = false;
                angular.element('#componentExport'+index).parent().removeClass('intermediate');
            }else if (count !== 0){
                task.selected = true;
                angular.element('#componentExport'+index).parent().addClass('intermediate');
            }
        };

        $scope.clickerLatestTask = function(task,e,index){
            e.stopPropagation();
            if(angular.element('#componentlatest'+index).parent().hasClass('intermediate')){
                angular.element('#componentlatest'+index).parent().removeClass('intermediate');  
            }
            if(task && task.list && task.list.length){
                task.list.forEach(function(key,value){
                    key.selected = task.selected;
                });
            }
        };

        $scope.clickerLatestSubTask = function(task,e,index){
            e.stopPropagation();
            var count = 0;
            task.list.forEach(function(key,value){
                if(key.selected){
                    count ++;
                }
            });
            if(count === task.list.length){
                task.selected = true;
                angular.element('#componentlatest'+index).parent().removeClass('intermediate');
            }else if(count === 0){
                task.selected = false;
                angular.element('#componentlatest'+index).parent().removeClass('intermediate');
            }else if (count !== 0){
                    task.selected = true;
                angular.element('#componentlatest'+index).parent().addClass('intermediate');
            }
        };
        $scope.prepareSliderData =  function(){
            if($scope.selectedState === 'published'){
                $scope.allTasksDataPublishedCopy = $workflowService.cloneData($scope.allTasksDataPublished);
                var selectAllPublishedFlag =_.filter($scope.allTasksDataPublishedCopy,{selected:true});
                if(selectAllPublishedFlag.length === $scope.allTasksDataPublishedCopy.length){
                    $scope.allTasksSelectedPublished = true;
                }else{
                    $scope.allTasksSelectedPublished = false;
                }
            }else{
                $scope.allTasksDataIndevelopmentCopy = $workflowService.cloneData($scope.allTasksDataIndevelopment);
                var selectAllIndevelopmentFlag =_.filter($scope.allTasksDataIndevelopmentCopy,{selected:true});
                if(selectAllIndevelopmentFlag.length === $scope.allTasksDataIndevelopmentCopy.length){
                    $scope.allTasksSelectedIndevelopment = true;
                }else{
                    $scope.allTasksSelectedIndevelopment = false;
                }
            }
            $timeout(function(){
                $scope.loadingTasksList =  false;
            },200);
        };
        $scope.openTasksSlider = function(state,type){
            $scope.taskToLoad =  300;
            $scope.showNameSearch = false;
            $scope.loadingTasksList = true;
            $scope.search.nameSearchQuery = "";
            $scope.selectedState = state;
            if(type === 'forms'){
                $scope.prepareFormsData();
                if($scope.selectedState === 'published'){
                    $scope.allFormsDataPublishedCopy = $workflowService.cloneData($scope.allFormsDataPublished);
                    var selectAllPublishedFormsFlag =_.filter($scope.allFormsDataPublishedCopy,{selected:true});
                    if(selectAllPublishedFormsFlag.length === $scope.allFormsDataPublishedCopy.length){
                        $scope.allFormsSelectedPublished = true;
                    }else{
                        $scope.allFormsSelectedPublished = false;
                    }
                }else{
                    $scope.allFormsDataIndevelopmentCopy = $workflowService.cloneData($scope.allFormsDataIndevelopment);
                    var selectAllFormsIndevelopmentFlag =_.filter($scope.allFormsDataIndevelopmentCopy,{selected:true});
                    if(selectAllFormsIndevelopmentFlag.length === $scope.allFormsDataIndevelopmentCopy.length){
                        $scope.allFormsSelectedIndevelopment = true;
                    }else{
                        $scope.allFormsSelectedIndevelopment = false;
                    }
                }
                $scope.openModalSlider('#formSelectionSlider');
            }else{
            if(!$scope.tasksLoaded){
                $scope.callback.getAllTasks().then(function (res) {
                    $scope.prepareTasksData();
                    $scope.prepareSliderData();
                   },function error(params) {
                  
                  });
            } else {
                $scope.prepareSliderData();
            }
            $scope.openModalSlider('#taskSelectionSlider');
        }
        };
        $scope.loadMore =  function(type) {
            if(type === 'published') {
                $scope.taskToLoad = $scope.allTasksDataPublishedCopy.length;
            } else {
                $scope.taskToLoad = $scope.allTasksDataIndevelopmentCopy.length;
            }
        };
        // Bot varialbles - collection management
        // $scope.openCollectionSlider = function(state,type){
        //     // $scope.showNameSearch = false;
        //     // $scope.search.nameSearchQuery = "";
        //     // $scope.selectedState = state;
        // };
        
        // Get all collections
        function getAllCollections() {
            BTStreamsService.btGetAllCollections($applicationService.userInfo().userId, $workflowService.selectedStream()._id).then(function(res){
                if(res && res.data) {
                    $scope.btCollectionVariables.collectionList = res.data;
                    if($scope.btCollectionVariables.collectionList && $scope.btCollectionVariables.collectionList.length) {
                        $scope.btCollectionVariables.collectionList.forEach(function(item) {
                            if(item.isActive) {
                                $scope.btCollectionVariables.selectedCollection = item;  
                            }
                        });
                    } else {
                        $scope.btCollectionVariables.collectionType = 'EMPTY';
                    }
                }
            },function(err){
                if (err && err.data && err.data.errors) {
                    NotificationService.notify(err.data.errors[0].msg, 'error');
                } else {
                    NotificationService.notify(i18n.i18nString('failed_collections'), 'error');
                }
            });
        }
        // Check customSettings.useCollections flag exist in appControl 
        function checkCollectionsExist() {
            var selectedAccount = $workflowService.selectedAccount();
            console.log(selectedAccount);
            if(selectedAccount && selectedAccount.customSettings && selectedAccount.customSettings.useCollections === true) {
                getAllCollections();
                $scope.btCollectionVariables.useCollections = selectedAccount.customSettings.useCollections;
            } 
        }
        checkCollectionsExist();
        // Collection variables sliders
        $scope.openCollectionSlider = function(){
            $scope.manageCollectionVarEnable = true;
            $scope.btCollectionVariables.exportBot = true;
            $scope.btCollectionVariables.collectionType = 'EXPORT';
            setTimeout(function(){
                $scope.openModalSlider('#manageCollectionsSlider');
            }, 200);
        };

        $scope.btCollectionVariables.close = function() {
            $scope.closeModalSlider('#manageCollectionsSlider');
            $scope.manageCollectionVarEnable = false;
        };

        $scope.taskSelectionSliderClose = function(){
            $scope.closeModalSlider('#taskSelectionSlider');
        };
        $scope.formSelectionSliderClose = function(){
            $scope.closeModalSlider('#formSelectionSlider');
        };
        $scope.saveTasksID = function(selectedState){
            var subTasks = {};
            subTasks.dialogs = [];
            subTasks.alerts = [];
            subTasks.actions = [];
            if(selectedState === 'published'){
                $scope.allTasksDataPublishedCopy.forEach(function(task){
                    if(task.selected){
                        if(task._id.startsWith('dg-')){
                            subTasks.dialogs.push(task._id);
                        } else if(task._id.startsWith('a-')){
                            subTasks.actions.push(task._id);
                        } else if(task._id.startsWith('l-')){
                            subTasks.alerts.push(task._id);
                        }
                    }
                });
            }else{
                if($scope.allTasksDataIndevelopmentCopy && $scope.allTasksDataIndevelopmentCopy.length){
                    $scope.allTasksDataIndevelopmentCopy.forEach(function(task){
                        if(task.selected){
                            if(task._id.startsWith('dg-')){
                                subTasks.dialogs.push(task._id);
                            } else if(task._id.startsWith('a-')){
                                subTasks.actions.push(task._id);
                            } else if(task._id.startsWith('l-')){
                                subTasks.alerts.push(task._id);
                            }
                        }
                    });
                }
                
            }
            if(selectedState === 'published'){
                if($('#taskSelectionSlider .tableContainer .checkbox input:checked').length === $('#taskSelectionSlider .tableContainer .checkbox input').length){
                    $scope.tasksSelectionLengthPublished = i18n.i18nString('bt_export_all_tasks');
                }else{
                    var selectedPublished = _.filter($scope.allTasksDataPublishedCopy,{selected:true});
                    $scope.tasksSelectionLengthPublished = selectedPublished.length + i18n.i18nString('bt_export_tasks');
                }
                $scope.allTasksDataPublished = $workflowService.cloneData($scope.allTasksDataPublishedCopy);
            }else if(selectedState === 'indevelopment'){
                if($('#taskSelectionSlider .tableContainer .checkbox input:checked').length === $('#taskSelectionSlider .tableContainer .checkbox input').length){
                    $scope.tasksSelectionLengthIndevelopment = i18n.i18nString('bt_export_all_tasks');
                }else{
                    var selectedDevelopment = _.filter($scope.allTasksDataIndevelopmentCopy,{selected:true});
                    $scope.tasksSelectionLengthIndevelopment = selectedDevelopment.length + i18n.i18nString('bt_export_tasks');
                }
                $scope.allTasksDataIndevelopment = $workflowService.cloneData($scope.allTasksDataIndevelopmentCopy);
            }
            $scope.closeModalSlider('#taskSelectionSlider');
            return subTasks;
        };
        $scope.saveFormsID = function(selectedState){
            var subForms = [];
            if(selectedState === 'published'){
                $scope.allFormsDataPublishedCopy.forEach(function(task){
                    if(task.selected){
                            subForms.push(task._id);
                    }
                });
            }else{
                if($scope.allFormsDataIndevelopmentCopy && $scope.allFormsDataIndevelopmentCopy.length){
                    $scope.allFormsDataIndevelopmentCopy.forEach(function(task){
                        if(task.selected){
                            if(task.selected){
                                subForms.push(task._id);
                        }
                        }
                    });
                }
            }
            if(selectedState === 'published'){
                if($('#formSelectionSlider .tableContainer .checkbox input:checked').length === $('#formSelectionSlider .tableContainer .checkbox input').length){
                    $scope.formsSelectionLengthPublished = i18n.i18nString('bt_export_all_forms');
                }else{
                    $scope.formsSelectionLengthPublished = $('#formSelectionSlider .tableContainer .checkbox input:checked').length + i18n.i18nString('bt_export_forms');
                }
                $scope.allFormsDataPublished = $workflowService.cloneData($scope.allFormsDataPublishedCopy);
            }else if(selectedState === 'indevelopment'){
                if($('#formSelectionSlider .tableContainer .checkbox input:checked').length === $('#formSelectionSlider .tableContainer .checkbox input').length){
                    $scope.formsSelectionLengthIndevelopment = i18n.i18nString('bt_export_all_forms');
                }else{
                    $scope.formsSelectionLengthIndevelopment = $('#formSelectionSlider .tableContainer .checkbox input:checked').length + i18n.i18nString('bt_export_forms');
                }
                $scope.allFormsDataIndevelopment = $workflowService.cloneData($scope.allFormsDataIndevelopmentCopy);
            }
            $scope.closeModalSlider('#formSelectionSlider');
            return subForms;
        };
        $scope.sortTaskList = function(sortType){
            if(sortType=="nameSort"){
                if($scope.orderType =='name' ){
                    $scope.orderType='-name';
                }else{
                    $scope.orderType='name';
                }
            }
            if(sortType=="datesSort"){
                if($scope.orderType =='lMod' ){
                    $scope.orderType='-lMod';
                }else{
                    $scope.orderType='lMod';
                }
            }
        };

        $scope.activateNameSearch = function(show) {
            if(show) {
                $scope.showNameSearch = true;
            }
            else{
                $scope.search.nameSearchQuery = "";
                $scope.showNameSearch = false;
            }
            setTimeout(function(){
                $('.focusNameSearch').focus();
            },100);
        };

        //used while builder is resuming//
        $scope.$emit('nestedComponentLoaded', { 'id': 'exportBot', 'flag': false });
        //Add below whenever nestedComponentLoaded is FINALLY emitted.
        $timeout(function(){
            $scope.$emit('gSearchLoad');
        });
        // Bot Import/Export save button
        $scope.updateBotExport = function (e) {
            $scope.exportBot();
        };
        $scope.$on("updateBotExport", function(evt){
            $scope.updateBotExport();
        });
    }]);
})(angular);


;(function (ng) {

    'use strict';

    var _module = ng.module('bt-flowTask-create', ['app.helpers', 'bt-forms']);

    _module.controller('BTFlowTaskCreateCtrl', ['$scope', '$rootScope', '$location', '$workflowService', 'BTSeedDataService', 'NotificationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService',
        function ($scope, $rootScope, $location, $workflowService, BTSeedDataService, NotificationService, BTAlertsService, BTActionsService, BTStreamsService) {
            $rootScope.saveAndExit = false;

            $scope.displayMode = '';

            $scope.wftype = $workflowService.workflowType();

            $scope.selectedStream = $workflowService.selectedStream();

            if (!$workflowService.workflowType()) {
                $location.path(window.appConfig.CONTEXT_PATH);
                return;
            }

            $scope.sections = {
                showFlow: false
            };

            $scope.entityObj = {
                type: 'flowtask'
            };

            $scope.currentStep = 1;

            $scope.finishSetup = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            function errorSaveHandler() {
                triggerNextStep();
            }

            $scope.gotostream = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            function navigateTo(screen) {
                $scope.sections[screen] = true;
                $scope.currentStage = screen;
                $('html, body').animate({scrollTop: 0}, 'fast');
            }
            
            $scope.onCancel = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            $scope.navigateTo = function (screen) {
                $rootScope.saveAndExit = false;
                navigateTo(screen);
            };

            navigateTo('showFlow');
        }]);

})(angular);


;(function (ng) {

    'use strict';

    var _module = ng.module('bt-flowTask-edit', ['app.helpers', 'bt-forms']);

    _module.controller('BTFlowTaskEditCtrl', ['$scope', '$rootScope', '$location', '$workflowService', 'BTSeedDataService', 'NotificationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService',
        function ($scope, $rootScope, $location, $workflowService, BTSeedDataService, NotificationService, BTAlertsService, BTActionsService, BTStreamsService) {
            $rootScope.saveAndExit = false;

            $scope.displayMode = 'edit';

            $scope.wftype = $workflowService.workflowType();
            $scope.flowtaskObj = $workflowService.flowtaskInfo();
            $scope.selectedStream = $workflowService.selectedStream();

            if (!$workflowService.workflowType()) {
                $location.path(window.appConfig.CONTEXT_PATH);
                return;
            }

            $scope.sections = {
                showFlow: false
            };

            $scope.entityObj = {
                type: 'flowtask'
            };

            $scope.currentStep = 1;

            $scope.finishSetup = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            function errorSaveHandler() {
                triggerNextStep();
            }

            $scope.gotostream = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            function navigateTo(screen) {
                $scope.sections[screen] = true;
                $scope.currentStage = screen;
                $('html, body').animate({scrollTop: 0}, 'fast');
            }
            
            $scope.onCancel = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            $scope.navigateTo = function (screen) {
                $rootScope.saveAndExit = false;
                navigateTo(screen);
            };

            navigateTo('showFlow');
        }]);

})(angular);


;(function (ng) {

    'use strict';

    var _module = ng.module('bt-flowTask-view', ['app.helpers', 'bt-forms']);

    _module.controller('BTFlowTaskViewCtrl', ['$scope', '$rootScope', '$location', '$workflowService', 'BTSeedDataService', 'NotificationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService',
        function ($scope, $rootScope, $location, $workflowService, BTSeedDataService, NotificationService, BTAlertsService, BTActionsService, BTStreamsService) {
            $rootScope.saveAndExit = false;
            $scope.displayMode = 'view';

            $scope.wftype = $workflowService.workflowType();
            $scope.flowtaskObj = $workflowService.flowtaskInfo();
            $scope.selectedStream = $workflowService.selectedStream();

            if (!$workflowService.workflowType()) {
                $location.path(window.appConfig.CONTEXT_PATH);
                return;
            }

            $scope.sections = {
                showFlow: false
            };

            $scope.entityObj = {
                type: 'flowtask'
            };

            $scope.currentStep = 1;

            $scope.finishSetup = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            function errorSaveHandler() {
                triggerNextStep();
            }

            $scope.gotostream = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            function navigateTo(screen) {
                $scope.sections[screen] = true;
                $scope.currentStage = screen;
                $('html, body').animate({scrollTop: 0}, 'fast');
            }
            
            $scope.onCancel = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };

            $scope.navigateTo = function (screen) {
                $rootScope.saveAndExit = false;
                navigateTo(screen);
            };

            navigateTo('showFlow');
        }]);

})(angular);


;(function(ng){

	'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btImportExport',['$workflowService', '_constants_', '$rootScope','i18n' , 
     function($workflowService, constants, $rootScope,_constants_,i18n){

    	return{
    		restrict : 'EA',
            scope:{
                callback: "=",
                importFrom: "=",
                enterPrise: "="
            },
    		templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-import-export/bt-import-export.html',
            controller: ['$scope', function ($scope) {
                $scope.$emit('nestedComponentLoaded', {
                    'id': 'btImportExport',
                    'flag': false
                });
                $scope.callback.activeTab = 'IMPORT';
                var searchQuery = $workflowService.storeSearchQry();
                if(searchQuery && searchQuery.navigateTo === 'export') {
                    $workflowService.storeSearchQry({
                        'userSearchQueryFlag': false,
                        'searchQry': ''
                    });
                    setTimeout(function(){
                        $('#exportBotTabSelection').click();
                    },200);
                }
                // Check for Active Tab
                $scope.checkActiveTab = function(type) {
                    if(type === 'EXPORT') {
                        $scope.callback.activeTab = 'EXPORT';
                    } else if(type === 'IMPORT') {
                        $scope.callback.activeTab = 'IMPORT';
                    } else {
                        $scope.callback.activeTab = 'IMPORT';
                    }
                };
            }]
        };
    }]);
})(angular);

;(function (ng) {
    var _module = angular.module("bt-import-bot", []);
    _module.directive("btImportBot", function () {
        return {
            restrict: "EA",
            scope: {
                callback: "=",
                importFrom: "=",
                enterPrise: "=",
                importType: "="
            },
            templateUrl: window.appConfig.TMPLT_PRE_PATH + "js/modules/bt-import/bt-importBot.html",
            controller: ['$scope', '$workflowService', 'BTFlowtaskService', 'NotificationService', '$location', '$endpoints', '$applicationService', 'env_conf','$window','$route','BTFileUploadService','$rootScope','BTStreamsService','$timeout','$element','accessControlService','navigator','i18n','mixPanel',
                function ($scope, $workflowService, BTFlowtaskService, NotificationService, $location, $endpoints, $applicationService, env_conf,$window,$route,BTFileUploadService,$rootScope,BTStreamsService,$timeout,$element,accessControlService,navigator,i18n,mixPanel) {
                    $scope.displayMode = accessControlService.getAccessRight('BOTBUILDER_BOT_IMPORT');
                    $scope.publishPermission = accessControlService.getAccessRight('BOTBUILDER_PUBLISH_BOT');
                    $scope.assetsBase = env_conf['assets-url'];
                    $scope.newBotStreamId = '';
                    $scope.selectedAccount=$workflowService.selectedAccount();
                    $scope.partialImportAllowed = !($scope.selectedAccount.platformVersion) ||  !$scope.selectedAccount.accountType;
                    $scope.parentDisplayMode = accessControlService.getAccessRight('BOTBUILDER_BOT_SETTINGS');
                    var _selectedStream = $workflowService.selectedStream();
                    if(_selectedStream.permissions && _selectedStream.permissions.BOTBUILDER_BOT_IMPORT[0] && ($scope.importFrom=='newBotImport')){   //exception here from publish mode
                        $scope.displayMode = _selectedStream.permissions.BOTBUILDER_BOT_IMPORT[0];
                    }
                    $scope.filesObj = {
                        loadingBotConfig:false,
                        loadingBotDefinition:false

                    };
                    $scope.dialogProperties = {
                        includeComments: true,
                    };
                    $scope.botFunctions = {};
                    $scope.importBotDefinition = "importBotDefinition";
                    $scope.importConfig = "importConfig";
                    $scope.allowedFileTypes =  ['json'];
                    $scope.uploadBotDefinitionStatus =  function(event){
                        if(event && event.status === 'pending'){
                            $scope.filesObj.loadingBotDefinition =  true;
                            setTimeout(function() {
                                $scope.$apply();
                            }, 100);
                        }
                        if(event.status === 'error'){
                            $scope.importedBotData = null;
                            $scope.importedBotName =  null;
                            $scope.filesObj.loadingBotDefinition =  false;
                            if(event.data && event.data.fileExtensionError) {
                                NotificationService.notify(i18n.i18nString('only_json_file'), "error");
                            } else {
                                NotificationService.notify(i18n.i18nString('save_script_error'), 'error');
                            }
                            setTimeout(function() {
                                $scope.$apply();
                            }, 100);
                        }else if(event && event.status==='success') {
                            if(event.data && event.data.values && event.data.values.componentFileId) {
                                $scope.filesObj.loadingBotDefinition =  false;
                                $scope.importedBotName =  event.data.values.componentData.filename;
                                $scope.importedBotData = event.data.values;
                                $scope.importedBotData.fileId = event.data.values.componentFileId;
                                $scope.callback.definitionFormData = event.formData;
                                setTimeout(function() {
                                    $scope.$apply();
                                }, 100);
                            }
                        } else {
                            $scope.importedBotData = null;
                            $scope.importedBotName =  null;
                        }
                    };
                    $scope.uploadVariablesStatus =  function(event){
                        if(event && event.status === 'pending'){
                            console.log('Loading File');
                            $scope.filesObj.loadingBotConfig =  true;
                            setTimeout(function() {
                                $scope.$apply();
                            }, 100);
                        }
                        if(event.status === 'error'){
                            console.log('Error Loading File');
                            $scope.filesObj.loadingBotConfig =  false;
                            $scope.importedVariablesData = null;
                            $scope.importedBotVariableName =  null;
                            if(event.data && event.data.fileExtensionError) {
                                NotificationService.notify(i18n.i18nString('only_json_file'), "error");
                            } else {
                                NotificationService.notify(i18n.i18nString('save_script_error'), 'error');
                            }
                            setTimeout(function() {
                                $scope.$apply();
                            }, 100);
                        }else if(event && event.status==='success') {
                            if(event.data && event.data.values && event.data.values.componentFileId) {
                                $scope.filesObj.loadingBotConfig =  false;
                                console.log('Error Loading Success');
                                $scope.importedBotVariableName =  event.data.values.componentData.filename;
                                $scope.importedVariablesData = event.data.values;
                                $scope.importedVariablesData.fileId = event.data.values.componentFileId;
                                $scope.callback.configFormData = event.formData;
                                setTimeout(function() {
                                    $scope.$apply();
                                }, 100);
                            }
                        } else {
                            $scope.importedVariablesData = null;
                            $scope.importedBotVariableName =  null;
                        }
                    };
                    $scope.statusLogsLimit =  200;
                    $scope.rightClass = "right400";
                    $scope.callback = $scope.callback || {};
                    $scope.fileExtensionError = false;
                    $scope.imageExtensionError = false;
                    $scope.fileExtensionVariablesError = false;
                    $scope.importing = "backupNote";
                    $scope.importingSvg = env_conf['context-url'] + '/assets/images/importing.png';
                    $scope.importSuccessBlue = env_conf['context-url'] + '/assets/images/import-success-blue.png';
                    $scope.importSuccessGreen = env_conf['context-url'] + '/assets/images/import-success.png';
                    $scope.importWarningIcon = env_conf['context-url'] + '/assets/icons-new/import-warning/importing.png';
                    $scope.importSucessSvg = env_conf['context-url'] + '/assets/images/import-success.png';
                    $scope.importErrorSvg = env_conf['context-url'] + '/assets/images/import-error.png';
                    $scope.closeCross = env_conf['context-url']+'/assets/icons/closeCross.png';
                    $scope.checkDone = env_conf['context-url']+'/assets/icons/Check-done.svg';
                    $scope.warning = env_conf['context-url'] + '/assets/icons/Warning-orange.svg';
                    $scope.bulbBlue = env_conf['context-url'] + '/assets/icons-new/bulb/bulb-blue.svg';
                    $scope.bulbNavyBlue = env_conf['context-url'] + '/assets/icons-new/bulb/bulb-navy-blue.svg';
                    $scope.successCheck = env_conf['context-url'] + '/assets/icons/success-check.svg';
                    $scope.failImg = env_conf['context-url'] + '/assets/icons/fail-import-fullbot.svg';
                    $scope.warningTriangle = env_conf['context-url'] + '/assets/icons-new/exclamation-triangle/exclamation-triangle-orange.svg';
                    $scope.totalProgress = 0;
                    $scope.totalProgressPublish = 0;
                    $scope.bulbIcon = env_conf['context-url'] +'/assets/images/24x29-bulbicon.png';
                    $scope.streamRefId = "";
                    $scope._importStatusInit = null;
                    var progressInterval = null;
                    var progressIntervalPublish = null;
                    $scope.importErrors = [];
                    $scope.statusLogs = [];
                    $scope.showFailedErrors  = true;
                    $scope.initializeScrollBar = false;
                    $scope.disableProceed = false;
                    $scope.newStreamData = {};
                    $scope.newStreamData.iconFile = null;
                    $scope.newStreamData.icon = env_conf['context-url']+'/assets/botIcons/new/bot-1.png';
                    $('#iconFile').val('');
                    $scope._constants_ = $rootScope._constants_;
                    $scope.defaultImg = env_conf['context-url']+'/assets/botIcons/new/bot-1.png';
                    $scope.bot = {};
                    $scope.bot.importType = "fullImport";
                    $scope.publish = {};
                    $scope.done_label =  i18n.i18nString('done');
                    $scope.ok_text_label =  i18n.i18nString('ok_label'); 
                    $scope.retry_label  =  i18n.i18nString( 'retry');
                    $scope.retrying_label =  i18n.i18nString( 'retrying_label');
                    $scope.retry_all =  i18n.i18nString( 'retry_all');
                    
                    $scope.appControls = $applicationService.userInfo().appControls;
                    $scope.license = {};
                    $scope.planSelectionCb = {};
                    $scope.selectedStream = $workflowService.selectedStream();
                    $scope.planValidationDetails = {};
                    $scope.isSmartBot = function(){
                        if(_selectedStream.type === "solution"){
                            return true;
                        }else{
                            return false;
                        }
                    };
                    $scope.isSampleBot = function(){
                        if(_selectedStream.type === "sample"){
                            return true;
                        }else{
                            return false;
                        }
                    };
                    if(_selectedStream.type == "universalbot"){
                        $scope.linkedBots = [{task:i18n.i18nString('linked_bots'),value:"linkedBots",selected:true},
                            {task:i18n.i18nString('small_talk'),value:"smallTalk",selected:true}
                        ];
                        $scope.settings = [{task:i18n.i18nString('bot_settings'),value:"botSettings",selected:true},
                            {task:i18n.i18nString('bot_variables'),value:"botVariables",selected:true},
                            {task:i18n.i18nString('ivr_properties_normal'),value:"ivrSettings",selected:true}
                        ];
                        $scope.nlp = _selectedStream['universalBotVersion'] === 2?[{task:i18n.i18nString('training_data'),value:"training_data",selected:true},
                            {task:i18n.i18nString('ddval_synonyms'),value:"bot_synonyms",selected:true},
                            {task:i18n.i18nString('settings'),value:"nlpSettings",selected:true},
                            {task:i18n.i18nString('default_dialog'),value:"defaultDialog",selected:true},
                            {task:i18n.i18nString('ddval_standard'),value:"standardResponses",selected:true}
                        ]:[{task:i18n.i18nString('nlp_settings'),value:"nlpSettings",selected:true},
                            {task:i18n.i18nString('default_dialog'),value:"defaultDialog",selected:true},
                            {task:i18n.i18nString('ddval_standard'),value:"standardResponses",selected:true}
                            ];

                        $scope.categories = [ {key:"Bot Components",list:$scope.linkedBots,selected:true,value:i18n.i18nString('task_name')},
                            {key:"NLP Data",list:$scope.nlp,selected:true,value:i18n.i18nString('nlp_data')},
                            {key:"Settings",list:$scope.settings,selected:true,value:i18n.i18nString('settings')},
                            {key:"Custom Dashboards",selected:true,value:i18n.i18nString('custonDashboards')}
                        ];
                    }else{
                        $scope.tasks = [{task:i18n.i18nString('tasks_only'),value:"botTask",selected:true},
                            {task:i18n.i18nString('knowledge_graph'),value:"knowledgeGraph",selected:true},
                            {task:i18n.i18nString('small_talk'),value:"smallTalk",selected:true},
                        ];
                        // if(!$scope.isSmartBot() && !$scope.isSampleBot()) {
                            $scope.tasks.push({task:i18n.i18nString('uiforms'),value:"forms",selected:true});
                        // }
                        $scope.settings = [{task:i18n.i18nString('bot_settings'),value:"botSettings",selected:true},
                            {task:i18n.i18nString('bot_variables'),value:"botVariables",selected:true},
                            {task:i18n.i18nString('ivr_properties_normal'),value:"ivrSettings",selected:true}
                        ];
                        $scope.nlp = [{task:i18n.i18nString('nlp_settings'),value:"nlpSettings",selected:true,displayValue:i18n.i18nString('nlp_settings')},
                            {task:i18n.i18nString('Utterances'),value:"utterances",selected:true,displayValue:i18n.i18nString('Utterances')},
                            {task:i18n.i18nString('Patterns'),value:"patterns",selected:true,displayValue:"NLP Patterns"},
                            {task:i18n.i18nString('ddval_standard'),value:"standardResponses",selected:true,displayValue:i18n.i18nString('ddval_standard')}
                        ];
                        $scope.categories = [ {key:"Bot Tasks",list:$scope.tasks,selected:true,value:i18n.i18nString('task_name')},
                            {key:"NLP Data",list:$scope.nlp,selected:true,value:i18n.i18nString('nlp_data')},
                            {key:"Settings",list:$scope.settings,selected:true, value:i18n.i18nString('settings')},
                            {key:"Custom Dashboards",selected:true,value:i18n.i18nString('custonDashboards')}
                        ];
                    }
                    $scope.componentDisplayNames = {};
                    if($scope.linkedBots && $scope.linkedBots.length){
                        $scope.linkedBots.forEach(function(value,key){
                             $scope.componentDisplayNames[value.value]= value.task;
                        });
                    }
                    if($scope.tasks && $scope.tasks.length){
                        $scope.tasks.forEach(function(value,key){
                            $scope.componentDisplayNames[value.value]= value.task;
                        });
                    }
                    if($scope.settings && $scope.settings.length){
                        $scope.settings.forEach(function(value,key){
                            $scope.componentDisplayNames[value.value]= value.task;
                        });

                    }
                    if($scope.nlp && $scope.nlp.length){
                        $scope.nlp.forEach(function(value,key){
                            $scope.componentDisplayNames[value.value]= value.displayValue;
                        });
                    }
                    if($scope.categories && $scope.categories.length){
                        $scope.categories.forEach(function(value,key){
                            $scope.componentDisplayNames[value.value]= value.key;
                        });
                    }
                   
                   
                    
                    $scope.utterances = {};
                    $scope.utterances.option = "append";
                    $scope.utterances.value = "Append";
                    $scope.patterns = {};
                    $scope.patterns.option = "append";
                    $scope.patterns.value = "Append";
                    function startImportProgress() {
                        progressInterval = setInterval(function () {
                            if ($scope.totalProgress > 90) {
                                $scope.totalProgress = 90;
                            }
                            $scope.totalProgress += 0.1;
                        }, 350);
                    }

                    function startPublishProgress(){
                        progressIntervalPublish = setInterval(function(){
                             if($scope.totalProgressPublish > 90){
                                $scope.totalProgressPublish = 90;
                            }
                            $scope.totalProgressPublish += 0.1;
                        },350);
                    }

                    $scope.readBotFile = function () {
                        $scope.importedBotName = $scope.importBot.name;
                        if ($scope.importedBotName) {
                            var _ext = $scope.importedBotName.substring($scope.importedBotName.lastIndexOf('.'));
                            if (_ext !== '.json') {
                                NotificationService.notify(i18n.i18nString('upload_json'), "error");
                                $scope.fileExtensionError = true;
                                return;
                            } else {
                                $scope.fileExtensionError = false;
                            }
                        }

                        var reader = new FileReader();
                        reader.readAsText($scope.importBot);

                        reader.onload = function (e) {
                            var data = reader.result;
                            $scope.importedBotData = data;
                            $scope.$apply();
                        };
                        angular.element("#importFile").val("");
                    };

                    $scope.showMoreStatusResults = function(logs) {
                       $scope.statusLogsLimit = logs.length + 10;
                    };
                    $scope.readBotVariablesFile = function () {
                        $scope.importedBotVariableName = $scope.importVariables.name;
                        if ($scope.importedBotVariableName) {
                            var _ext = $scope.importedBotVariableName.substring($scope.importedBotVariableName.lastIndexOf('.'));
                            if (_ext !== '.json') {
                                NotificationService.notify(i18n.i18nString('upload_json'), "error");
                                $scope.fileExtensionVariablesError = true;
                                return;
                            } else {
                                $scope.fileExtensionVariablesError = false;
                            }
                        }

                        var reader = new FileReader();
                        reader.readAsText($scope.importVariables);

                        reader.onload = function (e) {
                            var data = reader.result;
                            $scope.importedVariablesData = data;
                            $scope.$apply();
                        };
                        angular.element("#importVariableFile").val("");
                    };
                    $scope.startNewBotImporting = function() {
                        // calling api to import
                        if(isJson($scope.importedBotData)) {
                            $scope.importedBotData = JSON.parse($scope.importedBotData);
                        }
                        if(isJson($scope.importedVariablesData)) {
                            $scope.importedVariablesData = JSON.parse($scope.importedVariablesData);
                        }
                        // overiding bot name , color and purpose
                        $scope.importedVariablesData.name = $scope.$parent.streamObject.name.trim().replace(/\s\s+/g, ' ');
                        $scope.importedVariablesData.color = $scope.$parent.streamObject.color;
                        if($scope.$parent.streamObject.purpose) {
                            $scope.importedVariablesData.purpose = $scope.$parent.streamObject.purpose;
                        }
                        $scope.importedVariablesData.icon = $scope.$parent.streamObject.icon.fileId || $scope.newStreamData.icon.fileId;
                        // var payload = {"botDefinition":$scope.importedBotData,"configInfo":$scope.importedVariablesData,"botFunctions":[{"fileId":$scope.botFunctionFileId,"fileName":$scope.botFunctionFileName}]};
                        var payload = {
                            "botDefinition" : $scope.importedBotData.fileId,
                            "configInfo" : $scope.importedVariablesData.fileId,
                            "botFunctions":[],
                            "icon":$scope.importedVariablesData.icon,
                            "name": $scope.importedVariablesData.name,
                            "purpose": $scope.importedVariablesData.purpose
                          };
                          if($scope.botFunctionFileId) {
                            payload.botFunctions.push($scope.botFunctionFileId);
                          }
                        
                        BTFlowtaskService.importNewBot($applicationService.userInfo().userId, payload).then(function (res) {
                            if (res && res.data) {
                                $scope.streamRefId = res.data._id || "";
                                $scope.statusLogs = res.data.statusLogs || [];
                                if(res.data.status === 'pending') {
                                    $scope._importStatusInit = startPollImportStatus(3000);
                                }
                                else if(res.data.status === 'success') {
                                   stopImportBotPolling('success');
                                   
                                }
                                else {
                                    stopImportBotPolling('failed');
                                }
                            }
                        }, function (error) {
                            $scope.importing = "failed";
                            if (error && error.data && error.data.errors) {
                                $scope.importErrors = error.data.errors;
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                $scope.importErrors = error.errors;
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('save_script_error'), 'error');
                            }
                        }); 
                    };
                    $scope.callback.importNewBot = function() {
                        var _botInfo = {
                            streamId:$workflowService.selectedStream()._id,
                            BotName:$workflowService.selectedStream().name,
                         };
                        //  mixPanel.postEvent('Import Bot',_botInfo);
                        $('#arabicInput').val($('#arabicInput').val().trim().replace(/\s\s+/g, ' '));
                       if (!$scope.importedBotData) {
                            NotificationService.notify(i18n.i18nString('bt_import_config_required'), "error");
                            return;
                        }
                        if (!$scope.importedVariablesData) {
                            NotificationService.notify(i18n.i18nString('bt_import_variable_file_required'), "error");
                            return;
                        }
                        if($scope.fileExtensionVariablesError) {
                            NotificationService.notify(i18n.i18nString('only_json_file'), "error");
                            return;
                        }
                        if (!$scope.$parent.streamObject.icon) {
                            $scope.iconRequiredError = true;
                            NotificationService.notify(i18n.i18nString('please_upload_botICon'), "error");
                            return;
                        }
                        $scope.importErrors = [];
                        $scope.importing = "inprogress";
                        $scope.showImportModal('no_publish');
                        startImportProgress();
                        $scope.uploadStreamIcon();
                    };
                    
                    $scope.callback.isFormValid = function() {
                        if($scope.importFrom !== 'existingBotImport' && (!$scope.$parent.streamObject.name || $scope.$parent.streamObject.name === "")){
                            return false;
                        }
                        if (!$scope.importedBotData) {
                            return false;
                        }
                        if (!$scope.importedVariablesData) {
                            return false;
                        }
                        if($scope.fileExtensionVariablesError) {
                            return false;
                        }
                        if ($scope.importFrom !== 'existingBotImport' && !$scope.$parent.streamObject.icon) {
                            return false;
                        }
                        return true;
                    };

                    var checkForChannels = function(){
                         var _channels=[];
                        _channels = _.filter(_selectedStream.channels, function(channelObject){
                            return channelObject.enable;
                        });
                        
                        
                        if (!(_.isArray(_channels) && _channels.length > 0) || ($scope.publishPermission === 'NO')) {
                              $scope.disableAutoPublish = true;
                              $scope.publish.autoPublish = false;   
                        }else{
                             $scope.disableAutoPublish = false;
                             $scope.publish.autoPublish = true;
                        }
                        return _channels;
                    };


                    $scope.showBackup = function() {
                        var _botInfo = {
                            streamId:$workflowService.selectedStream()._id,
                            BotName:$workflowService.selectedStream().name,
                         };
                        //  mixPanel.postEvent('Import Bot',_botInfo);
                        $scope.importing = "backupNote";
                        $scope.enabledChannels = checkForChannels();
                        $scope.showImportModal();
                        
                    };
                    $scope.readMore = function(event) {
                         if(event){
                            var e = event.currentTarget;
                            $(e).toggleClass('less');
                             if($(e).hasClass('less')){
                                $(e)[0].innerText = 'Read less';
                             }else{
                                $(e)[0].innerText = 'Read more';
                             } 
                         }else{
                            $scope.importing = "backupNote1";
                            if(!$scope.initializeScrollBar){
                              setTimeout(function(){
                                    $('.psScrollZindex').scrollTop(2);
                                },100); 
                                $scope.initializeScrollBar = true; 
                            }
                         }
                         
                                                 
                       
                    };
                    var saveByteArray = (function () {
                        var a = document.createElement("a");
                        document.body.appendChild(a);
                        a.style = "display: none";
                        return function (data, name) {
                            var blob = new Blob(data, {type: "octet/stream"}),
                                    url = window.URL.createObjectURL(blob);
                            a.href = url;
                            a.download = name;
                            a.click();
                            window.URL.revokeObjectURL(url);
                        };
                    }());
                    function writeAndDownloadDialog(fileName, data) {
                       saveByteArray([data], fileName);
                    }
                    $scope.startExport=function(){

                        function startExport(){
                          
                        $scope.disableProceed = true;
                        var payload = {"exportType":'latest',"exportOptions":{},'allTasks': true,'IncludeDependentTasks': true,'subTasks': {dialogs: [], alerts: [], actions: []}};
                        var taskResult,nlpdata,showFailedErrors;
                        payload.exportOptions.nlpData=[];
                        payload.exportOptions.settings=[];
                        if(_selectedStream.type == "universalbot"){
                            payload.exportOptions.botComponents=[];
                            taskResult = $scope.categories[0].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.exportOptions.botComponents.push(key.value);
                                }
                            });
                            nlpdata = $scope.categories[1].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.exportOptions.nlpData.push(key.value);
                                }
                            });
                            showFailedErrors = $scope.categories[2].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.exportOptions.settings.push(key.value);
                                }
                            });
                            if($scope.categories[3].key === "Custom Dashboards" && $scope.categories[3].selected){
                                payload.customDashboard = true;
                            }else{
                                payload.customDashboard = false;
                            }
                        }else{  
                            payload.exportOptions.tasks=[];
                            taskResult = $scope.categories[0].list.forEach(function(key,value){
                                payload.exportOptions.tasks.push(key.value);
                            });
                            nlpdata = $scope.categories[1].list.forEach(function(key,value){
                                payload.exportOptions.nlpData.push(key.value); 
                            });
                            showFailedErrors = $scope.categories[2].list.forEach(function(key,value){
                                payload.exportOptions.settings.push(key.value);
                            });
                            if($scope.categories[3].key === "Custom Dashboards" && $scope.categories[3].selected){
                                payload.customDashboard = true;
                            }else{
                                payload.customDashboard = false;
                            }
                        }
                        BTFlowtaskService.exportBot(_selectedStream._id,payload).then(function (res) {
                            if(res && res.data) {
                                if (res.data.status === 'pending') {
                                         $scope.exporting = res.data.status;
                                         $scope._exportStatusInit = startPollExportStatus(3000);
                                 } else if (res.data.status === 'success') {
                                            stopExportBotPolling('success');
                                  } else {
                                     stopExportBotPolling('failed');
                                  }
                                /*$scope.disableProceed = true;
                                writeAndDownloadDialog(_selectedStream.name+".zip", res.data);
                                $scope.startImport();*/
                            }
                        }, function (error) {
                            $scope.disableProceed = false;
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if(error.errors && _.isArray(error)){
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg,'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('save_script_error'), 'error');
                            }
                        });  
                        }
                     function cancleExport(){
                         return;
                     }
                     function checkBoxCb(checkValue){
                       console.log(checkValue);
                       $scope._constants_.updateDownloadPopUppreferance(checkValue);
                     }
                     if($scope._constants_.config.showDownloadPopUps){
                      NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{"enable":true,"checkBoxCb":checkBoxCb}}, "", undefined,i18n.i18nString('export_bot'));  
                     }else{
                         startExport();
                     }

                     
                    };
                    function startPollExportStatus(timeout) {
                    return setInterval(function() {
                        BTFlowtaskService.exportStatusBot(_selectedStream._id)
                     .then(function(res) {
                             if (res && res.data) {
                                  if (res.data.status === 'success' && res.data.fileId) {
                                     var fileIdDownload = res.data.fileId;
                                     var storeUrl=res.data.store.urlParams;
                                     BTStreamsService.downloadProgressDockExportFile(fileIdDownload).then(function(res){
                                        if(res && res.data){
                                            $scope.hrefURL = res.data.fileUrl + storeUrl;
                                            var xyz = "#backupButton";
                                            $(xyz).attr('href', $scope.hrefURL);
                                            $timeout(function() {
                                                $(xyz).get(0).click(function(e){
                                                    e.stopPropagation();
                                                });
                                            },450);
                                        }
                                    }, function(err) {
                                        if(err && err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) {
                                            NotificationService.notify(err.data.errors[0].msg, 'error');
                                        }                        
                                    });
                                    /* $timeout(function(){
                                         $element.find('#backupButton')[0].click();
                                     },500);*/
                                     stopExportBotPolling('success');
                                 } else if (res.data.status === 'failed') {
                                     stopExportBotPolling('failed');
                                 }
                             }
                         },
                         function(err) {
                             stopExportBotPolling('failed');
                             var _msg = i18n.i18nString('error_on_fetching_bot_export_status');
                             if (err.data && err.data.errors && err.data.errors.length > 0) {
                                 _msg = err.data.errors[0].msg;
                             }
                             NotificationService.notify(_msg, "error");
                         });
             }, timeout);
            
         }
                    function stopExportBotPolling(_status){
                        if($scope._exportStatusInit) {
                                clearTimeout($scope._exportStatusInit);
                                $scope._exportStatusInit = null;
                            }
                            if(_status === 'success') {
                                // $timeout(function(){
                                //     $element.find('#backupButton')[0].click();
                                // },500);
                                finishedExport();
                            }
                            else{
                                $scope.exporting = "failed";
                            }
                    }
                    function finishedExport() {
                        clearInterval($scope._exportStatusInit);
                        $timeout(function(){
                             $scope.exporting = "finished";
                             $scope.disableProceed = false;
                        },3000);
                        
                    }
                    $scope.getLicenseInfo = function() {
                        $scope.license = {};
                        $scope.supportPlan = {};
                        $scope.selectedStream = $workflowService.selectedStream();
                        $scope.appControls = $applicationService.userInfo().appControls;
                        if($scope.selectedStream) {
                            if($scope.selectedStream.license) {
                                $scope.license = $scope.selectedStream.license;
                                $scope.license.totalCredits = (($scope.license.baseAllowedCredits + $scope.license.extraCredits) - $scope.license.creditsUsed);
                                $scope.license.totalSessions = (($scope.license.baseAllowedSessions + $scope.license.extraSessions) - $scope.license.sessionsUsed);
                                $scope.license.totalRequests = ($scope.license.baseAllowedRequests - $scope.license.requestsUsed);
                            }
                            if($scope.selectedStream.planValidationDetails) {
                                $scope.planValidationDetails = $scope.selectedStream.planValidationDetails;
                            }
                            // $scope.planSelectionCb = {};
                        }
                    };
                    function getBTStreamsAndUpdate() {
                        var streamId = (_selectedStream && _selectedStream._id)?_selectedStream._id:'';
                        if(($scope.importFrom !== 'existingBotImport') && $scope.newBotStreamId) { // for new bot import , stream id will be new
                            streamId = $scope.newBotStreamId;
                        }
                        if(!streamId){
                            return;
                        }
                        BTStreamsService.getBTStream(streamId).then(function (res) {
                            $workflowService.selectedStream(res.data);
                            _selectedStream = res.data;
                            $scope.selectedStream = res.data;
                            $scope.getLicenseInfo();
                        }, function (err) {
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }
                    $scope.openCustomModal = function(targetId) {
                        if(targetId) {
                            $("#" + targetId).modal("show");
                        }
                    };
                    $scope.closeCustomModal = function(targetId) {
                        if(targetId) {
                            $("#" + targetId).modal("hide");
                        }
                    };

                    $scope.startImport = function (publish) {
                        if (!$scope.importedBotData) {
                            NotificationService.notify(i18n.i18nString('bt_import_config_required'), "error");
                            return;
                        }
                        if (!$scope.importedVariablesData) {
                            NotificationService.notify(i18n.i18nString('bt_import_variable_file_required'), "error");
                            return;
                        }
                        if($scope.fileExtensionVariablesError) {
                            NotificationService.notify(i18n.i18nString('only_json_file'), "error");
                            return;
                        }
                        if (!$scope.newStreamData.icon) {
                            $scope.iconRequiredError = true;
                            NotificationService.notify(i18n.i18nString('please_upload_botICon'), "error");
                            return;
                        }

                        if(publish && publish.autoPublish && !publish.comments){
                            NotificationService.notify(i18n.i18nString('publish_comments'),"warning");
                            return;
                        }

                        
                        
                        $scope.importErrors = [];
                        $scope.importing = "inprogress";
                        $scope.publishOptions = publish;
                        //$scope.showImportModal();
                        $('.psScrollZindex').animate({scrollTop:2});
                        startImportProgress();
                        
                        // calling api to import
                        if(isJson($scope.importedBotData)) {
                            $scope.importedBotData = JSON.parse($scope.importedBotData);
                        }
                        if(isJson($scope.importedVariablesData)) {
                            $scope.importedVariablesData = JSON.parse($scope.importedVariablesData);
                        }
                        $scope.importedVariablesData.icon = $scope.newStreamData.icon.fileId;

                        
                        var payload = {"importOptions":{},"botDefinition":$scope.importedBotData.fileId,"configInfo":$scope.importedVariablesData.fileId,"botFunctions":[]};
                        if($scope.botFunctionFileId){
                            payload.botFunctions.push($scope.botFunctionFileId);
                        }
                        if(publish && publish.autoPublish){
                            payload['autoPublish'] = {"versionComment":publish.comments};
                        }
                        payload.importOptions.nlpData=[];
                        payload.importOptions.settings=[];
                        payload.importOptions.options={};
                        payload.importOptions.storyBoardScenes =  {
                            "includeComments":  $scope.dialogProperties.includeComments
                        };
                        var taskResult,nlpdata,showFailedErrors;
                        if(_selectedStream.type == "universalbot"){
                            payload.importOptions.botComponents=[];
                            taskResult = $scope.categories[0].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.importOptions.botComponents.push(key.value);
                                }
                            });
                            nlpdata = $scope.categories[1].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.importOptions.nlpData.push(key.value);
                                    if(key.value === 'patterns'){
                                        payload.importOptions.options.patterns = $scope.savePatternOptions();
                                    }
                                    if(key.value === 'utterances'){
                                        payload.importOptions.options.utterances = $scope.saveUtteranceOptions();
                                    }

                                 }
                                });

                            showFailedErrors = $scope.categories[2].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.importOptions.settings.push(key.value);
                                }
                            });
                            if($scope.categories[3].key === "Custom Dashboards" && $scope.categories[3].selected){
                                payload.importOptions.customDashboard = true;
                            }else{
                                payload.importOptions.customDashboard = false;
                            }
                        }else{  
                            payload.importOptions.tasks=[];
                            taskResult = $scope.categories[0].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.importOptions.tasks.push(key.value);
                                }
                            });
                            nlpdata = $scope.categories[1].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.importOptions.nlpData.push(key.value);
                                    if(key.value === 'patterns'){
                                        payload.importOptions.options.patterns = $scope.savePatternOptions();
                                    }
                                    if(key.value === 'utterances'){
                                        payload.importOptions.options.utterances = $scope.saveUtteranceOptions();
                                    }

                                     }
                            });
                            showFailedErrors = $scope.categories[2].list.forEach(function(key,value){
                                if(key.selected === true){
                                    payload.importOptions.settings.push(key.value);
                                }
                            });
                            if($scope.categories[3].key === "Custom Dashboards" && $scope.categories[3].selected){
                                payload.importOptions.customDashboard = true;
                            }else{
                                payload.importOptions.customDashboard = false;
                            }
                        }
                        BTFlowtaskService.importExistingBot($applicationService.userInfo().userId, _selectedStream._id, payload,$scope.bot).then(function (res) {
                            if (res && res.data) {
                                $scope.streamRefId = res.data._id || "";
                                $scope.statusLogs = res.data.statusLogs || [];
                                if(res.data.status === 'pending') {
                                    $scope._importStatusInit = startPollImportStatus(3000);
                                }
                                else if(res.data.status === 'success') {
                                    if($scope.publishOptions.autoPublish){
                                        finishedImport();
                                    }else{
                                       stopImportBotPolling('success'); 
                                    }
                                    
                                }
                                else {
                                    stopImportBotPolling('failed');
                                }
                                //$rootScope.$emit('getProgressDockStatus');
                            }
                        }, function (error) {
                            $scope.importing = "failed";
                            if(error && error.data && error.data.errors && error.data.errors.length && error.data.errors[0] && error.data.errors[0].code && error.data.errors[0].code === "ImportWarning"){
                                $scope.importErrors = error.data.errors;
                                $scope.showImportModal();
                            }else if (error && error.data && error.data.errors && error.data.errors.length && error.data.errors[0] && error.data.errors[0].code && error.data.errors[0].code !== "ImportWarning") {
                                $scope.importErrors = error.data.errors;
                                var importErrorsMsg = $scope.importErrors[0].msg.split("\n");
                                var importErrorsArray = [];
                                _.forEach(importErrorsMsg,function(msg){
                                    if (msg === "NLP Patterns"){
                                        msg = 'patterns';
                                    }
                                    if ($scope.componentDisplayNames[msg]){
                                        importErrorsArray.push($scope.componentDisplayNames[msg]);
                                    }
                                 });
                                //  $scope.importErrors[0].msg = $scope.importErrors[0].msg.split('\n')[0] + importErrorsArray;
                                $scope.importErrors[0].msg = $scope.importErrors[0].msg.split('\n')[0];
                                 $scope.importErrors[0].errors = importErrorsArray;
                                // var _msg = error.data.errors[0].msg;
                                // NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                $scope.importErrors = error.errors;
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('save_script_error'), 'error');
                            }
                        });
                    };

                    function publishLogs(res){
                        $scope.messages = [];
                        $scope.allowRetry=true;
                        if(res.length){
                                    var _msg;
                                    res.map(function (message) {
                                    if (message.result && message.result.name) {
                                        _msg = message.result.name || message.result.resourceId;
                                     }else if(message.result && message.result.hasOwnProperty('length')){
                                        _msg = message.result[0].name || message[0].result[0].resourceId;
                                     }else if(message.result && message.resourceType === 'smalltalk' && !message.result.name){
                                        _msg = 'Small Talk';
                                     }
                                    if (message.status === 'SUCCESS') {
                                         $scope.messages.push({
                                            type: 'success',
                                            state: "published" || message.result.state,
                                            message: _msg 
                                        });
                                    } else if (message.status === 'FAILURE') {
                                         $scope.messages.push({
                                            type: 'error',
                                            error: getErrorMsg(message.result),
                                            message: _msg,
                                            //context: getResource(payload, message.resourceId),
                                            taskId: message.resourceId
                                        });
                                    }
                                });   
                                    $scope.publishStatus = 'success';
                                    if ($scope.appControls.isBillingEnabled && _selectedStream.type !=='sample' && _selectedStream.type !=='solution' && _selectedStream.type !== 'universalbot' && _selectedStream.visibility.namespace === 'private' && $scope.appControls && $scope.selectedAccount.adminPreferences && $scope.selectedAccount.adminPreferences.autoApproval && $scope.selectedAccount.accountType && $scope.selectedAccount.accountType===1) {                                    
                                        $scope.publishInTrailMsg = true;
                                    } else {
                                        $scope.publishInTrailMsg = false;
                                    }
                                }
                    }

                    function startPollPublishStatus(timeout){
                        return setInterval(function(){
                            BTFlowtaskService.botImportStatus($applicationService.userInfo().userId, $scope.streamRefId)
                                .then(function (res) {
                                        if(res.data.status === 'publish_success'){
                                            pubStatus = 'success';
                                            stopPublish(pubStatus);
                                            if(res.data && res.data.autoPublish){
                                                publishLogs(res.data.autoPublish.response);
                                            }
                                        }else if(res.data.status === 'publish_failed'){
                                            pubStatus = "failed";
                                            stopPublish(pubStatus);
                                            if(res.data.autoPublish && res.data.autoPublish.response.errors && res.data.autoPublish.response.errors.length){
                                                $scope.errorMess = res.data.autoPublish.response.errors[0].msg;
                                                NotificationService.notify($scope.errorMess,'error');  
                                            }
                                        }
                                },function(err){
                                    $scope.allowRetry = true;
                                    if(err && err.data && err.data.errors){
                                        NotificationService.notify(err.data.errors[0].msg,'error');
                                    }else{
                                         NotificationService.notify(i18n.i18nString( 'something_went_wrong'),'error');
                                    }
                                });
                        },timeout);
                    }

                    function getErrorMsg(message) {
                        var msg = (message && message.errors && message.errors[0].msg) ||  i18n.i18nString( 'something_went_wrong');
                        return msg;
                    } 

                    function getResource(publishInfo, id) {

                        var payload = {};

                        var resource = publishInfo.resources.filter(function (resource) {
                            return resource.resourceId === id;
                        });

                        if ($scope.stream.publishType == "smartbot") {

                            payload = {
                                botDesc: publishInfo.botDesc,
                                configInst: publishInfo.configInst,
                                configInstURL: publishInfo.configInstURL
                            };

                        }

                        payload.resources = resource;

                        return payload;

                    }
                    $scope.openPlanUsage = function(planType){
                        $("#upDownRequired").modal('hide');
                        if(planType === 'plan') {
                            $scope.planSelectionCb.page = "publish";
                            $scope.planSelectionCb.planSelection = true;
                            $scope.planSelectionCb.supportSelection = false;
                        }
                        $scope.planSelectionCb.license = $scope.license;
                        $scope.planSelectionCb.plansSlider = true;
                    };
                    $scope.submitToAdminPublish = function(){
                        $scope.planSelectionCb.publishSubmitToAdmin = true;
                        $scope.publishBot($scope.publish, true);
                    };
                    $scope.doubleClick = false;
                    $scope.planSelectionCb.confirmPublish = function() {
                        if($scope.doubleClick){
                            return;
                        }
                        $scope.doubleClick = true;
                        $timeout(function () {
                            $scope.doubleClick = false;
                        }, 1000);
                        $scope.publishBot($scope.publish, true);
                    };

                    $scope.planSelectionCb.openImportModal = function() {
                        $('.import-bot-modal-publish').show();
                    };

                    $scope.allowRetry = true;
                    $scope.publishBot = function(publish,retry){
                        var payload = {};
                        $scope.allowRetry = false;

                        if(retry){
                            setTimeout(function(){
                               $('.import-bot-modal-publish .modal-body').animate({scrollTop:0});
                            },100);
                        }
                        if(publish && publish.comments){
                            if($scope.selectedStream && $scope.license && !$scope.license.planName && $scope.selectedStream.visibility.namespace === 'private' && $scope.planSelectionCb && (!$scope.planSelectionCb.publishFreeBot && !$scope.planSelectionCb.publishSubmitToAdmin && !$scope.planSelectionCb.publishPaidBot)) {
                                $('.import-bot-modal-publish').hide();
                                $scope.openPlanUsage('plan');
                                return;
                            }
                            if($scope.planValidationDetails && $scope.planValidationDetails.exceededData && $scope.license && $scope.license.planName && $scope.planValidationDetails.exceededData[$scope.license.planId] && (!$scope.planSelectionCb.publishFreeBot && !$scope.planSelectionCb.publishSubmitToAdmin && !$scope.planSelectionCb.publishPaidBot)) {
                                setTimeout(function(){
                                    $("#upDownRequired").modal('show');
                                }, 0);
                                return;
                            }
                            payload['versionComment'] = publish.comments;
                            BTStreamsService.publishImportBot(_selectedStream._id,payload).then(function(res){
                                publishLogs(res.data);
                            },function(err){
                                $scope.allowRetry = true;
                                if(err && err.data && err.data.errors){
                                    NotificationService.notify(err.data.errors[0].msg,'error');
                                }else{
                                    NotificationService.notify(i18n.i18nString( 'something_went_wrong'),'error');
                                }
                                
                            });
                        }else{
                            NotificationService.notify(i18n.i18nString('publish_comments'),"warning");
                            return;
                        }
                        
                    };

                    $scope.allowRetry=true;
                    $scope.retry = function (payload) {
                       $scope.allowRetry=false;
                       payload.versionComment  = $scope.publish && $scope.publish.versionComments?$scope.publish.versionComments : '';
                        var service = $scope.stream.publishType == "smartbot" ? BTStreamsService.solutionPublish : BTStreamsService.standardPublish;
                         if(_selectedStream.publishType !== "smartbot" && _selectedStream.publishType !== 'samplebot'){
                                    payload.publishAllComponents = false; 
                                    payload.versionComment  = payload.versionComment;
                            }
                        service(_selectedStream._id, payload)
                            .then(function (res) {
                                 publishLogs(res.data);
                            }, function (err) {
                                $scope.allowRetry=true;
                                var msg = err.data.errors[0].msg ||  i18n.i18nString( 'something_went_wrong_try_again');
                                NotificationService.notify(msg, 'error');
                            });
                    };

                    $scope.toggleCommentValue = function(publish){
                        if(!publish.autoPublish){
                            publish.comments = '';
                        }
                    };
                    
                    function startPollImportStatus(timeout) {
                        return setInterval(function () {
                            BTFlowtaskService.botImportStatus($applicationService.userInfo().userId, $scope.streamRefId)
                                .then(function (res) {
                                    if (res && res.data) {
                                        if(res.data.streamId) {
                                            $scope.newBotStreamId = res.data.streamId;
                                            $workflowService.importedNewBotId(res.data.streamId);
                                        }
                                        $scope.statusLogs = res.data.statusLogs || [];
                                        $scope._failedStatus = _.filter($scope.statusLogs,{'status':'failed'});
                                        var pubStatus = '';
                                        if(!$scope.initializeScrollBar) {
                                            setTimeout(function(){
                                                $('.import-bot-modal-body').scrollTop(2);
                                            },100);
                                            $scope.initializeScrollBar = true;
                                        }
                                        if(res.data.status === 'success') {
                                           if($scope.publishOptions && $scope.publishOptions.autoPublish && !$scope._failedStatus.length){
                                                pubStatus = 'initial';
                                                finishedImport(pubStatus);
                                           }else if($scope._failedStatus.length && $scope.publishOptions && $scope.publishOptions.autoPublish){
                                                stopImportBotPolling("success");
                                           }
                                           else if($scope.publishOptions && $scope.publishOptions.hasOwnProperty('autoPublish')){
                                                if($scope._importStatusInit) {
                                                    clearTimeout($scope._importStatusInit);
                                                    $scope._importStatusInit = null;
                                                }  
                                                pubStatus = 'initial';
                                                finishedImport(pubStatus);  
                                           }
                                           else{
                                                stopImportBotPolling('success');
                                           }  
                                        }
                                        else if(res.data.status === 'publish_pending'){
                                            setTimeout(function(){
                                                $scope.importing = 'finished';
                                            },200);
                                            setTimeout(function(){
                                                $scope.importing = '';
                                                $scope.publishStatus = 'pending';
                                                
                                            },1000);
                                            stopPublish();
                                            startPublishProgress();
                                            $scope._publishStatusInit = startPollPublishStatus(3000);

                                        }
                                        else if(res.data.status === 'publish_success'){
                                            pubStatus = 'success';
                                            finishedImport();
                                            setTimeout(function(){
                                                $scope.importing = '';                                                
                                            },200);
                                            stopPublish(pubStatus);
                                            if(res.data && res.data.autoPublish){
                                                publishLogs(res.data.autoPublish.response);
                                            }
                                        }else if(res.data.status === 'publish_failed'){
                                            pubStatus = "failed";
                                            finishedImport();
                                            setTimeout(function(){
                                                $scope.importing = '';                                                
                                            },200);
                                            stopPublish(pubStatus);
                                            if(res.data.autoPublish && res.data.autoPublish.response.errors && res.data.autoPublish.response.errors.length){
                                                $scope.errorMess = res.data.autoPublish.response.errors[0].msg;
                                                NotificationService.notify($scope.errorMess,'error');  
                                            }
                                        }
                                        else if(res.data.status === 'failed') {
                                            $scope.showFailedErrors = false;
                                            stopImportBotPolling('failed');
                                        }
                                    }
                                },
                                function (err) {
                                    stopImportBotPolling();
                                    var _msg = i18n.i18nString('bot_import_error');
                                    if (err.data && err.data.errors && err.data.errors.length > 0) {
                                        _msg = err.data.errors[0].msg;
                                    }
                                    NotificationService.notify(_msg, "error");
                                });
                        }, timeout);
                    }
                    
                    function stopImportBotPolling(_status) {
                        if($scope._importStatusInit) {
                            clearTimeout($scope._importStatusInit);
                            $scope._importStatusInit = null;
                        }
                        if(_status === 'success') {
                            finishedImport();
                            
                        }
                        else{
                            $scope.importing = "failed";
                        }
                    }
                    function stopPublish(_status){
                        if($scope._importStatusInit){
                            clearTimeout($scope._importStatusInit);
                        }
                        if($scope._publishStatusInit){
                            clearTimeout($scope._publishStatusInit);
                        }
                        if(_status === 'success'){
                            finishedPublish(_status);
                        }else if(_status === 'failed'){
                            $scope.publishStatus = 'failed';
                            clearInterval(progressIntervalPublish);
                            progressIntervalPublish = null;
                        }

                    }
                    function importBotCompletion(){

                    }
                    $scope.downloadLog = function() {
                        writeAndDownloadLog("botImportLog.json", JSON.stringify($scope.statusLogs));
                    };
                    function writeAndDownloadLog(filename, data) {
                        if(navigator.msSaveBlob){
                            var blob = new Blob([data],  {type : 'data:text/plain;charset=utf-8'});
                            return window.navigator.msSaveOrOpenBlob(blob, filename);
                        } else {
                            var element = document.createElement('a');
                            element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(data));
                            element.setAttribute('download', filename);

                            element.style.display = 'none';
                            document.body.appendChild(element);
                            
                            element.click();

                            document.body.removeChild(element);
                        }
                    }
                    function finishedImport(pubStatus) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                        $scope.totalProgress = 100;
                        setTimeout(function(){
                            $scope.importing = "finished";
                        },200);
                        if(pubStatus){
                            setTimeout(function(){
                                $scope.importing = '';
                                $scope.publishStatus = pubStatus;
                            },2000);
                        }
                        getBTStreamsAndUpdate();
                        
                    }
                    function finishedPublish(){
                        clearInterval(progressIntervalPublish);
                        progressIntervalPublish = null;
                        $scope.totalProgressPublish = 100;
                        setTimeout(function(){
                            $scope.publishStatus = "success";
                        },200);
                    }
                    var getFileBlob = function (url, cb) {
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", url);
                        xhr.responseType = "blob";
                        xhr.addEventListener('load', function() {
                            cb(xhr.response);
                        });
                        xhr.send();
                    };

                    var blobToFile = function (blob, name) {
                        blob.lastModifiedDate = new Date();
                        blob.name = name;
                        return blob;
                    };

                    var getFileObject = function(filePathOrUrl, cb) {
                       getFileBlob(filePathOrUrl, function (blob) {
                          cb(blobToFile(blob, 'newBot.png'));
                      });
                   };
                    function getStreamIconData() {
                        var url = env_conf['components-source'];
                        getFileObject(url + '/assets/botIcons/new/bot-1.png', function (fileObject) {
                            $scope.newStreamData.iconFile = fileObject;
                            $scope.loadStreamIcon(false);
                        });
                    }
                    getStreamIconData();
                    $scope.loadStreamIcon = function() {
                        if ($scope.newStreamData && $scope.newStreamData.iconFile && $scope.newStreamData.iconFile.name) {
                            var _ext = $scope.newStreamData.iconFile.name.substring($scope.newStreamData.iconFile.name.lastIndexOf('.'));
                            if (_ext !== '.png') {
                                NotificationService.notify(i18n.i18nString('uploadfile_noty_error'), "error");
                                $scope.imageExtensionError = true;
                                return;
                            }
                            else{
                                // $('#iconFile')[0].title = $scope.newStreamData.iconFile.name;
                                $scope.imageExtensionError = false;
                                var reader = new FileReader();
                                reader.onload = function(loadEvent) {
                                  $scope.$apply(function() {
                                    $scope.defaultImg = loadEvent.target.result;
                                  });
                                };
                                reader.readAsDataURL($scope.newStreamData.iconFile);
                            }
                        }
                        else{
                            return;
                        }
                    };
                    $scope.uploadStreamIcon = function() {
                        if ($scope.newStreamData.iconFile.name) {
                            var _ext = $scope.newStreamData.iconFile.name.substring($scope.newStreamData.iconFile.name.lastIndexOf('.'));
                            if (_ext !== '.png') {
                                NotificationService.notify(i18n.i18nString('uploadfile_noty_error'), "error");
                                $scope.imageExtensionError = true;
                                return;
                            }
                        }

                        $scope.imageExtensionError = false;

                        var data = new FormData();
                        data.append('file', $scope.newStreamData.iconFile);
                        data.append('fileContext', 'marketplace');
                        data.append('fileExtension', 'png');

                        $scope.iconUploading = true;

                        BTFileUploadService.uploadFile(data)
                                .then(function(response) {
                                    var fileUploaded = {
                                        fileName: $scope.newStreamData.iconFile.name,
                                        fileId: response.data.fileId
                                    };

                                    $scope.newStreamData.icon = fileUploaded;
                                    $scope.startNewBotImporting();
                                    $scope.iconUploading = false;
                                }, function(error) {
                                    NotificationService.notify(i18n.i18nString('oops_label') + error.data.errors[0].msg, "error");
                                    $scope.iconUploading = false;
                                    $scope.importing = "failed";
                                });
                    };
                    $scope.uploadFile = function (e) {
                        if (!$scope.botFunctions.botFuctionFile) {
                            return;
                        }
                        var _ext = "";
                        if ($scope.botFunctions.botFuctionFile.name) {
                            _ext = $scope.botFunctions.botFuctionFile.name.substring($scope.botFunctions.botFuctionFile.name.lastIndexOf('.'));
                            var supportingFileFormats = [".js"];
                            if ($.inArray(_ext, supportingFileFormats) === -1) {
                                NotificationService.notify(i18n.i18nString('upload_only_js_files'), "error");
                                return;
                            }
                        }
                        var _fileLimit = 500 * 1000;
                        if (e.target.files[0].size > _fileLimit) {
                            NotificationService.notify(i18n.i18nString('file_size_shouldnot_exced_err_noty'), "warning");
                            return;
                        }
                        var data = new FormData();
                        data.append('file', $scope.botFunctions.botFuctionFile);
                        data.append('fileContext', 'bulkImport');
                        data.append('fileExtension', 'txt');//_ext.substring(_ext.lastIndexOf('.') + 1)
                        //data.append('Content-Type', 'application/js');
                        $scope.fileuploading = true;
                        
                        BTStreamsService.uploadBotFunctionsFile($applicationService.userInfo().userId, data)
                            .then(function (response) {
                                var fileUploaded = {
                                    fileName: $scope.botFunctions.botFuctionFile.name,
                                    fileId: response.data.fileId
                                };
                                $scope.botFunctions.botFuctionFile = fileUploaded;
                                $scope.fileuploading = false;
                                $scope.botFunctionFileName = $scope.botFunctions.botFuctionFile.fileName;
                                $scope.botFunctionFileId = response.data.fileId;

                            }, function (err) {
                                //$scope.isGlobalWorkProgress = false;
                                NotificationService.notify(i18n.i18nString('oops_label') + err.data.errors[0].msg, "error");
                                $scope.fileuploading = false;
                            });
                    };
                    $scope.deleteStreamIcon = function() {
                        $scope.newStreamData.iconFile = null;
                        $scope.newStreamData.icon = null;
                        $('#iconFile').val('');
                    };
                    $scope.onCancel = function() {
                        $scope.importedBotName = "";
                        $scope.importedBotData = null;
                        $scope.importedBotVariableName = "";
                        $scope.importedVariablesData = null;
                        if($scope.botFunctions){
                            $scope.botFunctions.botFuctionFile = "";
                            $scope.botFunctions.botFuctionFile = null;
                        }
                        $scope.publish = {};
                        if(!_selectedStream.type || $scope.bot.importType === 'incrementalImport'){
                            $('.import-bot-modal').modal('hide');
                        }else{
                            $('.import-bot-modal-publish').modal('hide');
                        }
                        
                        NotificationService.notify(i18n.i18nString('importWarningToast'),"warning");
                    };
                    $scope.closeImportModal = function () {
                        $scope.importedBotName = "";
                        $scope.importedBotData = null;
                        $scope.importedBotVariableName = "";
                        $scope.importedVariablesData = null;
                        if(!_selectedStream.type){
                            $('.import-bot-modal').modal('hide');
                        }else{
                            $('.import-bot-modal-publish').modal('hide');
                        }
                       
                       
                        var _streamId = $workflowService.selectedStream()._id;
                        if ($workflowService.importedNewBotId().trim() !== "") {
                            _streamId = $workflowService.importedNewBotId().trim();
                            $workflowService.importedNewBotId("");
                        }   
                               
                        BTStreamsService.getBTStream(_streamId).then(function(res){
                             // $route.reload();
                            var allStreams = $workflowService.streamsAll();
                            var _eventToTrigger = 'selectOrChangeBot';//from Bots Listing
                            var _curState = navigator.setORGetPreviousState();
                            var baseComponent = _curState.path[0]; 
                            if(allStreams && allStreams.length) { 
                                $scope.allBots = $workflowService.streamsAll();
                                $.each($scope.allBots,function(i,bot){
                                    if(bot._id === $workflowService.selectedStream()._id ){
                                        bot = $workflowService.selectedStream();
                                    }
                                });
                                $workflowService.streamsAll($scope.allBots);
                            }
                            $workflowService.selectedStream(res.data);
                            $scope.$emit("streamUpdate");
                            $scope.$emit("botImportSuccess");
                            var eventInfoBotsCreate = {
                                "Category":"Activation",
                                "Sub Category":"Activation - VA",
                                "Level":'ONBOARDING AND ACTIVATION',
                                "VA - Inititiation Mode":"Import",
                            };
                             mixPanel.postEvent('VA - New Bot Initiated',eventInfoBotsCreate);
                            if (baseComponent === 'botDetailsForm') {
                                _eventToTrigger = 'selectBot';
                            }
                            if(!(allStreams && allStreams.length)){ //if new account or if no bots botsform will not be available to trigger 'selectOrChangeBot' or 'selectBot'//
                                var stream = res.data;
                                $rootScope.$emit("loadNewStream", stream);
                            }else {
                                $rootScope.$emit(_eventToTrigger,res.data);
                            }
                            
                            if ($scope.importFrom !== 'newBotImport') {
                                $scope.$parent.setCurrentTab('.tasks-pane');
                            } else {
                                $(".fullwidth-dialog").modal("hide");
                                // $scope.$parent.reloadBack();
                            }
                        });

                       
                    };
                    
                    $scope.showImportModal = function (importValue) {
                        if(!_selectedStream.type || importValue === 'no_publish' || $scope.bot.importType === 'incrementalImport'){
                            $('.import-bot-modal').modal('show');
                        }else{
                            $('.import-bot-modal-publish').modal('show');
                            setTimeout(function(){
                                $('.psScrollZindex').animate({'scrollTop':2});
                                $('#pubComments')[0].focus();
                            },500);
                        }
                        
                    };
                    
                    angular.element($window).on('resize', function (e) {
                        setTimeout(function () {
                            adjustCss();
                        }, 200);
                    });
                    adjustCss();
                    function adjustCss(){
                        var winHeight = $window.innerHeight;
                        $('.import-bot-modal-body').css('max-height',(winHeight-280)+'px');
                    }

                    $scope.clickerTask = function(task,e,index){
                        e.stopPropagation();
                        if(angular.element('#component'+index).parent().hasClass('intermediate')){
                          angular.element('#component'+index).parent().removeClass('intermediate');  
                        }
                        if(task && task.list && task.list.length){
                            task.list.forEach(function(key,value){
                                key.selected = task.selected;
                            });
                        }
                    };

                    $scope.clickerSubTask = function(task,e,index){
                        e.stopPropagation();
                        var count = 0;
                        task.list.forEach(function(key,value){
                            if(key.selected){
                                count ++;
                            }
                       });
                        if(count === task.list.length){
                            task.selected = true;
                            angular.element('#component'+index).parent().removeClass('intermediate');
                        }else if(count === 0){
                            task.selected = false;
                            angular.element('#component'+index).parent().removeClass('intermediate');
                        }else if (count !== 0){
                             task.selected = true;
                           angular.element('#component'+index).parent().addClass('intermediate');
                        }
                    };
                    $scope.openTaskPropertiesSlider =function(close, resetproperties) {
                        if(resetproperties){
                            $scope.dialogProperties = {
                                includeComments: true,
                            };
                        }
                        if(close){
                            $scope.closeModalSlider('#openTaskPropertiesSlider'); 
                        } else {
                            $scope.openModalSlider('#openTaskPropertiesSlider');
                        }
                    };
                    $scope.openUtteranceSlider = function(){
                        $scope.openModalSlider('#openUtteranceSlider');
                    };
                    $scope.utteranceSliderClose = function(){
                        $scope.closeModalSlider('#openUtteranceSlider');
                    };
                    $scope.saveUtteranceOptions = function(){
                        var options ={};
                      
                        if($scope.utterances.option === 'append'){
                            options.append = true;
                            options.replace = false; 
                            $scope.utterances.value = "Append";
                        }else{
                            options.append = false;
                            options.replace = true;
                            $scope.utterances.value = "Replace";
                        }
                        $scope.closeModalSlider('#openUtteranceSlider');
                        return options;
                    };
                    $scope.openPatternSlider = function(){
                        $scope.openModalSlider('#openPatternSlider');
                    };
                    $scope.closeSliderPattern = function(){
                        $scope.closeModalSlider('#openPatternSlider');
                    };
                    $scope.savePatternOptions = function(){
                        var options = {};
                       
                        if($scope.patterns.option === 'append'){
                            options.append = true;
                            options.replace = false; 
                            $scope.patterns.value = "Append";
                        }else{
                            options.append = false;
                            options.replace = true;
                            $scope.patterns.value = "Replace";
                        }
                        $scope.closeModalSlider('#openPatternSlider');
                        return options;
                    };
                       
                    //used while builder is resuming//
                    $scope.$emit('nestedComponentLoaded', { 'id': 'importBot', 'flag': false });
                    //Add below whenever nestedComponentLoaded is FINALLY emitted.
                    $timeout(function(){
                        $scope.$emit('gSearchLoad');
                    });
                    // Bot Import/Export save button
                    $scope.updateBotImport = function (e) {
                        $scope.showBackup();
                    };
                    $scope.$on("updateBotImport", function(evt){
                        $scope.updateBotImport();
                    });
                    // Check weather is it a JSON or not
                    function isJson(str) {
                        try {
                            JSON.parse(str);
                        } catch (e) {
                            return false;
                        }
                        return true;
                    }
                }]
        };
    });
})(angular);

;(function(ng) {

	'use strict';

	var _module = ng.module('bt-knowledge-create', []);

	_module.directive("btKnowledgeCreate", function(){
		return {
			restrict: "EA",
			templateUrl: window.appConfig.TMPLT_PRE_PATH + "js/modules/bt-knowledge-create/bt-knowledge-create.html",
			controller: "BTKnowledgeCreateCtrl"
		};
	});

	_module.controller('BTKnowledgeCreateCtrl',['$scope','$routeParams','$location', '$workflowService', '$rootScope','i18n',
	 function($scope,$routeParams,$location, $workflowService, $rootScope,i18n){
                $(window).scrollTop();
		$scope.displayMode = 'edit';
		$scope.taskEditInfo = $workflowService.taskEditInfo();
		$scope.wftype=$scope.taskEditInfo.taskType;
                $scope.tmpltPrePath=$scope.$root.tmpltPrePath;
		

		$scope.displayMode = $workflowService.taskMode() || "New";//$routeParams.displayMode || 'New';

	    $scope.wftype = $scope.taskEditInfo.taskType;

	    $scope.selectedStream = $workflowService.selectedStream();
	    $scope.streamId = $scope.selectedStream._id;

		if(!$workflowService.workflowType()){
			$location.path(window.appConfig.CONTEXT_PATH);
			return;
		}

		$scope.onStreamFormCancel=function(){
			$location.path(window.appConfig.CONTEXT_PATH);
			$("#btFullpageModal").modal("hide");
			$("body").removeClass("bt-modal-open");
			$rootScope.$emit("insertOrUpdateTask", $scope.wftype, $scope.taskEditInfo, false);
			$rootScope.$emit("showContent");
			$rootScope.$broadcast("updateEditTask", false);
		};

		$scope.onCancel = function() {
			$scope.onStreamFormCancel();
		};

		$scope.onStreamFormSave=function(){
			$location.path(window.appConfig.CONTEXT_PATH);
		};

		$scope.gotostream = function() {
			$location.path(window.appConfig.CONTEXT_PATH);
		};

	}]);

}(angular));

;(function (ng) {

    'use strict';

    var btlogs = ng.module('bt-kora-logs', []);
    //bt-kora-logs.js  <--  bt-kora-users.js(BTKoraUsersCtrl)  <--bot-chat-history.js(botChatHistory) 
    //commented below for security concern PLAT-3350, also this file we are not using anymore
    // btlogs.config(function ($sceProvider) {
    //     $sceProvider.enabled(false);
    // });
    btlogs.controller('BTKoraLogsCtrl',
            ['$scope', '$rootScope', '$q', '$endpoints', '$translator', 'BTKoraService', '$routeParams', 'user', 'streamId', '$modalInstance', '$timeout',
                function ($scope, $rootScope, $q, $endpoints, $translator, BTKoraService, $routeParams, user, streamId, $modalInstance, $timeout) {
                    var offset = 0, limit = 50, moreAvailable = false;
                    $scope.loadingMore = false;
                    var _ele;
                    $scope.loadLogs = function () {
                        $scope.koralogs = 'loading';
                        $scope.modalTitle = user.firstName ? 'Chat history with ' + user.firstName : 'Chat history';
                        _ele.scrollTop(_ele[0].scrollHeight);
                        BTKoraService.getKoraLogs(user.id, streamId, offset, limit).then(function (res) {
                            offset = offset + limit;
                            $scope.koralogs = res.data.koralogs.length ? res.data.koralogs.reverse() : [];
                            $scope.registerScrollEvent();
                            if (res.data) {
                                moreAvailable = res.data.moreAvailable;
                            } else {
                                moreAvailable = false;
                            }

                            $timeout(function () {
                                _ele.scrollTop(_ele[0].scrollHeight);
                            }, 100);

                        }, function (errRes) {
                            moreAvailable = false;
                        });
                    };

                    $scope.loadMoreLogs = function () {
                        if (moreAvailable && !$scope.loadingMore) {
                            $scope.loadingMore = true;
                            var _beforeHt = _ele[0].scrollHeight;
                            BTKoraService.getKoraLogs(user.id, streamId, offset, limit).then(function (res) {
                                offset = offset + limit;
                                if (res.data.koralogs.length) {
                                    $scope.koralogs = res.data.koralogs.reverse().concat($scope.koralogs);
                                    $scope.loadingMore = false;
                                }
                                if (res.data) {
                                    moreAvailable = res.data.moreAvailable;
                                } else {
                                    moreAvailable = false;
                                }
                                $timeout(function () {
                                    _ele.scrollTop(_ele[0].scrollHeight - _beforeHt);
                                }, 500);
                            }, function (errRes) {
                                moreAvailable = false;
                                $scope.loadingMore = false;
                            });
                        }
                    };
                    $scope.closeModal = function () {
                        $modalInstance.close();
                        $(".kora-logs-modal .modal-body").off('scroll');
                    };

                    $scope.registerScrollEvent = function () {
                        $(".kora-logs-modal .modal-body").off('scroll').on("scroll", function () {
                            if ($(this).scrollTop() <= 0) {
                                $scope.loadMoreLogs();
                            }
                        });
                    };
                    $timeout(function () {
                        $scope.koralogs = 'loading';
                        _ele = $(".kora-logs-modal .modal-body");
                        $scope.loadLogs();
                    }, 10);

                }]);

    btlogs.filter('convertmdtohtml', ['$sce', function ($sce) {
            return function (val) {
                var str = val;

//            function nextLnReplacer(match, p1, offset, string) {
//                return "<br/>";
//            }
//            var nextln = /\n/g;
//            str = str.replace(nextln, nextLnReplacer);
//            str= $sce.trustAsHtml(str);
                return str;
            };
        }]);

})(angular);


;(function (ng) {

    'use strict';

    var btUsers = ng.module('bt-kora-users', []);
    btUsers.filter('name', function () {
        return function (user) {
            if (user.firstName || user.lastName) {
                return user.firstName + " " + user.lastName;
            } else {
                return 'Unknown';
            }
        };
    });
    btUsers.filter('email', function () {
        return function (user) {
            if (user.emailId) {
                if (user.emailId.indexOf('botrtm.ignore') !== -1) {
                    return user.id;
                } else {
                    return user.emailId;
                }
            } else {
                if (user.phoneNo) {
                    return user.phoneNo;
                } else {
                    return 'Unknown';
                }
            }
        };
    });
    btUsers.controller('BTKoraUsersCtrl',
            ['$scope', '$rootScope', '$q', '$endpoints', '$translator', 'BTKoraService', '$routeParams', '$modal',
                function ($scope, $rootScope, $q, $endpoints, $translator, BTKoraService, $routeParams, $modal) {
                    var streamId = $scope.streamId, offset = 0, limit = 30, moreAvailable = false;
                    $scope.loadingMore = false;
                    $scope.loadUsers = function () {
                        $scope.users = 'loading';
                        BTKoraService.getKoraUsers(streamId, offset, limit).then(function (res) {
                            offset = offset + limit;
                            if (res.data.users.length) {
                                $scope.users = res.data.users;
                            } else {
                                $scope.users = 'norecords';
                            }
                            if (res.data) {
                                moreAvailable = res.data.moreAvailable;
                            } else {
                                moreAvailable = false;
                            }

                        }, function (errRes) {
                            $scope.users = 'error';
                        });
                    };

                    $scope.loadMoreUsers = function () {
                        if (moreAvailable && !$scope.loadingMore) {
                            $scope.loadingMore = true;

                            BTKoraService.getKoraUsers(streamId, offset, limit).then(function (res) {
                                offset = offset + limit;
                                if (res.data.users.length) {
                                    $scope.users = $scope.users.concat(res.data.users);
                                }
                                if (res.data) {
                                    moreAvailable = res.data.moreAvailable;
                                } else {
                                    moreAvailable = false;
                                }
                                $scope.loadingMore = false;
                            }, function (errRes) {
                                $scope.users = 'error';
                                $scope.loadingMore = false;
                            });
                        }
                    };

                    $scope.showLogs = function (user) {
                        $modal.open({
                            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-kora-logs/bt-kora-logs.html',
                            controller: 'BTKoraLogsCtrl',
                            windowClass: 'modal-kr kora-logs-modal',
                            resolve: {
                                user: function () {
                                    return user;
                                },
                                streamId: function () {
                                    return streamId;
                                }
                            }
                        });


                    };

                    $('.logs-max-height').on("scroll", function (event) {
                        if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9)  {
                            if ($(".kora-users-row").is(":visible")) {
                                $scope.loadMoreUsers();
                            }
                        }
                    });
                    $scope.loadUsers();
                }]);

})(angular);


;(function() {
    'use strict';

    angular
        .module('bt-login', [])
        .controller('BTLoginCtrl', Login);

    Login.$inject = ['$rootScope', '$scope', '$timeout', '$location', 'security', '$translator', '$applicationService','NotificationService','$modal','localstore','i18n','mixPanel','env_conf','$sce'];

    function Login($rootScope, $scope, $timeout, $location, security, $translator, $applicationService,NotificationService,$modal,localstore,i18n,mixPanel,env_conf,$sce) {
        if (security.isAuthenticated()) {
            $location.path(window.appConfig.CONTEXT_PATH);
        }else{
            localstore.setFromLoginScreenFlag();
        }
        $scope.marketingBannerForms = {
                default:true,
                credentials:true,
                forgot:true
        };
         var  queryLanguage = window.localStorage.getItem('queryParamLang');
        $scope.language = queryLanguage ||  'en';
        $scope.marketingUrl = '';
        if(window.appConfig.homePageIframeUrl) {
            $scope.marketingUrl = $sce.trustAsResourceUrl(window.appConfig.homePageIframeUrl+'?lan='+$scope.language);
        }
        if(window.appConfig && window.appConfig.enableHomepage){
            $scope.showMarketingBanner =  true;
            $scope.dynoff= -55;
        }
        $scope.hideSSOBtns= window.appConfig.HIDE_SSO_LOGIN || false;
        $scope.tmpltPrePath=$scope.$root.tmpltPrePath;
        $scope.multiUsers = null;
        $scope.emailSent = i18n.i18nString('email_sent');
        $scope.codeSent = i18n.i18nString('code_sent');
        $scope.emailResetLinkLabel = i18n.i18nString('email_reset');
        $scope.charRemaining= i18n.i18nString('Generalform_charlimit');
        $scope.userAvatar = env_conf['context-url']+'/img/user-gray.svg';
        $scope.cOne = env_conf['context-url']+'/assets/login/carousel/Bot_home_banner_Multilingual-Virtual-Assistants-1.jpg';
        $scope.cTwo = env_conf['context-url']+'/assets/login/carousel/Bot_home_banner_conversation-testing.jpg';
        $scope.cThree = env_conf['context-url']+'/assets/login/carousel/Use-Cases-Main-Banner.jpg';
        $scope.platform = env_conf['context-url']+'/assets/login/carousel/Platform.svg';
        $scope.resetLinkSent = false;
        $scope.passwordExpired = false;
        $scope.showFormType = false;
        $rootScope.showLoginLoader= window && window.appConfig && window.appConfig.DIRECT_SSO_LOGIN;
        $scope.ssoOptions = [];
        var searchParms = $location.search();
        var hashParms = $location.hash();
        $scope.defaultLoginPage = 'default';
        if(hashParms === 'login' && (searchParms.email || searchParms.emailId || searchParms.phoneNo || searchParms.sso) ) {
            $scope.checkingId = true; 
            // $scope.defaultLoginPage = '';
        }
        // SSO Details //
        $scope.allAvailableSSOoptions = {
            google:{
                key:'google',
                class:'sso-google',
                icon:'bt-google-login',
                image:env_conf['context-url']+'/assets/login/sso-icons/google-icon.svg',
                name:i18n.i18nString('label_google')
            },
            microsoft:{
                key:'microsoft',
                class:'sso-ms',
                icon:'btn-google-login',
                image:env_conf['context-url']+'/assets/login/sso-icons/microsoft-icon.svg',
                name:i18n.i18nString('label_microsoft')
            },
            linkedin:{
                key:'linkedin',
                class:'sso-linkedin',
                icon:'btn-google-login',
                image:env_conf['context-url']+'/assets/login/sso-icons/linkedin-icon.svg',
                name:i18n.i18nString('label_linkedin')
            },
            github:{
                key:'github',
                class:'ss0-gitHub',
                icon:'bt-google-login',
                image:env_conf['context-url']+'/assets/login/sso-icons/github-icon.svg',
                name:i18n.i18nString('label_github')
            }
        };
        $scope.initCarousal  = function(){
            setTimeout(function(){
               $('#carouselkoreLogin').carousel(); 
            });
        };
        function prepareSSOOptions(){
            var options = [];
            var config  = window.appConfig;
            if(config && config.SSO_PROVIDERS && (typeof config.SSO_PROVIDERS == 'object')) {
              $.each(config.SSO_PROVIDERS,function(key,val){
                  if(val && $scope.allAvailableSSOoptions[key]){
                    options.push($scope.allAvailableSSOoptions[key]);
                  }
              });
            }
            $scope.ssoOptions = options;
        }
        prepareSSOOptions();
        $scope.clearLocalStorage = function() {
            if(window && window.localStorage){
                window.localStorage.removeItem('previousState');
            } 
        };
        function resizeIframe(){
            var iframe= document.getElementById('marketingContentFrame');
             var iframewindow= iframe.contentWindow? iframe.contentWindow : iframe.contentDocument.defaultView;
              setTimeout(function(){
                      try {
                         iframe.height = iframewindow.document.body.scrollHeight + 50 + "px";
                         $('#marketingContentFrame').css({
                             height:iframe.height
                         });
                      } catch(e) {
                          console.log('cross-origin');
                         // iframe.height = '100%';
                      }    
                  },500);
        }
        
        $scope.resizeIframe = resizeIframe;
        $scope.clearLocalStorage();
        if(window && window.appConfig && window.appConfig.DIRECT_SSO_LOGIN){
             $scope.formType = $scope.defaultLoginPage;
             $scope.showFormType = true;
            $translator.translate('bt.check.directSSOStatus')
            .then(function (res) {
                if(res && res.data.defaultSSOEnabled){
                   security.handleSSORedirect(res.data, 'direct');
                }else{
                   $rootScope.showLoginLoader=false;
                }
            },function(err){
                   $rootScope.showLoginLoader=false;
            });
        } else {
                   $scope.formType = $scope.defaultLoginPage;
                   $rootScope.showLoginLoader=false;
                   $scope.showFormType = true;
        }
        $scope.login = {error:false};
        $scope.passwordPolicy = {'hintText':i18n.i18nString('password_policy'),'pattern':'^','minLength':8,'maxLength':256};
        $scope.formTitles = {
            'default'     : i18n.i18nString('formtitles_default'),
            'credentials' : i18n.i18nString('formtitles_credentials'),
            'multi'       : i18n.i18nString('formtitles_multi'),
            'forgot'      : i18n.i18nString('formtitles_forgot'),
            'reset-pass'  : i18n.i18nString('formtitles_reset_pass'),
            'sign-up'     : i18n.i18nString('formtitles_sign-up'),
            'pre-sign-up'     : i18n.i18nString('formtitles_pre_sign_up'),
            'verify-email': i18n.i18nString('formtitles_verify_email'),
            'verify-phone': i18n.i18nString('formtitles_verify_phone'),
            'disable-signup': i18n.i18nString('formtitles_disable_signup'),
            'landing-page': i18n.i18nString('formtitles_landing-page')
        };
        $scope.formTitle = $scope.formTitles[$scope.formType];
        if(queryLanguage && queryLanguage == "ja"){
            $scope.showJapanesePolicy = true;
        }else{
            $scope.showJapanesePolicy = false;
        }
        
        // Data sets
        $scope.emailPhone = null;
        $scope.oneTimeToken = null;

        // Country Codes
        $scope.countryCodes = [
            // At the moment, login using phone number is not supported
            // When required, import all the country codes from a seperate file
            {name: "Canada", value: "+1"},
            {name: "India", value: "+91"}
        ];
        $scope.selectedCountryCode = $scope.countryCodes[0];
        $scope.searchCountryCodes = '';

        // Booleans
        $scope.displayCountryCodes = false;
        $scope.loginComplete = false;
        $scope.error = false;
        $scope.errorReset = false;

        // functions
        $scope.switchForms = switchForms;
        $scope.removeSession = removeSession;
        $scope.phoneCode = phoneCode;
        $scope.selectCountryCode = selectCountryCode;
        $scope.chooseAccount = chooseAccount;
        $scope.selectFavorite = selectFavorite;
        $scope.chooseFavorite = chooseFavorite;
        $scope.hideFavorite = hideFavorite;
        $scope.submitAutoLogin = submitAutoLogin;
        $scope.submitMultiLogin = submitMultiLogin;
        $scope.submitLogin = submitLogin;
        $scope.ssoLogin = ssoLogin;
        $scope.submitResetLink = submitResetLink;
        $scope.resetPassword = resetPassword;
        $scope.submitSignUp = submitSignUp;
        $scope.resendCode = resendCode;
        $scope.resendEmail = resendEmail;
        $scope.cancel = cancel;
        $scope.changeEmailPhone = changeEmailPhone;
        $scope.checkValidations=checkValidations;
        // $scope.openVersionModal = openVersionModal;
        window.localStorage.setItem('sortType', "BotName");
        window.localStorage.setItem('botSortValue', "allBots");
        var _usrInfo = JSON.parse(window.localStorage.getItem('emailIdStorage'));
        if(_usrInfo){
          $scope.emailPhone = _usrInfo.email || "";
          var _emailJson = {'email':$scope.emailPhone};
          window.localStorage.setItem('emailIdStorage', JSON.stringify(_emailJson));
        }
        var _queryEmail=$location.search().email;
        if(_queryEmail){
          $scope.emailPhone = _queryEmail || "";  
        }
        // $scope.initHeader = function(){
        //     setTimeout(function(){
        //     window.onscroll = function() {registerScroll()};

        // var header = document.getElementById("myKoreLoginHeader");
        // var sticky = header.offsetTop;

        // function registerScroll() {
        //   if (window.pageYOffset > sticky) {
        //     header.classList.add("sticky");
        //   } else {
        //     header.classList.remove("sticky");
        //   }
        // }
        // },100)
        // } 
        
        $scope.doFocus = function () {
            $timeout(function () {
                var _ele = $(".sign-up-in input:visible");
                $.each(_ele, function (k, ele) {
                    if ($(ele).val().trim() === '') {
                        $(ele).focus();
                        return false;
                    }
                });
            }, 500);
        };
        $scope.showLoginForm = function() {
            switchForms("default");
        };
        $rootScope.$on('EVENT.PASSWORD_EXPIRY', function (name,res) {
            $scope.passwordExpired = true;
            $scope.error = false;

             $modal.open({
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/bt-user-profile/bt-change-password.html',
                    controller: 'BTChangePasswordCtrl',
                    //backdrop: 'static',
                    windowClass: 'modal-kr changePwdLogin loginBG',
                    resolve: {
                                                config: function () {
                                                        return {

                                                                        userInfo: res.username || {}

                                                        };
                                                }
                                        }
                     });
        });
        activate();
        function handleVerifyStatus(search,missingFields){
                        //While verifying user by cliking verfy link opened by user,
                        //need to determine sso user or normal user so that respective screen will be shown to login
                        //calling CheckIdStatus to differ sso and non sso
                        var _identity = search.emailId || search.phoneNo;
                        var data = {
                            "phone": search.phoneNo ? true : false,
                            "emailPhone": _identity,
                            "username": _identity
                        };
                        if(missingFields){
                            data.missingFields=missingFields;
                        }
                        submitAutoLoginByData(data);
        }
        function activate() {
            mixPanel.reset();
            var search = $location.search() || {};
            search.email = search.email || search.emailId || search.phoneNo; 
            var hash = $location.hash();
            if(search && search.name){
                $scope.firstName = search.name;
            }
            if(hash==='signup'){
                if(search.email) {
                    var _signUpidentity = search.email || search.emailId || search.phoneNo;
                    $scope.emailPhone = _signUpidentity;
                } 
                    switchForms('pre-sign-up');
            } else if(hash === 'login'){ // #login
                if(search.email) {
                    var _identity = search.email || search.emailId || search.phoneNo;
                    var data = {
                        "phone": search.phoneNo ? true : false,
                        "emailPhone": _identity,
                        "username": _identity
                    };
                    submitAutoLoginByData(data,true); 
                } else if(search.sso) {
                    ssoLogin(search.sso);
                }
            } 
            else if (hash === '_accountactivation') {
                security.handleAccountActivation(search, {
                    success: function(){
                       $scope.emailPhone = search.emailId || search.phoneNo;
                       handleVerifyStatus(search);
                    },
                    failure: function(res){
                        if(res.data.errors && res.data.errors.length) {
                            $scope.searchParams = angular.copy(search);
                            if(res.data.errors[0].code == 225) {
                                switchForms('link-expired');
                            } else if (res.data.errors[0].moreInfo) {
                                $scope.emailPhone = res.data.errors[0].moreInfo.userInfo.emailId;
                                $scope.firstName = res.data.errors[0].moreInfo.userInfo.firstName;
                                $scope.lastName = res.data.errors[0].moreInfo.userInfo.lastName;
                                handleVerifyStatus(search,res.data.errors[0].moreInfo);
                            }
                        }
                        if($scope.emailPhone){
                            security.getPasswordPolicy($scope.emailPhone, {
                                updatePasswordPolicy: function (res) {
                                    $scope.passwordPolicy = res;
                                }
                            });
                        }
                    }
                });
            }
            else if (hash === '_resetpassword') {
                handleResetPassword(search);
            }
            else if( search.form ==='accountsList'){
                newBotLanding();
            }
            if( search.form !== 'accountsList'){
                $location.search({});
            }

            //$location.search({});
            $location.hash('');
        }

        // Complete the login
        function completeLogin() {
            $scope.loginComplete = true;
        }

        // ACTIONS

        // Switch between the different forms
        function switchForms(type,differentUser) {
            $scope.login.error = false;
            $scope.error = false;
            if(differentUser){
                $scope.emailPhone = "";
                $timeout(function () {
                    var _ele = $("input:visible");
                    $.each(_ele, function (k, ele) {
                        if ($(ele) && $(ele).val() && $(ele).val().trim() === '') {
                            $(ele).focus();
                        }
                    });
                }, 500);
            }
            if(type === 'forgot' && $scope.emailPhone) {
                var userInfo =  {
                    $email: $scope.emailPhone,
                    Category:"Onboarding",
                    SubCategory:"Signup",
                };
                mixPanel.reset();
                mixPanel.setUserInfo($scope.emailPhone,userInfo);
                mixPanel.postEvent('Signup by Email - Forgot Password',userInfo);
            }
            $scope.formType = type;
            $scope.formTitle = $scope.formTitles[type];
            if(type === "landing-page" && $scope.availableAccounts.length === 0 ){
              $scope.formTitle = $scope.formTitles["default"];
            }
            $scope.doFocus();
            $rootScope.showLoginLoader = false;
            setTimeout(function(){
                $scope.checkingId =  false;
            },100);
            setTimeout(function(){
                $('.koreLoginContainer').scrollTop(1);
             },600);
        }
        // Remove a user session
        function removeSession(indexNum) {
            $scope.multiUsers.splice(indexNum, 1);
        }

        // Set whether the phone codes should be displayed.
        function phoneCode(value) {
            $scope.displayCountryCodes = value;
        }

        // Select a country code (if needed).
        function selectCountryCode(item) {
             $scope.selectedCountryCode = item;
        }

        // select an account
        function chooseAccount(item, evt) {
             evt.stopPropagation();
             evt.preventDefault();
             $scope.appControlData.defaultAccountId = $scope.selectFavoriteAccount;
             $scope.appControlData.chosenAccountId = item.accountId;
             security.saveUserData($scope.appControlData);
             //localStorage.setItem("selectedAccount",JSON.stringify(item));
             if(!$scope.emailPhone){
                  $scope.emailPhone = $scope.appControlData.userInfo.emailId;
             }
             if(item.hasOwnProperty('idp')){
                  item.client_email = $scope.appControlData.userInfo.emailId;
                  localStorage.setItem("selectedSSOAccount",JSON.stringify(item));
                  var newidp = item.idp;
                  ssoLogin(newidp, 'direct');
             }
             else{
                $('.login-container').hide();
                $rootScope.showLoginLoader = true;
                $timeout(function() {
                  localStorage.removeItem("selectedSSOAccount");
                  $location.search({});
                  localstore.setSelectedAccount(item);
                  completeLogin();
                  security.authenticateSelectedUser(item);
                  //$location.path(window.appConfig.CONTEXT_PATH);
                });
             }

        }
        $scope.closeFlow = function (account) {
            security.logout();
        };
        function chooseFavorite(item, $event) {
             $scope.selectFavoriteAccount = item.accountId;
             security.saveUserData($scope.appControlData);
             $translator.translate('bt.prefs.update', {}, {defaultAccountId: item.accountId})
                     .then(function (res) {
                        $scope.appControlData.defaultAccountId = item.accountId;
                     });
        }

        function selectFavorite($event) {
            var _currEle = $($event.currentTarget);
            _currEle.find('.favoriteAcccount').removeClass('hide');
        }

        function hideFavorite($event) {
            var _currEle = $($event.currentTarget);
            _currEle.find('.favoriteAcccount').addClass('hide');
        }

        // Pending
        // Move this function to security
        function checkResetPassLinkExpiry(search) {
            var url = 'mp.user.resetPassLinkExpiry';
            var params = {
                token: search.token
            };
            return $translator.translate(url, params);
        }

        function handleResetPassword(search) {
            // check if link expired
            checkResetPassLinkExpiry(search).then(
                function(){
                    switchForms('reset-pass');
                    security.getPasswordPolicy(search.emailId, {
                      updatePasswordPolicy : function (res) {
                          $scope.pwdPolicy = res;
                      }
                    });
                    $scope.emailPhone = search.emailId;
                    $scope.oneTimeToken = search.token;
                },
                function(){
                    NotificationService.notify(i18n.i18nString('reset_password_link'), "error");
                }
            );
        }
        function linkedinInsightTracking(){
            var appConfig =   window.appConfig;
            try {
                if(window && window.lintrk && appConfig.ENABLE_LINKEDIN_INSIGHT && appConfig.LINKEDIN_INSIGHT_ID) {
                    window.lintrk('track', { conversion_id: appConfig.LINKEDIN_INSIGHT_ID});
                }
            } catch(e){
                console.log('Failed lintrk');
            }
        }
        // Submit the auto login information to security.
        function submitAutoLogin(form) {
            linkedinInsightTracking();
            $scope.emailPhone = form.emailPhone.$modelValue;

            // Set up the data to be sent.
            var data = {
                phone: $scope.displayCountryCodes,
                countryCode: $scope.selectedCountryCode.value,
                emailPhone: $scope.emailPhone,
                formType:$scope.formType
            };
            submitAutoLoginByData(data);
        }
        function submitAutoLoginByData(data,skipPreSignup){
            $scope.existingUser = false;
            $scope.showSpinner = true;

            // Send the data to security to login.
            security.autoLogin(data, {
                userExist: function(){
                    $scope.showSpinner =  false;
                    $scope.existingUser = true;
                    $scope.checkingId =  false;
                },
                // Successful login.
                success: function() {
                    $scope.showSpinner = false;
                    $scope.existingUser = false;
                    $scope.checkingId =  false;
                },

                // More is required of the user to continue.
                moreRequired: function(value) {
                 
                    // Set a small delay to give the user a moment.
                    $timeout(function() {
                        if((value === 'pre-sign-up') && skipPreSignup) {
                            value='sign-up';
                        }
                        switchForms(value);
                        $scope.showSpinner = false;
                        // $scope.checkingId =  false;
                    }, 500);
                },

                failure: function(response, isSecondaryIdentity){
                    $scope.showSpinner = false;
                    $scope.checkingId =  false;
                    $scope.error = true;
                    if (isSecondaryIdentity) {
                        $scope.errorMsg = i18n.i18nString('userid_failure');
                    }
                    else {
                        $scope.errorMsg = $applicationService.getErrorMessage(response);
                    }
                    NotificationService.notify($scope.errorMsg, "error");
                },
                stopFurther: function (res) {
                    $scope.showSpinner = false;
                    $scope.checkingId =  false;
                    if(res.reason==='ShowError'){
                         //$scope.error = true;
                         //$scope.errorMsg = res.msg;
                         NotificationService.notify(res.msg, 'error', 4000);
                    }

                },
                updatePasswordPolicy : function (res) {
                    $scope.passwordPolicy = res;
                    $scope.checkingId =  false;
                }
            });
        }
        // Submit the multi screen login information to security.
        function submitMultiLogin(value) {

            // Set up the data to be sent.
            var data = {
                phone: false,
                emailPhone: value
            };

            // Send the data to security to login.
            security.autoLogin(data, {

                // Successful login.
                success: function() {
                    completeLogin();
                }
            });
        }

        // Submit the login with credentials to security.
        function submitLogin(form) {

            // Set up the data to be sent.
            var data = {
                phone: $scope.displayCountryCodes,
                emailPhone: form.emailPhone.$modelValue,
                pass: form.pass.$modelValue
            };

            // Turn off the error.
            $scope.error = false;
            $scope.login.error = false;

            // Send the data to security to login.
            security.login(data, {

                // Successful login.
                success: function() {
                    completeLogin();
                },

                moreRequired: function(value, currentAccount) {
                    $scope.loginComplete = false;
                    $scope.appControlData = currentAccount;
                    $scope.availableAccounts = _.filter(currentAccount.associatedAccounts, function (account) {
                        return (account.isDeveloper||false);
                    });
                    // Set a small delay to give the user a moment.
                    $timeout(function() {
                        switchForms(value);
                    }, 500);
                },

                // Something went wrong.
                failure: function(res) {
                    $scope.error = true;
                    $scope.login.error = true;
                    if($scope.passwordExpired){
                        $scope.errorMsg = i18n.i18nString('password_expired');
                        $scope.passwordExpired = false;
                    }else{
                        $scope.errorMsg = $applicationService.getErrorMessage(res);
                    }
                    NotificationService.notify($scope.errorMsg, "error");
                }
            });
        }

        function getJSON(string) {
            var json;
            try {
                json = JSON.parse(string);
                return json;
            }
            catch (e) {
                return false;
            }
        }

        function newBotLanding () {
          var jStorage =  localstore.getAuthData();
          if(jStorage){
                $scope.appControlData = jStorage.currentAccount;
                $scope.availableAccounts = _.filter(jStorage.currentAccount.associatedAccounts, function (account) {
            return (account.isDeveloper||false);
                });
          if($scope.appControlData.defaultAccountId && $scope.appControlData.defaultAccountId !== ""){
                    $scope.selectFavoriteAccount = $scope.appControlData.defaultAccountId;
                }
          //switchForms("landing-page");
          $scope.login.error = false;
          $scope.error = false;
          $scope.formType = "landing-page";
          if(jStorage.currentAccount && jStorage.currentAccount.userInfo && jStorage.currentAccount.userInfo.profImage && (jStorage.currentAccount.userInfo.profImage !=='no-avatar')){
            $scope.userAvatar = window.appConfig.API_SERVER_URL + "/api/1.1/getMediaStream/profilePictures/"+ jStorage.currentAccount.userInfo.id+ "/r_64x64_profile.png";
          }
          $scope.formTitle = $scope.formTitles["landing-page"];
          if($scope.availableAccounts.length <= 0) {
            $scope.formTitle = $scope.formTitles["default"];
          }
                   }
          $rootScope.showLoginLoader = false;
          setTimeout(function(){
             $('.koreLoginContainer').scrollTop(1);
          },600);
        }

        function ssoLogin(idp, checkDirect) { // idp = 'google' or 'facebook'
            linkedinInsightTracking();
            var dataObject = {
                idp: idp
            };
            if ($scope.emailPhone && $scope.emailPhone.length) {
                if ($scope.displayCountryCodes) {
                    dataObject.username = ($scope.selectedCountryCode.value + $scope.emailPhone).replace(/-/g, '');
                }
                else {
                    dataObject.username = $scope.emailPhone;
                }
            }
            security.handleSSORedirect(dataObject, checkDirect);
        }

        // Submit a reset link for the password.
        function submitResetLink(form) {
            if ($scope.displayCountryCodes) {
                console.log('Pending');
            }
            else {
                $scope.emailResetLinkLabel = i18n.i18nString('Sending');
            }
            var data = {
                phone: $scope.displayCountryCodes,
                countryCode: $scope.selectedCountryCode.value,
                emailPhone: form.emailPhone.$modelValue
            };
            security.sendResetLink(data, {

                success: function(){
                    $scope.resetLinkSent = true;
                    if ($scope.displayCountryCodes) { // In case username is mobile no
                        console.log('Pending');
                    }
                    else { // In case username is email id
                        $scope.emailResetLinkLabel =i18n.i18nString('sent');
                        $timeout(function() {
                            $scope.emailResetLinkLabel = i18n.i18nString('email_resent_link');
                        }, 5000);
                    }
                },
                failure: function(res){
                    $scope.error = true;
                    if(res.status === 429){
                      $scope.errorMsg = res.data.errors[0].msg;
                      $timeout(function() {
                          $scope.emailResetLinkLabel = i18n.i18nString('email_resent_link');
                      }, 1000);
                    }
                    else{
                      $scope.errorMsg = res.data.errors[0].msg;
                    }
                }
            });
        }

        function resetPassword(form) {
            // Set up the data to be sent.
            var data = {
                pass: form.pass.$modelValue,
                passConfirm: form.passConfirm.$modelValue,
                token: $scope.oneTimeToken
            };

            // Send the data to security to sign up.
            security.passReset(data, {

                // Successful login.
                success: function(value) {
                    switchForms(value);
                },
                failure: function(res){
                    $scope.errorReset = true;
                    $scope.errorMsg = res.data.errors[0].msg;
                }
            });
        }

        // Submit the sign up form
        function submitSignUp(form, isFromPassword) {

            // Set up the data to be sent.
            var data = {
                phone: $scope.displayCountryCodes,
                emailPhone: form.emailPhone.$modelValue,
                firstName: form.koreFN.$modelValue,
                lastName: form.koreLN.$modelValue,
                pass: form.KoreSecure.$modelValue,
                passConfirm: form.KoreSecureConfirm.$modelValue
            };

            if (form.KoreAccNa && form.KoreAccNa.$modelValue) {
                data.accountName = form.KoreAccNa.$modelValue || '';
            }


            if(isFromPassword){
                data.token = $scope.searchParams.token;
                data.emailId = form.emailPhone.$modelValue;
                security.handleAccountActivation(data, {
                    success: function(){
                        $scope.emailPhone = form.emailPhone.$modelValue || $scope.displayCountryCodes;
                        switchForms('credentials');
                    },
                    failure: function(res){
                        $scope.errorSignUp = true;
                        $scope.errorMsg = res.data.errors[0].msg;

                        // $scope.searchParams = angular.copy(search);

                        // $scope.emailPhone = res.data.errors[0].moreInfo.userInfo.emailId;
                        // $scope.firstName = res.data.errors[0].moreInfo.userInfo.firstName;
                        // $scope.lastName = res.data.errors[0].moreInfo.userInfo.lastName;
                        // switchForms("sign-up-password");
                    }
                });
                return;
            }
            // Send the data to security to sign up.
            security.signUp(data, {

                // Successful login.
                success: function(value) {
                    $scope.emailPhone = form.emailPhone.$modelValue || $scope.displayCountryCodes;
                    switchForms(value);
                },

                failure: function(res){
                    $scope.error = true;
                    $scope.errorMsg = res.data.errors[0].msg;
                }
            });
        }

        // Resend the phone number verification code.
        function resendCode() {
            $scope.codeSent = i18n.i18nString('code_sent_name');
            $timeout(function() {
                $scope.codeSent = i18n.i18nString('code_sent');
            }, 5000);
        }

        // Resend the phone number verification code.
        function resendEmail(showNotification) {
            if ($scope.emailSent === i18n.i18nString('email_sent_name')) {
                return;
            }
            var payload = {
                emailId: $scope.emailPhone
            };
            $scope.emailSent = i18n.i18nString('send_email');
            security.resendVerification(payload, false).then(
                function () {
                    if(showNotification){
                        NotificationService.notify(i18n.i18nString('link_sent_to_your_email'), "success");
                    }
                    $scope.emailSent = i18n.i18nString('email_sent_name');
                    $timeout(function() {
                        $scope.emailSent = i18n.i18nString('email_sent');
                    }, 5000);
                },
                function (res){
                    $scope.error = true;
                    $scope.emailSent = i18n.i18nString('email_sent');
                    if( res.data &&  res.data.errors && res.data.errors.length && res.data.errors[0].msg) {
                        $scope.errorMsg = res.data.errors[0].msg;
                        NotificationService.notify($scope.errorMsg, "error");
                    } else {
                        NotificationService.notify(i18n.i18nString('error_handle_msg'), "error");
                    }
                }
            );
        }

        // Cancel the login process and go back to home.
        function cancel() {
            $scope.emailPhone = null;
            $scope.displayCountryCodes = false;
            switchForms('default');
        }
        $scope.openLinks = function(type,$event){
            if(type === 'community') {
                $rootScope.redirectToLink('https://community.kore.ai/',$event,true);
            } else if(type === 'koreAcademy') {
                $rootScope.redirectToLink('https://info.kore.ai/online-training-schedule',$event,true);
            } else if(type === 'documents'){
                $rootScope.redirectToLink('https://developer.kore.ai/docs/bots/chatbot-overview/koreai-platform/',$event,true);
            } else if(type === 'support'){
                $rootScope.redirectToLink('https://support.kore.ai',$event,true);
            }
            
        };
        // Change the user's email or phone number.
        function changeEmailPhone() {
            var modalData;

            // change the user's email.
            if ($scope.displayCountryCodes === false) {
                modalData = {
                    alertType: 'info',
                    alertTitle: i18n.i18nString('change_email_title'),
                    alertMessage: i18n.i18nString('change_email_message'),
                    acceptButton: i18n.i18nString('change')
                };
            }

            // Change the user's phone number.
            else {
                modalData = {
                    alertType: 'info',
                    alertTitle: i18n.i18nString('change_phone_title'),
                    alertMessage: i18n.i18nString('change_phone_message'),
                    acceptButton: 'Change'
                };
            }

        }
        $scope.validations={
            invalidFirstName:false,
            invalidLastName:false,
            invalidAccountName:false
        };
        function  checkValidations(type,string){
            var format1 = /[~!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/;
            var format2 = /(www|http|https)/;
            if (format1.test(string) || format2.test(string)){
                if(type=='firstName'){
                   $scope.validations.invalidFirstName = true;
                }else if(type == 'lastName'){
                   $scope.validations.invalidLastName = true;
                }else{
                    $scope.validations.invalidAccountName = true;
                 }
            }else{
               if(type=='firstName'){
                   $scope.validations.invalidFirstName = false;
                }else if(type == 'lastName'){
                    $scope.validations.invalidLastName = false;
                 }else{
                     $scope.validations.invalidAccountName = false;
                  }
            }
        }

    }
})();


;(function() {
    'use strict';

    angular
        .module('bt-login')
        .controller('BTAcceptLicenseCtrl', acceptLicense);

    acceptLicense.$inject = ['$rootScope', '$scope', '$timeout', '$location', 'security', '$applicationService', '$translator','mixPanel'];

    function acceptLicense($rootScope, $scope, $timeout, $location, security, $applicationService, $translator,mixPanel) {

        $scope.accept = accept;
        $scope.decline = decline;
        $scope.enableAgree=false;
        $scope.MP_URL=window.appConfig.MP_URL;

        $scope.apiCallInProgress = false;
    	
        activate();

        function activate() {
            var _userInfo = $applicationService.userInfo();
            if (_userInfo && _userInfo.koreUserInfo && _userInfo.koreUserInfo.isBTLicenseAccepted && !_userInfo.koreUserInfo.isBTLicenseAccepted_update) {
                $scope.isUpdate=true;
            }
            if ($('.bt-modal-wrong-sso').length) {
                return false;
            }
                $('#termsConditions').modal({
                    backdrop: 'static',
                    keyboard: false
                });  
          
             $(document).on("shown.bs.modal", "#termsConditions", function(evt) {
                $timeout(function(){
                    $("body").addClass("modal-open");
                }, 1000);
                


      });

            PerfectScrollbar.initialize($('#termsConditions .modal-body')[0], {
                wheelSpeed: 2,
                wheelPropagation: true,
                minScrollbarLength: 25
            });
            // $('#termsConditions').on('scroll', function () {
            //     if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight) {
            //         $scope.enableAgree = true;
            //         $scope.$apply();
            //     }
            // });

        }

        function accept() {

            $scope.apiCallInProgress = true;

            var url = 'mp.user.acceptbtlicense';
            var params = {
                userId: $applicationService.userInfo().userId
            };

            $translator.translate(url, params).then(
                function(){
                    var userInfo = {
                        $email:$applicationService.userInfo().emailPhone,
                        FirstName: $applicationService.userInfo().firstName,
                        LastName: $applicationService.userInfo().lastName,
                    };
                    mixPanel.postEvent('License Agreement Accepted',userInfo);
                    $scope.apiCallInProgress = false;
                    window.location=window.appConfig.CONTEXT_PATH;
                },
                function(){
                    $scope.apiCallInProgress = false;
                }
            );
        }

        function decline() {
            var userInfo = {
                $email:$applicationService.userInfo().emailPhone,
                FirstName: $applicationService.userInfo().firstName,
                LastName: $applicationService.userInfo().lastName,
            };
            mixPanel.postEvent('License Agreement Declined',userInfo);
            security.logout();
        }


    }

})();

;(function() {
    'use strict';

    angular
        .module('bt-login')
        .controller('BTInfoCtrl', information);

        information.$inject = ['$routeParams','$rootScope', '$scope', '$timeout', '$location', 'security', '$translator', '$applicationService','NotificationService','$modal','localstore','i18n','AuthInterceptor'];

    function information($routeParams,$rootScope, $scope, $timeout, $location, security, $translator, $applicationService,NotificationService,$modal,localstore,i18n,AuthInterceptor) {
        $scope.case="default";
        if($routeParams.infoType){
            $scope.case=$routeParams.infoType;
        }
    $scope.buttonText = i18n.i18nString('re_login');
    $rootScope.showLoginLoader = false;
    $rootScope.$emit('botTestEnd');
    $scope.relogin = function(){
        security.resetlocalStoragAfterLogout();
        $rootScope.showLoginLoader = true;
        //$location.path(window.appConfig.CONTEXT_PATH + '/login'); 
        AuthInterceptor.setReAuthFormOpened(false);
        security.redirectToLoginPath();
     };
    }
})();


;(function() {
    'use strict';

    angular
        .module('bt-login')
        .controller('BTRequestAccessCtrl', requestAccess);

    requestAccess.$inject = ['$rootScope', '$scope', '$timeout', '$location', 'security', '$applicationService', '$translator', '$routeParams','i18n',];

    function requestAccess($rootScope, $scope, $timeout, $location, security, $applicationService, $translator, $routeParams,i18n) {

        // Functions
        $scope.submitRequest = submitRequest;
        $scope.logout = logout;

        // variables
        $scope.firstName = '';
        $scope.lastName = '';
        $scope.businessEmail = '';
        $scope.companyName = '';
        $scope.jobTitle = '';
        $scope.message1 = '';
        $scope.message2 = '';
        $scope.message3 = '';
        $scope.error = false;
        $scope.displayMessage = false;
        $scope.message = null;

        $scope.done = i18n.i18nString('done');
        $scope.cancel = i18n.i18nString('cancel');


        if($applicationService.userInfo() && $applicationService.userInfo().koreUserInfo){
            var _koreUserInfo = $applicationService.userInfo().koreUserInfo;
            $scope.firstName = _koreUserInfo.firstName || '';
            $scope.lastName = _koreUserInfo.lastName || '';
            $scope.businessEmail = _koreUserInfo.emailId || '';
            $scope.companyName = _koreUserInfo.orgDomain || '';
        }

        var _isFreeDomain = $routeParams.isFreeDomain;

        if (_isFreeDomain && _isFreeDomain === 'true') {
            $scope.message = i18n.i18nString('bt_reqst_access_only_enterprise_owners');
            $scope.displayMessage = true;
        }

        $(document).on("shown.bs.modal", "#request-bt-access", function(evt) {
           $("body").removeClass("hidebodyscroll");
           $("body").addClass("modal-open");
       });

        activate();

        function activate() {
            $('#request-bt-access').modal({
                backdrop: 'static',
                keyboard: false
            });
            PerfectScrollbar.initialize($('#request-bt-access .modal-body')[0], {
                wheelSpeed: 2,
                wheelPropagation: true,
                minScrollbarLength: 25
            });
        }

        // hit the api
        function submitRequest() {
        	var url = 'mp.user.getBTAccess';
            var params = {
                userId: $applicationService.userInfo().userId
            };

            if(params.userId){
                requestForBTAccess(params, url);
            }else {
                $scope.signUpAndAccessBt();
            }




            
        }



         $scope.signUpAndAccessBt = function(){
            // Send the data to security to sign up.
             // Set up the data to be sent.
            var data = {
                emailPhone: $scope.businessEmail,
                firstName: $scope.firstName,
                lastName: $scope.lastName
            };
            security.signUpUser(data, {

                // Successful login.
                success: function(value) {
                    var params = {
                        userId: value.data.userId
                    };
                    var url = 'mp.user.getBTAccessPublic';
                    requestForBTAccess(params, url);  
                },

                failure: function(res){
                    $scope.error = true;
                    $scope.errorMsg = res.data.errors[0].msg;
                }
            });
        };


        function requestForBTAccess(params, url){

            var payload = {
                "requestInfo": {
                    "firstName": $scope.firstName,
                    "lastName": $scope.lastName,
                    "emailId": $scope.businessEmail,
                    "companyName": $scope.companyName,
                    "jobTitle": $scope.jobTitle,
                    "message": $scope.message1 + ' \n\n' + $scope.message2 + ' \n\n' + $scope.message3
                }
            };
            $translator.translate(url, params, payload).then(
                function() {
                    $scope.displayMessage = true;
                    $scope.message = i18n.i18nString('bt_reqst_access_reqst_sent_approval')+' <br>'+i18n.i18nString('bt_reqst_access_notified_through_email');
                    $timeout(function(){
                        PerfectScrollbar.update($(".modalPerfectScroll")[0]);
                    }, 1000);
                    
                },
                function(response) {
                    NotificationService.notify(response.data.errors[0].msg, "error");
                }
                );

        }

        function logout() {
            security.logout();
        }
    }

})();

;(function() {
    'use strict';

    angular
        .module('bt-login')
        .controller('STBTRequestAccessCtrl', requestAccess);

    requestAccess.$inject = ['$rootScope', '$scope', '$timeout', '$location', 'security', '$applicationService', '$workflowService', '$translator', '$routeParams', 'env_conf','i18n'];

    function requestAccess($rootScope, $scope, $timeout, $location, security, $applicationService, $workflowService, $translator, $routeParams, env_conf,i18n  ) {
        $scope.streamData = $workflowService.selectedStream();
        $scope.userInfo = $applicationService.userInfo();
        $scope.reqBTAccessDetails = {
            "userId" : $scope.userInfo.userId,
            "FirstName" : "",
            "LastName" : "",
            "Email" : "",
            "Title" : "",
            "CompanyName" : "",
            "Number_Of_Employees" : "",
            "Industry" : "",
            "Phone" : "",
            "Describe_the_use_cases_for_bots_E" : "",
            "Does_the_backend_system_have_APIs_E" : "",
            "Do_you_have_access_to_those_APIs_E" : "",
            "How_many_users_would_use_this_bot_E" : "",
            "What_backend_sys_will_bot_interact_E" : "",
            "What_is_the_title_of_budget_owner_E" : "",
            "When_to_purchase_licenses_for_users_E" : "",
            "Who_is_the_budget_owner_E" : "",
            "Why_are_bots_valuable_for_org_E" : ""
        };


        $scope.closeSFBTAccessModal = function() {

            //$location.path("/login");
            $location.path(window.appConfig.CONTEXT_PATH + '/login');

        };

        // Functions
        $scope.submitRequest = submitRequest;
        $scope.logout = logout;

        // variables
        $scope.firstName = '';
        $scope.lastName = '';
        $scope.businessEmail = '';
        $scope.companyName = '';
        $scope.jobTitle = '';
        $scope.message1 = '';
        $scope.message2 = '';
        $scope.message3 = '';
        $scope.error = false;
        $scope.displayMessage = false;
        $scope.message = null;
        $scope.bulbSvg = env_conf['context-url']+'/assets/images/bulbicon.svg';
        $scope.dateField= {
            format:"dd/MM/yyyy",
            title:"License Purchase Date",
            placeholder:"dd/mm/yyyy"
            
        };
                

        var _isFreeDomain = $routeParams.isFreeDomain;

        if (_isFreeDomain && _isFreeDomain === 'true') {
            $scope.message = i18n.i18nString('sf_bt_reqest_only_enterprise_domain_notify');
            $scope.displayMessage = true;
        }

        $(document).on("shown.bs.modal", "#request-bt-access", function(evt) {
           $("body").removeClass("hidebodyscroll");
           $("body").addClass("modal-open");
       });

        activate();

        function activate() {
            $('#request-sf-bt-access').modal({
                backdrop: 'static',
                keyboard: false
            });
            PerfectScrollbar.initialize($('#request-sf-bt-access .modal-body')[0], {
                wheelSpeed: 2,
                wheelPropagation: true,
                minScrollbarLength: 25
            });
        }


        $scope.signUpAndAccessBt = function(){
            
            var _userId = $location.search()['userId'];
            // Send the data to security to sign up.
            // Set up the data to be sent.
            if (_userId) {
                submitRequest(_userId);
            } else {
                var data = {
                    // phone: $scope.reqBTAccessDetails.Phone,
                    emailPhone: $scope.reqBTAccessDetails.Email,
                    firstName: $scope.reqBTAccessDetails.FirstName,
                    lastName: $scope.reqBTAccessDetails.LastName
                };
                security.signUpUser(data, {

                    // Successful login.
                    success: function (value) {
                        submitRequest(value.data.userId);
                    },

                    failure: function (res) {
                        $scope.error = true;
                        $scope.errorMsg = res.data.errors[0].msg;
                    }
                });
            } 
            
        };

        // hit the api
        function submitRequest(userId) {
        	var url = 'mp.user.getSFBTAccess';
            var params = {
                userId: userId
            };
            var payload = {
                // "requestInfo": {
                //     "firstName": $scope.firstName,
                //     "lastName": $scope.lastName,
                //     "emailId": $scope.businessEmail,
                //     "companyName": $scope.companyName,
                //     "jobTitle": $scope.jobTitle,
                //     "message": $scope.message1 + ' \n\n' + $scope.message2 + ' \n\n' + $scope.message3
                // }
            };

            payload = $scope.reqBTAccessDetails;
            payload.userId = userId;

            $translator.translate(url, params, payload).then(
                function(res) {
                    $scope.displayMessage = true;
                    $scope.message =i18n.i18nString('bt_reqst_access_reqst_sent_approval')+' <br>'+i18n.i18nString('bt_reqst_access_notified_through_email');
                },
                function(response) {
                    NotificationService.notify(response.data.errors[0].msg, "error");
                }
            );
        }

        function logout() {
            security.logout();
        }
    }

})();

;
(function (ng) {
    'use strict';
    var _module = ng.module('manage-components', []);
    _module.directive('manageComponentsForm', function () {
        return {
            restrict: 'EA',
            scope: {
                onComplete: '&?',
                wfType: '@?',
                configure: '&?'
            },
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-manage-components/manage-components.html',
            controller: ['$window', '$element', '$rootScope','$scope', '$workflowService', '$location', '$routeParams', 'BTStreamsService', '$q', 'BTAlertsService', 'BTActionsService', 'BTFlowtaskService', '$timeout', 'color', '$filter', '_constants_', 'NotificationService', 'form_util','indexerUtil','accessControlService','env_conf','$applicationService','i18n','mixPanel',
                function ($window, $element, $rootScope, $scope, $workflowService, $location, $routeParams, BTStreamsService, $q, BTAlertsService, BTActionsService, BTFlowtaskService, $timeout, color, $filter, _constants_, NotificationService, form_util, indexerUtil,accessControlService,env_conf,$applicationService,i18n,mixPanel) {
                    var _flowTaskConnectionBlock = $element.find('.flowTaskConnectionBlock');
                    var _flowTaskPropertyPanel = $element.find('.flowTaskPropertyPanel');
                    $scope.constants = _constants_;
                    $scope.assetsBase = env_conf['assets-url'];
                    $scope.stream = angular.copy($workflowService.selectedStream());
                    $scope.selectedBotState = $workflowService.selectedStreamState();
                    if($scope.selectedBotState ==='indevelopment'){
                        $scope.selectedBotState = "configured";
                    }
                    $scope.showLoading = true;
                    $scope.componentsNames = [
                         {'type': 'Intent','name': 'User Intent', 'active': true},
                         {'type': 'Entity','name': 'Entity', 'active': false}, 
                         {'type': 'Service','name': 'Service', 'active': false}, 
                         {'type': 'Script','name': 'Script', 'active': false},
                         {'type': 'Message','name': 'Message', 'active': false}, 
                         {'type': 'dialogact','name': i18n.i18nString('configurable_dialogact_name'), 'active': false}, 
                         {'type': 'SDKWebHook','name':i18n.i18nString('configurable_webhook_name'), 'active': false}, 
                         {'type': 'agentTransfer','name': i18n.i18nString('configurable_agenttransfer_name'), 'active': false},
                         {'type': 'Form','name': i18n.i18nString('configurable_form_name'), 'active': false}, 
                         {'type': 'Logic','name': i18n.i18nString('configurable_logic_name'), 'active': false},
                         {'type': 'botAction','name': i18n.i18nString('configurable_botAction_name'), 'active': false},
                         {'type': 'process','name': i18n.i18nString('configurable_process_name'), 'active': false},
                        ];
                    $scope.componentsCount = {'intent': 0, 'entity': 0, 'service':0, 'script': 0, 'message': 0, 'dialogact': 0, 'sdkwebhook': 0, 'agenttransfer': 0};
                    $scope.flowTasks = $workflowService.dialogTasks();
                    $scope._botComponents = [];
                    $scope._nodes = [];
                    $scope.flowtaskApi={};
                    $scope.flowtaskApi.type = "ManageComponents";
                    /** GET ACCESS VALUE TO SET MODE OF VIEW **/
                     $scope.modeOfAccess = accessControlService.setRetrieveValue();
                     $scope.taskAccess = accessControlService.getAccessRight("BOTBUILDER_TASKS");
                     $scope.faClose = env_conf['context-url']+'/assets/icons/fa-close.svg';
                     $scope.searchIconGray = env_conf['context-url']+'/assets/icons/searchIconGray.svg';
                     $scope.trashIcon = env_conf['context-url']+'/assets/icons/trashIcon.svg';
                     $scope.chevronLeft = env_conf['context-url']+'/assets/icons-new/chevron/chevron-left-gray.svg';
//                    $scope.updateStreamState = function (evn, streamState) {
//                        $scope.selectedBotState = $workflowService.selectedStreamState();
//                        BTFlowtaskService.getComponents($scope.stream._id).then(function (res) {
//                            _botComponents = res && res.data;
//                            $scope.showType(0);
//                            updateDialogEntities();
//                            intialize();
//                            $scope.showType(0);
//                        }, function (error) {
//                            _botComponents = 'error';
//                        });
//                    };
//                    $rootScope.$on("updateStreamState", $scope.updateStreamState);
                     function updateDialogEntities(){
                        $scope.dialogEntities = _.filter(_botComponents, {type:"entity"});
                    }

                     BTFlowtaskService.getComponents($scope.stream._id).then(function (res) {
                        _botComponents = res && res.data;
                        updateDialogEntities();
                    }, function (error) {
                        _botComponents = 'error';
                    });
                    
                    $scope.closeManageComponentsModal = function() {
                        $scope.$emit("updateStep", -1);
                        $scope.$parent.closeFullPageModal();
                        $scope.$parent.modalType = 'createBot';
                        $scope.$parent.callback.onFlowDialogClosed(true);
                    };
                           
                    $scope.unlockDailogComponent = function (node, event) {
                        $scope.currentNode = angular.copy(node);
                        if(event){
                          event.preventDefault();
                        event.stopPropagation();  
                        }
                        if (node && node.flowtasksInvolvedIds) {
                            node.flowtasksInvolvedCount = node.flowtasksInvolvedIds.length;
                        } else {
                            node.flowtasksInvolvedCount = 1;
                        }
                        function confirmUnlock() {
                            var payload = {
                                "resources": [{
                                        "resourceType": "dialogComponent",
                                        "resourceId": node._id
                                    }]
                            };
                            BTStreamsService.unlockDailogComponent($scope.stream._id, payload)
                                    .then(function (response) {
                                        if (response.data[0].status == "FAILURE") {
                                            NotificationService.confirmDialog(i18n.i18nString('manage_components_confirmDialog_nodeType',{nodeType: node.type},{nodeName: node.name}), function () {}, {okText: i18n.i18nString('ok'), noCancelBtn: true});
                                            return;
                                        } else if (response.data[0].status == "SUCCESS") {
                                            BTFlowtaskService.getComponents($scope.stream._id).then(function (res) {
                                                _botComponents = res && res.data;
                                                updateDialogEntities();
                                                intialize();
                                                $scope.showType($scope.currentIndex);
                                                NotificationService.notify(i18n.i18nString('dialog_success'), "success");
                                            }, function (error) {
                                                _botComponents = 'error';
                                            });
                                        }
                                    }, function (error) {
                                        NotificationService.notify(i18n.i18nString('error_label'), "error");
                                    });
                        }
                        function cancleUnlock() {
                            return;
                        }

                        function confirmTaskUnlock() {
                            var resources = [];
                            resources.push({resourceId:node.dialogId || node.flowtasksInvolvedIds[0], resourceType: "dialog"});
                            var requestData = {
                                resources: resources
                            };
                            BTStreamsService.unlockDialog(node.dialogId, _selectedStream._id, requestData)
                                    .then(function (response) {
                                        if (response.data[0].status == "SUCCESS") {
                                            $workflowService.navigateTabIndex(".tasks-pane");
                                            NotificationService.notify(i18n.i18nString('task_unlock'), "success");
                                            $rootScope.$broadcast("loadBots", $workflowService.selectedStream());
                                        }
                                    }, function (error) {
                                         NotificationService.notify(i18n.i18nString('error_label'), "error");
                                    });
                        }
                        function cancleTaskUnlock() {
                            return;
                        }

                        if (node.flowtasksInvolvedCount == 1) {
                            var taskUnLocked = $scope.checkTaskUnlock(node.flowtasksInvolvedIds[0]);
                            if (!taskUnLocked) {
                                NotificationService.userConfirm(i18n.i18nString('flowtask_unlock'), [confirmTaskUnlock, cancleTaskUnlock], {okText: i18n.i18nString('confirm')}, "", undefined, i18n.i18nString('task_lock'));
                            } else {
                                confirmUnlock();
                            }
                        } else {
                            NotificationService.confirmDialog(i18n.i18nString('manage_components_confirmDialog_clone_node',{nodeType: node.type},{nodeName: node.name}), function () {}, {okText: i18n.i18nString('ok'), noCancelBtn: true});
                            return;
                        }
                    };
                    $scope.checkTaskUnlock= function(dailogId){
                        var dailog  = _.find($scope.flowTasks, {_id: dailogId});

                        return dailog.editable;
                    };
                    
               
                    $scope.flowtaskApi.updateManageComponenmts = function(nodeObj){
                       $scope.unlockDailogComponent(nodeObj.nodeDataObj);
                    };
                    $scope.clearSearch =function(){
                             $scope.componentsSearchQuery = '';
                             return;
                         };
                    $scope.showType = function(index) {
                        $scope.currentIndex = index;
                        $scope.componentsNames = [
                            {'type': 'Intent','name': i18n.i18nString('userIntent'), 'active': false},
                            {'type': 'Entity','name': i18n.i18nString('configurable_entity_name'), 'active': false},
                            {'type': 'Service','name': i18n.i18nString('configurable_service_name'), 'active': false}, 
                            {'type': 'Script','name': i18n.i18nString('configurable_script_name'), 'active': false}, 
                            {'type': 'Message','name': i18n.i18nString('constants.nlp_Message'), 'active': false}, 
                            {'type': 'dialogact','name': i18n.i18nString('configurable_dialogact_name'), 'active': false},
                            {'type': 'SDKWebHook','name':i18n.i18nString('configurable_webhook_name'), 'active': false},
                            {'type': 'agentTransfer','name': i18n.i18nString('configurable_agenttransfer_name'), 'active': false},
                            {'type': 'Form','name': i18n.i18nString('configurable_form_name'), 'active': false}, 
                            {'type': 'Logic','name': i18n.i18nString('configurable_logic_name'), 'active': false},
                            {'type': 'botAction','name': i18n.i18nString('configurable_botAction_name'), 'active': false},
                            {'type': 'process','name': i18n.i18nString('configurable_process_name'), 'active': false},
                        ];
                        $scope.componentsNames[index].active = true;
                        var type = $scope.componentsNames[index].type;
                         if(type!=='botAction') {
                            type = type.toLowerCase();
                         }
                        fetchBotComponentsByType(type,function(){
                            $(".manageComponentRightContainer").scrollTop(0);
                            $scope.showLoading = true;
                            
                            $('.row').removeClass("componentSelectedBorder");
                            if($scope.componentsSearchQuery) {
                                $scope.componentsSearchQuery = "";
                            }
                            $scope.propertyCb.closePropertyPanel();
                            $timeout(function () {
                                $scope.showLoading = false;
                            }, 350);
                        });
                    };
                    // BTFlowtaskService.getComponents($scope.stream._id).then(function (res) {
                    //     $scope._botComponents = [];
                    //     if (res && res.data && res.data.length > 0) {
                    //         $.each(res.data, function (k, comp) {
                    //             //if (comp.status === 'configured') {
                    //                 $scope._botComponents.push(comp);
                    //             //}
                    //         });
                    //         $timeout(function () {
                    //             updateComponentsUsage();
                    //         }, 350);

                    //     }
                    // }
                    function fetchBotComponentsByType(type, callback){ 
                        if(type === 'dialogact') {
                            type = 'dialogAct';
                        }
                        if(type === 'sdkwebhook') {
                            type = 'SDKWebHook';
                        }
                        if(type === 'agenttransfer') {
                            type = 'agentTransfer';
                        }

                        var state = "published";
                        if($scope.selectedBotState==='indevelopement' || $scope.selectedBotState==='configured'){
                           state = "configured";
                        }
                        BTFlowtaskService.getComponentsByTypeAndState(_selectedStream._id,type,state).then(function (res) {
                            $scope._botComponents = [];
                            if (res && res.data && res.data.length > 0) {
                                $.each(res.data, function (k, comp) {
                                    if (comp.status === $scope.selectedBotState) {
                                        $scope._botComponents.push(comp);
                                    }
                                });
                                 updateDialogEntities();
                                $timeout(function () {
                                    callback();
                                    updateComponentsUsage();
                                }, 350);
                            }
                        }, function (error) {
                            _botComponents = [];
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('fetch_error'), 'error');
                            }
                        });
                    }
                    
                    function getNodeUsedList(tmpNode) {
                        var flowtaskNames = [];
                        $.each($scope.flowTasks, function (k, task) {
                            $.each(task.nodes, function (k, node) {
                                if(node.type === tmpNode.type && ((node.componentId === tmpNode._id) || (node.componentId===tmpNode.parentId))) {
                                    flowtaskNames.push(task.name);
                                    return false;
                                }
                            });
                              if (task.child && task.child.length) {
                                $.each(task.child[0].nodes, function (k, node) {
                                    if (node.type === tmpNode.type && ((node.componentId === tmpNode._id) || (node.componentId === tmpNode.parentId))) {
                                        flowtaskNames.push(task.name);
                                        return false;
                                    }
                                });
                            }
                        });
                        return _.uniq(flowtaskNames);
                    }
                    function getNodeUsedListIds(tmpNode) {
                        var flowtaskIds = [];
                        $.each($scope.flowTasks, function (k, task) {
                            $.each(task.nodes, function (k, node) {
                                if(node.type === tmpNode.type && node.componentId === tmpNode._id) {
                                    flowtaskIds.push(task._id);
                                    return false;
                                }
                            });
                            });  
                        return flowtaskIds;
                            }
                    function updateComponentsUsage() {
                        $scope._nodes = angular.copy($scope._botComponents);
                        $.each($scope._nodes, function (k, comp) {
                            comp.flowtasksInvolved = getNodeUsedList(comp);
                            comp.flowtasksInvolvedIds = getNodeUsedListIds(comp);
                        });
                        $.each($scope._nodes, function (k, comp) {
                            if(comp.status === $scope.filterToggle) {
                                $scope.componentsCount[comp.type.toLowerCase()] = $scope.componentsCount[comp.type.toLowerCase()]+1;
                            }
                        });
                        $timeout(function () {
                            $scope.showLoading = false;
                        }, 500);
                        $timeout(function () {
                            $(".manageComponentRightContainer").scrollTop(1);
                        }, 750);
                    }
                    
                    var _objList = [];
                    var _objConnection = [];
                    var count = 0;
                    var dummyConnectionCount = 0;
                    var _saveNodeInProgress = false;
                    var _dialogObj = {};
                    var _currentSourceNode = '', _dummyConnectionId = '';
                    var _previousPropertyPanelUid = "";
                    $scope.flowtaskObj = $workflowService.flowtaskInfo() || {};
                    var _selectedStream = $workflowService.selectedStream();                    
                    var errorMessages = $workflowService.seedData().entityErrorMessages[_selectedStream.defaultLanguage] || {};
                    if (errorMessages.string) {
                        errorMessages.label = errorMessages.string;
                    }
                    $scope.runBot = {show : true, hideSubBar : false, fromDialogTask: false};
                    $scope.objList = {};
                    $scope.firstNodeUId = '';
                    $scope.firstNodeComponentId = '';
                    $scope.selectedNode = '';
                    $scope.isPropertyPanelOpened = false;
                    $scope.isDebugConsolePanelOpened = false;
                    $scope.nodeObjList = [];
                    $scope.isConnecting = false;
                    $scope.nodeObj = {};
                    $scope.nodeObjLabels = {};
                    $scope.isDebugResized = 0;
                    $scope.serviceTypeList = [
                        { name: "REST", value: "rest" },
                        { name: "SOAP", value: "soap" }
                    ];
                    $scope.messagesObject = null;
                    $scope.isPrompt = true;
                    $scope.utterences = [];
                    $scope.authCB = {};
                    $scope.btTestFormApi = {};
                    $scope.btTestStatus = {};
                    $scope.notifierBridge = {};
                    $scope.notiRefs = {};
                    $scope.notiRefs.tempConnections = [];
                    $scope.objListSearch = [];
                    $scope.searchText = '';
                    $scope.searchUId = '';
                    $scope.runBot.hideSubBar = false;
                    $scope.dialogMode = null;
                    $scope.displayMode = 'edit';
                    $scope._constants_ = $rootScope._constants_;
                    $scope.isWorkProgress = false;
                    $scope.loaderMessage = i18n.i18nString('working_on_it');
                    $scope.importDialogHeader = i18n.i18nString('import_dialog_desc');
                    $scope.importModalTitle =i18n.i18nString('bt_streams_a_dialog');
                    $scope.doneImporting = false;
                    $scope.dialogRequiredError = false;
                    var _connectionColors = [
                        "#299d8e", "#5ea8d3", "#e9c369", "#f3a261", "#533a71",
                        "#6183d8", "#50c5b7", "#7ac74f", "#1c77c3", "#9f86c0"
                    ];
                    $scope.botColor = _selectedStream.color;
                    $scope.selectedStreamName = _selectedStream.name;
                    $scope.configurableElements = {
                        'message': { type: 'message', name: i18n.i18nString('bot_response'), description: i18n.i18nString('configurable_msg_desc'), shortDesc: i18n.i18nString('manage_components_send_a_msg'), showCreate: true },
                        'dialogAct': { type: 'dialogAct', name: i18n.i18nString('confirmation'), description: i18n.i18nString('configurable_dialogact_desc'), shortDesc: i18n.i18nString('manage_components_confirmation_short_desc'), showCreate: true },
                        'entity': { type: 'entity', name: i18n.i18nString('entity'), description: i18n.i18nString('manage_components_entity_desc'), shortDesc: i18n.i18nString('manage_components_entity_shortdesc'), showCreate: true },
                        'form': { type: 'form', name: i18n.i18nString('form_node_name'), description: i18n.i18nString('configurable_form_desc'), shortDesc: i18n.i18nString('configurable_form_name'), showCreate: true },
                        'logic': { type: 'logic', name: i18n.i18nString('logic_node_name'), description: i18n.i18nString('configurable_logic_desc'), shortDesc: i18n.i18nString('configurable_logic_name'), showCreate: true },
                        'service': { type: 'service', name: i18n.i18nString('service'), description: i18n.i18nString('configurable_service_desc'), shortDesc: i18n.i18nString('manage_components_servicecall_short_desc'), showCreate: true },
                        'script': { type: 'script', name: i18n.i18nString('script'), description: i18n.i18nString('configurable_script_desc'), shortDesc: i18n.i18nString('manage_components_jsscript_short_desc'), showCreate: true },
                        'subDialog': { type: 'subDialog', name: i18n.i18nString('dialog'), description: i18n.i18nString('configurable_subdialog_desc'), shortDesc: i18n.i18nString('manage_components_dialog_short_desc'), showCreate: false },
                        'SDKWebHook': { type: 'SDKWebHook', name: i18n.i18nString('webhook_uppercase'), description: i18n.i18nString('configurable_webhook_desc'), shortDesc: i18n.i18nString('manage_components_webhook_short_desc'), showCreate: true },                       
                        'intent': { type: 'intent', name: i18n.i18nString('userintent'), description: i18n.i18nString('configurable_intent_desc'), shortDesc: i18n.i18nString('manage_components_userIntent_short_desc'), showCreate: true }
                    };
                    
                    if (!$rootScope.appConfig.DISABLE_AGENT_TRANSFER) {
                        $scope.configurableElements.agentTransfer = {type: 'agentTransfer', name: i18n.i18nString('agent_transfer_uppercase'), description: i18n.i18nString('configurable_agenttransfer_desc'), shortDesc: i18n.i18nString('manage_components_agentTransfer_short_desc'), showCreate: true};
                    }
                    
                    var _nodeObj = {
                        type: '',
                        name: '',
                        uId: '',
                        connections: {},
                        tempConnections: {},
                        hide: true,
                        desc: "",
                        componentId: '',
                        nodeNumber: 0
                    };
                    var _connObj = {
                        connId: '',
                        sourceId: '',
                        targetId: '',
                        isDefault: false,
                        ifConditionPrefix: 'context',
                        ifCondition: '',
                        ifOperator: '',
                        value: '',
                        color: '#009dab',
                        top: 0,
                        showBottom: false,
                        connObjNumber: 1
                    };
                    var _ifOperatorList = {
                        '=': { name: "equals to", val: "=" },
                        ">=": { name: "greater than equals to", val: ">=" },
                        "<=": { name: "less than equals to", val: "<=" },
                        "!=": { name: "not equals to", val: "!=" },
                        ">": { name: "greater than", val: ">" },
                        "<": { name: "less than", val: "<" },
                        "": { name: "exists", val: "" },
                        'eq': { name: 'equals to', val: '=' },
                        'gte': { name: "greater than equals to", val: ">=" },
                        'lte': { name: "less than equals to", val: "<=" },
                        'neq': { name: "not equals to", val: "!=" },
                        'gt': { name: "greater than", val: ">" },
                        'lt': { name: "less than", val: "<" }
                    };
                    var resetFlag;
                    var _botComponents = [];
                    // Changing colors for the nodes
                    var _nodeColors = {
                        'subDialog': '#eaa724',
                        'intent': '#57187f',
                        'entity': '#3ab962',
                        'script': '#9b9b9b',
                        'SDKWebHook': '#8B572A',
                        'agentTransfer': '#8B572A',
                        'service': '#4a4a4a',
                        'message': '#007eff',
                        'dialogAct': '#1d758e'
                    };
                    $element.connections({ action: 'updateColors', nodeColors: _nodeColors });
                    $scope.displayOpts = {
                        "hideType": false,
                        "hideNode": false,
                        "hideConn": false
                    };
                    $scope.serviceNodeOptions=[
                        {'value': 'custom','name': $scope._constants_.flowtasks.serviceTypes.custom},
                        {'value': 'htmltoimage','name': $scope._constants_.flowtasks.serviceTypes.htmlToImage},
                        {'value': 'urltoimage','name': $scope._constants_.flowtasks.serviceTypes.urlToImage}
                    ];
                    
                    $scope.ifOperatorsFollowupIntents = [
                        {name: "Contains", val: "cnt"},
                        //{name: "Does Not Contain", val: "ncnt"},
                        {name: "Exists", val: ""} //should have some value but to make it backward compatable using the above ifOperatorList value for Exists as ""
                        //{name: "Does Not Exist", val: "nex"}
                    ];
                    
                    var _defaultIVRProps = $workflowService.defaultComponentIVRProps();

                    $scope.flowtaskApi.getIVRDefaults = function () {
                        return _defaultIVRProps;
                    };  
                    
                    $scope.flowtaskApi.getIfOperatorsFollowupIntents = function() {
                        return  $scope.ifOperatorsFollowupIntents;
                    };
                    // Initialization function 
                    function intialize() {
                        _objList = [];
                        _objConnection = [];
                        count = 0;
                        dummyConnectionCount = 0;
                        _saveNodeInProgress = false;
                        _dialogObj = {};
                        _currentSourceNode = '';
                        _dummyConnectionId = '';
                        $scope.runBot.show = true;
                        $scope.objList = {};
                        $scope.firstNodeUId = '';
                        $scope.selectedNode = '';
                        $scope.isPropertyPanelOpened = false;
                        $scope.isDebugConsolePanelOpened = false;
                        $scope.nodeObjList = [];

                        $scope.nodeObj = {};
                        $scope.nodeObjLabels = {};

                        if (resetFlag) {
                            $scope.introObj = { screenshots: [] };
                            $scope.introObj.needsAuth = false;
                        }

                        $scope.streamId = _selectedStream._id;
                        setDataForEdit();
                        $timeout(function () {
                            $element.find('.flowTaskPropertyPanel').draggable({
                                handle: ".property-panel-header",
                                containment: ".dialogFieldset",
                                drag: ondragging,
                                stop: onPanelDragStop
                            }).resizable({
                                containment: ".dialogFieldset",
                                minWidth: 500,
                                maxWidth: 700,
                                handles: "e, w"
                            });

                            $element.find('.flowTaskPropertyPanel').css('top', '5px').css('right', '5px').css('left', 'auto');
                        });
                    }
                    intialize();
                    function setDataForEdit() {
                        $.each($scope.flowTasks, function (k, _dialogObj) {
                            BTFlowtaskService.getFlowtaskComponents($scope.streamId, _dialogObj._id).then(function (res) {
                                var _res = res && res.data || [];
                                var _tempComponents = {};
                                $.each(_res, function (k, component) {
                                    _tempComponents[component._id] = component;
                                });
                                $.each(_dialogObj.nodes, function (k, node) {
                                    var _tempNodeObj = _tempComponents[node.componentId];
                                    if (_tempNodeObj && _tempNodeObj.name) {
                                        $scope.objList[node.componentId] = $.extend(true, {}, _nodeObj, {
                                            type: _tempNodeObj.type,
                                            name: _tempNodeObj.name,
                                            uId: node.nodeId,
                                            desc: _tempNodeObj.desc,
                                            metadata: node.metadata,
                                            componentId: _tempNodeObj._id,
                                            nodeOptions: node.nodeOptions
                                        });
                                        if (_tempNodeObj.type === 'intent') {
                                            $scope.objList[node.componentId].flowTaskId = node.flowTaskId;
                                            $scope.objList[node.componentId].intent = _tempNodeObj.intent;
                                            if (node.contextMap) {
                                                if (node.contextMap.constructor === String) {
                                                    try {
                                                        $scope.objList[node.componentId].contextMap = JSON.parse(node.contextMap);
                                                    } catch (e) {
                                                        $scope.objList[node.componentId].contextMap = {};
                                                    }
                                                } else {
                                                    $scope.objList[node.componentId].contextMap = node.contextMap;
                                                }
                                            }
                                        }
                                        $scope.objList[node.componentId].nodeTypeName = $scope.configurableElements[_tempNodeObj.type] ? $scope.configurableElements[_tempNodeObj.type].name : 'unknown';
                                        if (node.transitions && node.transitions.length > 0) {
                                            var connectionNum = 1;
                                            $.each(node.transitions, function (l, transition) {
                                                var _tempConnId = transition.metadata && transition.metadata.connId ? transition.metadata.connId : 'dummy' + dummyConnectionCount;
                                                dummyConnectionCount++;
                                                var _tempConnObj = {
                                                    connId: _tempConnId,
                                                    sourceId: node.componentId,
                                                    targetId: transition.default !== undefined ? transition.default : transition.then,
                                                    isDefault: transition.default !== undefined ? true : false
                                                };
                                                transition.if = transition.if || {};
                                                _tempConnObj.ifConditionPrefix = transition.if.intent !== undefined ? 'intent' : transition.if.field !== undefined ? 'field' : 'context';
                                                if (node.type === 'dialogAct') {
                                                    _tempConnObj.ifConditionPrefix = 'dialogAct';
                                                    _tempConnObj.ifOperator = '';
                                                    _tempConnObj.value = '';
                                                    if (_tempConnObj.isDefault) {
                                                        _tempConnObj.ifCondition = 'no';
                                                        delete transition.if;
                                                    } else {
                                                        _tempConnObj.ifCondition = 'yes';
                                                    }
                                                } else {
                                                    if (transition.default !== undefined) {
                                                        _tempConnObj.ifCondition = '';
                                                        _tempConnObj.ifOperator = '';
                                                        _tempConnObj.value = '';
                                                        delete transition.if;
                                                    } else {
                                                        if (transition.if.field !== undefined) {
                                                            _tempConnObj.ifCondition = transition.if.field || '';
                                                        } else if (transition.if.intent !== undefined) {
                                                            _tempConnObj.ifCondition = transition.if.intent || '';
                                                        } else {
                                                            _tempConnObj.ifCondition = transition.if.context || '';
                                                        }
                                                        _tempConnObj.ifOperator = transition.if.op || '';
                                                        _tempConnObj.value = transition.if.value || '';
                                                    }
                                                }
                                                if (transition.metadata && transition.metadata.color) {
                                                    _tempConnObj.color = transition.metadata.color;
                                                } else {
                                                    _tempConnObj.color = _connectionColors[l > 0 ? l : 0];
                                                    if (transition.metadata) {
                                                        _dialogObj.nodes[k].transitions[l].metadata.color = _tempConnObj.color;
                                                    } else {
                                                        _dialogObj.nodes[k].transitions[l].metadata = {
                                                            color: _tempConnObj.color
                                                        };
                                                    }
                                                }
                                                $scope.objList[node.componentId].connections[_tempConnId] = $.extend(true, {}, _connObj, _tempConnObj);
                                                _tempConnObj.connObjNumber = connectionNum;
                                                _objConnection.push($.extend(true, {}, _connObj, _tempConnObj));
                                                connectionNum++;
                                                var _tempConn = _tempConnId.replace('dummy', '');
                                                if (!isNaN(_tempConn)) {
                                                    if (parseInt(_tempConn) > dummyConnectionCount) {
                                                        dummyConnectionCount = parseInt(_tempConn) + 5;
                                                    }
                                                }
                                            });
                                        }
                                        _objList.push($.extend({}, _tempNodeObj, { nodeId: node.nodeId }));
                                    }
                                    // Get nodes largest Number
                                    var _nodeNumber = node.nodeId.replace(node.type, '');
                                    if ($scope.objList[node.componentId]) {
                                        $scope.objList[node.componentId].nodeNumber = parseInt(_nodeNumber) + 1;
                                    }
                                    if (!isNaN(_nodeNumber)) {
                                        if (parseInt(_nodeNumber) > count) {
                                            count = parseInt(_nodeNumber);
                                        }
                                    }
                                });
                                count++;
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify(i18n.i18nString('some_error_occured'), 'error');
                                }
                                $scope.closeManageComponentsModal();
                            });
                            });
                    }
                    function onPanelDragStop(e, u) {
                        if (e.target) {
                            var _parentEle = $element.find('.flowTaskConnectionBlock');
                            var _ele = $(e.target);
                            var _right = parseInt(_parentEle.width()) - u.position.left - parseInt(_ele.width());
                            _ele.css('right', _right + 'px');
                            _ele.css('left', 'auto');
                        }
                    }
                    function ondragging(e, u) {
                        if (u.position.top < 0) {
                            u.position.top = 0;
                        }
                        var _parentEleDrag = $element.find('.manageComponentRightContainer');
                        var _propertyPanelEle = $('.flowTaskPropertyPanel');
                        if(_parentEleDrag && _propertyPanelEle) {
                            var _parentHeight = _parentEleDrag.height();
                            var _propertyPanelEleHeight = _propertyPanelEle.height();
                            if((_propertyPanelEleHeight + u.position.top) > _parentHeight) {
                                u.position.top = 10;
                            }
                        }
                    }
                    $scope.editPrompt = function editPrompt(messages, isPrompt, openIndex,category) {
                        
                        if ($scope.displayMode === 'view') {
                            return false;
                        }
                        $scope.messagesObject = {};
                        $scope.isPrompt = isPrompt;
                        $scope.messagesObject.messages = {};
                        $scope.messagesObject.taskId = _dialogObj._id;
                        $scope.messagesObject.nodeId = $scope.selectedNode.nodeInfo._id;
                        $scope.messagesObject.name = $scope.selectedNode.nodeInfo.name;
                         $scope.messagesObject.nodeInfo = $scope.selectedNode.nodeInfo;
                        $scope.messagesObject.category = category;
                        $scope.dialogMode = "prompt";
                        $timeout(function () {
                            $scope.messagesObject = {};
                            $scope.isPrompt = isPrompt;
                            messages.forEach(function (message) {
                                message.text = decodeURIComponent(message.text);
                            });
                            $scope.messagesObject.messages = angular.copy(messages);
                            $scope.messagesObject.taskId = _dialogObj._id;
                            $scope.messagesObject.nodeId = $scope.selectedNode.nodeInfo._id;
                            $scope.messagesObject.name = $scope.selectedNode.nodeInfo.name;
                            $scope.messagesObject.nodeInfo = $scope.selectedNode.nodeInfo;
                            $scope.messagesObject.category = category;
                            if(openIndex && openIndex !== -1) {
                                $scope.messagesObject.openIndex = openIndex;
                            }
                            $scope.messagesObject.nodeInfo.nodeInfo = {
                                "editLocked": $scope.selectedNode.nodeInfo.editLocked
                            };
                            $timeout(function () {
                                $('#userprompt_configure').modal({
                                    backdrop: 'static',
                                    show: true
                                });
                            }, 250);
                        }, 100);
                    };
                    $scope.onPromptClose = function () {
                        $('#userprompt_configure').modal('hide');
                        $scope.dialogMode = null;
                    };
                    $scope.onDone = function (messages,multiCategory,promptType) {
                        $('#userprompt_configure').modal('hide');
                        $scope.dialogMode = null;
                        if(promptType && promptType==='submit'){
                            $scope.selectedNode.nodeInfo.submitMessage = angular.copy(messages);
                            messages.forEach(function (message) {
                                message.text = encodeURIComponent(message.text);
                            });
                            var x4 = $scope.propertyCb.updateSubmitMessages && $scope.propertyCb.updateSubmitMessages(messages);
                            $scope.selectedNode.nodeInfo.submitMessage = angular.copy(messages);
                        }else if(multiCategory) {
                              $scope.selectedNode.nodeInfo.multiCategoryPrompts = multiCategory;
                                var x2 = $scope.propertyCb.updateMulticategoryMessages && $scope.propertyCb.updateMulticategoryMessages(messages);  
                            
                        }
                        else{
                            $scope.selectedNode.nodeInfo.message = angular.copy(messages);                            
                            messages.forEach(function (message) {
                                message.text = encodeURIComponent(message.text);
                            });
                            var x1 = $scope.propertyCb.updateMessages && $scope.propertyCb.updateMessages(messages);
                            $scope.selectedNode.nodeInfo.message = angular.copy(messages);

                        }
                        //saveUserPrompts(messages);
                    };
                    
                    $scope.editError = function editError(errors,openIndex,category) {
                        if ($scope.displayMode === 'view') {
                            return false;
                        }
                        $scope.errorObject = {};
                        $scope.errorObject.errors = {};
                        $scope.errorObject.taskId = _dialogObj._id;
                        $scope.errorObject.nodeId = $scope.selectedNode.nodeInfo._id;
                        $scope.errorObject.name = $scope.selectedNode.nodeInfo.name;
                        $scope.dialogMode = "error";
                        $scope.errorObject.nodeInfo = $scope.selectedNode.nodeInfo;
                        $scope.errorObject.category = category;
                        if(openIndex && openIndex !== -1) {
                            $scope.errorObject.openIndex = openIndex;
                        }
                        $scope.errorObject.nodeInfo.nodeInfo = {
                            "editLocked": $scope.selectedNode.nodeInfo.editLocked
                        };
                        $timeout(function () {
                            $scope.errorObject = {};
                            errors.forEach(function (message) {
                                message.text = decodeURIComponent(message.text);
                            });
                            $scope.errorObject.errors = angular.copy(errors);
                            $scope.errorObject.taskId = _dialogObj._id;
                            $scope.errorObject.nodeId = $scope.selectedNode.nodeInfo._id;
                            $scope.errorObject.name = $scope.selectedNode.nodeInfo.name;
                            $scope.errorObject.nodeInfo = $scope.selectedNode.nodeInfo;
                            $scope.errorObject.category = category;
                            if(openIndex && openIndex !== -1) {
                                $scope.errorObject.openIndex = openIndex;
                            }
                            $scope.errorObject.nodeInfo.nodeInfo = {
                                "editLocked": $scope.selectedNode.nodeInfo.editLocked
                            };
                            $timeout(function () {
                                $('#errorprompt_configure').modal({
                                    backdrop: 'static',
                                    show: true
                                });
                            }, 250);
                        }, 100);
                    };

                    $scope.onErrorPromptClose = function () {
                        $('#errorprompt_configure').modal('hide');
                        $scope.dialogMode = null;
                    };
                    $scope.onErrorPromptDone = function (messages,multiCategory) {
                        $('#errorprompt_configure').modal('hide');
                        $scope.dialogMode = null;
                        //saveErrorPrompts(messages);
                        if(multiCategory) {
                                $scope.selectedNode.nodeInfo.multiCategoryPrompts = angular.copy(multiCategory);
                                var x2 = $scope.propertyCb.updateMulticategoryMessages && $scope.propertyCb.updateMulticategoryMessages(messages);                           
                            
                        }
                        else{
                            $scope.selectedNode.nodeInfo.errorMessage = angular.copy(messages);
                            messages.forEach(function (message) {
                                message.text = encodeURIComponent(message.text);
                            });
                            var x1 = $scope.propertyCb.updateErrorMessages && $scope.propertyCb.updateErrorMessages(messages);
                            $scope.selectedNode.nodeInfo.errorMessage = angular.copy(messages);
                        }
                    };

                    $scope.getNodeMessages = function (component, checkType) {
                        var _msg = '';
                        if (component && component.componentId) {
                            $.each(_objList, function (k, obj) {
                                if (obj._id === component.componentId) {
                                    if (checkType && obj.message && obj.message[0] && obj.message[0].type === 'uxmap') {
                                        _msg = 'Custom Javascript';
                                    } else if (obj.message) {
                                        try {
                                            _msg = decodeURIComponent(obj.message[0] && obj.message[0].text);
                                        } catch(e) {
                                            _msg = obj.message[0] && obj.message[0].text || '';
                                        }
                                    }
                                    return false;
                                }
                            });
                        }
                        return _msg;
                    };

                    function getUtterances(componentId) {   
                        if (componentId) {
                            BTStreamsService.getUtterances(componentId, $scope.utterences.length, 10, "").then(function (res) {
                                $timeout(function(){
                                var x = $scope.propertyCb.updateUtterance && $scope.propertyCb.updateUtterance(res);
                               }, 300);
                            }, function (error) {
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify(i18n.i18nString('getting_utterance'), 'error');
                                }
                            });
                        }
                    }
                    function encodeJS(_obj) {
                        return encodeURIComponent(_obj);
                    }
                    function saveUserPrompts(messages) {
                        var _tempMessage = [];
                        if (messages && messages.length > 0) {
                            $.each(messages, function (k, message) {
                                var _tempMessageObject = {
                                    channel: message.channel,
                                    text: encodeJS(message.text),
                                    type: message.type,
                                    _id: message._id
                                };

                                if (_tempMessageObject.channel === "wfacebook") {
                                    _tempMessageObject.isMention = message.isMention;
                                }

                                _tempMessage.push(_tempMessageObject);
                            });
                        }
                        var payload = {
                            name: $scope.selectedNode.nodeInfo.name,
                            message: _tempMessage
                        };
                        BTFlowtaskService.updateComponent($scope.streamId, $scope.selectedNode.nodeInfo._id, payload).then(function (res) {
                            if (res && res.data) {

                                $.each(messages, function (k, message) {
                                    message._id = res.data.message[k];
                                });

                                res.data.message = messages;
                                $scope.selectedNode.nodeInfo = res.data;
                                $scope.dialogData("updateComponent", res.data);
                                if($scope.isPrompt){
                                    NotificationService.notify(i18n.i18nString('prompts_updated'), 'info');
                                }
                                else{
                                    NotificationService.notify(i18n.i18nString('bot_res_updated'), 'info');
                                }
                            }
                        }, function (error) {
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                if($scope.isPrompt){
                                    NotificationService.notify(i18n.i18nString('prompts_failed'), 'error');
                                }
                                else{
                                    NotificationService.notify(i18n.i18nString('bot_res_failed'), 'error');
                                }
                            }
                        });
                    }
                    function mixPanelUpdateEvent(componentData,dialog){
                        componentData =  $scope.selectedNode.nodeInfo || {};
                        var _eventPayload = {
                            streamId:$workflowService.selectedStream()._id,
                            BotName:$workflowService.selectedStream().name,
                            "Component Name":componentData.intent || componentData.name,
                            "Dialog Version":'V2',
                            "Category":"Engagement L2",
                            "Sub Category":"Conversation - Dialog Task",
                            "Level":"Engagement L2",
                            "Primary Intent creation mode":"Storyboard"
                         };
                         var event =  "";
                         if(componentData.type === 'intent'){
                            event = "Conversation - Dialog Intent updated";
                         } else if(componentData.type === 'message'){
                           event = "Conversation - Dialog Message Node updated";
                         } else if(componentData.type === 'entity'){
                            event="Conversation - Dialog Entity Node updated";
                         } else if(componentData.type === 'dialogAct'){
                            event="Conversation - Dialog Confirmation Node updated";
                        } else if(componentData.type === 'service'){
                            event="Conversation - Bot action Service updated";
                        } else if(componentData.type === 'script'){
                            event="Conversation - Bot action Script updated";
                        } else if(componentData.type === 'logic'){
                            event="Conversation - Bot action Logic updated";
                        } else if(componentData.type === 'SDKWebHook'){
                            event="Conversation - Bot action Webhook updated";
                        }else if(componentData.type === 'process'){
                            event="Conversation - Bot action Process updated";
                        }else if(componentData.type === 'agentTransfer'){
                            event="Conversation - Agent Transfer node updated";
                        }else if(componentData.type === 'form'){
                            event="Conversation - Form node updated";
                        } else if(componentData.type === 'botAction'){
                          event="componentData - Bot action Node updated";
                        }
                        if(event){
                            mixPanel.postEvent(event,_eventPayload);
                        }
                    }

                    function saveErrorPrompts(messages) {
                        var _tempMessage = [];
                        if (messages && messages.length > 0) {
                            $.each(messages, function (k, message) {
                                _tempMessage.push({
                                    channel: message.channel,
                                    text: encodeJS(message.text),
                                    type: message.type,
                                    _id: message._id
                                });
                            });
                        }
                        var payload = {
                            name: $scope.selectedNode.nodeInfo.name,
                            errorMessage: _tempMessage
                        };
                        BTFlowtaskService.updateComponent($scope.streamId, $scope.selectedNode.nodeInfo._id, payload).then(function (res) {
                            if (res && res.data) {
                                mixPanelUpdateEvent();
                                $.each(messages, function (k, message) {
                                    message._id = res.data.message[k];
                                });

                                res.data.errorMessage = messages;
                                $scope.selectedNode.nodeInfo = res.data;
                                $scope.dialogData("updateComponent", res.data);
                                NotificationService.notify(i18n.i18nString('errors_updated'), 'info');
                            }
                        }, function (error) {
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('prompts_failed'), 'error');
                            }
                        });
                    }
                    function checkIfSingleComponent () {
                        if (Object.keys($scope.objList).length === 1) {
                            $scope.selectCurrentNode($scope.firstNodeUId);
                        }
                    }
                    $scope.getNodeName = function (nodeId) {
                        return $scope.objList[nodeId] ? $scope.objList[nodeId].name : nodeId;
                    };
                    // Select node on double click - Property panel triggers from here
                    $scope.selectCurrentNode = function (uId, type, node, event) {
                        $timeout(function () {
                            $scope.propertyCb.startPropertyPanelAnimate(type);
                        }, 500);
                        _flowTaskPropertyPanel.css('width', Math.floor(_flowTaskConnectionBlock.width() * 0.6));
                        _flowTaskPropertyPanel.removeClass('minimized');
                        $scope.isExpanded = true;
                        $scope.isMinimized = false;
                        if(event) {
                            var _ele = event.currentTarget;
                            $('.row').removeClass("componentSelectedBorder");
                            _ele.className = _ele.className + " componentSelectedBorder";
                        }
                        if(!node) {
                            node = $scope.selectedNode.nodeInfo;
                        }
                        var _refId = '';
                        $scope.selectedNode = "";
                        $timeout(function () {
                            $scope.$apply();
                        }, 50);
                        var _sendObj = {
                            openSection: type,
                            nodeInfo: {},
                            dialogNodeInstance: {},
                            dialogInfo: {
                                dialogId: '',
                                dummyConnCount: '',
                                currentEntities: [],
                                currentIntents: [],
                                firstNodeId: $scope.firstNodeUId,
                                firstNodeComponentId: $scope.firstNodeComponentId
                            },
                            //displayMode: (node.status === 'published'?'view':'edit'), /* overriding view mode status */
                            displayMode: ($scope.modeOfAccess === 'VIEW'?'view':'edit')
                        };
                        _sendObj.nodeDataObj = node; 
                        _sendObj.dialogInfo.dialogId = node.dialogId?node.dialogId:node.flowtasksInvolvedIds[0];
                        $.each($scope.objList, function (k, obj) {
                            var _tempNodeId = uId;  // added only to identify a match from object list since obj list has published nodes data 
//                            if(node && node.parentId){
//                                _tempNodeId = node.parentId;
//                            }
                            if (obj.componentId === _tempNodeId) {
                                obj.isSelected = true;
                                _sendObj.dialogNodeInstance = JSON.parse(JSON.stringify(obj)); // need to verify the call by reference method
                                _refId = obj.componentId;
                                _previousPropertyPanelUid = uId;
                            } else {
                                obj.isSelected = false;
                            }
                        });
                        $.each(_objList, function (k, obj) {
                            if (obj._id === _refId) {
                                _sendObj.nodeInfo = obj;
                                if (obj.type === 'intent') {
                                    $scope.utterences = [];
                                    getUtterances(_sendObj.nodeDataObj._id);
                                }
                            }
                            if (obj.type === 'entity') {
                                _sendObj.dialogInfo.currentEntities.push({
                                    name: obj.name,
                                    compId: obj._id,
                                    uId: obj.nodeId,
                                    unitType:obj.unitType,
                                    defaultUnit: obj.defaultUnit
                                });
                            }
                            if (obj.type === 'intent') {
                                _sendObj.dialogInfo.currentIntents.push({
                                    name: obj.name,
                                    compId: obj._id,
                                    uId: obj.nodeId
                                });
                            }
                        });
                        $scope.isPropertyPanelOpened = true;
                        if (node.type === 'intent') {
                            _sendObj.dialogInfo.currentIntents.push({
                                name: node.name,
                                compId: node._id,
                                uId: node._id
                            });
                            _sendObj.dialogInfo.firstNodeId = _sendObj.dialogNodeInstance.uId;
                        }
                        if($.isEmptyObject(_sendObj.nodeInfo)) {
                            _sendObj.nodeInfo = node;
                            _sendObj.dialogNodeInstance = JSON.parse(JSON.stringify(node));
                        }
                        $timeout(function () {
                            $scope.selectedNode = _sendObj;
                            $timeout(function () {
                                angular.element($window).trigger('resize');
                            }, 350);
                        }, 200);
                        $.each($scope.flowTasks, function (k, task) {
                            if(task._id === node.dialogId) {
                                _dialogObj = task;
                            }
                        });
                    };
                    $scope.propertyCb = {};
                    $scope.getTraitsGroupsApi = function () {
                        BTStreamsService.getTraitGroups($applicationService.userInfo().userId,$workflowService.selectedStream()._id).then(function (res) {
                            $scope.traitGroups = angular.copy(res.data);
                            $scope.propertyCb.allTraits=[];
                            var alltraitsArr=[];
                            $.each($scope.traitGroups,function(i,traits){
                                $.each(traits.traits,function(j,trait){
                                    var obj = {
                                    'groupId': traits._id,
                                    'traitId': trait.traitId || j,
                                    'traitName': trait.traitName
                                    };
                                    alltraitsArr.push(trait.traitName);
                                });
                            });
                            $scope.propertyCb.allTraits = _.uniq(alltraitsArr);
                        },
                            function (err) {
                                $scope.loadingTraits = false;
                                NotificationService.notify(i18n.i18nString('failed_traits'), 'error');
                            });
                    };
                    $scope.getTraitsGroupsApi();
                    $scope.propertyCb.closePropertyPanel = function () {
                        $scope.isPropertyPanelOpened = false;
                        $element.find('.flowTaskPropertyPanel').css('width', '');
                        $scope.selectedNode = "";
                        $('.row').removeClass("componentSelectedBorder");
                        //$scope.selectCurrentNode();
                    };
                    $scope.dialogData = function dialogData(type, data) {
                        var _uId = $scope.selectedNode.dialogNodeInstance.uId;
                        var _componentId = $scope.selectedNode.dialogNodeInstance.componentId;
                        if (type === 'updateDialog') {
                            if (data && data._id === _dialogObj._id) {
                                _dialogObj = data;
                                $.each($scope.flowTasks, function (k, task) {
                                    if(data._id ===task._id) {
                                        task = data;
                                    }
                                });
                                BTFlowtaskService.getComponents($scope.stream._id).then(function (res) {
                                    $scope._botComponents = [];
                                    if (res && res.data && res.data.length > 0) {
                                        $.each(res.data, function (k, comp) {
                                            if (comp.status === $scope.selectedBotState) {
                                                $scope._botComponents.push(comp);
                                            }
                                        });
                                         updateDialogEntities();
                                    }
                                }, function (error) {
                                    if (error && error.data && error.data.errors) {
                                        var _msg = error.data.errors[0].msg;
                                        NotificationService.notify(_msg, 'error');
                                    } else if (error.errors && _.isArray(error)) {
                                        var msg = error.errors[0].msg;
                                        NotificationService.notify(msg, 'error');
                                    } else {
                                        NotificationService.notify(i18n.i18nString('err_while_updating_components'), 'error');
                                    }
                                });
                                
                                // updating _objList
                                var _tempConnObj = {}, _tempDefaultConnection = {};
                                $.each(data.nodes, function (k, node) {
                                    if (_uId === node.nodeId) {
                                        $.each(node.transitions, function (k, transition) {
                                            var _connection = $.extend(true, {}, _connObj);
                                            if (transition && transition.metadata && transition.metadata.connId) {
                                                _connection.connId = transition.metadata.connId;
                                            } else {
                                                dummyConnectionCount++;
                                                _connection.connId = 'dummy' + dummyConnectionCount;
                                            }
                                            _connection.sourceId = node.nodeId;
                                            if (transition.if === undefined) {
                                                transition.if = {};
                                            }
                                            _connection.ifConditionPrefix = transition.if.dialogAct !== undefined ? 'dialogAct' : transition.if.intent !== undefined ? 'intent' : transition.if.field !== undefined ? 'field' : 'context';
                                            if (transition.default === undefined) {
                                                _connection.isDefault = false;
                                                _connection.targetId = transition.then;
                                                if (_connection.ifConditionPrefix === 'dialogAct') {
                                                    _connection.ifCondition = transition.if.dialogAct || 'yes';
                                                    _connection.ifOperator = '';
                                                    _connection.value = '';
                                                } else if (_connection.ifConditionPrefix === 'intent') {
                                                    _connection.ifCondition = transition.if.intent || '';
                                                    _connection.ifOperator = '';
                                                    _connection.value = '';
                                                } else if (_connection.ifConditionPrefix === 'field') {
                                                    _connection.ifCondition = transition.if.field;
                                                    _connection.ifOperator = transition.if.op || '';
                                                    _connection.value = transition.if.value || '';
                                                } else {
                                                    _connection.ifCondition = transition.if.context || '';
                                                    _connection.ifOperator = transition.if.op || '';
                                                    _connection.value = transition.if.value || '';
                                                }
                                            } else {
                                                _connection.targetId = transition.default;
                                                _connection.isDefault = true;
                                                delete transition.if;
                                            }
                                            if (transition.metadata) {
                                                _connection.color = transition.metadata.color || _connection.color;
                                            }
                                            if (_connection.isDefault) {
                                                _tempDefaultConnection[_connection.connId] = _connection;
                                                _tempDefaultConnection[_connection.connId].connObjNumber = k + 1;
                                            } else {
                                                _tempConnObj[_connection.connId] = _connection;
                                                _tempConnObj[_connection.connId].connObjNumber = k + 1;
                                            }
                                        });
                                        if ($scope.objList[_componentId]) {
                                            $scope.objList[_componentId].nodeOptions = node.nodeOptions;
                                            if ($scope.objList[_componentId].type === 'intent') {
                                                if (node.contextMap && node.contextMap.constructor === String) {
                                                    try {
                                                        $scope.objList[_componentId].contextMap = JSON.parse(node.contextMap);
                                                    } catch (e) {
                                                        $scope.objList[_componentId].contextMap = {};
                                                    }
                                                } else {
                                                    $scope.objList[_componentId].contextMap = node.contextMap || {};
                                                }
                                            }
                                        }
                                        return false;
                                    }
                                });
                                if (Object.keys(_tempDefaultConnection).length > 0) {
                                    _tempConnObj = $.extend(true, {}, _tempConnObj, _tempDefaultConnection);
                                }
                                for (var ke = 0; ke < _objConnection.length; ke++) {
                                    if (_objConnection[ke].sourceId === _uId && !_tempConnObj[_objConnection[ke].connId]) {
                                        _objConnection.splice(ke, 1);
                                        ke--;
                                    }
                                }
                                $scope.objList[_componentId].connections = {};
                                $scope.objList[_componentId].tempConnections = {};
                                $.each(_tempConnObj, function (k, tempConn) {
                                    var _isFound = false;
                                    $.each(_objConnection, function (l, connection) {
                                        if (k === connection.connId) {
                                            _isFound = true;
                                            var _source = $element.find('.dragEleConn[data-id="' + tempConn.sourceId + '"]');
                                            var _target = $element.find('.dragEleConn[data-id="' + tempConn.targetId + '"]');
                                            if (_source.length > 0 && _target.length > 0) {
                                                _source.connections({ to: '.draggableEle [data-id="' + tempConn.targetId + '"]', class: 'line source-' + tempConn.sourceId + ' target-' + tempConn.targetId, within: $element.find('.flowTaskConnectionBlock')[0], lineColor: tempConn.color, connectionNum: tempConn.connObjNumber });
                                                $scope.objList[_componentId].connections[connection.connId] = tempConn;
                                                _objConnection[l] = tempConn;
                                                if ($scope.objList[_componentId].tempConnections && $scope.objList[_componentId].tempConnections[connection.connId]) {
                                                    delete $scope.objList[_componentId].tempConnections[connection.connId];
                                                }
                                            } else {
                                                $scope.objList[_componentId].connections[connection.connId] = tempConn;
                                                $scope.objList[_componentId].tempConnections[connection.connId] = tempConn;
                                            }
                                            return false;
                                        }
                                    });
                                    if (!_isFound) {
                                        var _source = $element.find('.dragEleConn[data-id="' + tempConn.sourceId + '"]');
                                        var _target = $element.find('.dragEleConn[data-id="' + tempConn.targetId + '"]');
                                        if (_source.length > 0 && _target.length > 0) {
                                            _source.connections({ to: '.draggableEle [data-id="' + tempConn.targetId + '"]', class: 'line source-' + tempConn.sourceId + ' target-' + tempConn.targetId, within: $element.find('.flowTaskConnectionBlock')[0], lineColor: tempConn.color, connectionNum: tempConn.connObjNumber });
                                            $scope.objList[_componentId].connections[tempConn.connId] = tempConn;
                                            _objConnection.push(_tempConnObj);
                                            if ($scope.objList[_componentId].tempConnections && $scope.objList[_componentId].tempConnections[tempConn.connId]) {
                                                delete $scope.objList[_componentId].tempConnections[tempConn.connId];
                                            }
                                        } else {
                                            $scope.objList[_componentId].connections[tempConn.connId] = tempConn;
                                            $scope.objList[_componentId].tempConnections[tempConn.connId] = tempConn;
                                        }
                                    }
                                });
                            }
                        } else if (type === 'updateComponent') {
                            $.each($scope._botComponents, function (k, obj) {
                                if (obj._id === data._id) {
                                    if (data.message && data.message.length && !data.message[0].text) { // onchange entity type, server returns only message _ids
                                        data.message = $scope._botComponents[k].message;
                                    }
                                    if (data.errorMessage && data.errorMessage.length && !data.errorMessage[0].text) { // onchange entity type, server returns only message _ids
                                        data.errorMessage = $scope._botComponents[k].errorMessage;
                                    }
                                    $scope._botComponents[k] = data;
                                    return false;
                                }
                            });
                             updateDialogEntities();
                            $.each($scope._nodes, function (k, obj) {
                                if (obj._id === data._id) {
                                    var _flowTasksInvolved = $scope._nodes[k].flowtasksInvolved;
                                    var flowtasksInvolvedIds = $scope._nodes[k].flowtasksInvolvedIds;
                                    if (data.message && data.message.length && !data.message[0].text) { // onchange entity type, server returns only message _ids
                                        data.message = $scope._nodes[k].message;
                                    }
                                    if (data.errorMessage && data.errorMessage.length && !data.errorMessage[0].text) { // onchange entity type, server returns only message _ids
                                        data.errorMessage = $scope._nodes[k].errorMessage;
                                    }
                                    $scope._nodes[k] = data;
                                    $scope._nodes[k].flowtasksInvolved = _flowTasksInvolved;
                                    $scope._nodes[k].flowtasksInvolvedIds = flowtasksInvolvedIds;
                                    return false;
                                }
                            });
                            $.each(_objList, function (k, obj) {
                                if (obj._id === data._id) {
                                    if (data.message && data.message.length && !data.message[0].text) { // onchange entity type, server returns only message _ids
                                        data.message = _objList[k].message;
                                    }
                                    if (data.errorMessage && data.errorMessage.length && !data.errorMessage[0].text) { // onchange entity type, server returns only message _ids
                                        data.errorMessage = _objList[k].errorMessage;
                                    }
                                    if (_objList[k].nodeId) {
                                        data.nodeId = _objList[k].nodeId;
                                    }
                                    _objList[k] = data;
                                }
                            });
                            $.each($scope.objList, function (k, obj) {
                                if (obj.componentId === data._id) {
                                    obj.name = data.name;
                                    if (data.type === 'intent') {
                                        obj.intent = data.intent;
                                    }
                                }
                            });
                        }
                    };
                    
                    $scope.deleteComponent = function (node, event) {
                        event.preventDefault();
                        event.stopPropagation();
                        if((node.flowtasksInvolved.length > 1) || (node.flowtasksInvolved.length > 0) || (node.parentId)) {
                            NotificationService.confirmDialog(i18n.i18nString('manage_components_confirmDialog_delete_component',{nodeType: node.type},{nodeName: node.name}), function(){}, {okText:i18n.i18nString('ok'), noCancelBtn:true});
                            return;
                        }
                        window.bootbox.dialog({
                            message: i18n.i18nString('delete_selected_node'),
                            title: i18n.i18nString('cannot_delete_title'),
                            className: "alert-modal",
                            buttons: {
                                success: {
                                    label: i18n.i18nString('cancel'),
                                    className: "closeCancel",
                                    callback: function () {
                                    }
                                },
                                main: {
                                    label: i18n.i18nString('ok_uppercase'),
                                    className: "",
                                    callback: function () {
                                        $scope.propertyCb.closePropertyPanel();
                                        var _ele = event.currentTarget;
                                        _ele.className = _ele.className + " componentSelectedSpin";
                                        $('.componentSelectedSpin').removeClass('fa-trash-o');
                                        $('.componentSelectedSpin').addClass('fa-spin fa-refresh');
                                        BTFlowtaskService.deleteComponent($scope.stream._id, node._id).then(function (res) {
                                            $('.row').removeClass("componentSelectedBorder");
                                            $('.componentSelectedSpin').removeClass('fa-spin fa-refresh');
                                            $('.componentSelectedSpin').addClass('fa-check');
                                            $scope.componentsCount[node.type.toLowerCase()] = $scope.componentsCount[node.type.toLowerCase()]-1;
                                            if($scope.componentsCount[node.type.toLowerCase()] === 0) {
                                                $scope.showType(0);
                                            }
                                            $.each($scope._botComponents, function (k, obj) {
                                                if (obj._id === node._id) {
                                                    $scope._botComponents.splice(k,1);
                                                    return false;
                                                }
                                            });
                                             updateDialogEntities();
                                            $.each($scope._nodes, function (k, obj) {
                                                if (obj._id === node._id) {
                                                    $scope._nodes.splice(k,1);
                                                    return false;
                                                }
                                            });
                                            $.each(_objList, function (k, obj) {
                                                if (obj._id === node._id) {
                                                    _objList.splice(k,1);
                                                    return false;
                                                }
                                            });
                                            NotificationService.notify(i18n.i18nString('node_deleted_sucess',{dyn: node.name}), 'success');
                                        }, function (error) {
                                            $('.componentSelectedSpin').removeClass('fa-spin fa-refresh');
                                            $('.componentSelectedSpin').addClass('fa-times');
                                            $timeout(function () {
                                                $('.componentSelectedSpin').removeClass('fa-times');
                                                _ele.className = "fa deleteNode fa-trash-o";
                                            }, 350);
                                            if (error && error.data && error.data.errors) {
                                                var _msg = error.data.errors[0].msg;
                                                NotificationService.notify(_msg, 'error');
                                            } else if (error.errors && _.isArray(error)) {
                                                var msg = error.errors[0].msg;
                                                NotificationService.notify(msg, 'error');
                                            } else {
                                                NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                                            }
                                        });
                                    }
                                }
                            }
                        });
                    };
                    $scope.getNodeTypeName = function (nodeType, flowTaskId) {
                        if (nodeType === 'intent' && flowTaskId) {
                            nodeType = 'subDialog';
                        }
                        return $scope.configurableElements[nodeType] ? $scope.configurableElements[nodeType].name : '';
                    };
                    // Get data for nodes to show
                    $scope.onNodeClicked = function ($event, _type) {
                        var _isDialog = false;
                        if (_type === 'subDialog') {
                            _type = 'intent';
                            _isDialog = true;
                        }
                        if ($($event.currentTarget).hasClass('eleType')) {
                            $event.stopPropagation();
                            $scope.nodeObjList = [];
                            $scope.nodeObjListLoading = true;
                            $($event.currentTarget).siblings().find('.open').removeClass('open');
                            if (_type === 'intent') {
                                var _prevNodeType = ($($event.currentTarget).parents('.dummyConnections').siblings('.dragEleConn').data('type') || '').trim().toLowerCase();
                                /*if (_prevNodeType === 'service' || _prevNodeType === 'script' || _prevNodeType === 'sdkwebhook'  || _prevNodeType === 'agenttransfer') {
                                    NotificationService.notify('You cannot add intent to a Script/Service node', 'warning');
                                    return;
                                }*/
                                if (_prevNodeType === 'sdkwebhook'  || _prevNodeType === 'agenttransfer') {
                                    NotificationService.notify(i18n.i18nString('sdk_webhook'), 'warning');
                                    return;
                                }
                            }
                            $($event.currentTarget).find('.dropdown').addClass('open');
                            if (_botComponents === 'error') {
                                BTFlowtaskService.getComponents(_selectedStream._id).then(function (res) {
                                    _botComponents = res && res.data;
                                     updateDialogEntities();
                                    $scope.onNodeClicked($event);
                                }, function (error) {
                                    _botComponents = 'error';
                                });
                            } else {
                                $.each(_botComponents, function (k, component) {
                                    if (component && component.type === _type) {
                                        if (_type === 'intent' && _isDialog) {
                                            if (component.dialogId) {
                                                $scope.nodeObjList.push(component);
                                            }
                                        } else {
                                            $scope.nodeObjList.push(component);
                                        }
                                    }
                                });
                                $scope.nodeObjListLoading = false;
                            }
                            var _heightDiff = $($event.currentTarget).offset().top + 230 - parseInt($('.flowTaskConnectionBlock').height());
                            var _widthDiff = $($event.currentTarget).offset().left + 400 - parseInt($('.flowTaskConnectionBlock').width());
                            if (_widthDiff > 0) {
                                $timeout(function () {
                                    $('.flowTaskConnectionBlock').scrollLeft(_widthDiff + parseInt($('.flowTaskConnectionBlock').scrollLeft()));
                                }, 500);
                            }
                            if (_heightDiff > 0) {
                                $timeout(function () {
                                    $('.flowTaskConnectionBlock').scrollTop(_heightDiff + parseInt($('.flowTaskConnectionBlock').scrollTop()));
                                }, 500);
                            }
                        }
                    };
                    // UI Call - Remove node
                    $scope.onRemove = function (typeID) {
                        if (typeID === $scope.firstNodeUId) {
                            NotificationService.notify(i18n.i18nString('first_node'), 'error');
                            return;
                        }
                        window.bootbox.dialog({
                            message: i18n.i18nString('delete_selected_node'),
                            title: i18n.i18nString('cannot_delete_title'),
                            className: "alert-modal",
                            buttons: {
                                success: {
                                    label: i18n.i18nString('cancel'),
                                    className: "closeCancel",
                                    callback: function () {
                                    }
                                },
                                main: {
                                    label: i18n.i18nString('ok_uppercase'),
                                    className: "",
                                    callback: function () {
                                        $scope.propertyCb.closePropertyPanel();
                                        var _params = {
                                            name: _dialogObj.name,
                                            nodes: [],
                                            displayOption: _dialogObj.displayOption,
                                            visibility: _dialogObj.visibility
                                        };
                                        var _isIntent = $scope.objList[typeID] && $scope.objList[typeID].type === 'intent' ? true : false;
                                        if (_dialogObj.nodes && _dialogObj.nodes.length > 0) {
                                            $.each(_dialogObj.nodes, function (k, node) {
                                                if (node.nodeId !== typeID) {
                                                    var _nodeObj = node;
                                                    delete _nodeObj._id;
                                                    if (node.transitions && node.transitions.length > 0) {
                                                        $.each(node.transitions, function (k, transition) {
                                                            if (transition.then === typeID) {
                                                                node.transitions[k].then = '';
                                                                if (_isIntent) {
                                                                    node.transitions[k].if = {
                                                                        intent: ''
                                                                    };
                                                                }
                                                            } else if (transition.default === typeID) {
                                                                node.transitions[k].default = '';
                                                            }
                                                            if (transition.default !== undefined && transition.if) {
                                                                delete node.transitions[k].if;
                                                            }
                                                        });
                                                    }
                                                    _params.nodes.push(_nodeObj);
                                                }
                                                delete node.message;
                                            });
                                        }
                                        BTFlowtaskService.updateFlowtask(_selectedStream._id, _dialogObj._id, _params).then(function (res) {
                                            _dialogObj = res && res.data;
                                            for (var i = 0; i < _objList.length; i++) {
                                                if (_objList[i]._id === $scope.objList[typeID].componentId) {
                                                    _objList.splice(i, 1);
                                                    i--;
                                                    break;
                                                }
                                            }
                                            for (var j = 0; j < _objConnection.length; j++) {
                                                if (_objConnection[j] && (_objConnection[j].targetId === typeID || _objConnection[j].sourceId === typeID)) {
                                                    _objConnection.splice(j, 1);
                                                    j--;
                                                }
                                            }
                                            delete $scope.objList[typeID];
                                            $scope.objListSearch = [];
                                            $.each($scope.objList, function (k, obj) {
                                                $scope.objListSearch.push({ key: obj.uId, val: obj.name });
                                                if (obj.connections && Object.keys(obj.connections).length > 0) {
                                                    $.each(obj.connections, function (k, conn) {
                                                        if (conn && conn.targetId === typeID) {
                                                            conn.targetId = '';
                                                            if (_isIntent) {
                                                                conn.ifCondition = '';
                                                            }
                                                            obj.tempConnections = {};
                                                            $.each(obj.connections, function (k, conn) {
                                                                if (conn.targetId === '') {
                                                                    obj.tempConnections[k] = conn;
                                                                }
                                                            });
                                                        } else if (conn && conn.default === typeID) {
                                                            conn.default = '';
                                                            obj.tempConnections[k] = conn;
                                                        }
                                                    });
                                                    rearrangeConnectionsForObj(obj.uId);
                                                }
                                            });
                                            $timeout(function () {
                                                $scope.$apply();
                                                updateEntityRegExWarnings();
                                                updateEntityQuantityErrors();
                                                updateEntityLOIEnumeratorErrors();
                                                updateEntityLOILookupErrors();
                                                updateServiceSampleResWarnings();
                                                updateServiceReqDefWarnings();
                                                updateScriptDefWarnings();
                                            });
                                        }, function (error) {
                                            if (error && error.data && error.data.errors) {
                                                var _msg = error.data.errors[0].msg;
                                                NotificationService.notify(_msg, 'error');
                                            } else if (error.errors && _.isArray(error)) {
                                                var msg = error.errors[0].msg;
                                                NotificationService.notify(msg, 'error');
                                            } else {
                                                NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                                            }
                                        });
                                    }
                                }
                            }
                        });
                    };
                    function onResizeStart(e, u) {
                        if (e.target) {
                            var _ele = $(e.target);
                            var _left = u.position.left;
                            _ele.css('left', _left + 'px');
                            _ele.css('right', 'auto');
                        }
                    }
                    function onResizeStop(e, u) {
                        if (e.target) {
                            var _parentEle = $element.find('.flowTaskBlock');
                            var _ele = $(e.target);
                            var _right = parseInt(_parentEle.width()) - u.position.left - parseInt(_ele.width());
                            _ele.css('right', _right + 'px');
                            _ele.css('left', 'auto');
                        }
                    }
                    // Open configure Modal
                    function openPreviewModal(nodeType, isFirstNode) {
                        $timeout(function () {
                            $('#flowtask_node_Begin').modal({
                                backdrop: 'static',
                                show: true
                            });
                        }, 350);
                        initializeNodeModal(nodeType);
                        $scope.nodeObjLabels.isFirstNode = true;
                        var _modalBodyHeight = $(window).height() - 300;
                        $('#flowtask_node_Begin .modal-body').css('max-height', _modalBodyHeight);
                        $timeout(function () {
                            $scope.nodeObj.isInvalid = true;
                        }, 350);
                    }
                    // Edit node call from UI
                    $scope.onConfigure = function (typeID, type) {
                        $scope.selectCurrentNode(typeID, type);
                    };


                    $scope.exportDialog = function () {
                        BTFlowtaskService.exportDialog(_selectedStream._id, $scope.flowtaskObj._id).then(function (res) {
                            writeAndDownloadDialog(res.data.name + ".json", JSON.stringify(res.data));
                        });
                    };

                    $scope.readDialog = function () {
                        $scope.importedDialogName = $scope.importDialog.name;
                        if ($scope.importedDialogName) {
                            var _ext = $scope.importedDialogName.substring($scope.importedDialogName.lastIndexOf('.'));
                            if (_ext !== '.json') {
                                NotificationService.notify(i18n.i18nString('upload_json'), "error");
                                $scope.fileExtensionError = true;
                                return;
                            } else {
                                $scope.fileExtensionError = false;
                                $scope.dialogRequiredError = false;
                            }
                        }

                        var reader = new FileReader();
                        reader.readAsText($scope.importDialog);

                        reader.onload = function (e) {
                            var data = reader.result;
                            $scope.importedDialogData = data;
                        };
                        angular.element("#importFile").val("");
                    };

                    $scope.confirmImport = function () {
                        if (!$scope.importedDialogData) {
                            $scope.dialogRequiredError = true;
                            NotificationService.notify(i18n.i18nString('dialog_file_req'), "error");
                            return;
                        }
                        $scope.isWorkProgress = true;
                        $scope.loaderMessage = i18n.i18nString('importing');
                        BTFlowtaskService.importDialog(_selectedStream._id, $scope.flowtaskObj._id, $scope.importedDialogData).then(function (res) {
                            $scope.doneImporting = true;
                            $workflowService.flowtaskInfo(res.data);
                            $scope.flowtaskObj = res.data;
                            $scope.importModalTitle = i18n.i18nString('bt_streams_successful');
                            $scope.connections = getConnections(res.data.nodes);
                            $scope.importDialogHeader = i18n.i18nString('dialog_backup_success');
                            intialize();
                            $scope.importResults = i18n.i18nString('manage_components_importResults',{nodesLength: $scope.flowtaskObj.nodes.length},{connectionsLength: $scope.connections.length});
                            $scope.isWorkProgress = false;
                            $scope.loaderMessage = i18n.i18nString('working_on_it');
                            $scope.displayMode = 'edit';
                        }, function (error) {
                            $scope.doneImporting = true;
                            var _msg = error.data.errors[0].msg;
                            $scope.importDialogHeader = i18n.i18nString('dialog_backup_failure');
                            $scope.importResults = _msg;
                            $scope.isWorkProgress = false;
                            $scope.loaderMessage = i18n.i18nString('working_on_it');
                            $scope.importModalTitle = i18n.i18nString('failed_label');
                            NotificationService.notify(_msg, 'error');
                        });
                    };

                    $scope.finishImporting = function () {
                        $scope.doneImporting = false;
                        $scope.importedDialogName = undefined;
                        $scope.importedDialogData = undefined;
                        $scope.importDialog = undefined;
                        $scope.importDialogHeader = i18n.i18nString('import_dialog_desc');
                        $scope.importModalTitle = i18n.i18nString('bt_streams_a_dialog');
                        $scope.fileExtensionError = false;
                        $('#flowtask_import').modal('hide');
                    };

                    $scope.onFinishSetup = function (type) {
                        BTFlowtaskService.finishFlowtask(_selectedStream._id, _dialogObj._id).then(function (res) {
                            NotificationService.notify(i18n.i18nString('dialog_configured'), 'success');
                        }, function (error) {
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                            }
                        });
                    };

                    $scope.configure = function (val) {

                    };

                    $scope.validateTaskName = (function () {
                        var regexp = /^[a-zA-Z0-9][a-zA-Z0-9_<>* ]+$/, regexp2 = /^[a-zA-Z0-9]/;
                        return {
                            test: function (value) {
                                if (value && value.length === 1) {
                                    return regexp2.test(value);
                                } else {
                                    return regexp.test(value);
                                }
                            }
                        };
                    })();
                    $scope.updateServiceNodeType = function (value) {
                        if (value !== "custom") {
                            $element.find('.serviceNodeSubType').attr('disabled', 'disabled');
                        } else {
                            $element.find('.serviceNodeSubType').removeAttr('disabled');
                        }
                        $scope.nodeObj.serviceType = '';
                        $scope.checkCreateNodeFormDirty();
                    };
                    $scope.onImportClicked = function () {
                        NotificationService.notify(i18n.i18nString('onimport_click'), 'warning');
                    };
                    $scope.onExportClicked = function () {
                        NotificationService.notify(i18n.i18nString('onimport_click'), 'warning');
                    };

                    function writeAndDownloadDialog(filename, data) {

                        var element = document.createElement('a');
                        element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(data));
                        element.setAttribute('download', filename);

                        element.style.display = 'none';
                        document.body.appendChild(element);

                        element.click();

                        document.body.removeChild(element);
                    }
                    
                    function setPropertyPanelWidth() {
                        _flowTaskPropertyPanel.css('width', Math.floor(_flowTaskConnectionBlock.width() * 0.6));
                        if(_flowTaskPropertyPanel.resizable){
                            _flowTaskPropertyPanel.resizable("option", "maxWidth", Math.floor(_flowTaskConnectionBlock.width() * 0.6));
                        }
                    }
                    $scope.toggleSize = function (e) {
                        if ($scope.isExpanded) {
                            _flowTaskPropertyPanel.css('width', Math.floor(500));
                        } else {
                            _flowTaskPropertyPanel.css('width', Math.floor(_flowTaskConnectionBlock.width() * 0.6));
                        }
                        $scope.isExpanded = !$scope.isExpanded;

                    };
                    $scope.toggleMinMax = function (e) {
                        if (!$scope.isMinimized) {
                            _flowTaskPropertyPanel.addClass('minimized');
                        } else {
                            _flowTaskPropertyPanel.removeClass('minimized');

                        }
                        $scope.isMinimized = !$scope.isMinimized;

                    };


                    angular.element($window).on('resize', function (e) {
                        if ($.isWindow(e.target) && $scope && $scope.isPropertyPanelOpened) {
                            setPropertyPanelWidth();
                        }
                    });

                    $scope.validateJs = function () {
                        var code = "var a = 2; \n\n var b = 3; \n\n console.log(a); \n\n console.log(r)";
                        jsValidator.getError(code)
                            .then(function (res){
                                console.log(res);
                            }, function (err){
                                console.log('from factoryy..', err);
                            });
                    };
                    $scope.showType(0);
                    angular.element($window).on('resize', function (e) {
                        if ($scope && $scope.isPropertyPanelOpened) {
                            var _height = $('.wf-form-manageComponents .standard-response-header').height();
                            $element.find('.flowTaskPropertyPanel').css('top', '5px').css('height', (_height-20) + 'px');
                            var _innerPanelHeight = _height - 79;
                            if ($element.find('.flowTaskPropertyPanel .panel-body').length > 0) {
                                _innerPanelHeight = _innerPanelHeight - 30 * $element.find('.flowTaskPropertyPanel .panel-body').length;
                            }
                            $element.find('.flowTaskPropertyPanel .panel-body').css('height', _innerPanelHeight + 'px');
                            if($scope.selectedNode.nodeInfo && $scope.selectedNode.nodeInfo.parentId) {
                                $element.find('.flowTaskPropertyPanel .panel-body').css('height', (_innerPanelHeight-45) + 'px');
                            }
                            /*
                            var _height = $element.find('.flowTaskConnectionBlock').height();
                            if(_height > 800) {
                                _height = _height-100;
                            }
                            else if(_height > 600) {
                                _height = _height-250;
                            }
                            if (_height < 400) {
                                _height = 400;
                            }
                            var _innerPanelHeight = _height - 58;
                            $element.find('.flowTaskPropertyPanel').css('top', '5px').css('height', _height + 'px');
                            if ($element.find('.flowTaskPropertyPanel .panel-body').length > 0) {
                                _innerPanelHeight = _innerPanelHeight - 30 * $element.find('.flowTaskPropertyPanel .panel-body').length;
                            }
                            $element.find('.flowTaskPropertyPanel .panel-body').css('height', _innerPanelHeight + 'px');
                            */
                        }
                    });
                }]
        };
    });
})(angular);

;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btProcessApps', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-process-apps/bt-process-apps.html',
            controller: 'btProcessAppsController'
        };
    });
    _module.controller("btProcessAppsController", ['$scope', '$window', '$workflowService', '$element', '$location','jsEvents', '$sce',
        function ($scope, $window, $workflowService, $element, $location, jsEvents, $sce) {
            //$scope.DaasUrl="http://dev.kore.ai:4200/analytics/dashboard";  
            //$scope.stream = $workflowService.selectedStream();
            $scope.processFlowsURL = window.appConfig.API_SERVER_URL + '/builderx/process/home';         
            var iframe = $("#processFlowsFrame");
            iframe.on("load", function () { 
                //Make sure it is fully loaded
                iframe.contents().click(function (event) {
                    //iframe.trigger("click");
                    //$("body").trigger("click");
                });
               var processStoreOptions = $workflowService.toInstallProcessApp(); 
                if (processStoreOptions && processStoreOptions.processId) {
                    jsEvents.postMessageToChildIframes('processStore','#processFlowsFrame', {resourceId:processStoreOptions.processId}); 
                }
            });
        }]);

}(angular));




;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.filter('removeArrayPath', function () {
        return function (key, optional1, optional2) {
            var _arrayStartIndex = key.indexOf('[');
            var _arrayPath;
            if (_arrayStartIndex > -1) {
                _arrayPath = key.substring(_arrayStartIndex, key.length);
                key = key.substring(0, _arrayStartIndex);
            }
            return key;
        };

    });

    _module.controller('BTRequestCtrl', ['$scope', '$rootScope', '$translator', '$modalInstance', '$workflowService', 'BTStreamsService', 'config', 'BTFlowtaskService', 'urlutil', 'NotificationService', "BTIdpService", '$applicationService', '$timeout', 'env_conf','i18n',
        function ($scope, $rootScope, $translator, $modalInstance, $workflowService, BTStreamsService, config, BTFlowtaskService, urlutil, NotificationService, BTIdpService, $applicationService, $timeout, env_conf,i18n) {
            function init() {
                $scope.stream = $workflowService.selectedStream();
                $scope.task = $workflowService.taskEditInfo();
                $scope.component = config.component.nodeInfo;
                $scope.backArrow = env_conf['context-url']+'/assets/icons/backArrow.svg';
                $scope.backArrowGreen = env_conf['context-url']+'/assets/icons/caretRightGreen.svg';
                $scope.closeCross = env_conf['context-url']+'/assets/icons/closeCross.png';
                $scope.trashIcon = env_conf['context-url']+'/assets/icons/trashIcon.svg';
                $scope.testArrowIcon = env_conf['context-url']+'/assets/icons/testArrowIcon.svg';
                $scope.helpIcon = env_conf['context-url']+'/assets/icons/helpIcon.svg';
                $scope.saveInProgress = false;
                $scope.testInProgress = false;
                $scope.resSaveInProgress = false;
                $scope.advOpt = false;
                $scope.sampleResCB = {};
                $scope.rawParamsCB = {};
                $scope.modalSlider = {};
                $scope.rightClass = "right700";
                $scope.displayMode = config.component.displayMode;
                $scope.rawParamsCB.displayMode = config.component.displayMode;


                $scope.saving = i18n.i18nString('saving');
                $scope.save   = i18n.i18nString('save'); 
                $scope.testing = i18n.i18nString('testing_label');
                $scope.test    =i18n.i18nString('test_label');
                $scope.request = i18n.i18nString('request');
                $scope.post    = i18n.i18nString('post_label');
                $scope.sample_res = i18n.i18nString('sample_res');


                $scope.sections = {
                    auth: false,
                    headers: false,
                    params: false,
                    curl: false,
                    testReq: false
                };
                $scope.paramTypeMap = {
                    urlencoded: "application/x-www-form-urlencoded",
                    raw: "application/json",
                    xml: "application/xml",
                    custom: ""
                };
                $scope.contentTypeUIMap = {
                    urlencoded: "application/x-www-form-urlencoded",
                    raw: "application/json",
                    xml: "application/xml",
                    custom: "Custom"
                };
                $scope.options = {
                    aceMode: "ace/mode/javascript",
                    mode: $scope.displayMode === "view" ? 'tree' : 'code',
                    ace: window.ace
                };
                $scope.enterpriseLicenseType = $rootScope.licenseType;
                $scope.props = {
                    headers: [],
                    params: [],
                    rawParams: [],
                    endPoint: {}
                };
                $scope.authCB = config.authCB;
                $scope.btTestFormApi = config.btTestFormApi;
                $scope.btTestStatus = config.btTestStatus;
                $scope.idpConfig = {};
                $scope.piiDataEnabled = {
                    status: ""
                };
                $scope.props.headers = processUIHeaders($scope.component.headers || []);//[{key:"one",value:"oneVlue"},{key:"",value:""}];//{one:"vale","":""};
                $scope.props.headers.push({ key: "", value: "" });
                $scope.props.params = processUIHeaders($scope.component.payload || []);//[{key:"one",value:"oneVlue"},{key:"",value:""}];//{one:"vale","":""};
                $scope.props.params.push({ key: "", value: "" });
                if ($workflowService.selectedStream().sbStreamId) {
                    $scope.isChildBot = true;
                }


                //if ($scope.props.paramType === "raw") {
                $scope.props.rawParams = deProcessUIHeaders($scope.props.params);
                //}                
                $scope.props.endPoint.requestUrl = processUIEndPoint($scope.component.endPoint);
                $scope.props.endPoint.connectorEnabled = $scope.component.endPoint && $scope.component.endPoint.connectorEnabled || false;
                $scope.props.endPoint.method = $scope.component.endPoint && $scope.component.endPoint.method.toLowerCase() || 'get';
                $scope.props.sampleResponse = {};
                $scope.sampleResponseIndex = 0;
                if ($scope.component.sampleResponse) {
                    for (var i = 0; i < $scope.component.sampleResponse.length; i++) {
                        if ($scope.component.sampleResponse[i].isDefault) {
                            $scope.sampleResponseIndex = i;
                            $scope.props.sampleResponse = $scope.component.sampleResponse[i].response;
                            if (typeof $scope.props.sampleResponse === "string") {
                                try {
                                    $scope.props.sampleResponse = JSON.parse($scope.props.sampleResponse);
                                } catch (e) {
                                    $scope.props.sampleResponse = {};
                                }
                            }
                            break;
                        }
                    }
                }
                $scope.props.paramType = 'urlencoded';
                loadParamType();
                BTFlowtaskService.getAllVariables($applicationService.userInfo().userId, $scope.stream._id).then(function (res) {
                    $scope.getAllVariables = res.data.variables;
                }, function (error) {
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('unexpected_error_while_fetching_bot_variables'), 'error');
                    }
                });
                BTFlowtaskService.getComponents($scope.stream._id, $scope.component._id).then(function (res) {
                    $scope.piiDataEnabled.status = (typeof res.data.endPoint === 'undefined' || typeof res.data.endPoint.piiDataEnabled === 'undefined') ? false : res.data.endPoint.piiDataEnabled;
                },
                function (error) {
                    console.log('error', error);
                });
                //if ($scope.props.paramType === "raw" || $scope.props.paramType === "urlencoded") {
                $timeout(function () {
                    $scope.props.rawParams = ($scope.component.payload && $scope.component.payload.value) ? decodeURIComponent($scope.component.payload.value) : '';
                }, 200);
                //}
            }
            function loadParamType() {
                var h_index = _.findIndex($scope.props.headers, function (header) {
                    return header.key === "Content-Type";
                });
                if (h_index !== -1) {

                    var _formats = Object.keys($scope.contentTypeUIMap).map(function (key) {
                        return $scope.contentTypeUIMap[key];
                    });

                    var _selectedFormatIndex = _formats.indexOf($scope.props.headers[h_index].value);
                    if (_selectedFormatIndex !== -1) {

                        var _cntTypeKeys = Object.keys($scope.contentTypeUIMap);
                        var _cntTypeIndex = _.findIndex(_cntTypeKeys, function (format) {
                            return format === _cntTypeKeys[_selectedFormatIndex];
                        });

                        if (_cntTypeIndex !== -1) {
                            $scope.props.paramType = _cntTypeKeys[_cntTypeIndex];
                        } else {
                            $scope.props.paramType = 'custom';
                        }

                    } else {
                        $scope.props.paramType = 'custom';
                    }

                } else {
                    $scope.props.paramType = 'custom';
                }
            }
            function bindEvents() {

                //fix for IE 11 edit Request: placeholder text is not getting cleared 
                $modalInstance.opened.then(function () {
                    $timeout(function () {
                        $('.bt-request-modal').modal({
                        show:true,
                        backdrop:'static'
                    });
                    }, 300);
                });

                $scope.authCB.onModalShow = function () {
                    $('.bt-request-modal').addClass('modalSmall');
                };
                $scope.authCB.onModalClose = function () {
                    $('.bt-request-modal').removeClass('modalSmall');
                    $timeout(function () {
                        $('body').addClass('modal-open');
                    }, 700);
                };
                $scope.authCB.onCreateIDP = function (idpData) {
                    $scope.authLists.push({ _id: idpData._id, name: idpData.name, sso_type: idpData.sso_type });
                    $scope.newAuth.selected = $scope.authLists.filter(function (authItem) {
                        return authItem.name === (idpData.name);
                    })[0];
                };

                $scope.sampleResCB.onBlur = function (editor) {
                    var _value = editor.getText();
                    if (_value === '') {
                        $scope.props.sampleResponse = {};
                    }
                };
                $scope.rawParamsCB.onBlur = function (editor) {
                    $scope.invalidPayload = false;
                    var _value = editor.getText();
                    if (_value === '') {
                        $scope.props.rawParams = '';
                    } else {
                        $scope.props.rawParams = _value;
                        if (editor.aceEditor.getSession().getAnnotations().length) {
                            $scope.invalidPayload = true;
                        }
                    }
                };
            }

            $scope.closeModal = function () {
                $modalInstance.close();
            };

            $scope.hasArrayPath = function (key) {
                var _arrayStartIndex = key.indexOf('[');
                if (_arrayStartIndex > -1) {
                    return true;
                } else {
                    return false;
                }
            };

            $scope.showAdvancedOptions = function () {
                //$scope.advOpt = !$scope.advOpt;
                $scope.modalSlider.open('#requestmodelAdvanced');
            };
            $scope.closeRequestModal = function(){
                $scope.modalSlider.close('#requestmodelAdvanced');
            };
            function initAuthData() {
                $scope.newAuth = {};
                $scope.createNewIDP = function () {
                    $scope.authCB.createNewIDP();
                };
                //                $scope.idpSelectionChange=function(){
                //                    debugger;
                //                    if($scope.newAuth.selected===null || $scope.newAuth.selected===""){
                //                        $scope.createNewIDP();
                //                    }
                //                };

                $scope.$watch('newAuth.selected', function (newValue, oldValue) {
                    if (newValue === null || newValue === "") {
                        $scope.createNewIDP();
                        $scope.newAuth.selected = oldValue;
                    }
                });

                BTIdpService.getIdpList($workflowService.selectedStream()._id)
                    .then(function (res) {
                        $scope.authLists = res.data;
                        $scope.authLists.push({ _id: "none", name: "none", sso_type: "none" });
                        $scope.newAuth.selected = $scope.authLists.filter(function (authItem) {
                            return authItem.name === ($scope.component.idp || 'none');
                        })[0];
                        // bindAuthMechanism();
                    }, function (res) {
                        NotificationService.notify(i18n.i18nString('notify_idp'), "error");
                    });

            }
            $scope.navigate = function (section) {
                for (var key in $scope.sections) {
                    if ($scope.sections.hasOwnProperty(key)) {
                        $scope.sections[key] = false;
                    }
                }
                $scope.sections[section] = true;

                if (section === 'testReq') {
                    if ($scope.props.paramType === "urlencoded") {
                        $scope.props.rawParams = deProcessUIHeaders($scope.props.params);
                    }
                    $scope.updateContextParams();
                }
                if (section === 'curl') {
                    updateCurl();
                }
            };

            $scope.updateContextParams = function (index) {
                $scope.props.contextParams = arrayToKeyValueArray(getContextParams());
                var splittedContextKey = [];
                for (var i = 0; i < $scope.props.contextParams.length; i++) {
                    splittedContextKey[i] = $scope.props.contextParams[i].key.split('.');
                    splittedContextKey[i][0] = splittedContextKey[i][0] === 'content' ? 'locale' : splittedContextKey[i][0];
                }
                $timeout(function(){
                    for (var i = 0; i < splittedContextKey.length; i++) {
                        var contextParamVal = $scope.getAllVariables.filter(function (v) {
                            return v.variableType === splittedContextKey[i][0] && v.key === splittedContextKey[i][1];
                        });
                        if (contextParamVal[0] && contextParamVal[0].value && !(contextParamVal[0].scope === 'hidden' && $scope.isChildBot)) {
                            $scope.props.contextParams[i].value = contextParamVal[0].value;
                        }
                    }
                },250);
            };

            $scope.onHeaderFocus = function (index) {
                if ($scope.props.headers.length === index + 1) {
                    $scope.props.headers.push({ key: "", value: "" });
                }
            };

            $scope.deleteHeader = function (index) {
                $scope.props.headers.splice(index, 1);
            };

            $scope.onParamFocus = function (index) {
                if ($scope.props.params.length === index + 1) {
                    $scope.props.params.push({ key: "", value: "" });
                }
            };

            $scope.deleteParam = function (index) {
                $scope.props.params.splice(index, 1);
            };

            function processUIEndPoint(endPoint) {
                if (!endPoint) {
                    return "";
                }
                var _url = urlutil.concat({
                    host: endPoint.host,
                    path: endPoint.path,
                    port: endPoint.port ? (endPoint.port + '') : '',
                    protocol: endPoint.protocol
                });

                return _url;
            }

            function deProcessUIEndPoint(url, method) {

                var uriParser = window.URI;
                var components = uriParser.parse(url);

                var endPoint = {
                    host: components.host,
                    port: components.port ? (components.port + '') : '',
                    path: components.path,
                    protocol: components.scheme,
                    //'content-type': contentType,
                    method: method
                };

                endPoint.path += (components.query) ? ('?' + components.query) : '';
                endPoint.path += (components.fragment) ? ('#' + components.fragment) : '';

                return endPoint;
            }



            function objToArray(_obj) {
                if (!_obj) {
                    return [];
                }
                if (typeof (_obj) === 'string') {
                    try {
                        _obj = JSON.parse(_obj);
                    } catch (e) {
                        return [];
                    }
                }
                var _arr = [];
                var x = Object.keys(_obj).length && Object.keys(_obj).forEach(function (key) {
                    _arr.push({ key: key, value: _obj[key] });
                });
                return _arr;
            }
            function arrayToObj(_obj) {
                var _arr = [];
                var x = Object.keys(_obj).length && Object.keys(_obj).forEach(function (key) {
                    _arr.push({ key: key, value: _obj[key] });
                });
                return _arr;
            }
            function processUIHeaders(headers) {
                var _headers = [], headerObj = {};

                try {
                    headerObj = JSON.parse(headers.value);
                } catch (e) {
                    headerObj = {};
                }

                var x = Object.keys(headerObj).length && Object.keys(headerObj).forEach(function (key) {
                    _headers.push({ key: key, value: headerObj[key] });
                });
                return _headers;
            }
            function deProcessUIHeaders(headers) {
                var headerObj = {};
                var x = headers && headers.length && headers.forEach(function (header) {
                    if (header.key && header.value) {
                        headerObj[header.key] = header.value;
                    }
                });
                return headerObj;
            }

            function getTemplateTokens(str) {

                if (str && typeof (str) === 'string') {
                    var matchArr = str.match(/{{\s*[\w\.\[\]]+\s*}}/g);
                    if (matchArr && matchArr.length) {
                        return matchArr.map(function (x) {
                            return x.match(/[\w\.\[\]]+/)[0];
                        });
                    } else {
                        return [];
                    }

                } else {
                    return [];
                }

            }

            function arrayToKeyValueArray(_arr) {
                var contextArr = [];

                var x = _arr.forEach(function (key) {
                    contextArr.push({ key: key, value: "" });
                });
                return contextArr;
            }
            function addToArray(data, array) {
                if (data && data.length) {
                    array.push.apply(array, data);
                }
                return array;
            }
            function getContextParams() {
                var _params = [], headerObj = {};
                var x = $scope.props.headers.length && $scope.props.headers.forEach(function (header) {
                    if (header && header.value) {
                        addToArray(getTemplateTokens(header.value), _params);
                    }
                });

                var y = $scope.props.params.length && $scope.props.params.forEach(function (header) {
                    if (header && header.value) {
                        addToArray(getTemplateTokens(header.value), _params);
                    }
                });

                var rawStr = JSON.stringify($scope.props.rawParams);
                addToArray(getTemplateTokens(rawStr), _params);

                addToArray(getTemplateTokens($scope.props.endPoint.requestUrl), _params);
                _params = _.uniq(_params);
                return _params;
            }

            $scope.executeService = function () {
                $scope.testInProgress = true;
                $scope.statusCode = "";
                $scope.saveRequest(true, true);

            };
            $scope.saveSampleResponse = function () {
                var _payload = {};
                $scope.resSaveInProgress = true;
                if ((!$scope.component.sampleResponse) || (!$scope.component.sampleResponse.length)) {
                    $scope.component.sampleResponse = [];
                    var _obj = {};
                    _obj.name = "sampleResponse";
                    _obj.isDefault = true;
                    $scope.component.sampleResponse.push(_obj);
                }
                $scope.component.sampleResponse[$scope.sampleResponseIndex].response = JSON.stringify($scope.props.sampleResponse);
                _payload.sampleResponse = $scope.component.sampleResponse;
                BTFlowtaskService.updateComponent($scope.stream._id, $scope.component._id, _payload).then(function (res) {
                    if (res && res.data) {
                        if (config && config.cbBridge && config.cbBridge.onServiceSave) {
                            config.cbBridge.onServiceSave(res.data);
                        }
                    }
                    $scope.resSaveInProgress = false;
                }, function () {
                    $scope.resSaveInProgress = false;
                });
            };
            //            $scope.isValidSampleResponse = function () {
            //                if (Object.keys($scope.props.sampleResponse).length) {
            //                    return true;
            //                } else {
            //                    return false;
            //                }
            //            };

            $scope.saveRequest = function (silent, triggerTest) {
                $timeout(function () {
                    //if (!$scope.invalidPayload) {
                    var _payload = {};
                    _payload.headers = { type: "raw", value: JSON.stringify(deProcessUIHeaders($scope.props.headers)) };

                    //                        if ($scope.props.paramType === "raw") {
                    //                            _payload.payload = {type: "raw", value:($scope.props.rawParams)?JSON.stringify(deProcessUIHeaders(objToArray($scope.props.rawParams))):""};
                    //                        } else 

                    if ($scope.props.paramType === "raw" || $scope.props.paramType === "xml" || $scope.props.paramType === "custom") {
                        _payload.payload = { type: "raw", value: ($scope.props.rawParams) ? encodeURIComponent($scope.props.rawParams) : '' };
                    } else {
                        _payload.payload = { type: "raw", value: JSON.stringify(deProcessUIHeaders($scope.props.params)) };
                    }

                    //_payload.sampleResponse = $scope.props.sampleResponse;

                    _payload.endPoint = deProcessUIEndPoint($scope.props.endPoint.requestUrl, $scope.props.endPoint.method);
                    _payload.endPoint.connectorEnabled = $scope.props.endPoint.connectorEnabled;
                    _payload.endPoint.piiDataEnabled = $scope.piiDataEnabled.status;
                    _payload.idp = ($scope.newAuth.selected && $scope.newAuth.selected.name) || 'none';
                    _payload.authRequired = (_payload.idp === 'none') ? false : true;
                    saveToServer(_payload, silent, triggerTest);
                    //}else{
                    //    NotificationService.notify('Please provide valid payload', 'warning');
                    //}
                }, 100);
            };

            function generateObjectByPath(_obj) {
                var _returnObj = {};
                Object.keys(_obj).forEach(function (key) {
                    var _arrayStartIndex = key.indexOf('[');
                    var _arrayPath, _originalKey, _parsedData;
                    if (_arrayStartIndex > -1) {
                        _arrayPath = key.substring(_arrayStartIndex, key.length);
                        _originalKey = angular.copy(key);
                        try {
                            _parsedData = JSON.parse(_obj[_originalKey]);
                        } catch (e) {
                            NotificationService.notify(i18n.i18nString('valid_array'), 'error');
                        }
                        key = key.substring(0, _arrayStartIndex);
                    }
                    var _tempObj = {};
                    key.split('.').reverse().forEach(function (_parsedKey) {
                        var _t = {};
                        _t[_parsedKey] = (Object.keys(_tempObj).length) ? _tempObj : (_arrayStartIndex > -1) ? _parsedData : _obj[key];
                        _tempObj = _t;
                    });
                    angular.merge(_returnObj, _tempObj);
                });
                return _returnObj;

            }

            function testRequest() {
                $scope.testInProgress = true;
                var _executePayload = deProcessUIHeaders($scope.props.contextParams);
                var _idpName = $scope.newAuth && $scope.newAuth.selected && $scope.newAuth.selected.name;
                if (_idpName && _idpName.toLowerCase() !== 'none' && $scope.newAuth.selected.sso_type !== 'oauth2_client_credential') {
                    _executePayload['context.accountidtouse'] = $scope.accounts[0].streamAccountId;
                }
                _executePayload = generateObjectByPath(_executePayload);
                BTFlowtaskService.executeComponent($scope.stream._id, $scope.component._id, _executePayload).then(function (res) {
                    $scope.props.sampleResponse = res.data;
                    $scope.statusCode = res.data.statusCode;
                    $scope.testInProgress = false;
                }, function (res) {
                    var err = res.data;
                    var errMsg = (err && err.errors && err.errors[0].msg) || i18n.i18nString('some_thing_wrong_label');
                    //NotificationService.notify(errMsg, "error");
                    $scope.statusCode = err.errors[0].code;
                    $scope.testInProgress = false;
                    var parsedErrObj = {};
                    try {
                        parsedErrObj = JSON.parse(err.errors[0].msg);
                    } catch (e) {
                        parsedErrObj = err.errors[0].msg || { errors: [{ msg: i18n.i18nString('bt_reqst_unkown_msg'), code: "Unknown" }] };
                    }
                    $scope.props.sampleResponse = parsedErrObj; //res.data.body;//....?


                });
            }


            function saveToServer(_payload, silent, triggerTest) {
                if (!silent) {
                    $scope.saveInProgress = true;
                }
                BTFlowtaskService.updateComponent($scope.stream._id, $scope.component._id, _payload).then(function (res) {
                    if (res && res.data) {
                        if (config && config.cbBridge && config.cbBridge.onServiceSave) {
                            config.cbBridge.onServiceSave(res.data);
                        }
                        if (!silent) {
                            $scope.closeModal();
                        }
                        if (triggerTest) {
                            $scope.checkIdpAndExecuteAPI();
                        }

                    }
                    $scope.saveInProgress = false;
                }, function () {
                    $scope.saveInProgress = false;
                    $scope.testInProgress = false;
                });
            }
            $scope.$watch('props.endPoint.requestUrl', function (newVal, oldVal) {
                $scope.updateContextParams();
                updateCurl();
            });
            $scope.$watch('props.endPoint.method', function (newVal, oldVal) {
                updateCurl();

                if (newVal && newVal === 'get') {
                    $scope.disableBody = true;
                    $scope.props.params = [];
                    $scope.props.rawParams = deProcessUIHeaders($scope.props.params);
                } else {
                    $scope.disableBody = false;
                }
                $timeout(function () {
                    $('.bt-request-modal .headersTabBtn').click();
                }, 200);
            });
            $scope.$watch('props.paramType', function (newVal, oldVal) {
                if (newVal === 'raw') {
                    $scope.props.rawParams = deProcessUIHeaders($scope.props.params);
                } else {
                    $scope.props.params = objToArray($scope.props.rawParams);
                    $scope.props.params.push({ key: "", value: "" });
                }

                $timeout(function () {
                    if ($scope.props.paramType === 'xml') {
                        $scope.options.aceMode = 'ace/mode/xml';
                    } else if ($scope.props.paramType === 'custom') {
                        $scope.options.aceMode = 'ace/mode/text';
                    } else {
                        $scope.options.aceMode = 'ace/mode/json';
                    }
                }, 100);

            });

            $scope.$watch('curlText', function (newVal, oldVal) {

            });
            function requestToCurl(_reqObj) {
                return curl.toCurlString(_reqObj);
            }
            function updateCurl() {
                //disabling temporarly
                //                var reqObj = {};
                //                reqObj.payload = deProcessUIHeaders($scope.props.params);//arrayToObj($scope.props.rawParams);
                //                reqObj.headers = deProcessUIHeaders($scope.props.headers);//arrayToObj($scope.props.header);
                //
                //                reqObj.method = $scope.props.endPoint.method.toLowerCase();
                //                reqObj.url = $scope.props.endPoint.requestUrl;
                //
                //                $scope.curlText=requestToCurl(reqObj);
            }

            function curlToRequest(curlTxt) {
                curlTxt = $.trim(curlTxt);
                var reqObj = curl.parse(curlTxt);

                $scope.props.paramType = "raw";
                $scope.props.rawParams = reqObj.payload;
                $scope.props.params = objToArray($scope.props.rawParams);
                $scope.props.headers = objToArray(reqObj.header);

                $scope.props.endPoint.method = reqObj.method.toLowerCase();
                $scope.props.endPoint.requestUrl = reqObj.url;
            }

            $scope.curlOnBlur = function () {
                curlToRequest($scope.curlText);
            };

            $scope.onParamTypeChange = function () {
                var index = _.findIndex($scope.props.headers, function (header) {
                    return header.key === "Content-Type";
                });
                if (index !== -1) {
                    $scope.deleteHeader(index);
                    //$scope.props.headers[index] = {key: "Content-Type", value: $scope.paramTypeMap[$scope.props.paramType]};
                }
                //                else {
                //                    //$scope.props.headers.unshift({key: "Content-Type", value: $scope.paramTypeMap[$scope.props.paramType]});
                //                }
                $scope.props.headers.unshift({ key: "Content-Type", value: $scope.paramTypeMap[$scope.props.paramType] });

                if ($scope.props.paramType === 'custom') {
                    $timeout(function () {
                        $('.bt-request-modal .headersTabBtn').click();
                        $timeout(function () {
                            $('.bt-request-modal .headers-wrp .headerValue').first().focus();
                        }, 100);
                    });
                }

            };
            function idpTestListenersRegistration(callTestRequest) {

                $scope.btTestFormApi.afterInit = function afterInit(serviceAuth) {
                    console.info('idp test afterInit callback is called');
                    $scope.btTestFormApi.test(serviceAuth);
                };

                $scope.btTestFormApi.afterTest = function afterTest() {
                    console.info('idp test afterTest callback is called');
                    console.info($scope.btTestStatus);
                    $timeout(function () {
                        callTestRequest();
                    }, 2000);
                };

                $scope.btTestFormApi.afterClose = function afterClose() {
                    console.info('idp test afterClose callback is called');
                    $scope.testInProgress = false;
                };

                $scope.btTestFormApi.onError = function onError() {
                    console.error('idp test onError callback is called');
                    console.log($scope.btTestStatus);
                    $scope.testInProgress = false;
                };

                $scope.btTestFormApi.onCancel = function onCancel() {
                    console.warn('idp test onCancel callback is called');
                    console.log($scope.btTestStatus);
                    $scope.testInProgress = false;
                };
                $scope.btTestFormApi.onNewAccounts = function (accounts) {
                    $scope.accounts = accounts;
                };
                $scope.btTestFormApi.onAuthTestModalOpen = function () {
                    $('.bt-request-modal').addClass('modalSmall');
                };
                $scope.btTestFormApi.onAuthTestModalClose = function () {
                    $('.bt-request-modal').removeClass('modalSmall');
                    $scope.testInProgress = false;
                };



            }
            $scope.checkIdpAndExecuteAPI = function (account) {
                var _idpName = $scope.newAuth && $scope.newAuth.selected && $scope.newAuth.selected.name;
                if (_idpName && _idpName.toLowerCase() !== 'none') {
                    BTIdpService.getIdpByName(_idpName, $workflowService.selectedStream()._id)
                        .then(function (res) {
                            var idpConfig = res.data;

                            idpConfig = idpConfig || {};
                            idpConfig.type = "idp";
                            idpConfig.testFor = "idp";
                            idpTestListenersRegistration(callTestRequest);
                            if (account) {
                                callTestRequest();
                            } else {
                                $scope.btTestFormApi.init(idpConfig,"",true);
                                var data = { 'isFromtestReq': true };
                                $scope.btTestFormApi.serviceNodeTestInfo(data);
                            }
                        }, function (err) {
                            NotificationService.notify(i18n.i18nString('failed_fetch_idp'), "error");
                            $scope.idpConfig = {};
                        });
                } else {
                    callTestRequest();
                }

                function callTestRequest() {
                    testRequest();
                }

                function triggerTaskTest(account) {
                    loader();
                    var taskConfig = {
                        type: task._id[0] === "l" ? "alert" : "action",
                        testFor: 'task',
                        definition: task
                    };
                    $workflowService.requestData({});
                    task = angular.merge(finalObj, $workflowService.requestData());
                    taskConfig.definition = task;
                    taskTestListenersRegistration();
                    $scope.btTestStatus.streamAccountId = account ? account.streamAccountId : $scope.btTestStatus.streamAccountId || 'none';
                    taskConfig.accountId = $scope.btTestStatus.streamAccountId;

                    $scope.btTestFormApi.init(taskConfig);

                }
            };

            (function () {
                init();
                initAuthData();
                bindEvents();
            })();
        }]);

})(angular);


;(function(ng) {

	var _module = angular.module('bt-resource-versions',[]);
        _module.directive('versionHistory', [function () {

                return {
                    restrict: 'EA',
                    scope: {
                        activeTask: '=',
                    },
                    templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-resource-versions/bt-resource-versions.html',
                    controller: 'BTResourceVersionsCtrl'

                };

            }]);
	 _module.controller('BTResourceVersionsCtrl',
		['$scope','BTAlertsService','BTActionsService','$routeParams','$location','$workflowService','$filter','$rootScope',
		function($scope,BTAlertsService,BTActionsService,$routeParams,$location,$workflowService,$filter,$rootScope){


			$scope.versions = [];
			
		$scope.selectedStream=$workflowService.selectedStream();
		var taskId = $scope.activeTask._id;
		var taskType = $scope.activeTask.taskType;

		if(!$scope.selectedStream){
			$location.path(window.appConfig.CONTEXT_PATH);
			return;
		}

		$scope.options={
		    mode:'text',
		    ace:window.ace
		};

		$scope.context = {
			bot  : $scope.selectedStream.name,
			task : $scope.activeTask.name 
		};

			if(taskType === 'alert'){
				BTAlertsService.getVersions(taskId)
					.then(function(res){
						$scope.versions = res.data.map(function(version){ version.version = +version.version; return version;});
						$scope.versions = $filter('orderBy')($scope.versions,'+version');
					},function(err){

					});
					$scope.helpLink = $rootScope.helpLinks.VERSION_ALERT;
			}else if(taskType === 'action'){
				BTActionsService.getVersions(taskId)
					.then(function(res){
						$scope.versions = res.data.map(function(version){ version.version = +version.version; return version;});
						$scope.versions = $filter('orderBy')($scope.versions,'+version');
					},function(err){

					});
					$scope.helpLink = $rootScope.helpLinks.VERSION_ACTION;
			}else{
				$location.path(window.appConfig.CONTEXT_PATH);
			}

	$scope.exit=function(){
		$location.path(window.appConfig.CONTEXT_PATH);
	};

	}]);


}(angular));

;(function(ng) {

	var _mod = ng.module('bt-resource-view', ['app.helpers']);

	_mod.controller('BTResourceViewCtrl', ['$scope','$rootScope','$routeParams', '$location', '$applicationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService', 'BTFlowtaskService','i18n',
		 function($scope, $rootScope,$routeParams, $location, $applicationService, BTAlertsService, BTActionsService, BTStreamsService, BTFlowtaskService,i18n){

		var resourceType = $routeParams.resourceType,
			resourceId = $routeParams.resourceId,
			flowtype = $routeParams.flowtype,
			apConstants = $applicationService.getAppConstants();

		$scope._constants_ = $rootScope._constants_;

		$scope.resourceLoading = true;
		$scope.resourceType = resourceType;
		$scope.resourceId = resourceId;
		$scope.flowtype = flowtype;
		$scope.resourceDetails = {};

		function fetchResourceDetails() {
			var _promise;
			if(resourceType === apConstants.RESOURCE_TYPE_ALERT) {
				_promise = BTAlertsService.getBTAlert(resourceId);
			} else if(resourceType === apConstants.RESOURCE_TYPE_ACTION) {
				_promise = BTActionsService.getBTAction(resourceId);
			} else if(resourceType === apConstants.RESOURCE_TYPE_STREAM) {
				_promise = BTStreamsService.getBTStream(resourceId);
			} else if(resourceType === apConstants.RESOURCE_TYPE_FLOWTASK) {
                                _promise = BTFlowtaskService.getFlowtaks(resourceId);
                        }

			_promise.then(function(res) {
				$scope.resourceDetails = res.data;
				$scope.resourceDetails.createdBy = $scope.resourceDetails.createdBy.firstName + ' ' + $scope.resourceDetails.createdBy.lastName;
				if(resourceType === apConstants.RESOURCE_TYPE_ALERT) {
					if($scope.resourceDetails.alertFieldsRequired) {
						var alertFieldForTable = {};
						alertFieldForTable.headers = [{name: 'Name', sortable: false},
							                          {name: 'Description', sortable: false},
							                          {name: 'FieldType', sortable: false}];
						alertFieldForTable.rows = [];
						$scope.resourceDetails.alertFieldsDefinition.forEach(function(defn) {
							alertFieldForTable.rows.push({
								Name: defn.title,
	                            Description: defn.description,
	                            FieldType: defn.fieldType
							});
						});
						$scope.alertFieldsInfo = alertFieldForTable;
					}

					var rqInfoForTable = {};
					rqInfoForTable.headers = [{name: 'RqPath', sortable: false},
                        					  {name: 'endpoint', sortable: false}];
                    rqInfoForTable.rows = [];

                    $scope.resourceDetails.requestChain.forEach(function(defn) {
                    	rqInfoForTable.rows.push({
                            RqPath: defn.alertsPath,
                            endpoint: defn.endPoint.protocol+'://'+defn.endPoint.host+(defn.endPoint.port ? ':'+defn.endPoint.port : '')+'/'+defn.endPoint.path
                        });
                    });

                    $scope.rqInfo = rqInfoForTable;
				}

				if(resourceType === apConstants.RESOURCE_TYPE_ACTION) {
					var payloadInfoForTable = {};
					payloadInfoForTable.headers = [{name: 'Title', sortable: false},
                        					  {name: 'Key', sortable: false},
                        					  {name: 'Fieldtype', sortable: false},
                        					  {name: 'Type', sortable: false}];
                    payloadInfoForTable.rows = [];

                    $scope.resourceDetails.payloadField.forEach(function(defn) {
                    	payloadInfoForTable.rows.push({
                            Title: defn.title,
                            Key: defn.key,
                            Fieldtype: defn.fieldType,
                            Type: defn.type
                        });
                    });
                    $scope.payloadInfo = payloadInfoForTable;

					var rqActionInfoForTable = {};
					rqActionInfoForTable.headers = [{name: 'RqPath', sortable: false},
                        					  {name: 'endpoint', sortable: false}];
                    rqActionInfoForTable.rows = [];

                    $scope.resourceDetails.requestChain.forEach(function(defn) {
                    	rqActionInfoForTable.rows.push({
                            RqPath: defn.alertsPath,
                            endpoint: defn.endPoint.protocol+'://'+defn.endPoint.host+(defn.endPoint.port ? ':'+defn.endPoint.port : '')+'/'+defn.endPoint.path
                        });
                    });
                    $scope.rqInfo = rqActionInfoForTable;

     //                var queryFieldInfoForTable = {};
					// queryFieldInfoForTable.headers = [{name: 'Title', sortable: false},
     //                    					  {name: 'Key', sortable: false},
     //                    					  {name: 'Fieldtype', sortable: false},
     //                    					  {name: 'Type', sortable: false}];
     //                queryFieldInfoForTable.rows = [];

     //                $scope.resourceDetails.queryField.forEach(function(defn) {
     //                	queryFieldInfoForTable.rows.push({
     //                        Title: defn.title,
     //                        Key: defn.key,
     //                        Fieldtype: defn.fieldType,
     //                        Type: defn.type
     //                    });
     //                });
     //                $scope.queryFieldInfo = queryFieldInfoForTable;
				}

				loadResourceDetails();
			});
		}

		function loadResourceDetails() {
			$scope.resourceLoading = false;
		}

		fetchResourceDetails();

		$scope.exit = function(){
		    $location.path(window.appConfig.CONTEXT_PATH);
		};

		$scope.onBack = function(wftype) {
			if(wftype === apConstants.RESOURCE_TYPE_STREAM) {
				$location.path('bt/new');
			} else {
				$location.path('bt/workflows');
			}
		};

		$scope.onStreamFormEdit = function() {

		};

	}]);

})(angular);

;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTResponseCtrl', ['$scope', '$rootScope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','$timeout', 'i18n',
        function ($scope, $rootScope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService,$timeout, i18n) {
            var _editorData = '';
            $scope.saving = i18n.i18nString('saving');
            $scope.add    = i18n.i18nString('add');

            function init() {
                
                //fix for IE 11 edit Request: placeholder text is not getting cleared 
                $modalInstance.opened.then(function () {
                    $timeout(function () {
                        $('.bt-response-modal').modal({
                        show:true,
                        backdrop:'static'
                    });
                    }, 300);
                });
                
                $scope.stream = $workflowService.selectedStream();
                $scope.component = config.component.nodeInfo;
                $scope.displayMode = config.component.displayMode;
                $scope.formInvalid = true;
                $scope.saveInProgress = false;
                $scope.advOpt = false;
                $scope.soap = {};
                $scope.name = "";
                $scope.isDefault = false;
                $scope.sampleResCB={};
                $scope.sections = {
                    auth: true,
                    headers: false,
                    params: false,
                    curl: false,
                    testReq: false
                };
                $scope.enterpriseLicenseType = $rootScope.licenseType;
                $scope.props = {
                    headers: [],
                    params:[],
                    endPoint: {}
                };
                if(config.index === -1) {
                    $scope.soap.sample = {};
                    if((!$scope.component.sampleResponse || !$scope.component.sampleResponse.length)) {
                        $scope.isDefault = true;
                    }
                }
                else{
                    $scope.soap.sample = ($scope.component.sampleResponse && $scope.component.sampleResponse[config.index].response) && $scope.component.sampleResponse[config.index].response || {};
                    if(typeof $scope.soap.sample !== "object"){
                        $scope.soap.sample = JSON.parse($scope.soap.sample);
                    }
                    $scope.name = $scope.component.sampleResponse[config.index].name;
                    $scope.isDefault = $scope.component.sampleResponse[config.index].isDefault;
                }
                $scope.sampleResCB.onBlur = function (editor) {
                    var _value = editor.getText();
                    _editorData = _value;
                    if (_value === '') {
                        $scope.soap.sample = {};
                    }
                    $scope.checkFormValid();
                };
                $scope.disableDefaultCheck = (!$scope.component.sampleResponse || ($scope.component.sampleResponse.length === 1 && config.index !== -1) || !$scope.component.sampleResponse.length)?true:false;
                $scope.options={
                    mode:$scope.displayMode === "view"?'tree':'code',
                    ace:window.ace,
                    aceViewMode:$scope.displayMode === "view"?true:false
                };
            }

            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.checkFormValid = function(){
                if(($scope.soap && !$.isEmptyObject($scope.soap.sample)) && ( $scope.name && $scope.name.trim() !== "")){
                    return false;
                }
                return true;
            };
            $scope.saveResponse = function () {
                var _payload = {};
                var _isCorrectJSON = true;
                if (_editorData !== '') {
                    try {
                        JSON.parse(_editorData);
                    } catch (e) {
                        _isCorrectJSON = false;
                    }
                }
                if (_isCorrectJSON) {
                     if($scope.component.sampleResponse && $scope.isDefault) {
                         for(var i=0;i<$scope.component.sampleResponse.length;i++) {
                             $scope.component.sampleResponse[i].isDefault = false;
                         }
                     }
                    _payload.sampleResponse = $scope.component.sampleResponse?$scope.component.sampleResponse:[];
                    if(config.index === -1){
                        var _newResponse = {};
                        _newResponse.response = JSON.stringify($scope.soap.sample);
                        _newResponse.name = $scope.name.trim();
                        _newResponse.isDefault = $scope.isDefault;
                        _payload.sampleResponse.push(_newResponse);
                    }
                    else{
                        _payload.sampleResponse[config.index].response = JSON.stringify($scope.soap.sample);
                        _payload.sampleResponse[config.index].name = $scope.name.trim();
                        _payload.sampleResponse[config.index].isDefault = $scope.isDefault;
                        var _defaultAvaialable = false;
                        for (var j = 0; j < _payload.sampleResponse.length; j++) {
                            if (_payload.sampleResponse[j].isDefault) {
                                _defaultAvaialable = true;
                                break;
                            }
                        }
                        if(!_defaultAvaialable) {
                            _payload.sampleResponse[0].isDefault = true;
                        }
                    }
                    saveToServer(_payload);
                } else {
                    NotificationService.notify(i18n.i18nString('please_Correct_errors'));
                }
            };

            function saveToServer(_payload) {
                $scope.saveInProgress = true;
                BTFlowtaskService.updateComponent($scope.stream._id, $scope.component._id, _payload).then(function (res) {
                    if (res && res.data) {
                        if (config && config.cbBridge && config.cbBridge.onServiceSave) {
                            config.cbBridge.onServiceSave(res.data);
                        }
                        $scope.closeModal();
                    }
                    $scope.saveInProgress = false;
                }, function (error) {
                    $scope.component.sampleResponse = _.uniq($scope.component.sampleResponse, function(item, key, a) { 
                        return item.name;
                    });
                    $scope.saveInProgress = false;
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if (error.errors && _.isArray(error)) {
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg, 'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                    }
                });
            }
            $scope.checkFormValid();
            (function () {
                init();
            })();
        }]);

})(angular);


;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTSamplecontextCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'NotificationService','i18n',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, NotificationService,i18n) {
            var _editorData = '';

            $scope.saving = i18n.i18nString('saving');
            $scope.save   = i18n.i18nString('save'); 
            
            function init() {
                $scope.stream = $workflowService.selectedStream();
                $scope.component = config.component;
                $scope.saveInProgress = false;
                $scope.soap = {};
                $scope.sampleResCB={};
                try {
                    $scope.soap.sample = JSON.parse($scope.component.dialogComponent && $scope.component.dialogComponent.previewContext || "{}");
                } catch (e) {
                    $scope.soap.sample = {};
                }
                $scope.sampleResCB.onBlur = function (editor) {
                    var _value = editor.getText();
                    _editorData = _value;
                    if (_value === '') {
                        $scope.soap.sample = {};
                    }
                };
            }
            $scope.options={
                mode:$scope.displayMode === "view"?'tree':'code',
                ace:window.ace
            };
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.saveContextMap = function () {
                var _payload = {};
                var _isCorrectJSON = true;
                if (_editorData !== '') {
                    try {
                        JSON.parse(_editorData);
                    } catch (e) {
                        _isCorrectJSON = false;
                    }
                }
                if (_isCorrectJSON) {
                    _payload.previewContext = JSON.stringify($scope.soap.sample);
                    saveToServer(_payload);
                } else {
                    NotificationService.notify(i18n.i18nString('please_Correct_errors'));
                }
            };

            function saveToServer(_payload) {
                $scope.saveInProgress = true;
                BTFlowtaskService.updateComponent($scope.stream._id, $scope.component.dialogComponent._id, _payload).then(function (res) {
                    if (res && res.data) {
                        if (config && config.cbBridge && config.cbBridge.onServiceSave) {
                            config.cbBridge.onServiceSave(res.data, $scope.soap.sample);
                        }
                        $scope.closeModal();
                    }
                    $scope.saveInProgress = false;
                }, function (error) {
                    $scope.saveInProgress = false;
                });
            }

            (function () {
                init();
            })();
        }]);

})(angular);


;(function acify(ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTScriptCtrl', ['$scope', 'soap', '$rootScope', '$translator', '$modalInstance', '$workflowService', 'BTStreamsService', 'config', 'BTFlowtaskService', 'urlutil','NotificationService','i18n',
        function ($scope, soap, $rootScope, $translator, $modalInstance, $workflowService, BTStreamsService, config, BTFlowtaskService, urlutil, NotificationService,i18n) {
            function init() {
                $scope.stream = $workflowService.selectedStream();
                $scope.component = config.component.nodeInfo;
                $scope.readonly = config.component.displayMode && config.component.displayMode === 'view' ? true : false;
                $scope.saveInProgress = false;
                $scope.scriptObj = config.component.nodeInfo.script && decodeJS(config.component.nodeInfo.script)  || '';
                $scope.codeCallback = {};
            }
            $scope.saving = i18n.i18nString('saving');
			$scope.save   = i18n.i18nString('save'); 



            $scope.closeModal = function () {
                $modalInstance.close();
            };
            
            $scope.saveScript = function () {
                if($scope.invalidScript){
                    NotificationService.notify(i18n.i18nString('save_script'),'error');
                    return;
                }
                var _payload = {};
                _payload.script = encodeJS($scope.scriptObj);
                saveToServer(_payload);
            };
            function encodeJS(_obj) {
                return encodeURIComponent(_obj);
            }
            function decodeJS(_obj) {
                var decodeText = "";
                try{
                    decodeText =decodeURIComponent(_obj);
                }catch(ex){
                    decodeText = _obj; 
                }finally{
                    return decodeText;
                }
            }
            
            function saveToServer(_payload) {
                $scope.saveInProgress = true;
                BTFlowtaskService.updateComponent($scope.stream._id, $scope.component._id, _payload).then(function (res) {
                    if (res && res.data) {
                        if (config && config.cbBridge && config.cbBridge.onScriptSave) {
                            config.cbBridge.onScriptSave(res.data);
                        }
                        $scope.closeModal();
                    }
                    $scope.saveInProgress = false;
                }, function (error) {
                    if (error && error.data && error.data.errors) {
                        var _msg = error.data.errors[0].msg;
                        NotificationService.notify(_msg, 'error');
                    } else if(error.errors && _.isArray(error)){
                        var msg = error.errors[0].msg;
                        NotificationService.notify(msg,'error');
                    } else {
                        NotificationService.notify(i18n.i18nString('save_script_error'), 'error');
                    }
                    //$scope.closeModal();
                    //$scope.component.script = $scope.scriptObj;
                    //config.cbBridge.onScriptSave($scope.component);
                    $scope.saveInProgress = false;
                });
            }

            (function () {
                init();
            })();

            $scope.codeCallback.onBlur = function (editor) {
                if (_.filter(editor.getSession().getAnnotations(), {type: 'error'}).length) {
                    $scope.invalidScript = true;
                } else {
                    $scope.invalidScript = false;                    
                }
            };
            $scope.codeCallback.displayMode = config.component.displayMode;

        }]);

})(angular);


;(function (ng) {

    'use strict';

    var _module = ng.module('bt-solution-install', []);

    _module.directive("btSolutionInstall", function() {
        return {
            restrict: "EA",
            scope: {
                onCancel: '&',
                smartBotId:'='
            },
            templateUrl: window.appConfig.TMPLT_PRE_PATH + "js/modules/bt-solution-install/bt-solution-install.html",
            controller: "BTSolutionInstall"
        };
    });


    _module.controller('BTSolutionInstall',
            ['$scope', '$workflowService', 'BTStreamsService', 'BTFlowtaskService', '$location', '$endpoints', 'BTFileUploadService', 'NotificationService', 'form_util','$rootScope', "env_conf", "$applicationService",'i18n',
                function ($scope, $workflowService, BTStreamsService, BTFlowtaskService, $location, $endpoints, BTFileUploadService, NotificationService, form_util, $rootScope, env_conf, $applicationService,i18n) {
                    
                    $scope.char_remaining = i18n.i18nString('char_remaining');
                    
                    
                    
                    $scope.stream = $workflowService.selectedStream();
                    $workflowService.currentLanguage($scope.stream.defaultLanguage);
                    if ($scope.stream.solutionBotSettings && $scope.stream.solutionBotSettings.configInstFileId) {
                        $scope.showPdfLoading = true;
                        $scope.planeText= false;
                    }else{
                         $scope.planeText= true;
                    }
                    $scope.backArrow = env_conf['context-url']+'/assets/settingsIcons/closeCross.png';
                    $scope.sections = [
                        {name: 'instructionsForm', active: false, enabled: false},
                        {name: 'aboutBotForm', active: false, enabled: false,formName:'aboutBotForm'},
                    ];
                    $("embed").ready(function () {
                          setTimeout(function () {
                                 $scope.showPdfLoading = false;
                                 $("embed").removeClass('displayBlock');
                            }, 1000);
                    });
                    $scope.getBotVariables = function(smartbotid) {
                        BTFlowtaskService.getAllVariables($applicationService.userInfo().userId, smartbotid).then(function (res) {
                            
                            $workflowService.botEnvVariables(res.data.variables);
                            var _botVariables = res.data.variables;
                            $scope.botVariables=[];
                            $scope.constants = $rootScope._constants_;
                            $.each(_botVariables, function (i, variable) {
                                delete variable.createdBy;
                                delete variable.createdOn;
                                delete variable.modifiedBy;
                                delete variable.modifiedOn;
                                delete variable.__v;
                                delete variable._id;
                                delete variable.streamId;
                                if (variable.scope === 'askOnInstall') {
                                    variable.value = "";
                                }
                                if (variable.variableType === "env") {
                                    $scope.botVariables.push(variable);
                                }
                            });
                            if ($scope.botVariables && $scope.botVariables.length) {
                                $scope.sections[2]={name: 'variablesForm', active: false, enabled: false,formName:'variablesForm'};
                                $scope.sections[2].enabled = false;
                                var _ele = _.find($scope.botVariables, function (variable) {
                                    if (variable.scope === 'prePopulated' || variable.scope === 'askOnInstall') {
                                        $scope.sections[2].enabled = true;
                                        return variable;
                                    }
                                });
                            }
                            $scope.tempBotVariables = angular.copy($scope.botVariables);
                        }, function (error) {
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('unexpected_error_while_fetching_bot_variables'), 'error');
                            }
                        });
                    };
                    $scope.smartBotId = $scope.smartBotId || $scope.stream.sbStreamId;
                    $scope.getBotVariables($scope.stream._id);
                    if ($scope.stream.solutionBotSettings) {
                        if ($scope.stream.solutionBotSettings.configInstURL && $scope.stream.solutionBotSettings.configInstURL.startsWith("www.")) {
                            $scope.stream.solutionBotSettings.configInstURL = 'http://' + $scope.stream.solutionBotSettings.configInstURL;
                        }
                        $scope.sections[0].active = true;
                        $scope.sections[0].enabled = true;
                        $scope.sections[1].enabled = true;
                    } else {
                        $scope.sections[1].enabled = true;
                        $scope.sections[1].active = true;
                    }
                        
                  
                   
                    $scope.aboutBotData = {};
                    $scope.aboutBotData.name = $scope.stream.name;
                    $scope.aboutBotData.color = $scope.stream.color;
                    $scope.aboutBotData.inheritanceType = ($scope.stream.inheritanceType) || 1;

                    $scope.enabledSections = function () {
                        return _.filter($scope.sections, function (section) {
                            return section.enabled === true;
                        });
                    };

                    $scope.getActiveSectionIndex = function () {
                        return _.findIndex($scope.sections, function (section) {
                            return section.active === true;
                        });
                    };

                    $scope.canShowBack = function () {
                        return ($scope.enabledSections().length > 0) && ($scope.getActiveSectionIndex() > 0) ? true : false;
                    };
                    $scope.canShowNext = function () {
                        return ($scope.enabledSections().length > 0) && ($scope.getActiveSectionIndex() < $scope.enabledSections().length - 1) ? true : false;
                    };
                    $scope.canShowFinish = function () {
                        return ($scope.getActiveSectionIndex() === $scope.enabledSections().length - 1) ? true : false;
                    };
                    
                    $scope.validateSection = function (section) {
                        if (section && section.formName) {
                            if ($scope[section.formName]&& $scope[section.formName].$invalid) {
                                form_util.touch($scope[section.formName]);
                                return false;
                            } else {
                                return true;
                            }
                        }else{
                           return true; 
                        }
                    };
                   $scope.next= function(){
                       $scope.disableNext = true;
                       var index = $scope.getActiveSectionIndex();
                       var sectionIndex = index + 1;
                       if(sectionIndex===2){
                           var IDD  = sectionIndex;
                       }
                      if(sectionIndex<$scope.sections.length){
                          $scope.navigate($scope.sections[sectionIndex]);
                      }
                   };
                    $scope.navigate = function (section) {
//                        if (!$scope.validateSection($scope.enabledSections()[$scope.getActiveSectionIndex()])) {
//                            return;
//                        }
                        $scope.sections.forEach(function (section) {
                            section.active = false;
                        });
                        section.active = true;
                        $('html, body').animate({scrollTop: 0}, 'fast');
                        $scope.disableNext = false;
                    };
                    $scope.uploadStreamIcon = function () {
                        if ($scope.aboutBotData.iconFile.name) {
                            var _ext = $scope.aboutBotData.iconFile.name.substring($scope.aboutBotData.iconFile.name.lastIndexOf('.'));
                            if (_ext !== '.png') {
                                NotificationService.notify(i18n.i18nString('uploadfile_noty_error'), "error");
                                $scope.fileExtensionError = true;
                                return;
                            }
                        }

                        $scope.fileExtensionError = false;

                        var data = new FormData();
                        data.append('file', $scope.aboutBotData.iconFile);
                        data.append('fileContext', 'marketplace');
                        data.append('fileExtension', 'png');

                        $scope.iconUploading = true;

                        BTFileUploadService.uploadFile(data)
                                .then(function (response) {
                                    var fileUploaded = {
                                        fileName: $scope.aboutBotData.iconFile.name,
                                        fileId: response.data.fileId
                                    };

                                    $scope.aboutBotData.icon = fileUploaded;

                                    NotificationService.notify(i18n.i18nString('file_uploaded_sucess_noty',{dyn: fileUploaded.fileName}), "success");

                                    $scope.iconUploading = false;
                                }, function (response) {
                                    NotificationService.notify(i18n.i18nString('oops_label') + response.data.errors[0].msg, "error");
                                    $scope.iconUploading = false;
                                });
                    };
                    $scope.deleteStreamIcon = function () {
                        $scope.aboutBotData.iconFile = null;
                        $scope.aboutBotData.icon = null;
                        $('#sbots_iconFile').val('');
                    };

                    $scope.isFormValid = function () {
                        return !($scope.aboutBotForm.$invalid);
                    };
                    $scope.installSolBot = function () {

                        if (!$scope.validateSection($scope.enabledSections()[$scope.getActiveSectionIndex()])) {
                            return;
                        }
                        
                        var _aboutBotSection = _.find($scope.enabledSections(), {formName: "aboutBotForm"});
                        if (!$scope.validateSection(_aboutBotSection)) {
                            $scope.navigate(_aboutBotSection);
                            return;
                        }
                                               
                        var installSolBotData = {};// $workflowService.selectedStream();
                        installSolBotData.name = $scope.aboutBotData.name;
                        //installSolBotData.mention = $scope.aboutBotData.mention;
                        installSolBotData.color = $scope.aboutBotData.color;
                        if (!$scope.aboutBotData.iconType) {
                            installSolBotData.icon = $scope.aboutBotData.icon.fileId;//aboutBotData.icon.fileName;
                        }
                        if($scope.aboutBotData.inheritanceType){
                            installSolBotData.inheritanceType = parseInt($scope.aboutBotData.inheritanceType);
                        }else{
                            installSolBotData.inheritanceType = 1;
                        }
                         
//                        if($scope.botVariables){
//                            installSolBotData.variables = $scope.botVariables;
//                            installSolBotData.variables = $scope.botVariables.map(function(variable){
//                                if (variable.variables) {
//                                    var variables = variable.variables.map(function (variable) {
//                                        var _variable = {};
//                                        _variable.key = variable.key;
//                                        _variable.scope = variable.scope;
//                                        _variable.value = variable.value;
//                                        return _variable;
//                                    });
//
//                                    variable.variables = variables; 
//                                    return variable;
//                                }
//                            });
//                        }
                        

                        $scope.botInstalling=true;    
                        var variablePayload = $scope.botVariables;
                         BTStreamsService.addbulkBotVariables($applicationService.userInfo().userId,$scope.stream._id, variablePayload).then(function (res) {
                             BTStreamsService.editStream($workflowService.selectedStream()._id, installSolBotData)
                                .then(function (response) { // success
                                    $workflowService.selectedStream(angular.extend($workflowService.selectedStream(),response.data));
                                    BTStreamsService.updateMPStream($workflowService.selectedStream()._id, installSolBotData)
                                            .then(function (response) { // success
                                         NotificationService.notify(i18n.i18nString('bot_installed_success_noty'), 'success');
                                                $location.path(window.appConfig.CONTEXT_PATH);
                                                BTStreamsService.getStreams()
                                                .then(function(res) {
                                                    $workflowService.streamsAll(res.data);
                                                    $scope.$emit("streamUpdate");
                                                    // $rootScope.$emit("triggerSelectApp");
                                                    goHome();
                                                });
                                                $scope.botInstalling=true;                                
                                            }, function (res) { // error
                                                NotificationService.notify(res.data.errors[0].msg, 'error');
                                                $scope.botInstalling=false;
                                            });

                                }, function (res) { // error
                                    NotificationService.notify(res.data.errors[0].msg, 'error');
                                    $scope.botInstalling=false;
                                });
                         },function(err){
                             $scope.botInstalling=false;
                             NotificationService.notify(i18n.i18nString('bot_installation_err'), 'error');
                         });
                        


                    };

                  $scope.goToHome = function () {
                      var message = "<p><i class='fa fa-exclamation-circle fa-2x' aria-hidden='true' style='color: #009dac;'></i></p>"+i18n.i18nString('bt_solution_install_config_not_complete');
					window.bootbox.dialog({
						message: message,
						title: i18n.i18nString('bt_solution_install_cancel_install'),
						className: "alert-modal",
						buttons: {
							main: {
								label: i18n.i18nString('bt_solution_install_setup_later'),
								className: "btn-primary",
								callback: goHome
							},
							success: {
								label: i18n.i18nString('bt_solution_install_continue_setup'),
								className: "btn-primary",
								callback: function () {
									
								}
							}
						},
						onEscape: true
					});
                                
			};
                        function goHome() {
                        $workflowService.navigateTabIndex(".tasks-pane");
                        //$scope.$emit("loadBots", $workflowService.selectedStream());
                        $rootScope.$emit('selectOrChangeBot',$scope.stream);
                        $scope.onCancel();
                        $(".bootbox-close-button").trigger('click');
                    }
                }]);

})(angular);


;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btStore', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-store/bt-store.html',
            controller: 'btStoreController'
        };
    });
    _module.controller("btStoreController", ['$scope', '$window', '$workflowService', '$element', '$location','$sce', '$translator',
        function ($scope, $window, $workflowService, $element, $location,$sce, $translator) { 
            $scope.stream = $workflowService.selectedStream();
            $scope.productSelected = $scope.productSelected  || "Conversational-App";
            $scope.baseUrl = window.appConfig.API_SERVER_URL;
            if( window.location.href && (window.location.href.includes('dev.kore') || window.location.href.includes('localhost:4200'))){
                $scope.baseUrl= 'http://localhost:4201';
            }
            if($scope.selectedHomeTab && $scope.selectedHomeTab === 'bots'){
                var authObj = $translator.getAuthObj();
                var accessToken= authObj.accessToken;
                $scope.storeUrl = $scope.baseUrl+"/botstore/store?product=Conversational-App#from=botbuilder";
            } else if($scope.welcomeForm){
                if($scope.productSelected === 'Process-App'){
                    $scope.storeUrl = $scope.baseUrl+"/botstore/store?product=Process-App&iFrame=vaOnboarding#from=processApp";
                } else {
                    $scope.storeUrl = $scope.baseUrl+"/botstore/store?product=Conversational-App&iFrame=vaOnboarding#from=botbuilder";
                }
            }
            var iframe = $("#storeFrame");
             iframe.on("load", function () { 
                    //Make sure it is fully loaded
                    iframe.contents().click(function (event) {
                        iframe.trigger("click");
                        $("body").trigger("click");
                    });

                });
            window.addEventListener('message',function(event){
                if(event.data.action === "closeStore"){
                    $scope.loadingStore = false;
                    window.scrollTo(0,0);
                    $scope.$emit('updateStore',{'loadStore':$scope.loadingStore});
                }
            });

            $scope.$on('updateStoreIframeSrc',function(){
                if($scope.selectedHomeTab && $scope.selectedHomeTab === 'bots'){
                    var authObj = $translator.getAuthObj();
                    var accessToken= authObj.accessToken;
                    $scope.storeUrl = window.appConfig.API_SERVER_URL+"/botstore/store?product=Conversational-App#from=botbuilder";
                    // $scope.storeUrl = "http://localhost:4200"+"/botstore/store?product=Conversational-App#from=botbuilder";
                    }
               
            });

            $scope.trustSrc = function(url){
              return $sce.trustAsResourceUrl(url);
            };

        }]);

}(angular));


;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btStoryBoard', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-storyboard/bt-storyboard.html',
            controller: 'btStoryBoardController'
        };
    });
    _module.controller("btStoryBoardController", ['$scope', '$window', '$workflowService', '$element', '$location', '$sce','$util','BTStreamsService','$applicationService','i18n','mixPanel',
        function ($scope, $window, $workflowService, $element, $location, $sce, $util,BTStreamsService,$applicationService,i18n,mixPanel) {
            $scope.csvContent = null;
            $scope.importedSceneFile = null;
            $scope.fileName = null;
            $scope.userInfo = $applicationService.userInfo();
            $scope.fileId = null;
            $scope.startImporting =  false;
            $scope.importScene = {
              name: ''
            };
            $scope.incliudeComments = false;
            $scope.previewMode = false;
            $scope.resetLinkImg = window.appConfig.CONTEXT_PATH+'/assets/images/resetGreenIcon.svg';
            $scope.stream = $workflowService.selectedStream();
             function prepareIframeUrlForScene(scene){
                if( window.location.href && (window.location.href.includes('dev.kore') || window.location.href.includes('localhost'))){
                    $scope.storyBoardUrl = $sce.trustAsResourceUrl('http://localhost:4200/builderx/conversation/stories/' + $scope.stream._id + '/'+scene._id+'/storyEdit');
                 } else {
                     $scope.storyBoardUrl = window.appConfig.API_SERVER_URL + '/builderx/conversation/stories/' + $scope.stream._id+ '/'+scene._id+'/storyEdit';
                }
             }
            $scope.openSceneModal =  false;
            function setForm() {
                $scope.createSceneObj = {
                    name:'',
                    description:"",
                    status:"In Progress"
                };
            }
            setForm();
            $scope.createSceneSlider =  function(open,scene,clone){
                if(open){
                    setForm();
                    if(scene){
                        if(clone){
                            $scope.createSceneObj = {
                                name:'',
                                description:'',
                                status: "In Progress",
                                _id:scene._id
                            };
                        } else {
                            $scope.createSceneObj = {
                                name:scene.name,
                                description:scene.description,
                                status:scene.description || "In Progress",
                                _id:scene._id
                            };
                        }
                    } else{
                        setForm();
                    }
                    $scope.cloneScene = clone || false;
                    $scope.createSceneObj.showCreation =  true;
                    $scope.modalSlider.open("#createScene");
                } else {
                    $scope.createSceneObj.showCreation =  false;
                    $scope.modalSlider.close("#createScene");
                }
            };
            if($scope.botDetailsCb){
                $scope.botDetailsCb.createSceneSlider =  $scope.createSceneSlider;
            }
            $scope.openExportSlider =  function(scene){
                $scope.modalSlider.open("#exportStoryScene");
                $scope.selectedScene = scene;
                $scope.shareInfo = scene.shareInfo[0];
                $scope.interactiveLink = $scope.shareInfo.link;
                $scope.shareInfo.isSecured = $scope.shareInfo.isSecured || false;
                
            };
            $scope.closeExportSlider = function(){
                $scope.modalSlider.close("#exportStoryScene");
            };
            if($scope.botDetailsCb){
                $scope.botDetailsCb.openExportSlider =  $scope.openExportSlider;
            }
            $scope.iframeEvent = function(e,data){
                if (data && data.action) {
                    switch (data.action) {
                        
                        case 'openDialogTask':
                            if(data.payload) {
                               $scope.openDialog(data.payload);
                            }
                            break;
                        case 'previewOpened':
                             $scope.previewOpened(true);
                            break;
                        case 'previewClosed':
                             $scope.previewOpened(false);
                            break;  
                        case 'closeStoryConversation':
                            $scope.closeScene();
                            break;
                        default:
                            break;
                 }
             }
            };
            $scope.$on("dialogIframeEvent", $scope.iframeEvent);
            $scope.openDialog = function(data){
                if($util.isIE11OrEarlier()){
                    $util.showUnSupportedBrowserWarningForDialog();
                    return false;
                }
                $scope.editOrViewWorkflow(data,'dialog');
            };
            $scope.previewOpened =  function(mode){
                $scope.previewMode = mode;  
            };
            var iframe = $("#storyBoardFrame");
            iframe.on("load", function () { 
                //Make sure it is fully loaded
                iframe.contents().click(function (event) {
                    iframe.trigger("click");
                    $("body").trigger("click");
                });
            });
            $scope.$emit('nestedComponentLoaded', {
                'id': 'storyboard',
                'flag': false
            });
            $scope.openScene =  function(scene){
                prepareIframeUrlForScene(scene);
                $scope.openSceneModal =  true;
                $("#storySceneModal").modal("show");
            };
            if($scope.botDetailsCb){
                $scope.botDetailsCb.openScene =  $scope.openScene;
            }
            $scope.closeScene = function(){
                $("#storySceneModal").modal("hide");
                $scope.openSceneModal =  false;
                $scope.cloneScene =  false;
            };
            $scope.proceedCreateScene =  function(){
             var payload = {
                name:$scope.createSceneObj.name,
                description:$scope.createSceneObj.description,
                status:$scope.createSceneObj.status || "In Progress"
             };
             if($scope.cloneScene && $scope.createSceneObj._id) {
                $scope.cloningInProgress =  true;
                BTStreamsService.cloneScene($workflowService.selectedStream()._id,$scope.createSceneObj._id,payload).then(function (res) {
                    $scope.cloningInProgress =  false;
                    $scope.cloneScene =  false;
                    $scope.callbacks.getScenes($workflowService.selectedStream()._id);
                    $scope.createSceneSlider();
                    $scope.openScene(res.data);
                },function(err){
                    $scope.cloningInProgress =  false;
                });
             } else if($scope.createSceneObj._id){
                  $scope.creatingScene =  true;
                BTStreamsService.editScene($workflowService.selectedStream()._id,$scope.createSceneObj._id,payload).then(function (res) {
                    $scope.creatingScene =  false;
                    $scope.callbacks.getScenes($workflowService.selectedStream()._id);
                },function(err){
                    $scope.creatingScene =  false;
                });
             } else {
                BTStreamsService.createScene($workflowService.selectedStream()._id,payload).then(function (res) {
                    $scope.creatingScene =  false;
                    $scope.callbacks.getScenes($workflowService.selectedStream()._id);
                    $scope.createSceneSlider();
                    $scope.openScene(res.data);
                },function(err){
                    $scope.creatingScene =  false;
                });
             }
            };
            $scope.clearModal = function () {
                $scope.csvContent = null;
                $scope.fileName = null;
                $scope.fileId = null;
                $('#importStoryFile').val(null);
                $scope.importScene = {
                    name: '',
                };
                $scope.incliudeComments = false;
                $scope.fileExtensionError = false;
            };
            $scope.fileChangeListener = function (event) {
                $scope.fileExtensionError = false;
                var fileName = '';
                if (event && event.target && event.target.files && event.target.files.length && event.target.files[0].name) {
                    fileName = event.target.files[0].name;
                } else {
                    return;
                }
                var _ext = fileName.substring(fileName.lastIndexOf('.'));
                if (_ext !== '.csv') {
                    $('#importStoryFile').val(null);
                    $scope.fileExtensionError = true;
                    NotificationService.notify(i18n.i18nString('validation_csv'), 'error');
                    return;
                } else {
                    $scope.fileName = fileName;
                    $scope.fileExtensionError = false;
                }
                $scope.onFileSelect(event.target, _ext);
            };
            $scope.onFileSelect = function (input, ext) {
                ext = (ext || '').replace('.', '');
                var files = input.files;
                var content = $scope.csvContent;
                if (files && files.length) {
                    var fileToRead = files[0];

                    var onFileLoad = function (fileLoadedEvent){
                        var textFromFileLoaded = fileLoadedEvent.target.result;
                        $scope.csvContent = textFromFileLoaded;
                        var data = new FormData();
                        data.append('file', fileToRead);
                        data.append('fileContext', 'bulkImport');
                        data.append('fileExtension', ext);
                        data.append('Content-Type', fileToRead.type);
                        BTStreamsService.uploadFAQFile($applicationService.userInfo().userId, data)
                            .then(function (response) {
                                $scope.fileId = response.data.fileId;
                                NotificationService.notify(i18n.i18nString('file_uploaded_sucess_noty',{dyn: $scope.fileName}), 'success');
                                $scope.fileExtensionError = false;
                                $('#importStoryFile').val(null);
                            }, function (errRes) {
                                if (errRes && errRes.error.errors && errRes.error.errors.length && errRes.error.errors[0] && errRes.error.errors[0].msg) {
                                    NotificationService.notify(errRes.error.errors[0].msg, 'error');
                                } else {
                                    NotificationService.notify(i18n.i18nString('failed_file'), 'error');
                                }
                            });
                    };
                    var fileReader = new FileReader();
                    fileReader.onload = onFileLoad;

                    fileReader.readAsText(fileToRead, 'UTF-8');
                }
            };
            $scope.importSelectedSceneFile = function(fileId) {
                    $scope.startImporting = true;
                    var payload = {
                      fileName: fileId,
                      fileType: 'csv',
                      importType: 'new',
                      delimiter: ',',
                      includeComments : $scope.incliudeComments
                  };
                    if ($scope.importInfo && $scope.importInfo.importMode === 'existing') {
                    payload.importType = 'existing';
                    payload.sceneId = $scope.importInfo.sceneId;
                  } else {
                    payload.sceneName = $scope.importScene.name;
                  }
                  BTStreamsService.importScene($workflowService.selectedStream()._id, payload)
                            .then(function (response) {
                                $scope.callbacks.getScenes($workflowService.selectedStream()._id);
                                var eventPayload =  {
                                    "streamId":$workflowService.selectedStream()._id,
                                    "Bot Name": $workflowService.selectedStream().name,
                                    "Level":"Engagement L1",
                                    "Category":"Engagement L1",
                                    "Description":"If the user taps on proceed to start with the new storyboard or successfully imports a scene to get started with a storyboard",
                                    "Sub Category": "Conversation - Storyboard",
                                    "Storyboard Source":'Import',
                                    "Result":"Import SuccessFull",
                                  };
                                  mixPanel.postEvent('Conversation - Initiate Storyboard',eventPayload);
                                  $scope.clearModal();
                                  $scope.closeImportStoryModal();
                                  $scope.openImport = false;
                                  $scope.startImporting = false;
                                  NotificationService.notify(i18n.i18nString('scene_imported'), 'success');
                            }, function (errRes) {
                                errRes =  errRes.data;
                                var _eventPayload =  {
                                    "streamId": $workflowService.selectedStream()._id,
                                    "Bot Name": $workflowService.selectedStream().name,
                                    "Level":"Engagement L1",
                                    "Category":"Engagement L1",
                                    "Description":"If the user taps on proceed to start with the new storyboard or successfully imports a scene to get started with a storyboard",
                                    "Sub Category": "Conversation - Storyboard",
                                    "Storyboard Source":'Import',
                                    "Result":"Import Failed",
                                  };
                                  $scope.startImporting = false;
                                  if (errRes && errRes.error && errRes.error.errors && errRes.error.errors.length && errRes.error.errors[0] && errRes.error.errors[0].msg) {
                                    NotificationService.notify(errRes.error.errors[0].msg, 'error');
                                    _eventPayload.failure = errRes.error.errors[0].msg;
                                  } else {
                                    _eventPayload.failure = "Import Failed";
                                    NotificationService.notify(i18n.i18nString('failed_import'), 'error');
                                  }
                                  mixPanel.postEvent('Conversation - Initiate Storyboard',_eventPayload);
                            });
                    
                  };
                   $scope.resetInteractiveLink = function(){
                    console.log($scope.shareInfo);
                    var hash = $scope.interactiveLink.split('/');
                    var queryParams = {
                      streamId: $scope.stream._id,
                      sceneId: $scope.selectedScene._id,
                      hash: hash[hash.length - 1]
                    };
                    BTStreamsService.resetShareURL(queryParams).then(function (res) {
                       $scope.shareInfo.link = res.data.newLink;
                    //    $scope.interactiveLink = res.data.newLink;
                    }, function (err) {
                                   NotificationService.notify(err.data.errors[0].msg, "error");
                               });

                   };
                   $scope.protectedPassword = function(){
                       var payload = {
                           shareInfo:[] 
                        };
                           if(!$scope.shareInfo.isSecured){
                               $scope.shareInfo.password = "";
                               payload.shareInfo.push($scope.shareInfo);
                               $scope.updatePassword(payload);
                           }
                         };
                   $scope.updatePassword = function(payload){
                       if(!payload){
                           payload = {
                            shareInfo :[]
                           };
                           payload.shareInfo.push($scope.shareInfo);
                       }
                       if($scope.shareInfo.isSecured && !$scope.shareInfo.password){
                        NotificationService.notify(i18n.i18nString('need_password'), 'error');
                           return;
                       }else{
                        NotificationService.notify(i18n.i18nString('scene_updated'), 'success');
                       }
                       BTStreamsService.updateScene($workflowService.selectedStream()._id,$scope.selectedScene._id,payload).then(function (res) {
                        // $scope.shareInfo.link = res.data.newLink,
                        // $scope.interactiveLink = res.data.newLink;
                     }, function (err) {
                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                });
                   
                   };
                   $scope.copyInteractiveLink = function(text){
                    var textarea = document.createElement('textarea');
                    document.body.appendChild(textarea);
                    textarea.value = text;
                    textarea.select();
                    textarea.setSelectionRange(0, 99999);
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    NotificationService.notify('Copied successfully', 'success');
                   };
                //    $scope.copyToClipboard  = function(text) {
                //     var textarea = document.createElement('textarea');
                //     document.body.appendChild(textarea);
                //     textarea.value = text;
                //     textarea.select();
                //     textarea.setSelectionRange(0, 99999);
                //     document.execCommand('copy');
                //     document.body.removeChild(textarea);
                //     NotificationService.notify('Copied successfully', 'success');
                // };

                $scope.openImportStoryModal =  function(params) {
                    $scope.importScene.showImport =  true;
                    setTimeout(function(){
                        $scope.modalSlider.open("#importStoryScene");
                        if ($('#importStoryFile').length) {
                          $('#importStoryFile').val(null);
                        }
                    },500);
                 };
                 $scope.closeImportStoryModal = function() {
                  $scope.modalSlider.close("#importStoryScene");
                  $scope.openImport = false;
                  if (!$scope.startImporting) {
                    $scope.clearModal();
                    setTimeout(function(){$scope.importScene.showImport =  false;},500);
                  }
                 };
                 if($scope.botDetailsCb){
                    $scope.botDetailsCb.openImportStoryModal =  $scope.openImportStoryModal;
                    $scope.botDetailsCb.closeImportStoryModal =  $scope.closeImportStoryModal;
                }
        }]);

}(angular));



;(function(ng) {

	'use strict';

	var _module = ng.module('bt-stream-create', []);

	_module.controller('BTStreamCreateCtrl',['$scope','$routeParams','$location',function($scope,$routeParams,$location){
                $(window).scrollTop();
		$scope.displayMode = 'edit';
		$scope.streamId = $routeParams.streamId;

		$scope.onStreamFormCancel=function(){
			$location.path(window.appConfig.CONTEXT_PATH);
		};

		$scope.onStreamFormSave=function(){
			$location.path(window.appConfig.CONTEXT_PATH);
		};

		$scope.gotostream = function() {
			$location.path(window.appConfig.CONTEXT_PATH);
		};

	}]);

}(angular));

;(function(ng) {

	'use strict';

	var _module = ng.module('bt-stream-edit', []);

	_module.controller('BTStreamEditCtrl',['$scope','$routeParams','$location','BTStreamsService','NotificationService','$workflowService','i18n',
		function($scope,$routeParams,$location,BTStreamsService,NotificationService,$workflowService,i18n){

		$scope.displayMode = 'edit';
		$scope.streamId = $routeParams.streamId;

		$scope.selectedStream = $workflowService.selectedStream();

		if(Object.keys($workflowService.selectedStream()).length===0){
		    $location.path(window.appConfig.CONTEXT_PATH);
		}

		$scope.onEdit=function(){
			$scope.displayMode = ($scope.displayMode==='view')?'edit':'view';
		};

		$scope.deleteStream=function(){
			BTStreamsService.deleteStream($scope.streamId)
			.then(function(res){
					NotificationService.notify(i18n.i18nString('bot_successfully_deleted'),"success");
					$location.path(window.appConfig.CONTEXT_PATH);
				},function(err){
					NotificationService.notify(i18n.i18nString('bot_successfully_delete_fail'),"error");
			});
		};

		$scope.onStreamFormCancel=function(){
			$scope.displayMode='view';
			$location.path(window.appConfig.CONTEXT_PATH);
		};

		$scope.onStreamFormSave=function(){
			$scope.displayMode='view';
			$location.path(window.appConfig.CONTEXT_PATH);
		};

		$scope.gotostream = function() {
			$location.path(window.appConfig.CONTEXT_PATH);
		};

	}]);

}(angular));

;(function (ng) {

    'use strict';

    var btstreams = ng.module('bt-streams', ['ui.bootstrap']);
    
    btstreams.directive('adjustbotlist','i18n', function ($window, $document,i18n) {
        return function (scope, element) {
            var w = ng.element($window);
            //d = ng.element($document),
            //_cntr = $('.botsDetailContainer');
            $scope.saving = i18n.i18nString('saving');
            $scope.save   = i18n.i18nString('save');
            $scope.utterances_label = i18n.i18nString('Utterances');
            $scope.utterance_label = i18n.i18nString('utterence_label');


            function setCss() {
                //element.height(d.height() - element.offset().top);
                element.css('height', w.height() - element.offset().top + $(document).scrollTop() + 'px');
            }
            setCss();
            scope.onWinResize = function () {
                setCss();
            };
            w.bind('resize', function () {
                scope.onWinResize();
            });
            w.bind('scroll', function () {
                setCss();
            });
        };
    });
    btstreams.filter('myBots', function ($applicationService) {
        return function (streams) {
            return _.filter(streams, function (stream) {
                return stream.createdBy.id === $applicationService.userInfo().userId;
            });
        };
    });
    btstreams.filter('sharedBots', function ($applicationService) {
        return function (streams) {
            return _.filter(streams, function (stream) {
                return stream.createdBy.id !== $applicationService.userInfo().userId;
            });
        };
    });

    /**
     * Params element,full in view is boolen and scroll element 
     * This utility is to know the element in in view port or not.we are using this to decide we need to scroll or not to view the element 
     */
    btstreams.factory('indexerUtil', [function () {
        function isElementInView(element, fullyInView, srollEle) {
            var pageTop = $(srollEle).scrollTop();
            var pageBottom = pageTop + $(srollEle).height();
            var elementTop = $(element).offset().top;
            var elementBottom = elementTop + $(element).height();

            if (fullyInView === true) {
                return ((pageTop < elementTop) && (pageBottom > elementBottom));
            } else {
                return ((elementTop <= pageBottom) && (elementBottom >= pageTop));
            }
        }
        return {
            isElementVisible: isElementInView
        };
    }]);



    btstreams.factory('flowsUtil', [function () {

        function arrangeMappings(mappings) {
            var results = [];
            var obj = {};
            mappings.map(function (mapping, index) {
                var key = "";
                if (mapping.sourceResourceId && mapping.targetResourceId) { // to handle dialog task mappings
                    key = mapping.sourceResourceId + '-' + mapping.targetResourceId;
                    if (!obj[key]) {
                        obj[key] = {
                            index: index,
                            sourceResourceVersion: mapping.sourceResourceVersion,
                            targetResourceVersion: mapping.targetResourceVersion,
                            oldVersions: []
                        };
                    } else if (compareVersion(obj[key].sourceResourceVersion, mapping.sourceResourceVersion, mapping) || compareVersion(obj[key].targetResourceVersion, mapping.targetResourceVersion, mapping)) {
                        obj[key].oldVersions.push(_.clone(obj[key]));
                        obj[key].index = index;
                        obj[key].sourceResourceVersion = mapping.sourceResourceVersion;
                        obj[key].targetResourceVersion = mapping.targetResourceVersion;
                    }
                }
                else {
                    key = mapping.alertId + '-' + mapping.actionId;
                    if (!obj[key]) {
                        obj[key] = {
                            index: index,
                            alertVersion: mapping.alertVersion,
                            actionVersion: mapping.actionVersion,
                            oldVersions: []
                        };
                    } else if (compareVersion(obj[key].alertVersion, mapping.alertVersion, mapping) || compareVersion(obj[key].actionVersion, mapping.actionVersion, mapping)) {
                        obj[key].oldVersions.push(_.clone(obj[key]));
                        obj[key].index = index;
                        obj[key].alertVersion = mapping.alertVersion;
                        obj[key].actionVersion = mapping.actionVersion;
                    }
                }
            });
            Object.keys(obj).map(function (key) {
                var mapping = mappings[obj[key].index];
                mapping.oldVersions = [];
                obj[key].oldVersions
                    .map(function (version) {
                        mapping.oldVersions.push(mappings[version.index]);
                        //to show parent published tasks
                        if (mappings[version.index].state === 'active' && mapping.parentMapId === mappings[version.index].mapId) {
                            mappings[version.index].parentOf = mapping.mapId;
                            results.push(mappings[version.index]);
                        }
                    });
                results.push(mapping);
            });
            return results;
        }

        function compareVersion(version1, version2, mapping) {
            version1 = version1.split('.').map(function (number) { return +number; });
            version2 = version2.split('.').map(function (number) { return +number; });
            if (+version1[0] > +version2[0]) {
                return false;
            } else if (+version1[0] == +version2[0] && +version1[1] > +version2[1]) {
                return false;
            } else if (+version1[0] == +version2[0] && +version1[1] == +version2[1] && mapping.state === "active") {
                return false;
            } else {
                return true;
            }
        }

        return {
            arrangeFlows: arrangeMappings
        };

    }]);

    btstreams.controller('BTStreamsCtrl',
        ['$scope', '$rootScope', '$q', '$applicationService', 'pollFactory', '$timeout', '$route', '$filter', '$workflowService', 'BTSeedDataService', 'BTStreamsService', 'BTFlowtaskService', '$translator', '$location', 'BTAlertsService', 'BTActionsService', 'BTParamMapService', 'NotificationService', 'form_util', 'AppsDataService', '$modal', 'BTIdpService', 'TimerNotification', '$window', 'flowsUtil', 'uuid4', 'security', 'jsValidator','localstore','i18n',
            function ($scope, $rootScope, $q, $applicationService, pollFactory, $timeout, $route, $filter, $workflowService, BTSeedDataService, BTStreamsService, BTFlowtaskService, $translator, $location, BTAlertsService, BTActionsService, BTParamMapService, NotificationService, form_util, AppsDataService, $modal, BTIdpService, TimerNotification, $window, flowsUtil, uuid4, security, jsValidator,localstore,i18n) {
                var loader = "";
                var _isInCAP = false;
                $scope.loadingStreams = true;
                $scope.loadingStream = true;
                $scope.loadingAlerts = true;
                $scope.loadingActions = true;
                $scope.loadingFlows = true;
                $scope.loadingKnowledge = true;
                $scope.showTestBot = false;
                $scope.showSolutionBotSetup = false;
                $scope.showFlowtaskSetup = true;
                $scope.showContent = false;
                $scope._count = 8;
                $scope.count = 8;
                $scope.views = {
                    'bots': true,
                    'apps': false
                };
                $scope.authInfo = null;
                $scope.account1 = null;
                $scope.btTestFormApi = {};
                $scope.btTestStatus = {};
                $scope.idpConfig = null;
                $scope.context = {
                    api: {}
                };
                $rootScope.showLoginLoader = false;
                $scope.displayTabId = null;
                $scope.sdkCallback = { isFromSettings: true };
                $scope.changeLogCallback = {};
                $scope.userShareCallback = {};
                $scope.userImportCallback = {};
                $scope.authorizationCallback = {};
                $scope.variableMngtCallback = {};
                $scope.asCallback = {};
                $scope.gsCallback = {};
                $scope.bssCallback = {};
                $scope.navigateTabIndex = ".tasks-pane";
                $scope.isHelpLinkClicked = false;
                $scope.linkedBots = [];
                $scope.configuredBots = [];
                $scope.trymodecallback = {};
                $scope.bulbIcon = window.appConfig.CONTEXT_PATH+'/assets/images/24x29-bulbicon.png';
                $scope.autotrainData = {};
                $scope.autotrainData.enableAutoUtteranceAddition = false;
                /**
                 * these flags are to open full page dialogs like version history,view logs,create bot,publishbot and flows
                 */
                $scope.activeTask = null;
                $scope.dialogMode = null;
                $scope.publishBot = false;
                $scope.showMapping = false;
                $scope.initializeCreateBot = false;
                $scope.activeEntityFlow = null;
                $scope.currentLanguage = "en";

                $scope.saving = i18n.i18nString('saving');
                $scope.save   = i18n.i18nString('save');



                if($workflowService.currentLanguage() && $workflowService.currentLanguage() !== "") {
                    $scope.currentLanguage = $workflowService.currentLanguage();
                }


                $scope.taskCreateCallback = {};
                $scope.modeSelectorCallback = {};
                $scope.aceEditorCallback = {};
                var scriptNodeEditorModal = false;

                var talkToBotStates = ["configured", "awaitingApproval", "published", "rejected"];

                var updateShowTestBot = function(_canAccessService){
                    $scope.showTestBot = _canAccessService;
                };

                var canAccessService = function(){
                    var _allTasks = [].concat($scope.alerts, $scope.actions, $scope.flowtasks, $scope.reports);

                    /**
                     * code to check all child task
                     */
                    var _allChildTasks = _.pluck(_allTasks, 'child') || [];
                    _allChildTasks = _.filter(_allChildTasks, function(data){return data!==undefined;}) || [];
                    _allChildTasks = _.flatten(_allChildTasks || []);
                    /**
                     * end of child tasks
                     */
                    _allTasks = [].concat(_allTasks, _allChildTasks);

                    var _canAccessService = $scope.knowledgeTasks.length > 0 ? true : false;
                    
                    if(_canAccessService){
                        updateShowTestBot(_canAccessService);
                        return;
                    }

                    _canAccessService = _.findIndex(_allTasks, {'state':'configured'}) !== -1 ? true : _canAccessService;

                     if(_canAccessService){
                        updateShowTestBot(_canAccessService);
                        return;
                    }

                    _canAccessService = _.findIndex(_allTasks, {'state':'published'}) !== -1 ? true : _canAccessService;

                    if(_canAccessService){
                        updateShowTestBot(_canAccessService);
                        return;
                    }

                    _canAccessService = _.findIndex(_allTasks, {'state':'awaitingApproval'}) !== -1 ? true : _canAccessService;

                    if(_canAccessService){
                        updateShowTestBot(_canAccessService);
                        return;
                    }

                    _canAccessService = _.findIndex(_allTasks, {'state':'rejected'}) !== -1 ? true : _canAccessService;

                     if(_canAccessService){
                        updateShowTestBot(_canAccessService);
                        return;
                    }

                    updateShowTestBot(_canAccessService);
                };
                
                $scope.isCreateTaskOpen = false;
                $rootScope.$on("createTaskOpen", function (event, flag) {
                    $scope.isCreateTaskOpen = flag;
                });

                function isEleVisible(element){
                    return $(element).is(":visible");
                }

                if(!isEleVisible("#termsConditions")){
                    $("body").removeClass("modal-open");
                }
                
                //$('body').removeClass('bt-modal-open');

                $scope.selectView = function (selectedView) {

                    Object.keys($scope.views)
                        .map(function (view) {
                            $scope.views[view] = false;
                        });

                    $scope.views[selectedView] = true;

                    if (selectedView === 'apps') {
                        getApps();
                    }

                };
                $scope.canShowUtterances = false;
                $scope.showUtterances = function () {
                    openModalByClass('.utterances-form');
                    $scope.canShowUtterances = true;
                };

                $scope.canShowBatchTesting = false;
                $scope.showBatchTesting = function(){
                    openModalByClass(".batchtesting-form");
                    $scope.canShowBatchTesting = true;
                };

                $scope.canShowontology = false;
                $scope.openOntologyModel = function(noClose){


                    function proceedToOpenOntology(){
                        openModalByClass(".ontology-form");
                        $scope.canShowontology = true;
                        if($('.kore-chat-window') && $('.kore-chat-window').length && !$('.kore-chat-window').hasClass('minimize')) {
                            $('.kore-chat-window .minimize-btn').trigger('click');
                        }
                    }

                    if(!noClose){
                        $scope.closeFullPageModal();
                        proceedToOpenOntology();
                    }else{
                        $scope.lockTask($scope.knowledgeTasks[0], prepareTimer, "knowledgeTask")
                        .then(function (res) {
                            proceedToOpenOntology();
                        }, function (err) {

                        });
                    }
                };


                $scope.$on("openOntology", function(){
                    $scope.openOntologyModel(true);
                });

                $scope.isEligibleForDeleteBot = function (stream) {
                    var createdBy = _.isObject(stream.createdBy) ? stream.createdBy._id : stream.createdBy;
                    if ($scope.selectedStream.type === 'universalbot') {
                        return $applicationService.userInfo().userId === createdBy && $scope.selectedStream.visibility.namespace === 'private';
                    } else {
                        return $applicationService.userInfo().userId === createdBy;
                    }
                };
                var _dialogSettingsCB = {};
                _dialogSettingsCB.updateFlowData = function (flowData) {
                    $scope.flowtaskObj = flowData;
                };
                $scope.openDialogSettings = function (flowtask) { 
                    $modal.open({
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/forms/dialog-settings/dialog-settings.html',
                        controller: 'DialogSettings',
                        resolve: {
                            config: function () {
                                return {
                                    "dialogObj":flowtask,
                                    cb: _dialogSettingsCB,
                                    load: load
                                };
                            }
                        }
                    });
                };
                $scope.exportDialog = function (flowtaskId) {
                    BTFlowtaskService.exportDialog($workflowService.selectedStream()._id, flowtaskId).then(function (res) {
                        writeAndDownloadDialog(res.data.name + ".json", JSON.stringify(res.data));
                    });
                };
                $scope.storeActiveFlowTask = function(flowtask) {
                    $scope.activeFlowTask = flowtask;
                };
                $scope.importObj = {};
                $scope.importObj.importDialog = null;
                $scope.readDialog = function () {
                    $scope.importedDialogName = $scope.importObj.importDialog.name;
                    if ($scope.importedDialogName) {
                        var _ext = $scope.importedDialogName.substring($scope.importedDialogName.lastIndexOf('.'));
                        if (_ext !== '.json') {
                            NotificationService.notify(i18n.i18nString('upload_json'), "error");
                            $scope.fileExtensionError = true;
                            return;
                        } else {
                            $scope.fileExtensionError = false;
                            $scope.dialogRequiredError = false;
                        }
                    }
                   
                    var reader = new FileReader();
                    reader.readAsText($scope.importObj.importDialog);

                    reader.onload = function (e) {
                        var data = reader.result;
                        if(!data || data && !data.length){
                            NotificationService.notify(i18n.i18nString('upload_valid'), "error");
                            $scope.fileEmptyError = true;
                        }
                        else{
                            $scope.fileEmptyError = false;
                        }
                        $scope.importedDialogData = data;
                    };
                    //angular.element("#importFile").val("");
                };

                $scope.confirmImport = function () {
                    if (!$scope.importedDialogData) {
                        $scope.dialogRequiredError = true;
                        NotificationService.notify(i18n.i18nString('dialog_file_req'), "error");
                        return;
                    }
                    $scope.isWorkProgress = true;
                    $scope.loaderMessage = "Importing...";
                    var _currFlowtaskID = $scope.activeFlowTask._id;
                    if($scope.activeFlowTask.state === 'published' || $scope.activeFlowTask.state === 'suspended') {
                        _currFlowtaskID = $scope.activeFlowTask.child[0]._id;
                    }
                    BTFlowtaskService.importDialog($workflowService.selectedStream()._id, _currFlowtaskID, $scope.importedDialogData).then(function (res) {
                        $scope.doneImporting = true;
                        $workflowService.flowtaskInfo(res.data);
                        $scope.flowtaskObj = res.data;
                        $scope.importModalTitle = i18n.i18nString('bt_streams_successful');
                        $scope.connections = getConnections(res.data.nodes);
                        $scope.importDialogHeader = i18n.i18nString('dialog_backup_success');
                        $scope.importResults = "Analyzing file . . . \n\n" + $scope.flowtaskObj.nodes.length + " Nodes found and " + $scope.connections.length + " connections found \n\n Checking data integrity . . . \n\n No issues found. \n\n Replacing current dialog with imported data . . . \n\n All nodes and connections imported successfully!";
                        $scope.isWorkProgress = false;
                        $scope.loaderMessage = i18n.i18nString('working_on_it');
                        $scope.displayMode = 'edit';
                        //$('#flowtask_imports').modal('hide');
                    }, function (error) {
                        $scope.doneImporting = true;
                        var _msg = error.data.errors[0].msg;
                        $scope.importDialogHeader = i18n.i18nString('dialog_backup_failure');
                        $scope.importResults = _msg;
                        $scope.isWorkProgress = false;
                        $scope.loaderMessage = i18n.i18nString('working_on_it');
                        $scope.importModalTitle = i18n.i18nString('failed');
                        NotificationService.notify(_msg, 'error');
                    });
                };

                function getConnections (data) {
                    var transitions = _.flatten(_.pluck(data, 'transitions'));
                    return _.filter(transitions, function (each){
                        return (each.default !== "end" && !_.isEmpty(each.default)) || _.isUndefined(each.default);
                    });
                }

                $scope.finishImporting = function () {
                    $scope.doneImporting = false;
                    $scope.importedDialogName = undefined;
                    $scope.importedDialogData = undefined;
                    $scope.importObj.importDialog = undefined;
                    $scope.importDialogHeader = i18n.i18nString('import_dialog_desc');
                    $scope.importModalTitle = i18n.i18nString('bt_streams_a_dialog');
                    $scope.fileExtensionError = false;
                    $('#flowtask_imports').modal('hide');
                    load();
                };

                $scope.onFinishSetup = function (type) {
                    BTFlowtaskService.finishFlowtask(_selectedStream._id, _dialogObj._id).then(function (res) {
                        NotificationService.notify(i18n.i18nString('dialog_configured'), 'success');
                    }, function (error) {
                        if (error && error.data && error.data.errors) {
                            var _msg = error.data.errors[0].msg;
                            NotificationService.notify(_msg, 'error');
                        } else if (error.errors && _.isArray(error)) {
                            var msg = error.errors[0].msg;
                            NotificationService.notify(msg, 'error');
                        } else {
                            NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                        }
                    });
                };
                
                function writeAndDownloadDialog(filename, data) {

                    if(navigator.msSaveBlob){
                        var blob = new Blob([data],  {type : 'data:text/plain;charset=utf-8'});
                        return window.navigator.msSaveOrOpenBlob(blob, filename);
                    } else {
                        var element = document.createElement('a');
                        element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(data));
                        element.setAttribute('download', filename);

                        element.style.display = 'none';
                        document.body.appendChild(element);
                        
                        element.click();

                        document.body.removeChild(element);
                    }
                }

                $scope.availableActions = {
                    inProgress: {
                        view: true,
                        edit: true,
                        editbasic: false,
                        clone: false,
                        upgrade: false,
                        map: false,
                        versions: false,
                        delete: true
                    },
                    configured: {
                        view: true,
                        edit: true,
                        editbasic: false,
                        clone: true,
                        upgrade: false,
                        map: false,
                        versions: false,
                        delete: true,
                        logs: true
                    },
                    upgradeInProgress: {
                        view: true,
                        edit: true,
                        editbasic: false,
                        clone: false,
                        upgrade: false,
                        map: false,
                        versions: false,
                        delete: true
                    },
                    published: {
                        view: true,
                        edit: false,
                        editbasic: true,
                        clone: true,
                        upgrade: true,
                        map: true,
                        versions: true,
                        delete: false,
                        command: true,
                        logs: true,
                        unpublish: true
                    },
                    awaitingApproval: {
                        view: true,
                        edit: true,
                        editbasic: false,
                        clone: true,
                        upgrade: false,
                        map: false,
                        versions: false,
                        delete: true,
                        recall: true
                    },
                    rejected: {
                        view: true,
                        edit: true,
                        editbasic: false,
                        clone: true,
                        upgrade: false,
                        map: false,
                        versions: false,
                        delete: true
                    },
                    suspended: {
                        view: true,
                        edit: false,
                        editbasic: true,
                        clone: true,
                        upgrade: true,
                        map: false,
                        versions: true
                    }
                };

                $scope.getAvailability = function (state, action) {
                    return $scope.availableActions[state][action];
                };
                $scope.setDisplayTabId = function (id) {
                    // fix for minimise sdk
                    if($('.kore-chat-window') && $('.kore-chat-window').length && !$('.kore-chat-window').hasClass('minimize')) {
                        $('.kore-chat-window .minimize-btn').trigger('click');
                    }
                    if (!$(id).hasClass('in')) {
                        $scope.displayTabId = id;
                    } else {
                        $scope.displayTabId = "";
                    }

                    if(id == '#synonyms' || id == "#patterns"){
                        $scope.displayTabId = id;
                    }
                };

                $scope.nlp = {
                    testText: ''
                };


                function getConnectorsList() {

                    BTIdpService.connectors()
                        .then(function (res) {
                            $scope.connectors = res.data;
                            $workflowService.botConnectors(angular.copy(res.data));
                        }, function (err) {
                            $scope.connectors = [];
                        });

                }

                $scope.$watch('$root.isManaged', function () {
                    getConnectorsList();
                });
                $scope.selectedStream = {};
                $scope.enterpriseUser = $rootScope.licenseType;
                $scope.eligibleForPublishing = $scope.enterpriseUser || $rootScope.wfAdmin;

                $scope.isEligibleForAuthorization = function () {
                    return $scope.selectedStream.type !== 'universalbot';
                };

                $scope.isUniversalBot = function () {
                    return $scope.selectedStream.type === 'universalbot';
                };

                $scope.isEligibleForSdkConf = function () {
                    return $scope.selectedStream.type !== 'universalbot';
                };

                $scope.isEligibleToManageBot = function (stream) {
                    var createdBy = _.isObject(stream.createdBy) ? stream.createdBy._id : stream.createdBy;
                    return $rootScope.isManaged && $applicationService.userInfo().userId === createdBy && $scope.selectedStream.type !== 'universalbot';
                };
                $scope.isEligibleForPublishing = function () {
                    $scope.eligibleForPublishing = $rootScope.isManaged || $rootScope.wfAdmin;
                    return $scope.eligibleForPublishing;
                };

                $scope.isWorkFlowAdmin = function () {
                    $scope.isWFAdmin = $rootScope.wfAdmin;
                    return $scope.isWFAdmin;
                };

                $scope.isEligibleToShare = function () {
                    return $rootScope.isManaged;
                };

                $scope.generateRandomId = function (prefix) {
                    $scope.stIconv = prefix + '' + uuid4.generate();
                };

                $scope.generateRandomId();



                $scope.isEligibleToReleaseLock = function (userId) {
                    return $applicationService.userInfo().userId === userId;
                };

                $scope.isEligibleToDelete = function (task) {
                    if (task && !(task.state === "published" || task.state === 'suspended')) {
                        return true;
                    } else {
                        return $rootScope.wfAdmin;
                    }
                };

                $scope.publishViews = {};


                Object.defineProperty($scope.publishViews, 'initialView', {
                    get: function () {

                        var value = false;
                        $scope.publishViews.hasPublishedTasks = false;
                        $scope.publishViews.newTasksCount = 0;
                        $scope.publishViews.upgradeCount = 0;
                        $scope.publishViews.message = "";


                        $scope.alerts.map(function (alert) {

                            if (alert.state === "configured") {
                                value = true;
                                $scope.publishViews.newTasksCount++;
                            }

                            if (alert.state === "published" || alert.state === "awaitingApproval") {
                                $scope.publishViews.hasPublishedTasks = true;
                            }

                            (alert.child || [])
                                .map(function (child) {

                                    if (child.state === "configured") {
                                        value = true;
                                        $scope.publishViews.upgradeCount++;
                                    }

                                    if (child.state === "published" || child.state === "awaitingApproval") {
                                        $scope.publishViews.hasPublishedTasks = true;
                                    }

                                });

                        });

                        $scope.actions.map(function (action) {

                            if (action.state === "configured") {
                                value = true;
                                $scope.publishViews.newTasksCount++;
                            }

                            if (action.state === "published" || action.state === "awaitingApproval") {
                                $scope.publishViews.hasPublishedTasks = true;
                            }

                            (action.child || [])
                                .map(function (child) {

                                    if (child.state === "configured") {
                                        value = true;
                                        $scope.publishViews.upgradeCount++;
                                    }

                                    if (child.state === "published" || child.state === "awaitingApproval") {
                                        $scope.publishViews.hasPublishedTasks = true;
                                    }

                                });
                        });

                        $scope.reports.map(function (action) {

                            if (action.state === "configured") {
                                value = true;
                                $scope.publishViews.newTasksCount++;
                            }

                            if (action.state === "published" || action.state === "awaitingApproval") {
                                $scope.publishViews.hasPublishedTasks = true;
                            }

                            (action.child || [])
                                .map(function (child) {

                                    if (child.state === "configured") {
                                        value = true;
                                        $scope.publishViews.upgradeCount++;
                                    }

                                    if (child.state === "published" || child.state === "awaitingApproval") {
                                        $scope.publishViews.hasPublishedTasks = true;
                                    }

                                });
                        });

                        $scope.flowtasks.map(function (flowTask) {

                            if (flowTask.state === "configured") {
                                value = true;
                                $scope.publishViews.newTasksCount++;
                            }

                            if (flowTask.state === "published" || flowTask.state === "awaitingApproval") {
                                $scope.publishViews.hasPublishedTasks = true;
                            }

                            (flowTask.child || [])
                                .map(function (child) {

                                    if (child.state === "configured") {
                                        value = true;
                                        $scope.publishViews.upgradeCount++;
                                    }

                                    if (child.state === "published" || child.state === "awaitingApproval") {
                                        $scope.publishViews.hasPublishedTasks = true;
                                    }

                                });

                        });
                        $scope.publishViews.message = ($scope.publishViews.upgradeCount > 0 || $scope.publishViews.newTasksCount > 0) ?
                            ($scope.publishViews.upgradeCount > 0 && $scope.publishViews.upgradeCount > 0) ?
                                " (" + getSingleorPluralMessage($scope.publishViews.upgradeCount, " upgrade ") +
                                " , " + getSingleorPluralMessage($scope.publishViews.newTasksCount, " new ") + " )"
                                : $scope.publishViews.upgradeCount > 0 ?
                                    " (" + getSingleorPluralMessage($scope.publishViews.upgradeCount, " upgrade ") + "  )" : " ( " + getSingleorPluralMessage($scope.publishViews.newTasksCount, " new ") + " )" : "";
                        return !value && $scope.isEligibleForPublishing();

                    },
                    set: angular.noop,
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty($scope.publishViews, 'botPublish', {
                    get: function () {
                        return $rootScope.wfAdmin && !$scope.publishViews.initialView && !$scope.selectedStream.isSolutionBot && !$scope.publishViews.hasPublishedTasks;
                    },
                    set: angular.noop,
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty($scope.publishViews, 'solutionBotPublish', {
                    get: function () {
                        return !$scope.publishViews.initialView && !$scope.publishViews.botPublish && $scope.isEligibleForPublishing() && $scope.isWorkFlowAdmin() && $scope.selectedStream.isSolutionBot && $scope.selectedStream.botType !== 'sample';
                    },
                    set: angular.noop,
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty($scope.publishViews, 'standardBotPublish', {
                    get: function () {
                        return !$scope.publishViews.initialView && !$scope.publishViews.botPublish && $scope.isEligibleForPublishing() && !$scope.selectedStream.isSolutionBot && $scope.selectedStream.botType !== 'sample';
                    },
                    set: angular.noop,
                    enumerable: true,
                    configurable: true
                });

                Object.defineProperty($scope.publishViews, 'sampleBotPublish', {
                    get: function () {
                        return !$scope.publishViews.initialView && !$scope.publishViews.botPublish && $scope.isEligibleForPublishing() && $scope.isWorkFlowAdmin() && $scope.selectedStream.botType === 'sample';
                    },
                    set: angular.noop,
                    enumerable: true,
                    configurable: true
                });

                function retainScrollPosition() {
                    var _streamEle = $('#' + $workflowService.selectedStream()._id);
                    if (_streamEle) {
                        var _container = _streamEle.closest('.ps-container');
                        if (_container) {
                            var _scrollHeight = _streamEle.offset().top - _container.offset().top + _container.scrollTop();
                            _container.animate({
                                scrollTop: _scrollHeight
                            }, 'slow');
                        }
                    }
                }

                 $scope.isSelectedLanguageApproved = function(task){
                     
                     if($.inArray($workflowService.currentLanguage(), (task.approvedLanguages || [])) !== -1){
                        return true;
                    }

                    return false;
                };

                $scope.allLanguagesApproved = function(task){
                     if((task.approvedLanguages || []).length == ($scope.selectedStream.supportedLanguages || []).length){
                         return true;
                     }else{
                         return false;
                     }
                };

                function getSingleorPluralMessage(count, type) {
                    return count > 1 ? count + " " + type + " tasks" : count + " " + type + " task";
                }
                function load() {

                    var currentUser = localstore.getAuthData().currentAccount;
                    $scope.isDomainKore = currentUser.domain.split('.')[0] === 'kore';

                    $scope.showContent = false;
                    $scope.activeTask = null;
                    $scope.isGlobalWorkProgress = false;
                    $scope.isWorkProgress = false;
                    $scope.activeEntityFlow = null;
                    $scope.dialogMode = null;
                    $(".modal-backdrop").remove();
                    $q.all([BTSeedDataService.getSeedCategories(), BTStreamsService.getStreams(), BTStreamsService.getSampleBots(),BTStreamsService.getSmartBots()]).then(function (res) {

                        var seedData = $workflowService.seedData();
                        $scope.loadingStreams = false;
                        $scope.categories = res[0].data.categories;
                        $scope.streams = res[1].data;
                        $workflowService.allSampleBots(res[2].data);
                        $workflowService.allSmartBots(res[3].data);
                        $scope.removeModalOpenClass();
                        if ($scope.streams.length > 0) {

                            $scope.streams = $filter('orderBy')($scope.streams, '+name');
                            $workflowService.streamsAll($scope.streams);
                            if($workflowService.importedNewBotId().trim() !== "") {
                                var importedBot = $scope.streams.filter(function(stream){
                                    return $workflowService.importedNewBotId() === stream._id;
                                });
                                if(importedBot && importedBot.length > 0) {
                                    $workflowService.selectedStream(importedBot[0]);
                                    $workflowService.currentLanguage(importedBot[0].defaultLanguage);
                                    $scope.currentLanguage = importedBot[0].defaultLanguage;
                                }
                                $workflowService.importedNewBotId(" ");
                            }
                            $('.kore-chat-header .close-btn').trigger('click');
                            if (_.isObject($workflowService.selectedStream()) && !$workflowService.selectedStream()._id) {
                               

                               var streamSelected = $scope.streams[0];
                               $scope.streams[0].active = true;
                                $scope.changeBotLanguage(streamSelected.defaultLanguage);
                                $.each($scope.streams, function(i, stream){
                                    if(stream.createdBy.id === $applicationService.userInfo().userId){
                                        stream.active = true;
                                        streamSelected = stream;
                                        if(i !== 0){
                                            $scope.streams[0].active = false;
                                        }
                                        
                                        return false;
                                    }
                                });   
                               
                                $workflowService.selectedStream(streamSelected);
                                if (streamSelected.state && streamSelected.state === 'setup') {
                                    $scope.showSolutionBotSetup = true;
                                }
                                $q.all([getAlerts(streamSelected._id),
                                getActions(streamSelected._id),
                                getFlowTasks(streamSelected._id),
                                getKnowledgeTasks(streamSelected._id),
                                getStream(streamSelected),

                                getMappings(streamSelected._id),
                                getAlertDialogMappings(streamSelected._id)]
                                ).then(function (res) {
                                    showActiveTab();
                                    $timeout(function () {
                                        $(window).trigger('resize');
                                        retainScrollPosition();

                                    });
                                });

                                
                                
                            } else {

                                if ($workflowService.selectedStream().state && $workflowService.selectedStream().state === 'setup') {
                                    $scope.showSolutionBotSetup = true;
                                }
                                $q.all([getAlerts($workflowService.selectedStream()._id),
                                getActions($workflowService.selectedStream()._id),
                                getFlowTasks($workflowService.selectedStream()._id),
                                getKnowledgeTasks($workflowService.selectedStream()._id),
                                getStream($workflowService.selectedStream()),

                                getMappings($workflowService.selectedStream()._id),
                                getAlertDialogMappings($workflowService.selectedStream()._id)])
                                    .then(function (res) {
                                        showActiveTab();
                                        $timeout(function () {
                                            $(window).trigger('resize');
                                            retainScrollPosition();
                                        });
                                    });

                                for (var i = 0; i < $scope.streams.length; i++) {
                                    if ($scope.streams[i]._id === $workflowService.selectedStream()._id) {
                                        $scope.streams[i].active = true;
                                    }
                                }
                            }

                        } else {
                            $scope.loadingStream = false;
                        }


                    }, function (err) {
                        if (+err.status !== 401) {
                            NotificationService.notify('error', i18n.i18nString('loading_error'));
                        }
                    });
                }

                // check for authentication
                if (security.isAuthenticated()) {
                    load();
                }
                else {
                    var unregisterEvent = $rootScope.$on('security:authenticated', function () {
                        load();
                        unregisterEvent();
                    });
                }

                $scope.removeModalOpenClass = function () {
                    $timeout(function () {
                       if(!isEleVisible("#termsConditions")){
                    $("body").removeClass("modal-open");
                }
                        $("body").removeClass("bt-modal-open");
                    });
                };

                $scope.launchMigrationTool = function () {
                    var activeUser = localstore.getAuthData().currentAccount;
                    activeUser.environment = window.location.hostname;
                    var _encryptedUserDetails = "#" + base64.encode(JSON.stringify(activeUser));
                    // var _link = window.location.protocol +'//'+ window.location.hostname + ':3002/#/login/' + _encryptedUserDetails;
                    var _link = 'http://52.86.255.9/#/login/' + _encryptedUserDetails;

                    window.open(_link, '_blank');

                };

                $scope.isTaskAvailable = function (taskName) {
                    return $scope[taskName].length > 0;
                };

                $scope.anyTaskAvailable = function () {
                    return ($scope.alerts.length || $scope.actions.length || $scope.reports.length || $scope.flowtasks.length || $scope.knowledgeTasks.length || $scope.mappings.length);
                };



                function showActiveTab() {
                    $scope.showContent = true;
                    $(".tasks-pane").removeClass("active");
                    $scope.navigateTabIndex = $workflowService.navigateTabIndex();
                    $($scope.navigateTabIndex).addClass("active");
                }

                function getMappings(id) {
                    var deferred = $q.defer();
                    $scope.loadingFlows = true;
                    $scope.mappings = [];
                    BTStreamsService.getMappings(id)
                        .then(function (res) {
                            var _alertMappings = angular.copy(res.data);
                            //triggerTaskLockReleasing();
                            _alertMappings = _alertMappings.map(function (mapping) {
                                mapping.actionStreamIcon = (_.find($scope.streams, { _id: mapping.actionStreamId }) || {}).icon;
                                mapping.alertStreamIcon = (_.find($scope.streams, { _id: mapping.alertStreamId }) || {}).icon;
                                mapping.actionName = mapping.actionName ? mapping.actionName.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                                mapping.actionStream = mapping.actionStream ? mapping.actionStream.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                                mapping.alertName = mapping.alertName ? mapping.alertName.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                                mapping.alertStream = mapping.alertStream ? mapping.alertStream.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                                return mapping;
                            });

                            $scope.mappings = $scope.mappings.concat(_alertMappings);
                            $scope.mappings = flowsUtil.arrangeFlows($scope.mappings);
                            //$scope.loadingFlows=false;
                            deferred.resolve(res);
                        });
                    return deferred.promise;
                }
                function getAlertDialogMappings(id) {
                    var deferred = $q.defer();
                    $scope.loadingFlows = true;
                    BTStreamsService.getAlertDialogMappings(id)
                        .then(function (res) {
                            var _dialogMappings = angular.copy(res.data);
                            triggerTaskLockReleasing();
                            _dialogMappings = _dialogMappings.map(function (mapping) {
                                mapping.sourceStreamIcon = (_.find($scope.streams, { _id: mapping.sourceResourceStreamId }) || {}).icon;
                                mapping.targetStreamIcon = (_.find($scope.streams, { _id: mapping.targetResourceStreamId }) || {}).icon;
                                mapping.sourceResourceName = mapping.sourceResourceName ? mapping.sourceResourceName.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                                mapping.targetResourceName = mapping.targetResourceName ? mapping.targetResourceName.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                                return mapping;
                            });
                            $scope.mappings = $scope.mappings.concat(_dialogMappings);
                            $scope.mappings = flowsUtil.arrangeFlows($scope.mappings);
                            $scope.loadingFlows = false;
                            deferred.resolve(res);
                        });
                    return deferred.promise;
                }
                function getAlerts(id) {
                    if (!id) {
                        return;
                    }
                    var deferred = $q.defer();
                    $scope.alerts = $scope.alerts || [];
                    $scope.loadingAlerts = true;
                    BTAlertsService.getAlerts(id)
                        .then(function (res) {
                            $scope.alerts = assignAlertParent(angular.copy(res.data));
                            angular.forEach($scope.alerts, function (alert, key) {
                                if (alert && alert.name) {
                                    alert.name = alert.name.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                                if (alert && alert.shortDesc) {
                                    alert.shortDesc = alert.shortDesc.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                            });
                            $scope.organizeDataBasedOnAlerts();
                            $scope.loadingAlerts = false;
                            deferred.resolve(res);
                        }, function (err) {
                            NotificationService.notify(i18n.i18nString('alerts_loading'), "error");
                            $scope.alerts = [];
                        });

                    return deferred.promise;
                }

                $scope.organizeDataBasedOnAlerts = function () {
                    $rootScope.hasPublishedAlerts = false;
                    $rootScope.hasPublishedAlerts = _.find($scope.alerts, function (alert) {
                        return (alert.state == 'published' || alert.state == 'awaitingApproval');
                    }) && true;
                    // if (!$scope.showTestBot) {
                    //     $scope.showTestBot = _.find($scope.alerts, function (alert) {
                    //         return canAccessService(alert.state);
                    //     }) && true;
                    // }
                    canAccessService();
                    isInMarket($scope.alerts);
                    $workflowService.alerts($scope.alerts);
                    triggerTaskLockReleasing();
                };

                $rootScope.$on("insertOrUpdateTask", function (event, taskType, taskObject, isNewTask) {
                    if (taskType === "flowTask") {
                        $scope.workingTaskType = "";
                    }
                    $scope.updateTasks(taskType, taskObject, isNewTask);
                });

                $rootScope.$on("showContent", function () {
                    $scope.showContent = true;
                });


                $scope.updateTasks = function (taskType, taskObject, isNewTask) {
                    $rootScope.$broadcast('reloadTasks', taskType);
                    clearActiveClass(true);
                    $workflowService.navigateTabIndex($scope.navigateTabIndex);
                    showActiveTab();
                    // if(taskType === "alert"){
                    // if(isNewTask){
                    //     $scope.alerts.push(taskObject);
                    // }else{
                    //      $.each($scope.alerts, function(i, alertObject){
                    //         if(alertObject._id === taskObject._id){
                    //             debugger;
                    //             taskObject = assignAlertParent(angular.copy([taskObject]));
                    //            $scope.alerts[i] = taskObject[0]; 
                    //         }
                    //     });
                    // }

                    // $scope.organizeDataBasedOnAlerts();

                    //   }else if(taskType === "action"){
                    //     if(isNewTask){
                    //         $scope.actions.push(taskObject);
                    //     }else{
                    //         $.each($scope.actions, function(i, actionObject){
                    //             if(actionObject._id === taskObject._id){
                    //                 debugger;
                    //                 taskObject = assignActionParent(angular.copy([taskObject]));
                    //                $scope.actions[i] = taskObject[0]; 
                    //             }
                    //         });
                    //     }

                    //     $scope.organizeDataBasedOnActions();

                    // }
                    // $scope.showContent = true;
                    // }
                };

                function getActions(id) {
                    if (!id) {
                        return;
                    }
                    var deferred = $q.defer();
                    $scope.reports = $scope.reports || [];
                    $scope.actions = $scope.actions || [];

                    $scope.loadingActions = true;
                    BTActionsService.getActions(id)
                        .then(function (res) {

                            var actions = assignActionParent(angular.copy(res.data));
                            var _pureActions = [], _pureReports = [];
                            actions.map(function (val) {
                                if (val.isReport) {
                                    _pureReports.push(val);
                                } else {
                                    _pureActions.push(val);
                                }
                                if (val && val.name) {
                                    val.name = val.name.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                                if (val && val.shortDesc) {
                                    val.shortDesc = val.shortDesc.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                            });
                            $scope.reports = _pureReports;
                            $scope.actions = _pureActions;
                            $scope.organizeDataBasedOnActions();
                            $scope.loadingActions = false;
                            deferred.resolve(res);
                        }, function (error) {
                            NotificationService.notify(i18n.i18nString('actions_loading'), "error");
                            $scope.actions = [];
                            $scope.reports = [];
                        });
                    return deferred.promise;
                }

                $scope.organizeDataBasedOnActions = function () {
                    var actions = [];
                    actions = $scope.actions.concat($scope.reports);
                    $rootScope.hasPublishedActions = false;
                    $rootScope.hasPublishedActions = _.find(actions, function (action) {
                        return (action.state == 'published' || action.state == 'awaitingApproval');
                    }) && true;
                    // if (!$scope.showTestBot) {
                    //     $scope.showTestBot = _.find(actions, function (action) {
                    //         return canAccessService(action.state);
                    //     }) && true;
                    // }
                    canAccessService();
                    isInMarket(actions);
                    $workflowService.actions(actions);
                    triggerTaskLockReleasing();
                };

                function getFlowTasks(id) {
                    var deferred = $q.defer();
                    $scope.flowtasks = $scope.flowtasks || [];
                    $scope.loadingFlows = true;
                    BTFlowtaskService.getFlowtaks(id)
                        .then(function (res) {
                            $scope.flowtasks = assignAlertParent(angular.copy(res.data));
                            $rootScope.hasPublishedFlowtasks = false;
                            angular.forEach($scope.flowtasks, function (flowtask, key) {
                                if (flowtask && flowtask.name) {
                                    flowtask.name = flowtask.name.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                                if (flowtask && flowtask.shortDesc) {
                                    flowtask.shortDesc = flowtask.shortDesc.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                            });
                            $rootScope.hasPublishedFlowtasks = _.find($scope.flowtasks, function (flowtask) {
                                var _hasPublished = (flowtask.state === 'published' || flowtask.state === 'awaitingApproval');
                                if (!_hasPublished && flowtask.child && flowtask.child.length) {
                                    $.each(flowtask.child, function (k, child) {
                                        if (child.state === 'published' || child.state === 'awaitingApproval') {
                                            _hasPublished = true;
                                            return false;
                                        }
                                    });
                                }
                                return _hasPublished;
                            }) && true;
                            // if (!$scope.showTestBot) {
                            //     $scope.showTestBot = _.find($scope.flowtasks, function (flowtask) {
                            //         var _canShowBot = canAccessService(flowtask.state);
                            //         // var _canShowBot = (flowtask.state === 'published' || flowtask.state === 'configured');
                            //         if (!_canShowBot && flowtask.child && flowtask.child.length) {
                            //             $.each(flowtask.child, function (k, child) {
                            //                 // if (child.state === 'published' || child.state === 'configured') {
                            //                 if(canAccessService(child.state)){
                            //                     _canShowBot = true;
                            //                     return false;
                            //                 }
                            //             });
                            //         }
                            //         return _canShowBot;
                            //     }) && true;
                            //     
                            // }
                            canAccessService();

                            isInMarket($scope.flowtasks);
                            $workflowService.flowTasks($scope.flowtasks);
                            triggerTaskLockReleasing();
                            $scope.loadingFlows = false;
                            deferred.resolve(res);
                        }, function (err) {
                            $scope.flowtasks = [];
                        });
                    return deferred.promise;
                }
                /* Function to get knowledge tasks*/
                function getKnowledgeTasks() {
                    var deferred = $q.defer();
                    $scope.knowledgeTasks = $scope.knowledgeTasks || [];
                    $scope.loadingKnowledge = true;
                    var requestData = { "streamId": $workflowService.selectedStream()._id };
                    BTStreamsService.getAllKtsList($applicationService.userInfo().userId, requestData)
                        .then(function (res) {
                            $scope.loadingKnowledge = false;
                            $scope.knowledgeTasks = angular.copy(res.data);
                            angular.forEach($scope.knowledgeTasks, function (knowledgeTask, key) {
                                if (knowledgeTask && knowledgeTask.name) {
                                    knowledgeTask.name = knowledgeTask.name.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                                if (knowledgeTask && knowledgeTask.description) {
                                    knowledgeTask.description = knowledgeTask.description.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                }
                            });
                            // if (!$scope.showTestBot) {
                            //     $scope.showTestBot = _.find($scope.knowledgeTasks, function (knowledgeTask) {
                            //         return canAccessService(knowledgeTask.state);
                            //     }) && true;
                            // }
                            canAccessService();
                            isInMarket($scope.knowledgeTasks);
                            $workflowService.knowledgeTasks($scope.knowledgeTasks);
                            triggerTaskLockReleasing();
                            deferred.resolve(res);
                        }, function (err) {
                            NotificationService.notify(i18n.i18nString('kg_laoding'), "error");
                            $scope.knowledgeTasks = [];
                        });
                    return deferred.promise;
                }

                $scope.getKnowledgeTasks = getKnowledgeTasks;

                function isInMarket(tasks) {

                    var _allTasks = [].concat($scope.alerts, $scope.actions, $scope.flowtasks);

                    _isInCAP = _.findIndex(_allTasks, {'state':'configured'}) !== -1 ? true : false;
                    _isInCAP = _.findIndex(_allTasks, {'state':'published'}) !== -1 ? true : _isInCAP;
                    _isInCAP = _.findIndex(_allTasks, {'state':'awaitingApproval'}) !== -1 ? true : _isInCAP;

                    $workflowService.isInCAP(_isInCAP); 




                    for (var i = 0; i < tasks.length; i++) {
                        if (tasks[i].state === 'published' || tasks[i].state === 'suspended' || tasks[i].state === 'awaitingApproval') {
                            $scope.selectedStream.isInMarket = true;
                            $workflowService.selectedStream($scope.selectedStream);
                            break;
                        }
                    }
                    for (var j = 0; j < tasks.length; j++) {
                        if (tasks[j].state === 'published' || tasks[j].state === 'suspended') {
                            $workflowService.publishedOrSuspended(true);
                            break;
                        } else {
                            $workflowService.publishedOrSuspended(false);
                        }
                    }

                     for (var k = 0; k < tasks.length; k++) {
                        if (tasks[k].state === 'published') {
                            $workflowService.isTaskPublished(true);
                            return;
                        } else {
                            $workflowService.isTaskPublished(false);
                        }
                    }
                }

                function assignAlertParent(alerts) {
                    var parents = alerts.filter(function (alert) {
                        return (!alert.parentId);
                    });
                    var childs = alerts.filter(function (alert) {
                        return (alert.parentId);
                    });
                    parents = parents.map(function (parent) {
                        childs.map(function (child) {
                            if (parent._id === child.parentId) {
                                parent.child = [];
                                parent.child.push(angular.copy(child));
                                parent.child[0].parent = angular.copy(parent);
                                parent.isParent = true;
                            } else if (parent._id === child._id) {
                                parent.isChild = true;
                            }
                        });
                        return parent;
                    }).filter(function (parent) {
                        return (parent.isChild !== true);
                    });
                    return parents;
                }

                function assignActionParent(actions) {
                    var parents = actions.filter(function (action) {
                        return (!action.parentId);
                    });
                    var childs = actions.filter(function (action) {
                        return (action.parentId);
                    });
                    parents = parents.map(function (parent) {
                        childs.map(function (child) {
                            if (parent._id === child.parentId) {
                                parent.child = [];
                                parent.child.push(angular.copy(child));
                                parent.child[0].parent = angular.copy(parent);
                                parent.isParent = true;
                            } else if (parent._id === child._id) {
                                parent.isChild = true;
                            }
                        });
                        return parent;
                    }).filter(function (parent) {
                        return (parent.isChild !== true);
                    });
                    return parents;
                }
                function getAccountForStream() {
                    BTStreamsService.getAccounts($workflowService.selectedStream()._id, "true", "true")
                        .then(function (res) {
                            $scope.account1 = res.data;
                            updateIDPData();
                        }, function (err) {

                        });

                }

                var updateIDPData = function (accountDetails) {
                    var idpDetails = angular.copy($scope.idpConfigs);

                    if (accountDetails) {
                        $.each(idpDetails, function (j, idpData) {
                            if (idpData.name === accountDetails.idp) {
                                idpDetails[j].account = [];
                            }
                        });
                    } else {
                        $.each($scope.account1, function (i, accountData) {
                            $.each(idpDetails, function (j, idpData) {
                                if (idpData.name === accountData.idp) {
                                    idpDetails[j].account = [accountData];
                                }
                            });
                        });

                    }


                    $scope.idpConfigs = angular.copy(idpDetails);
                };

                $scope.testIdp = function (index) {
                    $scope.btTestFormApi.afterInit = function afterInit() {
                        $scope.btTestFormApi.test();
                    };

                    $scope.btTestFormApi.afterTest = function afterTest(success) {

                        if (success) {

                            NotificationService.notify(i18n.i18nString('auth_test_success'), "success");

                        } else {

                            NotificationService.notify(i18n.i18nString('auth_test_failed'), "error");

                        }

                        $scope.btTestFormApi.close();

                    };
                    $scope.btTestFormApi.onNewAccounts = function onNewAccounts(accounts) {
                        $scope.account1 = accounts;
                        $scope.updateTryMode(true);
                        updateIDPData();

                    };

                    $scope.btTestFormApi.init({
                        _id: $scope.idpConfigs[index]._id,
                        type: 'idp',
                        testFor: 'idp',
                        isTryOutUserConnection: "true"
                        //definition:  $scope.authInfo
                    });

                };
                $scope.changeAuthorization = function (accountAuth, index) {

                    BTIdpService.deleteStreamUserAccount(accountAuth[0].streamAccountId)
                        .then(function () {
                            //$scope.account1 = null;
                            $scope.testIdp(index);
                        }, function () {

                        });
                };
                $scope.streamSearchQuery = "";

                $scope.getEncodedSearchName = function(searchQuery){
                    if(searchQuery && searchQuery.trim()){
                        return $scope.getTextEncoded(searchQuery);
                    }
                };

                $scope.getTextEncoded = function(name) {
                    return name.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                 };

                $scope.updateScroll = function(){
                    PerfectScrollbar.update($(".sreamlist")[0]);
                    $(".sreamlist").scrollTop(0);
                };

                $scope.getTextIncludingTags = function(name) {
                    if(!name){
                        return "";
                    }
                   return name.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                };
                function loadAutoTrainMLStatus(){
                    $scope.autotrainData = {};
                    if($scope.selectedStream.hasOwnProperty("enableAutoUtteranceAddition")) {
                        $scope.autotrainData.enableAutoUtteranceAddition = $scope.selectedStream.enableAutoUtteranceAddition;
                    }
                    else {
                        $scope.autotrainData.enableAutoUtteranceAddition = false;
                    }
                }
                function saveBotStream(_payload) {
                    BTStreamsService.editStream($scope.selectedStream._id, _payload).then(function (res) {
                        $scope.selectedStream = res.data;
                        $workflowService.selectedStream(angular.copy($scope.selectedStream));
                        NotificationService.notify(i18n.i18nString('settings_saved_sucessfully'), 'success');
                    }, function (error) {
                        if (error && error.data && error.data.errors) {
                            var _msg = error.data.errors[0].msg;
                            NotificationService.notify(_msg, 'error');
                        } else if (error.errors && _.isArray(error)) {
                            var msg = error.errors[0].msg;
                            NotificationService.notify(msg, 'error');
                        } else {
                            NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                        }
                    });
                }
                $scope.saveAutoTrainMLStatus = function() {
                    var _payload = {enableAutoUtteranceAddition:$scope.autotrainData.enableAutoUtteranceAddition};
                    saveBotStream(_payload);
                };
                function getUserSessionContext() {
                    BTStreamsService.getSessions($workflowService.selectedStream()._id)
                        .then(function (res) {
                            if(res && res.data) {
                                $workflowService.contextData(res.data);
                            }
                        },
                        function (err) {
                        });
                }
                function getStream(stream) {
                    var id = stream._id;
                    var deferred = $q.defer();
                    $scope.loadingStream = true;
                    $scope.selectedStream = {};
                    $scope.authInfo = null;
                    $scope.account1 = null;

                    var _reqStreamID = (stream.state && stream.state === 'setup') ? stream.sbStreamId : id;
                    var requests = [BTStreamsService.getBTStream(id), BTStreamsService.getMPStream(id)];

                    $q.all(requests).then(function (res) {

                        $scope.selectedStream = angular.extend($scope.selectedStream, res[0].data);
                        loadAutoTrainMLStatus();
                        delete res[1].data.visibility;
                        $scope.selectedStream = angular.extend($scope.selectedStream, res[1].data);
                        $scope.selectedStream.name = $scope.selectedStream.name ? $scope.selectedStream.name.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                        $scope.selectedStream.description = $scope.selectedStream.description ? $scope.selectedStream.description.replace(/&lt;/g, '<').replace(/&gt;/g, '>') : '';
                        $scope.selectedStream.state = res[0].data.state;
                        $scope.supportedLanguages = mapSupportedLanguages();
                        $workflowService.supportedLanguages($scope.supportedLanguages);
                        $workflowService.selectedStream(angular.copy($scope.selectedStream));
                        fetchLinkedBots();
                        getUserSessionContext();
                        BTStreamsService.getAuthinfo(id).then(function (res) {
                            if (res.data) {
                                $scope.authInfo = res.data;
                                $scope.idpConfigs = [];

                                $.each($scope.authInfo, function (i, authData) {
                                    BTIdpService.getIdpByName(authData.idpName,$workflowService.selectedStream()._id)
                                        .then(function (res) {
                                            // $scope.idpConfig = res.data;
                                            $scope.idpConfigs.push(res.data);
                                        }, function (err) {
                                            // $scope.idpConfig = {};
                                            $scope.idpConfigs = $scope.idpConfigs || [];
                                        });
                                });

                                getAccountForStream();
                            }
                        }, function (err) {

                        });

                        BTStreamsService.getSolutionBotStream(_reqStreamID)
                            .then(function (res) {
                                if (res.data.botType === "solution" || res.data.botType === "workplacefb" || res.data.botType === "enterprise") {
                                    res.data.isSolutionBot = true;
                                }
                                $scope.selectedStream = angular.extend($scope.selectedStream, res.data);
                                if (!$scope.selectedStream.bBanner) {
                                    $scope.selectedStream.bBanner = 'no-image';
                                }
                                $workflowService.selectedStream(angular.copy($scope.selectedStream));
                                appendCategory($scope.selectedStream);
                                $timeout(function () {
                                    $scope.loadingStream = false;
                                });
                                deferred.resolve(res);
                            }, function (err) {
                                appendCategory($scope.selectedStream);
                                $timeout(function () {
                                    $scope.loadingStream = false;
                                });
                                deferred.resolve(res);
                            });

                    }, function (err) {

                        $timeout(function () {
                            $scope.loadingStream = false;
                        });
                        deferred.reject(err);

                    });
                    return deferred.promise;

                }

                function fetchLinkedBots() {
                    if ($scope.selectedStream.type === 'universalbot') {
                        $scope.linkedBots = [];
                        $scope.configuredBots = angular.copy($scope.streams.filter(function (stream) {
                            if ($scope.selectedStream.configuredBots.indexOf(stream._id) !== -1) {
                                stream.state = 'linked';
                                return true;
                            }
                        }));

                        $scope.linkedBots = $scope.linkedBots.concat($scope.configuredBots);
                        $scope.linkedBots = $scope.linkedBots.concat(angular.copy($scope.streams.filter(function (stream) {
                            if ($scope.selectedStream.awaitingApprovalBots.indexOf(stream._id) !== -1) {
                                stream.state = 'awaitingApproval';
                                return true;
                            }
                        })));
                        $scope.linkedBots = $scope.linkedBots.concat(angular.copy($scope.streams.filter(function (stream) {
                            if ($scope.selectedStream.publishedBots.indexOf(stream._id) !== -1) {
                                stream.state = 'published';
                                return true;
                            }
                        })));
                    }
                }

                $scope.publishUniversalBot = function () {

                    checkForChannels(triggerPublish);

                    function triggerPublish() {
                        var selectedBots = $scope.configuredBots.filter(function (bot) {
                            return (bot.linked);
                        });
                        if (selectedBots && selectedBots.length) {
                            var linkPayload = {
                                bots: _.pluck(selectedBots, "_id")
                            };
                            BTStreamsService.linkOrUnlinkBots($scope.selectedStream._id, 'publish', linkPayload).then(function (res) {
                                NotificationService.notify(i18n.i18nString('bt_streams_bots_published_success'), "success");
                                load();
                            }, function (err) {
                            });
                        } else {
                            NotificationService.notify(i18n.i18nString('please_select_atleast_one_bot'), "error");
                        }
                    }
                };

                $scope.createApp = function () {


                    $modal.open({
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-app-create/bt-app-create.html',
                        controller: 'BTAppCreateCtrl',
                        resolve: {
                            avalSreams: function () {
                                return $scope.avalSreams;
                            }
                        }
                    });

                };
                $scope.goBack = function (modalClass) {
                    closeModalByClass(modalClass);
                    $(".panel-heading").addClass("collapsed");
                    $('.panel-collapse.in').collapse('hide');
                };
                $scope.resetDisplayTabID = function(){
                    $scope.displayTabId = "";
                };
                $scope.closeVersionModal = function () {
                    $scope.activeTask = null;
                    $scope.dialogMode = null;
                    closeModalByClass('.version-form');
                };
                $scope.enableOrDisableTryMode = function (mode, accountED, index) {
                    //$scope.updateTryMode(!mode);
                    if (!mode && $scope.authInfo && (!accountED || !accountED.length || $accountED[0].status !== "active")) {
                        $scope.testIdp(index);
                    } else {
                        $scope.updateTryMode(!mode, index);
                    }
                };

                $scope.updateTryMode = function (enable, indexParam) {
                    var payLoad = {
                        "canTryOut": enable
                    };
                    BTStreamsService.updateTryMode($scope.selectedStream._id, payLoad).then(function (res) {
                        console.log(res);
                        $scope.isTryModeUpdated = true;
                        $scope.selectedStream.canTryOut = enable;
                    }, function (err) {
                        console.log(err);
                    });

                };

                function getApps() {
                    $scope.loadingApps = true;
                    $q.all([AppsDataService.getAppsList($scope.selectedStream._id), AppsDataService.getBotsList()])
                        .then(function (res) {
                            $scope.loadingApps = false;
                            if (res[1] && res[1].data) {
                                $scope.avalSreams = res[1].data;
                                //$scope.apps=[];
                            } else {
                                $scope.avalSreams = [];//Todo has to handle error case
                            }

                            if (res[0] && res[0].data && res[0].data.apps) {
                                $scope.apps = res[0].data.apps;
                                //$scope.apps=[];
                            } else {
                                $scope.apps = [];//Todo has to handle error case
                            }
                        }, function (err) {
                            $scope.loadingApps = false;
                            NotificationService.alertNotify(i18n.i18nString('get_apps'));
                        });
                }

                $rootScope.$on('app.created', function (event, args) {
                    getApps();
                });

                $rootScope.$on('app.updated', function (event, args) {
                    getApps();
                });

                $scope.triggerAppCreation = function triggerAppCreation() {
                    $scope.selectView('apps');
                    $scope.createApp();
                };

                $scope.createApp = function () {


                    $modal.open({
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-app-create/bt-app-create.html',
                        controller: 'BTAppCreateCtrl',
                        windowClass: 'modal-kr',
                        resolve: {
                            avalSreams: function () {
                                return $scope.avalSreams;
                            }, config: function () {
                                return { type: 'Create' };
                            }
                        }
                    });

                };
                $scope.editApp = function (app) {
                    $modal.open({
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-app-create/bt-app-create.html',
                        controller: 'BTAppCreateCtrl',
                        windowClass: 'modal-kr',
                        resolve: {
                            avalSreams: function () {
                                return $scope.avalSreams;
                            }, config: function () {
                                return {
                                    type: 'Edit',
                                    app: app
                                };
                            }
                        }
                    });

                };

                $scope.viewApp = function (app) {
                    $modal.open({
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-app-view/bt-app-view.html',
                        controller: 'BTAppViewCtrl',
                        windowClass: 'modal-kr',
                        resolve: {
                            config: function () {
                                return {
                                    type: 'View',
                                    app: app
                                };
                            }
                        }
                    });

                };

                $scope.deleteApp = function (app) {

                    function deleteAppRequest() {
                        var svcname = 'bt.apps.delete';
                        if ($applicationService.userInfo().appControls && $applicationService.userInfo().appControls.isManaged) {
                            svcname = 'bt.org.apps.delete';
                        }
                        $translator.translate(svcname, { appId: app.clientId }, {}).then(
                            function (res) {
                                if (res && res.status === 200) {
                                    getApps();
                                    NotificationService.notify(i18n.i18nString('app_deleted'), 'success', 1500);
                                } else {
                                    alert(i18n.i18nString('error_alert'));
                                }

                            }, function (errRes) {
                                alert(i18n.i18nString('error_alert'));
                            }
                        );
                    }

                    NotificationService.alert(i18n.i18nString('delete_app_desc'),
                        deleteAppRequest, [true]);

                };

                $rootScope.$on("taskCreateUpdate", function () {

                });

                $scope.selectApp = function (stream, updateLanguage) {
                    $scope.showContent = false;
                    $scope.activeTask = null;
                    $scope.activeEntityFlow = null;
                    $scope.dialogMode = null;
                    $scope.showSolutionBotSetup = false;
                    $('body').removeClass("bt-modal-open");    
                    $scope.nlTraceData = [];
                    if (!stream) {
                        return;
                    }
                    pollFactory.unSubscribeAll();
                    $rootScope.$emit('stopAutoTrainStatusPoll');
                    $rootScope.$emit('stopSpeechTrainStatusPoll');
                    $workflowService.selectedStream(stream);
                    $workflowService.streamType(stream.type || 'taskbot');
                    $scope.selectedStream = stream;
                    clearActiveClass();
                    openDialogTaskAccordion();
                    stream.active = true;
                    $scope.showTestBot = false;
                    if (stream.state && stream.state === 'setup') {
                        $scope.showSolutionBotSetup = true;
                    }

                    $('body').removeClass('modal-open');
                    $scope.closeDebugConsolePanel();
                    //$('body').removeClass('bt-modal-open');

                    $q.all([getAlerts(stream._id),
                    getActions(stream._id),
                    getKnowledgeTasks(stream._id),
                    getStream(stream),
                    getFlowTasks(stream._id),
                    getMappings(stream._id),
                    getAlertDialogMappings(stream._id)]
                    ).then(function (res) {
                        $scope.navigateTabIndex = ".tasks-pane";
                        $workflowService.navigateTabIndex($scope.navigateTabIndex);
                        showActiveTab();
                        $timeout(function () {

                            $(window).trigger('resize');
                        });
                    });
                    $(window).scrollTop(0);
                    $scope.destroyChatBot();
                    $('.myTabs').scrollTop(0);
                    if(!updateLanguage){
                        $scope.changeBotLanguage(stream.defaultLanguage);
                    }
                };

                function clearActiveClass(isFormUpdateTask) {
                    if (!isFormUpdateTask) {
                        for (var i = 0; i < $scope.streams.length; i++) {
                            $scope.streams[i].active = false;
                        }
                    }


                    $workflowService.navigateTabIndex(".tasks-pane");
                    $scope.navigateTabIndex = ".tasks-pane";
                    $(".tasks-pane").addClass("active").siblings().removeClass("active");
                    if (isFormUpdateTask) {
                        return;
                    }
                    // $(".panel-heading").addClass("collapsed");
                    $('.panel-collapse.in').collapse('hide');
                }

                function openDialogTaskAccordion() {
                    $timeout(function () {
                        $('#flowDialogTasks').collapse("show");
                        $("#headFlowTask").removeClass("collapsed");
                    }, 500);

                }

                $scope.enableNlpVerify = function enableNlpVerify() {

                    var enable = false;

                    $scope.alerts = _.isArray($scope.alerts) ? $scope.alerts : [];
                    $scope.actions = _.isArray($scope.actions) ? $scope.actions : [];
                    $scope.reports = _.isArray($scope.reports) ? $scope.reports : [];

                    $scope.alerts.map(function (alert) {
                        if (alert.state == 'configured' || alert.state == 'published') {
                            enable = true;
                        }
                    });

                    $scope.actions.map(function (action) {
                        if (action.state == 'configured' || action.state == 'published') {
                            enable = true;
                        }
                    });
                    $scope.reports.map(function (action) {
                        if (action.state == 'configured' || action.state == 'published') {
                            enable = true;
                        }
                    });

                    return enable;

                };

                $scope.manageChatResponse = function manageChatResponse() {
                    $location.path(window.appConfig.CONTEXT_PATH + '/nlp/' + $scope.selectedStream._id + '/response/edit/');
                };

                $scope.viewActionLogs = function (action) {
                    $scope.dialogMode = 'logs';
                    openModalDialog(action, 'action');
                };

                $scope.viewAlertLogs = function (alert) {
                    $scope.dialogMode = 'logs';
                    openModalDialog(alert, 'alert');
                };

                $scope.manageChatResponse = function manageChatResponse() {
                    $location.path(window.appConfig.CONTEXT_PATH + '/nlp/' + $scope.selectedStream._id + '/response/edit/');
                };

                $scope.selectStream = function (stream) {
                    $workflowService.selectedStream(stream);
                    $location.path(window.appConfig.CONTEXT_PATH + '/workflows');
                };

                $scope.openBotChooser = function (botType) {
                    $scope.bottype = botType;
                    //  $scope.bottype = 'taskbot';

                    $scope.initializeCreateBot = true;
                    openModalByClass('.stream-create-form');
                };

                $scope.onCreateNewBot = function () {
                    closeModalByClass('.stream-create-form');
                    $scope.initializeCreateBot = false;
                    $workflowService.navigateTabIndex(".tasks-pane");
                    $scope.navigateTabIndex = ".tasks-pane";
                    $(".tasks-pane").addClass("active").siblings().removeClass("active");
                    load();

                };
                $scope.onCancelBotCreation = function () {
                    $scope.initializeCreateBot = false;
                    closeModalByClass('.stream-create-form');
                };

                $scope.initiateBotCreation = function (type) {
                    closeModalByClass('.bot_type');
                    $('body').removeClass('modal-open');
                    //$('body').removeClass('bt-modal-open');
                    $timeout(function () {
                        $workflowService.streamType(type);
                        $location.path(window.appConfig.CONTEXT_PATH + '/streamcreate');
                    });
                };

                $scope.closeBotChooser = function () {
                    $scope.bottype = 'taskbot';
                    closeModalByClass('.bot_type');
                    $('body').removeClass('modal-open');
                    //$('body').removeClass('bt-modal-open');
                };

                $scope.openModeSelector = function () {
                    if ($scope.isEligibleForPublishing() && $scope._constants_.config.ENABLE_UNIVERSAL_BOT) {
                        $scope.modeSelectorCallback.openModeSelectorModal();
                    } else {
                        $scope.openBotChooser("taskbot");
                    }
                };

                $scope.verifyNlp = function () {
                    $workflowService.nlpStream($scope.selectedStream);
                    $location.path(window.appConfig.CONTEXT_PATH + '/nlp/bots/' + $scope.selectedStream._id + '/chatsettings');
                };

                $scope.viewChangeLog = function viewChangeLog(selectedStream) {
                    $workflowService.selectedStream($scope.selectedStream);
                    $location.path(window.appConfig.CONTEXT_PATH + '/bot/changelog');
                };

                $scope.initiateStreamCreation = function () {
                    $location.path(window.appConfig.CONTEXT_PATH + '/streamcreate');
                };

                $scope.initiateWorkflowCreation = function (type, navigate) {

                    $workflowService.workflowType(type);
                    $workflowService.mpAlertInfo({});
                    $workflowService.alertInfo({});
                    $workflowService.actionInfo({});
                    $workflowService.mpActionInfo({});
                    $workflowService.currentStep(3);
                    $workflowService.alertData({});
                    $workflowService.authData({});
                    $workflowService.requestData({});
                    $workflowService.responseData({});
                    $workflowService.settingsData({});

                    if (type === "knowledge") {
                        $location.path(window.appConfig.CONTEXT_PATH + '/knowledgecreate');
                        return;
                    }
                    if (type === "flowtask") {
                        $location.path(window.appConfig.CONTEXT_PATH + '/flowTask/new');
                        return;
                    }
                    if (!navigate) {
                        $location.path(window.appConfig.CONTEXT_PATH + '/new');
                    }
                };

                $scope.checkTaskAvailability = function(){
                    return $scope.alerts.length || $scope.actions.length || $scope.flowtasks.length || $scope.knowledgeTasks.length || $scope.reports.length;
                };

                $scope.initiateChatBot = function initiateChatBot() {
                    $scope.resetDebugConsole();
                    if (($scope.checkTaskAvailability() && $scope.showTestBot) || ($scope.selectedStream.type === 'universalbot' && $scope.linkedBots.length > 0)) {
                        $rootScope.$emit('botTestStart', $scope.selectedStream, undefined, $scope.pushDebugInfo, debugConsoleTrigger,null,$scope.pushHistoryInfo);
                        setDomPropToDebugConsole();
                    } else {
                        if ($scope.selectedStream.type === "universalbot") {
                            NotificationService.notify(i18n.i18nString('one_linkedbot'), "warning");
                            return;
                        }
                        NotificationService.notify(i18n.i18nString('bt_streams_atleast_one_bot_in_published_state'), "warning");
                    }
                };

                var _element = $("#debugConsoleRT");


                var setDomPropToDebugConsole = function(){
                    $timeout(function () {
                                $('#debugConsoleRT .flowTaskDebugConsolePanel').draggable({
                                handle: ".nav.nav-tabs",
                                        containment: "document",
                                        cancel: ".minimized"
                                }).resizable({
                                containment: "document",
                                        minWidth: 430,
                                        maxWidth: 800,
                                        minHeight: 400,
                                        handles: "e, s, se",
                                    stop: onDebugResizeStop,
                                    resize: function (event, ui) {
                                    var _minimized = ui.size.width < 800;
                                    var _ele = $(event.target).find('.toggleDebugConsolePanelSize');
                                    if (_ele) {
                                        _ele.toggleClass('fa-compress', !_minimized);
                                        _ele.toggleClass('fa-expand', _minimized);
                                    }
                                }
                            });
                            });
                };

                 function onDebugResizeStop(e, u) {
                        $scope.isDebugResized++;
                    }


                function debugConsoleTrigger (e) {
                    
                        if (e.event === 'debugClick') {
                            $scope.openDebugConsole();
                        } else if (e.event === 'minimizeClick') {
                            $scope.isDebugMinimized = $scope.isDebugConsolePanelOpened;
                               $scope.closeDebugConsolePanel();

                        } else if (e.event === 'maximizeClick') {
                            if ($scope.isDebugMinimized) {
                                $scope.openDebugConsole();
                                $scope.isDebugMinimized =false;
                            }
                        } else if (e.event === 'resetClick') {
                            $scope.resetDebugConsole();
                            return;
                        } else if (e.event === 'closeClick') {
                            $scope.closeDebugConsolePanel();
                            $scope.resetDebugConsole();
                            return;
                        }

                    }

                $scope.resetDebugConsole = function(){
                    $scope.debugInfo=[];
                    //$scope.debugInfo =[{debugTitle:"Reach to dialog to start the log..."}];

                    $scope.debugContext ='';
                    $scope.debugRaw={};
                    $scope.nlTraceData = [];
                };


                 $scope.openDebugConsole = function () {
                        $scope.isDebugConsolePanelOpened = true;
                        $timeout(function () {
                            var _ele = _element.find('.flowTaskDebugConsolePanel');

                            //if ($(_ele.selector).offset().left < 0) {
                            //    $(_ele.selector).css('left', '0px').css('top', '-56px');
                            //} else {
                                $(_ele.selector).css('left', '0px').css('top', '58px').css('width','800px');
                            //}
                            $scope.showNlTraceInitContent();
                        });
                    };

                    var emptySpace = String.fromCharCode(160);


                    var getSpaceByCount = function(count){
                        var tempEmptySpace = "";
                        for(var i=0;i<count;i++){
                            tempEmptySpace = tempEmptySpace+emptySpace;
                        }

                        return tempEmptySpace;
                    };

                    $scope.showNlTraceInitContent = function(){
                             $scope.nlTrace = ["> Initailizing", ""];
                            $scope.nlTrace.push("> Tasks Loaded...");
                            var taskList = [].concat($scope.alerts, $scope.actions, $scope.flowtasks);
                            
                            var types = {
                                'a': "Action",
                                "l": "Alert"
                            };

                            var getTaskTypeByID = function(taskid){
                                var taskType = types[taskid[0]];

                                if(!taskType){
                                    if(taskid.indexOf("dg-") !== -1){
                                        taskType = "Dialog";
                                    }
                                }

                                return (taskType || "");
                            };

                            var getTaskName = function(taskData){

                                if(taskData.state !== 'published' && taskData.state !== "suspended" && taskData.state !== "rejected" && $workflowService.selectedStream().visibility.namespace !== 'private'){
                                    return taskData.name+"   @development";
                                }

                                return taskData.name;

                            };



                            $.each(taskList, function(i, task){
                                $scope.nlTrace.push(getSpaceByCount(10)+""+getTaskTypeByID(task._id)+" Task   '"+getTaskName(task)+"'   "+(task.version || ''));
                                if(task.isParent){
                                    var childTask = task.child[0];
                                    $scope.nlTrace.push(getSpaceByCount(10)+""+getTaskTypeByID(childTask._id)+" Task   '"+getTaskName(childTask)+"'   "+(childTask.version || ''));
                                }
                            });

                            $.each($scope.knowledgeTasks, function(i, knowledgeData){
                                $scope.nlTrace.push(getSpaceByCount(10)+"Knowledge Task   '"+knowledgeData.name+"'   "+(knowledgeData.version || ''));
                            });

                            

                            $scope.nlTrace.push("> All Tasks Loaded Successfully");
                            $scope.nlTrace.push("> Ready for utterances");


                    };

                    var _scoringArray = [
                                            "taskNameAnalysis", 
                                            "penaltyScoring", 
                                            "bonusScoring",
                                            "wordScoring"
                                            ];
                                            
                                            var _keysToExclude = ["activityType", "debugTitle", "foundInSentence"];
                        function pushHistory(debug) {
                            //$scope.debugInfo =[{debugTitle:"Starting logging..."}];
                            $scope.debugInfo=$scope.debugInfo || [];
                            var node=debug.history;
                            //$.each(debug.history, function (k, node) {
                                var _timeStamp = "";
                                if(node.debugTitle){
                                   $scope.debugInfo.push(node);                                    
                                } node.timestampFormated = moment(node.timestamp).local().format('DD/MMM/YYYY  hh.mm.ssA');//ddd MMM DD YYYY HH:mm:ss
//                                else if (node && node.dialogState) {
//                                    $scope.debugInfo.push('> ' + node.dialogState);
//                                    if (node.timestamp && !isNaN(node.timestamp)) {
//                                        _timeStamp = moment(node.timestamp).local().format('MM/DD/YYYY HH:mm:ss');//ddd MMM DD YYYY HH:mm:ss
//                                        $scope.debugInfo.push(String.fromCharCode(160) + String.fromCharCode(160) + String.fromCharCode(160) + String.fromCharCode(160) + '' + _timeStamp);
//                                    }
//                                } else if (node && node.componentName) {
//                                    $scope.debugInfo.push('> ' + node.type + ' : ' + node.componentName + (node.state ? ' (' + node.state + ')' : ''));
//                                    if (node.timestamp && !isNaN(node.timestamp)) {
//                                        _timeStamp = moment(node.timestamp).local().format('MM/DD/YYYY HH:mm:ss');//ddd MMM DD YYYY HH:mm:ss
//                                        $scope.debugInfo.push(String.fromCharCode(160) + String.fromCharCode(160) + String.fromCharCode(160) + String.fromCharCode(160) + '' + _timeStamp);
//                                    }
//                                }
                            //});
                            
                           $timeout(function () {
                            var _debugLogDiv = $('.debug-log-body .log-console-body');
                            if (_debugLogDiv) {
                                _debugLogDiv.scrollTop(_debugLogDiv[0].scrollHeight);
                                //$rootScope.$emit('pefectScrollUpdate');  
                            }
                        }, 300);
                        }
                        $scope.pushHistoryInfo = function (debug) {
                            pushHistory(debug);
                        };
                        $scope.pushDebugInfo = function (debug) {
                            var tempDebug = angular.copy(debug);
                            if (tempDebug.NLAnalysis && tempDebug.NLAnalysis.length > 0) {

                                $scope.nlTraceData = [];
                                $scope.nlTraceData.push({type: 'String', title: ' > NL analysis', value: ""});
                                var recObjNL = function (spaceToAdd, obj) {
                                    var initSpace = spaceToAdd;
                                    if (Object.keys(obj).length > 0) {
                                        $.each(obj, function (k, tempObj) {
                                            if (tempObj !== undefined) {
                                                if (tempObj && tempObj.constructor === Object) {
                                                    $scope.nlTraceData.push({type: 'Object', title: initSpace + ' > ' + k, value: ''});
                                                    recObjNL(initSpace + getSpaceByCount(8), tempObj);
                                                } else if (tempObj && tempObj.constructor === Array) {
                                                    $scope.nlTraceData.push({type: 'Array', title: initSpace + ' > ' + k, value: ''});
                                                    recObjNL(initSpace + getSpaceByCount(8), tempObj);
                                                } else {
                                                    if ($.inArray(k, _keysToExclude) === -1) {
                                                        $scope.nlTraceData.push({type: 'String', title: initSpace + k, value: tempObj});
                                                    }
                                                }
                                            }
                                        });
                                    } else {
                                        if ($.inArray(k, _keysToExclude) === -1) {
                                            $scope.nlTraceData.push({type: 'String', title: initSpace + '---', value: '---'});
                                        }
                                    }
                                };

                                $.each(tempDebug.NLAnalysis, function (i, nlAnalalysis) {
                                    if (nlAnalalysis && Object.keys(nlAnalalysis).length > 0) {
                                        $.each(nlAnalalysis, function (k, obj) {
                                            if (obj && k !== 'history') {
                                                if (obj.constructor === Object) {

                                                    if ($.inArray(k, _scoringArray) !== -1) {
                                                        $scope.nlTraceData.push({type: 'Object', title: ' > ' + k + "" + getSpaceByCount(2) + "(" + obj.debugTitle.slice(obj.debugTitle.indexOf(":") + 2) + ")", value: ''});
                                                    } else {
                                                        $scope.nlTraceData.push({type: 'Object', title: ' > ' + k, value: ''});
                                                    }

                                                    recObjNL(getSpaceByCount(10), obj);
                                                } else if (obj.constructor === Array) {
                                                    $scope.nlTraceData.push({type: 'Array', title: ' > ' + k, value: ''});
                                                    recObjNL(getSpaceByCount(10), obj);
                                                } else {
                                                    if ($.inArray(k, _keysToExclude) === -1) {
                                                        $scope.nlTraceData.push({type: 'String', title: ' > ' + k, value: obj, noChild: true});
                                                    }

                                                }
                                            } else if (obj === 0) {
                                                if ($.inArray(k, _keysToExclude) === -1) {
                                                    $scope.nlTraceData.push({type: 'String', title: k, value: obj});
                                                }

                                            } else if (obj === null || obj === undefined) {
                                                if ($.inArray(k, _keysToExclude) === -1) {
                                                    $scope.nlTraceData.push({type: 'String', title: k, value: 'null'});
                                                }
                                            }
                                        });
                                    }
                                });



                                // $scope.nlTrace.push("> NL analysis:");
                                // $scope.nlTrace.push(tempDebug.NLAnalysis || []);

                                //pushHistory(debug);
                            }
                            if (tempDebug.type === 'contextUpdate') {
                                debug = debug.context || {};
                                $scope.debugRaw = debug;
                                $scope.debugContext = debug;
                            }
                            if (tempDebug.type === 'contextUpdate' && tempDebug.context.scriptErrorMeta) {
                                $scope.validateJs(tempDebug);
                            }
                            $timeout(function () {
                                $scope.$digest();
                            }, 350);
                        };

                     $scope.closeDebugConsolePanel = function () {
                        $scope.isDebugConsolePanelOpened = false;
                        var _ele = _element.find('.flowTaskDebugConsolePanel');
                        $timeout(function(){
                             $(_ele.selector).css('width', '');
                        },500);
                       
                    };


                $scope.isChatWindowOpen = function () {
                    return $(".kore-chat-window").is(":visible");
                };

                $scope.isSolutionBotSetup = false;
                $scope.setupSolutionBot = function () {
                    if ($scope.showSolutionBotSetup) {
                        //$location.path('/bt/solution/install/'+ $workflowService.selectedStream()._id +'/');
                        //$location.path('/bt/bot/solution/install');
                        $scope.isSolutionBotSetup = true;
                        $scope.openFullPageModal(3);

                        $("#btFullpageModal").off("hidden.bs.modal").on("hidden.bs.modal", function () {
                            if(!isEleVisible("#termsConditions")){
                    $("body").removeClass("modal-open");
                }
                            $("body").removeClass("bt-modal-open");
                            $scope.isSolutionBotSetup = false;
                        });
                    }
                };

                $scope.setupSampleBot = function () {
                    if ($scope.showSolutionBotSetup) {
                        $scope.openFullPageModal(3, 'createBot');
                        $workflowService.selectedSampleBot($scope.selectedStream);
                    }
                };


                $scope.unlockTask = function (task) {
                    $scope.selectedTask = task;
                    $timeout(function () {
                        openModalByClass('.unlock-sol-bot');
                    });
                };

                $scope.confirmUnlock = function () {
                    var task = $scope.selectedTask;
                    $scope.taskUnlocking = true;
                    if (task._id.substring(0, 1) === 'a') {//action
                        BTActionsService.unlockBTAction(task._id, $workflowService.selectedStream()._id)
                            .then(function (res) {
                                closeModalByClass('.unlock-sol-bot');
                                $('body').removeClass('modal-open');
                                //$('body').removeClass('bt-modal-open');
                                $route.reload();
                                $scope.taskUnlocking = false;
                            }, function (res) {
                                NotificationService.notify(i18n.i18nString('confirm_unlock'));
                                $scope.taskUnlocking = false;
                            });
                    } else if (task._id.substring(0, 1) === 'l') {//alert

                        BTAlertsService.unlockBTAlert(task._id, $workflowService.selectedStream()._id)
                            .then(function (res) {
                                closeModalByClass('.unlock-sol-bot');
                                $('body').removeClass('modal-open');
                                //$('body').removeClass('bt-modal-open');
                                $route.reload();
                                $scope.taskUnlocking = false;
                            }, function (res) {
                                NotificationService.notify(i18n.i18nString('confirm_unlock'));
                                $scope.taskUnlocking = false;
                            });
                    } else {
                        var userId = $applicationService.userInfo().userId;

                        var requestData = {
                            "resources": [
                                {
                                    "resourceType": "dialog",
                                    "resourceId": task._id
                                }
                            ]
                        };

                        BTActionsService.unlockDialog(task._id, $workflowService.selectedStream()._id, userId, requestData)
                            .then(function (res) {
                                closeModalByClass('.unlock-sol-bot');
                                $('body').removeClass('modal-open');
                                //$('body').removeClass('bt-modal-open');
                                $route.reload();
                                $scope.taskUnlocking = false;
                            }, function (res) {
                                NotificationService.notify(i18n.i18nString('confirm_unlock'));
                                $scope.taskUnlocking = false;
                            });
                    }

                };

                $scope.duplicateTask = function (task) {

                };

                $scope.destroyChatBot = function destroyChatBot() {
                    $rootScope.$emit('botTestEnd', $scope.selectedStream);

                };

                $scope.createChannel = function () {
                    $location.path(window.appConfig.CONTEXT_PATH + '/stream/' + $workflowService.selectedStream()._id + '/channel');
                };

                $scope.editChannel = function (channel) {

                    var stream = $workflowService.selectedStream();

                    editChannel();

                    // $scope.lockTask(stream,prepareTimer)
                    //     .then(function() {
                    //         editChannel();
                    //     },function(err) {
                    //         var errorMsg = "Something went wrong"; 
                    //         var error    = (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || errorMsg;
                    //         NotificationService.notify(error, 'error');
                    //     });

                    function editChannel() {
                        $location.path(window.appConfig.CONTEXT_PATH + '/stream/' + $workflowService.selectedStream()._id + '/channel/' + channel.type);
                    }

                };

                $scope.$on("streamUpdate", function () {
                    // $scope.streams = $workflowService.streamsAll();
                    angular.extend($scope.streams, $workflowService.streamsAll());
                    $scope.selectedStream = $workflowService.selectedStream();
                    $scope.generateRandomId();
                    $.each($scope.streams, function (i, streamDetails) {
                        if (streamDetails._id === $scope.selectedStream._id) {
                            $scope.streams[i].active = true;
                        }
                    });
                    $scope.$broadcast("updateLinkableBots");
                    $timeout(function () {
                        retainScrollPosition();
                    }, 2000);
                });

                $rootScope.$on("triggerSelectApp", function (e, reload) {
                    $scope.streams = $workflowService.streamsAll();
                    $scope.selectedStream = $workflowService.selectedStream();
                    for (var i = 0; i < $scope.streams.length; i++) {
                        if ($scope.streams[i]._id === $scope.selectedStream._id) {
                            $scope.selectApp($scope.streams[i], reload);
                                retainScrollPosition();
                            // $scope.streams[i].active = true;
                        }
                    }

                });

                $rootScope.$on("triggerSolutionBotSetup", function () {
                    $scope.showSolutionBotSetup = false;
                    $scope.showTestBot = false;
                    $scope.currentLanguage = $workflowService.currentLanguage();
                });


                $scope.$on("triggerHelpLinkUpdate", function () {
                    $scope.isHelpLinkClicked = true;
                    $timeout(function () {
                        $scope.isHelpLinkClicked = false;
                    });
                });

                $rootScope.$on("delaytriggerSelectApp", function (){                    
                    setTimeout(function (){$rootScope.$broadcast("triggerSelectApp", false);},200);
                });

                $scope.isCollapsed = function (ele) {
                    return $(ele).hasClass("collapsed") && !$scope.isHelpLinkClicked;
                };
                $scope.isDefaultDialogExpanded = function (ele) {
                    $scope.defaultDialogExpanded=$(ele).hasClass("collapsed");
                };
                $scope.onBotLinkingCompleted = function () {
                    closeModalByClass('.bots-selection-form');
                    load();
                };

                $scope.enableordisableChannel = function (channel, enable) {
                    if (!enable) {
                        NotificationService.alert(getChannelMessage(channel),
                            modifyChannelStatus, [true]);
                    } else {
                        modifyChannelStatus();
                    }

                    function modifyChannelStatus() {
                        channel.enable = enable;
                        var payload = {
                            channels: arrangeChannels(channel)
                        };

                        BTStreamsService.createOrEditChannel($scope.selectedStream._id, channel.type, channel)
                            .then(function (res) {
                                $workflowService.selectedStream().channels = payload.channels;
                                NotificationService.notify(!enable ? getChannelName(channel.type) + " channel disabled" : getChannelName(channel.type) + " channel enabled", "info");
                            }, function (err) {
                                console.log("error");
                            });
                    }

                };

                function arrangeChannels(channel) {
                    var index;

                    $scope.selectedStream.channels.map(function (channelInfo, i) {
                        if (channelInfo.type === channel.type && channelInfo.id === channel.id) {
                            index = i;
                        }
                    });

                    if (_.isUndefined(index)) {
                        $scope.selectedStream.channels.push(channel);
                    } else {
                        $scope.selectedStream.channels.splice(index, 1, channel);
                    }

                    return $scope.selectedStream.channels;

                }




                $scope.taskCreateCallback.openCreateFlowDialog = function () {
                    $scope.activeEntityFlow = {};
                    openModalByClass('.flowtask-create-form');
                };

                $scope.modeSelectorCallback.onModeSelected = function (selectedMode) {
                    // $timeout(function () {
                    $scope.openBotChooser(selectedMode);
                    // },1000);
                };


                $scope.onFlowDialogClosed = function (reload) {
                    $scope.activeEntityFlow = null;
                    if(!isEleVisible("#termsConditions")){
                        $("body").removeClass("modal-open");
                    }
                    $("body").removeClass("bt-modal-open");
                    closeModalByClass('.flowtask-create-form');
                    $scope.closeFullPageModal();
                    if (reload) {
                        load();
                        openDialogTaskAccordion();
                    }
                };

                $scope.deleteChannel = function (index) {
                    var channel = $scope.selectedStream.channels[index];
                    var msg = i18n.i18nString('bt_chnl_bot_will_not_available_noty',{dyn: channel.type});
                    NotificationService.alert(msg, deleteChannel, arguments);
                };

                function deleteChannel(index) {
                    var channel = $scope.selectedStream.channels[index];

                    BTStreamsService.deleteChannel($scope.selectedStream._id, channel.type)
                        .then(function (res) {
                            $scope.selectedStream.channels.splice(index, 1);
                            $workflowService.selectedStream(angular.copy($scope.selectedStream));
                            NotificationService.notify(i18n.i18nString('bt_streams_chnl_Deleted_sucess'), "success");
                        }, function (err) {
                            var errMsg = (err && err.errors && err.errors[0].msg) || i18n.i18nString('bt_chnl_form_chnl_delete_failed');
                            NotificationService.notify(errMsg, "error");
                        });
                }

                function getChannelName(type) {
                    return type === "rtm" ? "Web / Mobile client" : (type =='widgetsdk'?'Widget SDK': type);
                }
                function getChannelMessage(channel) {
                    var msg = i18n.i18nString('bt_streams_chnl_bot_not_able_to_respond',{dyn: getChannelName(channel.type)});
                    var appendMsg = i18n.i18nString('bt_streams_you_Can_still_talk_to_bot');
                    var message = " ";
                    var enableChannelExisted = false;
                    $scope.selectedStream.channels.map(function (channelInfo, i) {
                        if (!(channelInfo.type === channel.type && channelInfo.id === channel.id) && channelInfo.enable) {
                            message = message + getChannelName(channelInfo.type) + ", ";
                            enableChannelExisted = true;
                        }
                    });
                    if (enableChannelExisted) {
                        message = message.substr(0, message.length - 2);
                        return msg + appendMsg + message + ".";
                    }
                    return msg;
                }

                $workflowService.registerModalHiddenEvent();

                $scope.editStream = function (stream) {

                    editStream();

                    // $scope.lockTask(stream,prepareTimer)
                    //     .then(function() {
                    //         editStream();
                    //     },function(err) {
                    //         var errorMsg = "Something went wrong"; 
                    //         var error    = (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || errorMsg;
                    //         NotificationService.notify(error, 'error');
                    //     });

                    function editStream() {
                        $workflowService.selectedStream(stream);
                        $location.path('bt/streamedit/' + stream._id);
                    }

                };

                $scope.deleteStream = function (stream) {
                    NotificationService.alert(i18n.i18nString('delete_stream'), deleteStream, arguments);
                };

                $scope.helpUrl = "http://google.com";



                function deleteStream(stream) {
                    $q.all([BTStreamsService.deleteBTStream(stream._id)])
                        .then(function (res) {
                            $scope.streams.splice(getStreamIndex(stream._id), 1);
                            NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('bt_streams_bot_deleted_success'), "success");
                            if ($scope.streams.length > 0) {
                                var streamToSelect = $scope.streams[0];
                                 $.each($scope.streams, function(i, stream){
                                    if(stream.createdBy.id === $applicationService.userInfo().userId){
                                        streamToSelect = stream;
                                        return false;
                                    }
                                });

                                $scope.selectApp(streamToSelect);
                            } else {
                                $scope.selectedStream = {};
                                $("body").addClass("hidebodyscroll");
                            }
                            $("body").removeClass("bt-modal-open");
                            if(!isEleVisible("#termsConditions")){
                    $("body").removeClass("modal-open");
                }
                        }, function (err) {

                            NotificationService.alertNotify(i18n.i18nString('deletion_failed'), err.data ? err.data.errors[0].msg : i18n.i18nString('some_thing_went_wrong_err_noty'), "error");
                        });
                }

                $scope.workflows = {};
                var mappingsShown = [];

                $scope.lockTask = function lockTask(entity, prepareTimer, type) {
                    TimerNotification.removeTimer(entity._id);
                    return BTStreamsService.createLock(entity._id)
                        .then(function (res) {
                            var config = res.data;
                            config.lockCreatedTime = new Date(config.locktime);
                            config.locktime = new Date(config.locktime);
                            config.locktime.setMinutes(config.locktime.getMinutes() + $scope._constants_.timerTimeoutInMinutes);
                            TimerNotification.registerTimer(prepareTimer(config, entity, type));
                            return;
                        }, function (err) {
                            showLockErrorMessage(err.data, err);
                            return $q.reject(err);
                        });
                };

                function showLockErrorMessage(error, full) {
                    try {
                        error = error.errors;
                        var msg = _.isArray(error) ? error[0].msg : i18n.i18nString('some_thing_went_wrong_err_noty');
                        NotificationService.notify(msg, 'error');
                    } catch (ex) {
                        console.log(ex);
                    }

                }

                $scope.releaseLock = function (type, entity, hideMsg) {
                    return BTStreamsService.releaseLock(entity._id)
                        .then(function (res) {
                            $rootScope.$broadcast('reloadTasks', type);
                            if (!hideMsg) {
                                NotificationService.notify(i18n.i18nString('release_lock_success',{dyn: entity.name}), 'success');
                            }
                        }, function (err) {
                            if (!hideMsg) {
                                NotificationService.notify(i18n.i18nString('release_lock_failure',{dyn: entity.name}), 'error');
                            }
                            return $q.reject({ data: { 'error': i18n.i18nString('lock_release_failed') } });
                        });
                };

                $scope.$on('reloadTasks', function (evt, type) {
                    if (type == 'alert') {
                        getAlerts($workflowService.selectedStream()._id);
                    } else if (type == 'action' || type == 'report') {
                        getActions($workflowService.selectedStream()._id);
                    } else if (type == 'knowledgeTask') {
                        getKnowledgeTasks($workflowService.selectedStream()._id);
                    } else if (type == 'flowTask') {
                        getFlowTasks($workflowService.selectedStream()._id);
                    }
                });

                $rootScope.$on("onedittask", function (event, entity, type) {
                    $scope.editWorkflow(entity, type, "", true);
                });

                $scope.removeLoader = function () {
                    $("#noty_center_layout_container").empty();
                };

                $scope.editWorkflow = function (entity, type, isFromUpgrade, isFromCreation) {
                    $scope.workingTaskType = type;

                    $scope.lockTask(entity, prepareTimer, type)
                        .then(function (res) {
                            triggerEdit();
                        }, function (err) {

                        });



                    function triggerEdit() {
                        if (type !== "knowledgeTask" && !isFromUpgrade) {
                            if (type === "flowtaskEdit" || !isFromCreation) {
                                loader = NotificationService.loader(i18n.i18nString('please_wait_noty'));
                            } else {
                                $scope.$emit("showStatusLoader", true);
                            }

                        }
                        $scope.initiateWorkflowCreation(type, true);
                        if (type === "alert") {
                            $workflowService.alertInfo(entity);
                            $q.all([BTAlertsService.getMPAlert(entity._id), BTAlertsService.getBTAlert(entity._id)]).then(function (res) {
                                $workflowService.alertInfo(res[1].data);
                                res[1].data.taskType = type;
                                $workflowService.taskEditInfo(res[1].data);
                                $workflowService.taskMode("edit");
                                //$rootScope.$emit("createTaskOpen", true);
                                $workflowService.mpAlertInfo(res[0].data);
                                $workflowService.currentStep(3);
                                if (!isFromCreation) {
                                    loader();
                                }
                                $scope.$emit("showStatusLoader", false);
                                $scope.removeLoader();
                                $timeout(function () {
                                    $rootScope.$emit("updateEditTask", true);
                                });
                                $scope.openFullPageModal(3);
                                //$("#taskCreateOrEditModal").modal("show");

                                //$location.path('bt/' + type + '/' + entity._id + '/action/edit');
                            }, function (err) {
                                NotificationService.notify(i18n.i18nString('error_msg'), "error");
                                $workflowService.mpAlertInfo({});
                                $workflowService.alertInfo({});
                                if (!isFromCreation) {
                                    loader();
                                }
                                $scope.$emit("showStatusLoader", false);
                                $scope.removeLoader();
                            });
                        } else if (type === "action") {
                            $q.all([BTActionsService.getBTAction(entity._id), BTActionsService.getMPAction(entity._id)]).then(function (res) {
                                $workflowService.actionInfo(res[0].data);
                                $workflowService.mpActionInfo(res[1].data);
                                res[0].data.taskType = type;
                                $workflowService.taskEditInfo(res[0].data);
                                $workflowService.taskMode("edit");
                                //$rootScope.$emit("createTaskOpen", true);
                                $workflowService.currentStep(3);
                                if (!isFromCreation) {
                                    loader();
                                }
                                $scope.$emit("showStatusLoader", false);
                                $scope.removeLoader();
                                $timeout(function () {
                                    $rootScope.$emit("updateEditTask", true);
                                });
                                $scope.openFullPageModal(3);
                                // $("#taskCreateOrEditModal").modal("show");
                                //$location.path('bt/' + type + '/' + entity._id + '/action/edit');
                            }, function (err) {
                                NotificationService.notify(i18n.i18nString('error_msg'), "error");
                                $workflowService.mpActionInfo({});
                                $workflowService.actionInfo({});
                                if (!isFromCreation) {
                                    loader();
                                }

                                $scope.$emit("showStatusLoader", false);
                                $scope.removeLoader();
                            });
                        } else if (type === "knowledgeTask") {
                            $.each($workflowService.knowledgeTasks(), function (i, knowledge) {
                                if (knowledge._id === entity._id) {

                                    knowledge.taskType = "knowledgeTask";
                                    $workflowService.taskEditInfo(knowledge);
                                    $workflowService.taskMode("edit");
                                    $timeout(function () {
                                        $rootScope.$emit("updateEditTask", true);
                                    });
                                    $scope.openFullPageModal(3);
                                }
                            });
                            // $location.path('/bt/knowledge/edit/'+entity._id);
                        } else if (type === "flowtaskEdit") {
                            loader();
                            $scope.removeLoader();
                            entity.taskType = "flowTask";
                            $workflowService.taskEditInfo(entity);
                            $workflowService.flowtaskInfo(entity);
                            $workflowService.taskMode("edit");
                            $timeout(function () {
                                $rootScope.$emit("updateEditTask", true);
                            });
                            $scope.openFullPageModal(3);

                            //$location.path('/bt/flowTask/edit/'+entity._id);
                        }

                    }

                };

                $scope.showTrainBot = function (log) {
                    $scope.$emit("openFullPageModal", 'trainBot');
                    $workflowService.nlpTrainInput({});
                };


                $scope.openModalByClass = openModalByClass;
                function openModalByClass(modalClass) {
                    $(modalClass).modal("show");
                    // if(modalClass == '.ontology-form'){
                    //     // $("body").addClass("ontologymodalopen");
                    // }
                }
                function closeModalByClass(modalClass) {
                    $timeout(function () {
                        if(!isEleVisible("#termsConditions")){
                    $("body").removeClass("modal-open");
                }
                        $("body").removeClass("bt-modal-open");
                    });
                    $(modalClass).modal('hide');
                    if (modalClass === '.utterances-form') {
                        $(document).off("click.entity");
                        $scope.canShowUtterances = false;
                    }
                    if (modalClass === '.batchtesting-form'){
                         $scope.canShowBatchTesting = false;
                    }

                    if(modalClass === '.ontology-form'){
                        $scope.canShowontology = false;
                         $("body").removeClass("ontologymodalopen");
                        getKnowledgeTasks($workflowService.selectedStream()._id);
                    }
                }
                $scope.closeModalByClass = closeModalByClass;

                function triggerTaskLockReleasing() {

                    var userId = $applicationService.userInfo().userId;


                    var callReleaseLock = function(resourceObject, resourceName){

                        var proceedToReleaseLock = function(resourceObject){
                            if (resourceObject && resourceObject.lock && resourceObject.lock.lockkey) {
                                if (resourceObject.lock.userId == userId) {
                                    if(resourceName === "flow"){
                                        resourceObject._id = resourceObject.mapId;
                                    }
                                    $scope.releaseLock(resourceName, resourceObject, true);
                                    TimerNotification.removeTimer(resourceObject._id);
                                    delete resourceObject.lock;
                                }
                            }
                        };
                        
                        proceedToReleaseLock(resourceObject);
                        $.each((resourceObject.child || []), function(i, data){
                            proceedToReleaseLock(data);
                        });
                        

                    };

                    $scope.alerts.map(function (alert) {
                        // if (alert && alert.lock && alert.lock.lockkey) {
                        //     if (alert.lock.userId == userId) {
                        //         $scope.releaseLock('alert', alert, true);
                        //         TimerNotification.removeTimer(alert._id);
                        //         delete alert.lock;
                        //     }
                        // }
                        callReleaseLock(alert, "alert");
                    });

                    $scope.actions.map(function (action) {
                        // if (action && action.lock && action.lock.lockkey) {
                        //     if (action.lock.userId == userId) {
                        //         $scope.releaseLock('action', action, true);
                        //         TimerNotification.removeTimer(action._id);
                        //         delete action.lock;
                        //     }
                        // }
                        callReleaseLock(action, "action");
                    });
                    $scope.reports.map(function (report) {
                        // if (report && report.lock && report.lock.lockkey) {
                        //     if (report.lock.userId == userId) {
                        //         $scope.releaseLock('action', report, true);
                        //         TimerNotification.removeTimer(report._id);
                        //         delete report.lock;
                        //     }
                        // }
                        callReleaseLock(report, "action");
                    });

                    $scope.mappings.map(function (mapping) {
                        // if (mapping && mapping.lock && mapping.lock.lockkey) {
                        //     if (mapping.lock.userId == userId) {
                        //         mapping._id = mapping.mapId;
                        //         $scope.releaseLock('flow', mapping, true);
                        //         TimerNotification.removeTimer(mapping._id);
                        //         delete mapping.lock;
                        //     }
                        // }
                        callReleaseLock(mapping, "flow");
                    });

                    $scope.knowledgeTasks.map(function (kt) {
                        // if (kt && kt.lock && kt.lock.lockkey) {
                        //     if (kt.lock.userId == userId) {
                        //         $scope.releaseLock('knowledgeTask', kt, true);
                        //         TimerNotification.removeTimer(kt._id);
                        //         delete kt.lock;
                        //     }
                        // }
                        callReleaseLock(kt, "knowledgeTask");
                    });

                    if ($scope.selectedStream.lock && $scope.selectedStream.lock.lockkey) {
                        $scope.releaseLock('bot', $scope.selectedStream, true);
                    }

                }

                $scope.isNotAParentOf = function (mapping) {
                    return !mapping.parentOf;
                };

                $scope.editOrViewWorkflow = function (taskInfo, taskAction) {
                    if (!(taskInfo.state === 'published' || taskInfo.state === 'suspended')) {
                        taskAction = taskAction === "dialog" ? "flowtaskEdit" : taskAction;
                        $scope.editWorkflow(taskInfo, taskAction);
                    } else {
                        taskAction = taskAction === "dialog" ? "flowtaskView" : taskAction;
                        $scope.viewWorkflow(taskInfo, taskAction);
                    }
                };

                function prepareTimer(timerConfig, entity, taskType) {

                    var types = {
                        'a': "action",
                        "l": "alert",
                        "s": "bot",
                        "z": "flow",
                    };

                    var entityTypes = {
                        'a': "task",
                        "l": "task",
                        "s": "bot",
                        "z": "flow"
                    };
                    var type = taskType === "knowledgeTask" ? "knowledgeTask" : types[entity._id[0]];
                    var config = {};
                    var entityType = taskType === "knowledgeTask" ? "task" : entityTypes[entity._id[0]];

                    config.context = {
                        time: timerConfig.lockCreatedTime,
                        expiry: timerConfig.locktime,
                        task: timerConfig.resourceId,
                        lockkey: timerConfig.lockkey,
                        userId: timerConfig.userId,
                        islocked: timerConfig.islocked,
                        lockCreatedTime: timerConfig.lockCreatedTime
                    };

                    config.warning = {
                        msg: $scope._constants_.timerMsgs.warning.replace(/{task}/g, entity.name).replace(/{type}/g, entityType),
                        actions: {
                            success: warningSuccessCb,
                            failure: warningCancelCb
                        },
                        arguments: {
                            success: [],
                            failure: []
                        },
                        btnText: {
                            success: i18n.i18nString('bt_streams_extend'),
                            failure: i18n.i18nString('close')
                        }
                    };

                    config.expiry = {
                        msg: $scope._constants_.timerMsgs.expiry.replace(/{task}/g, entity.name).replace(/{type}/g, entityType),
                        actions: {
                            success: expirySuccessCb,
                            failure: expiryCancelCb
                        },
                        arguments: {
                            success: [],
                            failure: []
                        },
                        btnText: {
                            success: i18n.i18nString('bt_streams_extend'),
                            failure: i18n.i18nString('close')
                        }
                    };

                    function warningSuccessCb() {
                        this._stages.expiry = true;
                        entity.lock = entity.lock ? entity.lock : {};
                        entity.lock.locktime = true;
                        $scope.lockTask(entity, prepareTimer);
                    }

                    function warningCancelCb() { }

                    function expirySuccessCb() {
                        this._stages.expiry = true;
                        entity.lock = entity.lock ? entity.lock : {};
                        entity.lock.locktime = true;
                        $scope.lockTask(entity, prepareTimer);
                    }

                    function expiryCancelCb() {
                        $scope.releaseLock(type, entity);
                    }

                    return config;

                }

                $scope.viewWorkflow = function (entity, type) {
                    if (type !== "knowledgeTask") {
                        loader = NotificationService.loader('Please wait');
                    }
                    $scope.initiateWorkflowCreation(type, true);
                    if (type === "alert") {
                        $workflowService.alertInfo(entity);
                        $q.all([BTAlertsService.getMPAlert(entity._id), BTAlertsService.getBTAlert(entity._id)]).then(function (res) {
                            $workflowService.mpAlertInfo(res[0].data);
                            $workflowService.alertInfo(res[1].data);
                            res[1].data.taskType = type;
                            $workflowService.taskEditInfo(res[1].data);
                            $workflowService.taskMode("view");
                            $workflowService.currentStep(3);
                            loader();
                            //$location.path('bt/' + type + '/' + entity._id + '/action/view');
                            $timeout(function () {
                                $rootScope.$emit("updateEditTask", true);
                            });

                            $scope.openFullPageModal(3);
                        }, function (err) {
                            NotificationService.notify(i18n.i18nString('error_msg'), "error");
                            $workflowService.mpAlertInfo({});
                            $workflowService.alertInfo({});
                            loader();
                        });
                    } else if (type === "action" || type === "report") {
                        $q.all([BTActionsService.getBTAction(entity._id), BTActionsService.getMPAction(entity._id)]).then(function (res) {
                            $workflowService.actionInfo(res[0].data);
                            $workflowService.mpActionInfo(res[1].data);
                            res[0].data.taskType = type;
                            $workflowService.taskEditInfo(res[0].data);
                            $workflowService.taskMode("view");
                            $workflowService.currentStep(3);
                            loader();
                            // $location.path('bt/' + type + '/' + entity._id + '/action/view');
                            $timeout(function () {
                                $rootScope.$emit("updateEditTask", true);
                            });

                            $scope.openFullPageModal(3);
                        }, function (err) {
                            NotificationService.notiy(i18n.i18nString('error_msg'), "error");
                            $workflowService.mpActionInfo({});
                            $workflowService.actionInfo({});
                            loader();
                        });
                    } else if (type === "knowledgeTask") {

                        //$location.path('/bt/knowledge/view/'+entity._id);  
                        $.each($workflowService.knowledgeTasks(), function (i, knowledge) {
                            if (knowledge._id === entity._id) {

                                knowledge.taskType = "knowledgeTask";
                                $workflowService.taskEditInfo(knowledge);
                                $workflowService.taskMode("view");
                                $timeout(function () {
                                    $rootScope.$emit("updateEditTask", true);
                                });

                                $scope.openFullPageModal(3);
                            }
                        });
                    }
                    else if (type === "flowtaskView") {
                        loader();
                        $workflowService.flowtaskInfo(entity);
                        entity.taskType = "flowTask";
                        $workflowService.taskEditInfo(entity);
                        $workflowService.flowtaskInfo(entity);
                        $workflowService.taskMode("view");
                        $timeout(function () {
                            $rootScope.$emit("updateEditTask", true);
                        });
                        $scope.openFullPageModal(3);
                        //$location.path('/bt/flowTask/view/'+entity._id);
                    }
                };
                $scope.recallWorkflow = function (entity, type) {
                    NotificationService.alert(i18n.i18nString('recall_workflow'), recallTask, { okText: i18n.i18nString('continue'), cancelText: i18n.i18nString('cancel') });
                    function recallTask() {
                        if (type === "alert") {

                            BTAlertsService.configured(entity._id).then(function (res) {
                                $route.reload();
                            }, function (err) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        } else if (type === "action") {

                            BTActionsService.configured(entity._id).then(function (res) {
                                $route.reload();
                            }, function (err) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        }
                        else if (type === "flowtask") {
                            BTFlowtaskService.recallFlowtask($workflowService.selectedStream()._id, entity._id).then(function (res) {
                                $route.reload();
                            }, function (err) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        }
                    }
                };

                $scope.unPublishWorkflow = function (entity, type) {
                    function unpublishWF() {
                        if (type === "alert") {
                            BTAlertsService.upPublishBTAlert(entity._id).then(function (res) {
                                NotificationService.alertNotify(i18n.i18nString('bt_streams_unpublish_label'), i18n.i18nString('bt_streams_alert_task_has_been_unpublished'), "success");
                                $route.reload();
                            }, function (err) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        } else if (type === "action") {

                            BTActionsService.upPublishBTAction(entity._id).then(function (res) {
                                NotificationService.alertNotify(i18n.i18nString('bt_streams_unpublish_label'), i18n.i18nString('bt_streams_action_task_has_been_unpublished'), "success");
                                $route.reload();
                            }, function (err) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        } else if (type === "flowtask") {
                            BTFlowtaskService.unpublishFlowtask($workflowService.selectedStream()._id, entity._id).then(function (res) {
                                NotificationService.alertNotify(i18n.i18nString('bt_streams_unpublish_label'), i18n.i18nString('bt_streams_dialog_task_has_been_unpublished'), "success");
                                $route.reload();
                            }, function (err) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        }
                    }
                    var entityType = (type === 'action') ? $scope._constants_.action : 'alert';
                    NotificationService.alert(i18n.i18nString('bt_streams_unpublish_task_from_marketplace'), unpublishWF, { okText: i18n.i18nString('continue'), cancelText: i18n.i18nString('cancel') });

                };

                $scope.cloneWorkflow = function (entity, type) {
                    if (type === "alert") {
                        BTAlertsService.cloneBTAlert(entity._id).then(function (res) {
                            $route.reload();
                        }, function (err) {
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    } else if (type === "action") {
                        BTActionsService.cloneBTAction(entity._id).then(function (res) {
                            $route.reload();
                        }, function (err) {
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }
                };

                $scope.workflowHistory = function (entity, type) {
                    $scope.dialogMode = 'version';
                    openModalDialog(entity, type);
                };

                function openModalDialog(entity, type) {
                    $scope.activeTask = entity;
                    $scope.activeTask.taskType = type;
                    openModalByClass('.version-form');
                }
                $scope.upgradeWorkflow = function (entity, type) {
                    loader = NotificationService.loader(i18n.i18nString('please_wait_noty'));
                    if (type === "alert") {
                        BTAlertsService.upgradeBTAlert(entity._id).then(function (res) {
                            BTAlertsService.upgradeMPAlert(entity._id, res.data._id).then(function (res) {
                                $scope.editWorkflow(res.data, type, true);
                                //$route.reload();
                                loader();
                                getMappings($workflowService.selectedStream()._id);
                                getAlertDialogMappings($workflowService.selectedStream()._id);
                            }, function (err) {
                                loader();
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        }, function (err) {
                            loader();
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    } else if (type === "action") {
                        BTActionsService.upgradeBTAction(entity._id).then(function (res) {
                            BTActionsService.upgradeMPAction(entity._id, res.data._id).then(function (res) {
                                $scope.editWorkflow(res.data, type, true);
                                //$route.reload();
                                loader();
                                getMappings($workflowService.selectedStream()._id);
                                getAlertDialogMappings($workflowService.selectedStream()._id);
                            }, function (err) {
                                loader();
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        }, function (err) {
                            loader();
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    } else if (type === "flowtask") {
                        BTFlowtaskService.upgradeFlowtask($workflowService.selectedStream()._id, entity._id).then(function (res) {
                            $scope.editWorkflow(res.data, 'flowtaskEdit', true);
                            loader();
                        }, function (err) {
                            loader();
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }
                };

                $scope.trainBot = function () {
                    BTStreamsService.trainFaq($workflowService.selectedStream()._id)
                        .then(function (res) {

                            //NotificationService.notify("Knowledge task trained successfully", "info");
                        },
                        function (err) {
                            // if (err.data.errors.length > 0) {
                            //   //  NotificationService.notify(err.data.errors[0].msg, "error");
                            // } else {
                            //     //NotificationService.notify("Problem in training knowledge task", "error");
                            // }
                        });
                };

                $scope.deleteWorkflow = function (entity, type) {

                    var entityType = (type === 'action') ? (entity.isReport ? $scope._constants_.report : $scope._constants_.action) : (type === 'flowtask') ? 'Dialog Task' : 'Alert';
                    entityType = (type === "knowledgeTask") ? $scope._constants_.knowledge : entityType;

                    NotificationService.alert('Do you really want to delete this ' + entityType, deleteWorkflow, arguments);

                };

                function deleteWorkflow(entity, type) {

                    var entityType = (type === 'action') ? (entity.isReport ? $scope._constants_.report : $scope._constants_.action) : (type === 'flowtask') ? 'Dialog Task' : 'Alert';
                    entityType = (type === "knowledgeTask") ? $scope._constants_.knowledge : entityType;
                    if (type === "alert") {
                        $q.all([BTAlertsService.deleteBTAlert(entity._id)])
                            .then(function (res) {
                                NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('alerttask_delete'), "success");
                                getAlerts($workflowService.selectedStream()._id);
                                getMappings($workflowService.selectedStream()._id);
                                // $route.reload();
                            }, function (err) {
                                NotificationService.alertNotify(i18n.i18nString('delete_failure'), err.data.errors[0].msg, "error");
                            });
                    } else if (type === "action") {
                        $q.all([BTActionsService.deleteBTAction(entity._id)])
                            .then(function (res) {
                                NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('delete_entitytype',{dyn: entityType}), "success");
                                getActions($workflowService.selectedStream()._id);
                                getMappings($workflowService.selectedStream()._id);
                                // $route.reload();
                            }, function (err) {
                                NotificationService.alertNotify(i18n.i18nString('delete_failure'), err.data.errors[0].msg, "error");
                            });
                    } else if (type === "knowledgeTask") {
                        $q.all([BTStreamsService.deleteKnowledgeTask($applicationService.userInfo().userId, entity._id)])
                            .then(function (res) {
                                NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('delete_entitytype',{dyn: entityType}), "success");
                                $scope.trainBot();
                                getKnowledgeTasks($workflowService.selectedStream()._id);
                            }, function (err) {
                                NotificationService.alertNotify(i18n.i18nString('delete_failure'), err.data.errors[0].msg, "error");
                            });
                    } else if (type === "flowtask") {
                        $q.all([BTFlowtaskService.deleteFlowtask($workflowService.selectedStream()._id, entity._id)])
                            .then(function (res) {
                                NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('delete_entitytype',{dyn: entityType}), "success");
                                getFlowTasks($workflowService.selectedStream()._id);
                            }, function (err) {
                                NotificationService.alertNotify(i18n.i18nString('delete_failure'), err.data.errors[0].msg, "error");
                            });
                    }
                }

                $scope.publishWorkflow = function (entity, type) {
                    $workflowService.publishEntity({
                        entity: entity,
                        type: type
                    });
                    $location.path('bt/' + type + '/' + entity._id + '/publish');
                };

                $scope.command = {
                    context: {},
                    data: {}
                };

                $scope.manageCommands = function (action) {
                    $scope.command.context = {
                        actionId: action._id,
                        streamId: action.streamId,
                        show: {
                            _createSlash: true
                        },
                        hidecheckbox: true
                    };
                    $scope.command.data = {};
                    $scope.enableCommands = true;
                    $timeout(function () {
                        openModalByClass('.slashcommands');
                        ($scope.command.context.getSlashCommands || angular.noop)();
                    });
                };

                $scope.exitCommand = function () {
                    closeModalByClass('.slashcommands');
                    $timeout(function () {
                        $scope.enableCommands = false;
                    }, 100);
                };

                $scope.saveCommand = function (isValid, form) {

                    if (!isValid) {
                        form_util.touch(form);
                        return;
                    }

                    $scope.command.saving = true;
                    var errorMsg = i18n.i18nString('bt_cmnd_delete_failed');

                    if ($scope.command.context.createSlashCommand) {
                        $scope.command.context.createSlashCommand()
                            .then(function (res) {
                                NotificationService.notify(i18n.i18nString('cmd_Save_success'), 'success');
                                $scope.command.saving = false;
                                $scope.exitCommand();
                            }, function (err) {
                                var error = (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || errorMsg;
                                NotificationService.notify(error, 'error');
                                $scope.command.saving = false;
                            });
                    }

                };

                $scope.setCurrentTab = function (tabId) {
                    $(".myTabs").scrollTop(0);
                    $scope.displayTabId = "";
                    if ($scope.showSolutionBotSetup && $scope.selectedStream.sbStreamId) {
                        return;
                    }
                    $scope.navigateTabIndex = tabId;
                    $(tabId).addClass("active").siblings().removeClass("active");
                    if (tabId === ".settings-pane") {
                        $scope.showSettingsPane = true;
                    } else {
                        $scope.showSettingsPane = false;
                    }

                    $workflowService.navigateTabIndex(tabId);
                    $(".panel-heading").addClass("collapsed");
                    $('.panel-collapse.in').collapse('hide');
                    if (tabId === ".tasks-pane") {
                        openDialogTaskAccordion();
                    }
                    $scope.defaultDialogExpanded=false;                    
                };
                
                $scope.$watch('navigateTabIndex', function (nv, ov) {
                    if (nv === '.tasks-pane') {
                        $('body').removeAttr('non-tasks-pane-active');
                    } else {
                        $('body').attr('non-tasks-pane-active',true);
                    }

                });

                $scope.deleteCommand = function () {

                    $scope.command.deleting = true;
                    var errorMsg = i18n.i18nString('bt_cmnd_delete_failed');

                    if ($scope.command.context.deleteCommand) {
                        $scope.command.context.deleteCommand()
                            .then(function (res) {
                                NotificationService.notify(i18n.i18nString('bot_cmnd_deleted_Successfully'), 'success');
                                $scope.command.deleting = false;
                                $scope.exitCommand();
                            }, function (err) {
                                var error = (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || errorMsg;
                                NotificationService.notify(error, 'error');
                                $scope.command.deleting = false;
                            });
                    }


                };

                $scope.goToStreams = function () {
                    $location.path(window.appConfig.CONTEXT_PATH + '/streamnew');
                };

                function notifyError(errorResponse) {
                    if (errorResponse.data.errors) {
                        NotificationService.notify(errorResponse.data.errors[0].msg, 'error');
                    }
                }

                $scope.publishMapping = function (mapping, index) {
                    if (mapping.mapId) {
                        BTStreamsService.publishFlow(mapping.mapId)
                            .then(function (res) {
                                getMappings($workflowService.selectedStream()._id);
                                getAlertDialogMappings($workflowService.selectedStream()._id);
                                NotificationService.notify(i18n.i18nString('flow_publish'), 'success');
                            }, function (err) {
                                console.log(err);
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                            });
                    }
                    else {
                        BTStreamsService.publishAlertDialogFlow(mapping._id)
                            .then(function (res) {
                                getMappings($workflowService.selectedStream()._id);
                                getAlertDialogMappings($workflowService.selectedStream()._id);
                                NotificationService.notify(i18n.i18nString('flow_publish'), 'success');
                            }, function (err) {
                                console.log(err);
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                            });
                    }
                };

                $scope.mapWorkflows = function (entity, type) {
                    $scope.showMapping = true;
                    $scope.activeEntityFlow = angular.copy(entity);
                    $scope.activeEntityFlow.taskType = type;
                    openModalByClass('.flowtask-create-form');
                    //   $location.path('bt/' + type + '/' + entity._id + '/map/new');
                };
                
                var closeMappingWorkflow = $scope.$on('closeMappingWorkflowEvent', function(event){
                    $scope.showMapping = false;
                });

                $scope.newMapping = function () {
                    $location.path('bt/alert/new/map/new');
                };

                $scope.editMapping = function (entity, type, id) {
                    if (entity.mapId) {
                        entity._id = entity.mapId;
                        entity.name = entity.alertName + " " + entity.actionName;
                    }
                    else {// for dialog flow mapping
                        entity._id = entity._id;
                        entity.name = entity.sourceResourceName + " " + entity.targetResourceName;
                    }

                    $scope.lockTask(entity, prepareTimer)
                        .then(function () {
                            $scope.activeEntityFlow = entity;
                            entity.taskType = "flows";
                            //openModalByClass('.flowtask-create-form');
                            $workflowService.taskEditInfo(entity);
                            $workflowService.taskMode("edit");
                            $timeout(function () {
                                $rootScope.$emit("updateEditTask", true);
                            });

                            $scope.openFullPageModal(3);
                        }, function (err) {

                        });

                };

                $scope.deleteMapping = function (entity, index) {
                    NotificationService.alert(i18n.i18nString('flow_delete'), deleteMapping, arguments);
                };

                function deleteMapping(entity, index) {
                    if (entity.mapId) {
                        BTParamMapService.deleteMappedAlertAction(entity.mapId).then(function (res) {
                            NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('flow_deleted_sucess'), "success");
                            $scope.mappings.splice(index, 1);
                            if (entity.parentOf || entity.parentMapId) {
                                $route.reload();
                            }
                        }, function (err) {
                            NotificationService.alertNotify(i18n.i18nString('delete_failure'), i18n.i18nString('flow_deletion_failed'), "error");
                        });
                    }
                    else {
                        BTParamMapService.deleteMappedAlertDialog(entity._id).then(function (res) {
                            NotificationService.alertNotify(i18n.i18nString('deleted_label_exclamation'), i18n.i18nString('flow_deleted_sucess'), "success");
                            $scope.mappings.splice(index, 1);
                            if (entity.parentOf || entity.parentMapId) {
                                $route.reload();
                            }
                        }, function (err) {
                            NotificationService.alertNotify(i18n.i18nString('delete_failure'), i18n.i18nString('flow_deletion_failed'), "error");
                        });
                    }
                }

                function appendCategory(stream) {
                    var i, j, k;
                    stream.categoryname = [];
                    if (stream.categoryIds) {
                        for (j = 0; j < stream.categoryIds.length; j++) {
                            for (i = 0; i < $scope.categories.length; i++) {
                                if (stream.categoryIds[j] === $scope.categories[i]._id) {
                                    stream.categoryname.push($scope.categories[i].name);
                                }
                                var subC = $scope.categories[i].subCategories;
                                if (subC && subC.length) {
                                    for (k = 0; k < subC.length; k++) {
                                        if (stream.categoryIds[j] === subC[k]._id) {
                                            stream.categoryname.push(subC[k].name);
                                        }
                                    }
                                }
                            }
                        }
                        stream.categoryname = stream.categoryname.map(function (category, index) {
                            if (index !== 0) {
                                return ' ' + category;
                            } else {
                                return category;
                            }
                        });
                        stream.categoryname = stream.categoryname.join(',');
                    } else {
                        stream.categoryname = '';
                    }

                }

                function getStreamIndex(id) {
                    for (var i = 0; i < $scope.streams.length; i++) {
                        if ($scope.streams[i]._id === id) {
                            return i;
                        }
                    }
                    return -1;
                }

                $scope.gotostreams = function () {
                    $location.path(window.appConfig.CONTEXT_PATH);
                };

                $timeout(function () {
                    if ($scope.slashCommandsForm) {
                        $scope.slashCommandsForm._createSlash = true;
                    }
                });

                $scope.goToChatSettings = function () {
                    $workflowService.nlpText('');
                    $scope.verifyNlp();
                };

                $scope.navigateToPage = function (pageId) {
                    // fix for minimise sdk
                    if($('.kore-chat-window') && $('.kore-chat-window').length && !$('.kore-chat-window').hasClass('minimize')) {
                        $('.kore-chat-window .minimize-btn').trigger('click');
                    }
                    switch (pageId) {
                        case 0:
                            //$location.path("/bt/utterances/" + $scope.selectedStream._id);
                            $scope.showUtterances();
                            break;
                        case 1:
                            $workflowService.nlpText('');
                            $workflowService.nlpStream($scope.selectedStream);
                            //$location.path(window.appConfig.CONTEXT_PATH+"/synonyms/" + $scope.selectedStream._id);
                            openModalByClass('.wf-form');
                            break;
                        case 2:
                            $workflowService.nlpText('');
                            $workflowService.nlpStream($scope.selectedStream);
                            $location.path(window.appConfig.CONTEXT_PATH + "/patterns/" + $scope.selectedStream._id);
                            break;
                        case 3:
                            openModalByClass('.standard-responses-form');
                            break;
                         case 4:
                            //$location.path("/bt/utterances/" + $scope.selectedStream._id);
                            $scope.showBatchTesting();
                            break;
                    }
                };
                $scope.richEditorCallbacks = {
                    onKeyDown: function onKeyDown(event) {
                        if (event.keyCode == 13 && event.type == 'keydown') {
                            $timeout(function () {
                                $workflowService.nlpText($scope.nlp.testText);
                                $scope.verifyNlp();
                            });
                        }
                    }
                };

                function checkForChannels(callback) {
                    var _channels=[];
                    _channels = _.filter($scope.selectedStream.channels, function(channelObject){
                        return channelObject.enable;
                    });
                    
                    var msg = i18n.i18nString('bot_usage_desc');
                    if (!(_.isArray(_channels) && _channels.length > 0)) {
                        NotificationService.notify(msg, 'warning');
                    } else {
                        callback();
                    }
                }

                $workflowService.reigisterModalShownEvent();

                $scope.manageBot = function manageBot() {
                    $workflowService.selectedStream($scope.selectedStream);
                    $location.path(window.appConfig.CONTEXT_PATH + '/bot/share');
                };

                $scope.$watch("streams", function () {
                    if ($scope.streams && $scope.streams.length > 0) {
                        $("body").removeClass("hidebodyscroll");
                    } else {
                        $("body").addClass("hidebodyscroll");

                    }
                });

                $scope.showCantPublishWarning = function(){
                    NotificationService.confirmDialog(i18n.i18nString('show_publish_warning'), function(){}, {okText:i18n.i18nString('ok'), noCancelBtn:true});
                };


                $scope.isPublicBot = function(){
                    var streamData = $workflowService.selectedStream();
                    return (streamData.visibility && streamData.visibility.namespace === "public" && $rootScope.isManaged && !$rootScope.wfAdmin);
                };

                $scope.publishStandardBot = function publishStandardBot() {

               

                    if($scope.isPublicBot()){
                        $scope.showCantPublishWarning();
                        return;
                    }
                    
                    checkForChannels(triggerPublish);

                    function triggerPublish() {
                        $scope.publishBot = true;
                        $workflowService.selectedStream().publishType = "standardbot";
                        openModalByClass('.bot-publish-form');

                    }

                };

                $scope.linkBots = function (className) {

                    if (!$workflowService.linkableBots) {
                        NotificationService.notify(i18n.i18nString('bt_streams_no_linkablebots',{dyn: $scope.selectedStream.purpose}), 'warning');
                    } else {
                        openModalByClass(className);
                    }
                    $scope.$broadcast('updateLinkableBots');

                };


                $scope.onCloseBotPublishDialog = function onCloseBotPublishDialog(mode) {
                    closeModalByClass('.bot-publish-form');
                    $scope.publishBot = false;
                    if (mode) {
                        load();
                    }
                };



                $scope.publishSmartBot = function publishSmartBot() {

                    if($scope.isPublicBot()){
                        $scope.showCantPublishWarning();
                        return;
                    }

                    checkForChannels(triggerPublish);

                    function triggerPublish() {
                        $('.panel-collapse.in').collapse('hide');
                        $('.panel-heading').addClass("collapsed");
                        $scope.publishBot = true;
                        $workflowService.selectedStream().publishType = "smartbot";
                        openModalByClass('.bot-publish-form');
                    }

                };

                $scope.publishSampleBot = function publishSampleBot() {
                    checkForChannels(triggerPublish);

                    function triggerPublish() {
                        $('.panel-collapse.in').collapse('hide');
                        $('.panel-heading').addClass("collapsed");
                        $scope.publishBot = true;
                        $workflowService.selectedStream().publishType = "samplebot";
                        openModalByClass('.bot-publish-form');
                    }

                };

                $scope.linkOrUnlinkBot = function (botId) {
                    var payLoad = {
                        bots: [botId]
                    };
                    BTStreamsService.linkOrUnlinkBots($scope.selectedStream._id, 'unlink', payLoad).then(function () {
                        load();
                    }, function (err) {

                    });
                };

                $scope.options={
                    mode:'view',
                    ace:window.ace
                };

               function scriptDefinition (contextData) {
                    var contextCopy = angular.copy(contextData);
                    var code = contextData.contextData.code.body;
                    $scope.scriptObj= code.trim().substring(2, code.length-2);
                    $scope.error = contextData.error.message + " at " + (contextData.error.lineno - 9) + ":" + contextData.error.colno;
                    $scope.scriptNodeErrorHelp = "We could not successfully execute the " + ($scope.scriptNodeName || "") + " script node as the platform found errors as described above. Your current task is discarded. You can rerun the script by modifying the script here and also save the revised script to the script node.";
                    delete contextCopy.contextData.contextForResolution.scriptErrorMeta;
                    $scope.contextObject = contextCopy.contextData.contextForResolution;
                    scriptNodeEditorModal = true;
                    $('debug-console-panel .fa.fa-window-minimize.toggleMinMax').click();
                    openModalByClass('.script-node-edit-form');
                    // $timeout(function(){ $scope.updatePerfectScrollbar($(".modalPerfectScroll"));});
                    // $(".modalPerfectScroll").scrollTop(0);
                }

                $scope.saveScript = function () {
                    if ($scope.invalidScript) {
                        NotificationService.notify(i18n.i18nString('save_script'), 'error');
                        return;
                    }
                         $scope.saveInProgress = true;
                        BTFlowtaskService.getComponents($scope.contextData.botInfo.taskBotId, $scope.contextData.context.scriptErrorMeta.componentId).then(function (res) {
                            var _component = res && res.data;
                            var _payload = {};
                            
                            if ($scope.contextData.context.scriptErrorMeta.messageTemplateId) {
                                var _scriptPosition='message';
                                if($scope.contextData.context.scriptErrorMeta.msgTemplateIdType==='error'){
                                    _scriptPosition='errorMessage';
                                }
                                var _channel = _.find(_component[_scriptPosition], {_id: $scope.contextData.context.scriptErrorMeta.messageTemplateId});
                                _channel.text = encodeJS($scope.scriptObj);
                                _payload[_scriptPosition] = _component[_scriptPosition];
                                _payload[_scriptPosition]=_payload[_scriptPosition].map(function (channel) {
                                    return {
                                        channel: channel.channel,
                                        text: channel.text,
                                        type: channel.type,
                                        _id: channel._id
                                    };
                                });
                                //_payload.name=_component.name;
                            } else {
                                _payload.script = encodeJS($scope.scriptObj);
                            }
                             
                            
                            saveToServer(_payload);
                            $scope.contextData = undefined;
//                                 
                        },
                                function (error) {
                                     $scope.saveInProgress = false;
                                    if (error && error.data && error.data.errors) {
                                        var _msg = error.data.errors[0].msg;
                                        NotificationService.notify(_msg, 'error');
                                    } else if (error.errors && _.isArray(error)) {
                                        var msg = error.errors[0].msg;
                                        NotificationService.notify(msg, 'error');
                                    } else {
                                        NotificationService.notify(i18n.i18nString('error_handle'), 'error');
                                    }
                                });

                };
                function encodeJS(_obj) {
                    return encodeURIComponent(_obj);
                }
                function decodeJS(_obj) {
                    return decodeURIComponent(_obj);
                }
                
                $scope.closeModal = function () {
                    $scope.contextData = undefined;
                    scriptNodeEditorModal = false;
                    closeModalByClass('.script-node-edit-form');
                };

                function saveToServer(_payload) {
                    $scope.saveInProgress = true;
                    var _streamId = $scope.contextData.botInfo.taskBotId,
                            _componentId = $scope.contextData.context.scriptErrorMeta.componentId;


                    BTFlowtaskService.updateComponent(_streamId, _componentId, _payload).then(function (res) {
                        if (res && res.data) {
                            BTFlowtaskService.getComponents(_streamId, _componentId).then(function (res) {
                                if (res && res.data) {
                                    $rootScope.$broadcast('update node info', res.data);
                                    $scope.closeModal();
                                }
                            });

                        }
                        $scope.saveInProgress = false;
                    }, function (error) {
                        if (error && error.data && error.data.errors) {
                            var _msg = error.data.errors[0].msg;
                            NotificationService.notify(_msg, 'error');
                        } else if (error.errors && _.isArray(error)) {
                            var msg = error.errors[0].msg;
                            NotificationService.notify(msg, 'error');
                        } else {
                            NotificationService.notify(i18n.i18nString('save_script_error'), 'error');
                        }
                        $scope.saveInProgress = false;
                    });
                }

                $scope.validateJs = function (contextData) {
                    var showToast = true;
                    if(!$scope._constants_.config.showScriptNodeError){
                        return;
                    }

                    if(!contextData){
                        $scope.contextData.context.scriptErrorMeta.codeToBeRes.body = "<%" + $scope.scriptObj + "%>";
                    } else {
                        showToast = false;
                        $scope.contextData = angular.copy(contextData);
                    }
                    var data = {};
                    $scope.scriptNodeName = $scope.contextData.context.scriptErrorMeta.componentName;
                                        $scope.errNodeType = $scope.contextData.context.scriptErrorMeta.componentType;
                    if($scope.contextData.context){
                        data.contextForResolution = $scope.contextData.context;
                    }

                    if($scope.contextData.context && $scope.contextData.context.scriptErrorMeta && $scope.contextData.context.scriptErrorMeta.contextForRes.dateTimeFields){
                        data.dateTimeFields = $scope.contextData.context.scriptErrorMeta.contextForRes.dateTimeFields;
                    }

                    if($scope.contextData.context.scriptErrorMeta){
                        data.code = $scope.contextData.context.scriptErrorMeta.codeToBeRes;
                    }

                    (function (data){
                        jsValidator.getError(data)
                        .then(function (res){
                            $scope.showError = false;
                            NotificationService.notify(i18n.i18nString('script_success'), "success");                            
                        }, function (err){
                            $scope.showError = true;
                            if(showToast){
                                NotificationService.notify(i18n.i18nString('script_error'), "error");                            
                            }
                            scriptDefinition({contextData: data, error: err});
                        });
                    }(data));
                };

                $scope.aceEditorCallback.onBlur = function (editor) {
                    if (_.filter(editor.getSession().getAnnotations(), {type: 'error'}).length) {
                        $scope.invalidScript = true;
                    } else {
                        $scope.invalidScript = false;                    
                    }
                };

                $(document).on('show.bs.modal', '.modal', function (event) {
                    if(scriptNodeEditorModal){
                        var zIndex = 1040 + (10 * $('.modal:visible').length);
                        $(this).css('z-index', zIndex);
                        setTimeout(function() {
                            $('.modal-backdrop').not('.modal-stack').css('z-index', zIndex - 1).addClass('modal-stack');
                        }, 0);
                    }
                });

                $rootScope.$on('validate script', function (e, data){$scope.validateJs(data);});
                $scope.botExportCB = function(){
                    
                };
                $scope.exporBot = function () {
                    $modal.open({
                        templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-export/bt-exportBot.html',
                        controller: 'BTExportBotCtrl',
                        backdrop: 'static',
                        windowClass: 'bt-dialog-exportBot modal-kr',
                        resolve: {
                            config: function () {
                                return {
                                    botExportCB: $scope.botExportCB

                                };
                            }
                        }
                    });
                };
                
                $scope.changeBotLanguage = function (language, reload) {
                    $scope.currentLanguage = language;
                    $workflowService.currentLanguage(language);
                    if(reload){
                        // $scope.selectApp($scope.selectedStream, true);
                        $rootScope.$broadcast("triggerSelectApp", true);
                    }
                };

                function mapSupportedLanguages () {
                    var seedData = $workflowService.seedData();                    
                    return _.compact(_.map(seedData.nluSupportedLanguages, function (lang){
                        if(_.indexOf($scope.selectedStream.nluSupportedLanguages, lang.value) !== -1){
                            return lang;
                        }
                    }));
                }
                
            }]);

})(angular);


;(function (ng) {
    'use strict';
    var _module = ng.module('bt-kore-components');
    _module.directive('btSummary', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-summary/bt-summary.html',
            controller: 'botSummaryController'
        };
    });
    _module.controller("botSummaryController", ['$scope', '$window', '$workflowService', '$element', '$location', '_constants_', 'BTStreamsService', '$timeout', '$routeParams', 'NotificationService', '$modal', 'env_conf', '$q', 'BTSeedDataService', '$filter', 'BTIdpService', '$translator', '$rootScope', '$applicationService', '$endpoints','channelsConfig','BTFlowtaskService','i18n',
        function ($scope, $window, $workflowService, $element, $location, _constants_, BTStreamsService, $timeout, $routeParams, NotificationService, $modal, env_conf, $q, BTSeedDataService, $filter, BTIdpService, $translator, $rootScope, $applicationService, $endpoints,channelsConfig,BTFlowtaskService,i18n) {
            
         $scope.$emit('homeDirectivesLoaded');
         var grid;
         $scope.allinterruptions_error = i18n.i18nString('allinterruptions_error');
         $scope.enable_label = i18n.i18nString('enabled');
         $scope.notEnable_label = i18n.i18nString('not_enabled');
         $scope.apiFailed=false;
         $scope.showlanguageCount = 3;
         $scope.botState = $scope.botDetails.streamState=='indevelopment'?"configured":"published";
         $scope.fetchingSummary = true; 
         $scope.kgTotalCount = 0;
         $scope.upgradeUniProgress = 'initial';
         $scope.selectedStream = $workflowService.selectedStream();
         $scope.license = {};
         $scope.supportPlan = {};
         $scope.universalLink = 'https://developer.kore.ai/docs/bots/advanced-topics/universal-bot/universal-bots/#ub2.0';
         $scope.builderState = $workflowService.builderResumeState();
         channelsConfig.getDynamicChannels($workflowService.selectedStream());
         $scope.notificationEnabled = false;
         $scope.planValidationDetails = {};
         $scope.planValHeaders = {};
         $scope.planSelection = false;
         $scope.planSelectionCb = {};
         $scope.enterpriseLicenseType = $workflowService.selectedStream().purpose;
         $scope.selectedAccount = $workflowService.selectedAccount();
         $scope.showAllLang = function (params) {
             $scope.manageLanguage();
            // $scope.showlanguageCount = $scope.languages.length;
         };
         function preparePermissions(){
            $scope.permissions= {
                'botTasks':{
                    permissionId:'BOTBUILDER_TASKS',
                    dependentPermissions:['BOTBUILDER_KNOWLEDGE_GRAPH'],
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_TASKS'][0]=='NO'?$scope.summary.botInfo.permissions['BOTBUILDER_KNOWLEDGE_GRAPH'][0]:$scope.summary.botInfo.permissions['BOTBUILDER_TASKS'][0]
                },
                'linkedBots':{
                    permissionId:'BOTBUILDER_TASKS',
                    permission: $scope.summary.botInfo.permissions['BOTBUILDER_TASKS']?$scope.summary.botInfo.permissions['BOTBUILDER_TASKS'][0]:"FULL"
                },
                'smallTalk': {
                    permissionId: 'BOTBUILDER_TASKS',
                    permission: $scope.summary.botInfo.permissions['BOTBUILDER_TASKS']?$scope.summary.botInfo.permissions['BOTBUILDER_TASKS'][0]:"FULL"
                },
                'training':{
                    permissionId:'BOTBUILDER_NATURAL_LANGUAGE',
                    permission: $scope.summary.botInfo.permissions['BOTBUILDER_NATURAL_LANGUAGE']?$scope.summary.botInfo.permissions['BOTBUILDER_NATURAL_LANGUAGE'][0]:"FULL"        
                  },
                'intelligence':{
                    permissionId:'BOTBUILDER_NATURAL_LANGUAGE',
                    permission: $scope.summary.botInfo.permissions['BOTBUILDER_NATURAL_LANGUAGE'][0]!=='NO'?$scope.summary.botInfo.permissions['BOTBUILDER_NATURAL_LANGUAGE'][0]:$scope.summary.botInfo.permissions['BOTBUILDER_BOT_SETTINGS'][0]
                },
                'defaultConversation':{
                    permissionId:'BOTBUILDER_NATURAL_LANGUAGE',
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_NATURAL_LANGUAGE'][0]!=='NO'?$scope.summary.botInfo.permissions['BOTBUILDER_NATURAL_LANGUAGE'][0]:$scope.summary.botInfo.permissions['BOTBUILDER_EXTENSIONS'][0]
                },
                'batchTesting':{
                    permissionId:'BOTBUILDER_BATCH_TESTING',
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_BATCH_TESTING']?$scope.summary.botInfo.permissions['BOTBUILDER_BATCH_TESTING'][0]:"FULL"
                },
                'testTrain':{
                    permissionId:'FULL',
                    permission:'FULL'
                },
                'channels':{
                    permissionId:'BOTBUILDER_CHANNELS',
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_CHANNELS']?$scope.summary.botInfo.permissions['BOTBUILDER_CHANNELS'][0]:"FULL"
                },
                'agents':{
                    permissionId:'BOTBUILDER_APPS_AND_SCOPES',
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_APPS_AND_SCOPES']?$scope.summary.botInfo.permissions['BOTBUILDER_APPS_AND_SCOPES'][0]:"FULL"
                },
                'publish':{
                    permissionId:'BOTBUILDER_PUBLISH_BOT',
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_PUBLISH_BOT']?$scope.summary.botInfo.permissions['BOTBUILDER_PUBLISH_BOT'][0]:"FULL"
                },
                'analyze':{
                    permissionId:'BOTBUILDER_BOT_ANALYTICS',
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_BOT_ANALYTICS']?$scope.summary.botInfo.permissions['BOTBUILDER_BOT_ANALYTICS'][0]:"FULL"
                },
                'configurations':{
                    permissionId:'BOTBUILDER_BOT_SETTINGS',
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_BOT_SETTINGS']?$scope.summary.botInfo.permissions['BOTBUILDER_BOT_SETTINGS'][0]:"FULL"
                },
                'management':{
                    permissionId:'BOTBUILDER_BOT_SETTINGS',
                    dependentPermissions:['BOTBUILDER_BOT_DEVELOPERS','BOTBUILDER_BOT_IMPORT'],
                    permission:$scope.summary.botInfo.permissions['BOTBUILDER_BOT_SETTINGS'][0]=='NO'?($scope.summary.botInfo.permissions['BOTBUILDER_BOT_DEVELOPERS'][0]=='NO'?$scope.summary.botInfo.permissions['BOTBUILDER_BOT_IMPORT'][0]:$scope.summary.botInfo.permissions['BOTBUILDER_BOT_DEVELOPERS'][0]):$scope.summary.botInfo.permissions['BOTBUILDER_BOT_SETTINGS'][0]
                },
    
               };
              
               $timeout(function(){
                try {
                    gridInit(); // Init grid layout
                    $timeout(function(){
                    // $(window).resize();
                    grid.refreshItems();
                    $scope.fetchingSummary = false;
                    //$('.tasksDiv').addClass('zindex2');
                    },1000);
                } catch (e) {
                    console.log('Muri Load terinated');
                }
               },300);
            }

            function gridInit() {
                grid = new Muuri(".grid",{
                    dragEnabled: false,
                    layout: {
                        fillGaps: true,
                        horizontal: false,
                        alignRight: false,
                        alignBottom: false,
                        rounding: true,
                      },
                      showDuration: 0
                  });
            }
            $scope.searchGreen=function(e){
                $(e.currentTarget.parentElement).toggleClass('expand');
    
            };
            function checkActiveTypePermisions(activeType,innerRightViewElement){
                if($scope.permissions[activeType].permission=='NO'){
                    return false;
                }else{
                    if(innerRightViewElement=='importBot'){
                       return $scope.summary.botInfo.permissions['BOTBUILDER_BOT_IMPORT'][0]!=='NO';
                    }
                    if(innerRightViewElement=='developerShare'){
                        return $scope.summary.botInfo.permissions['BOTBUILDER_BOT_DEVELOPERS'][0]!=='NO';
                     }
                     if(innerRightViewElement=='knowledgeCollection'){
                        return $scope.summary.botInfo.permissions['BOTBUILDER_KNOWLEDGE_GRAPH'][0]!=='NO';
                     }
                     if(innerRightViewElement=='eventsManage'){
                        return $scope.summary.botInfo.permissions['BOTBUILDER_EXTENSIONS'][0]!=='NO';
                     }
                     if(innerRightViewElement=='advancedSettings'){
                        return $scope.summary.botInfo.permissions['BOTBUILDER_BOT_SETTINGS'][0]!=='NO';
                     }
                    return true;
                }
            }
    
    
        // permissions session ends here....................................................................................................................//  
        

        // Task data preparation...........................................................................................................................//
        $scope.channelsConfig=  channelsConfig;
            $scope.getTaskType={
                flowTask: i18n.i18nString('bt_task_chooser_dialog_label'),
                dialog:i18n.i18nString('bt_task_chooser_dialog_label'),
                alert:i18n.i18nString('alert'),
                action:i18n.i18nString('action_label')
            };
            $scope.botEventsKey={
                //keys//
                WELCOME_MESSAGE_EVENT:i18n.i18nString('welcome_event'),
                TASK_FAILURE_EVENT:i18n.i18nString('task_failure'),
                ON_CONNECT_EVENT:i18n.i18nString('on_connect'),
                FB_WELCOME_EVENT:i18n.i18nString('fb_welcome'),
                TELEGRAM_WELCOME_EVENT:i18n.i18nString('telegram_event'),
                CONVERSATION_END:i18n.i18nString('end_conversation'),
                TELEPHONY_WELCOME_EVENT:i18n.i18nString('telephony_welcome_ev'),
                RCS_OPTOUT_EVENT:i18n.i18nString('RCS_Opt_Out_Event'),
                RCS_OPTIN_EVENT:i18n.i18nString('RCS_Opt_In_Event'),
                INTENT_UNIDENTIFIED:i18n.i18nString('intent_identified'),
                //end of keys//

                //values//
                showMsg:i18n.i18nString('show_msg'),
                triggerDialog:i18n.i18nString('trigger_dialog'),
                runScript:i18n.i18nString('run_script'),
                voiceProp:i18n.i18nString('ivr_properties_normal')
                //end of values//
            };
          function prepareTaskData(taskData){
            $scope.allTasksSummary=[];
            $scope.dialogSummary=[];
            $scope.actionsSummary=[];
            // $scope.actionsSummary=[];
            $scope.alertsSummary=[];
            $scope.knowledgeSummary=[];
            $scope.smallTalks = [];
            var botState = $scope.botDetails.streamState || $workflowService.selectedStreamState();
            var states = ['configured','awaitingApproval','rejected'];
            if(botState=="indevelopment"){
                botState = 'configured';  
                states = ['configured','awaitingApproval','rejected'];
            } else {
                states = ['published','suspended'];
            }
            // // $.each(taskData.tasks[botState].items,function(i, tasK){

            // // });
            // $scope.dialogSummary= _.map(taskData.dialogs,function(dialog){
            //    dialog.taskType='flowTask';
            //    return dialog;
            // });
            // $scope.actionsSummary= _.map(taskData.actions,function(actions){
            //     actions.taskType='action';
            //     return actions;
            //  });
            //  $scope.alertsSummary= _.map(taskData.alerts,function(alerts){
            //     alerts.taskType='alert';
            //     return alerts;
            //  });
            states.forEach(function(state){
                if(taskData.tasks[state]){
                    $scope.allTasksSummary= $scope.allTasksSummary.concat(taskData.tasks[state].items);
                }
            });
            // if(taskData.tasks && taskData.tasks[botState]){
            //     $scope.allTasksSummary=taskData.tasks[botState].items;
            // }
            if(taskData.knowledgeTasks && taskData.knowledgeTasks[botState]) {
                var ind = 0;
                for(var key in taskData.knowledgeTasks[botState]) {
                    if(key) {
                        $scope.knowledgeSummary[ind] = {};
                        $scope.knowledgeSummary[ind].count = taskData.knowledgeTasks[botState][key];
                        $scope.kgTotalCount = $scope.kgTotalCount + $scope.knowledgeSummary[ind].count;
                        $scope.knowledgeSummary[ind].label = key;
                        ind++;
                    }
                }
            }
            if(taskData.smallTalkGroups[botState]) {
                $scope.smallTalks = _.cloneDeep(taskData.smallTalkGroups[botState]);
            }
            $timeout(function(){
                if(grid &&  grid.refreshItems){
                    grid.refreshItems();
                }
              },5000);
            $timeout(function(){
                if(grid &&  grid.refreshItems){
                    grid.refreshItems();
                }
                $scope.fetchingSummary = false; 
            },20000);// error handling due to async call if first api fails
             
          }

        // Task data preparation...........................................................................................................................//


        // Api calls session...............................................................................................................................//
        $scope.summary={};
        $scope.getBotTaskSummary= function (streamId) {
            BTStreamsService.botTasksSummary(streamId).then(function(res){
             $scope.summary.alltasksInfo = res.data;
            var forms = {
                 configured:{},
                 published:{}
             };
            var panels = {
                configured:{},
                published:{}
            };
            var widgets = {
                configured:{},
                published:{}
            };
             if(res.data.forms){
                $.each(res.data.forms,function(i,val){
                    if(val && val.configured) {
                        forms.configured = val.configured;
                    }
                    if(val && val.awaitingApproval) {
                        forms.configured.count = forms.configured.count + val.awaitingApproval.count;
                    }
                    if(val && val.rejected) {
                        forms.configured.count = forms.configured.count + val.rejected.count;
                    }
                    if(val && val.published)  {
                        forms.published = val.published;
                    }
                });
             }
             if(res.data.panels){
                $.each(res.data.panels,function(i,val){
                    if(val && val.configured) {
                        panels.configured = val.configured;
                    }
                    if(val && val.awaitingApproval) {
                        panels.configured.count = panels.configured.count + val.awaitingApproval.count;
                    }
                    if(val && val.rejected) {
                        panels.configured.count = panels.configured.count + val.rejected.count;
                    }
                    if(val && val.published)  {
                        panels.published = val.published;
                    }
                });
             }
             if(res.data.widgets){
                $.each(res.data.widgets,function(i,val){
                    if(val && val.configured) {
                        widgets.configured = val.configured;
                    }
                    if(val && val.awaitingApproval) {
                        widgets.configured.count = widgets.configured.count + val.awaitingApproval.count;
                    }
                    if(val && val.rejected) {
                        widgets.configured.count = widgets.configured.count + val.rejected.count;
                    }
                    if(val && val.published)  {
                        widgets.published = val.published;
                    }
                });
             }
             $scope.summary.alltasksInfo.forms=forms;
             $scope.summary.alltasksInfo.widgets=widgets;
             $scope.summary.alltasksInfo.panels=panels;
             prepareTaskData(res.data);
            });
        };
        $scope.getBotTaskSummary($scope.stream._id);
        $scope.getBotSummary= function (streamId) {
            BTStreamsService.botSummary(streamId).then(function(res){
                res.data.debugLogs = res.data.debugLogs || [];
                res.data.channels =res.data.channels || [];
                $.each(res.data.channels,function(i,channel){
                    channel.displayName = channel.displayName || ($scope.channelsConfig.channelsObject[channel.type]?$scope.channelsConfig.channelsObject[channel.type].name:channel.type);
                });
                $.each(res.data.debugLogs,function(key,value){
                     value.createdDate = new moment(value.createdOn).format('MM-DD-YYYY');
                     value.createdTime = new moment(value.createdOn).format('hh:mm:ss A');
                });
             $scope.summary.botInfo = res.data;
             var createdData = new moment(res.data.createdOn).format('Do MMMM YYYY');
             var createdTime = new moment(res.data.createdOn).format('hh:mm A');
             $scope.summary.created = createdData + ' ' +  createdTime;
            //  $workflowService.selectedStream(res.data);
            //  channelsConfig.getDynamicChannels(res.data);          
             $scope.botEvents=[];
             if(res.data.type=='universalbot'){
                $scope.publishedBots = res.data.publishedBots.filter(function (bot) {
                    if(!_.filter(res.data.unpublishedBots.concat(res.data.awaitingApprovalBots),{'_id':bot._id}).length){
                        return bot;
                    } 
                 });
                 $scope.summary.botInfo.configured = res.data.configuredBots.concat($scope.publishedBots,res.data.awaitingApprovalBots);
                 $scope.summary.botInfo.published = res.data.publishedBots;
                //  $workflowService.selectedStream(res.data);
             }
            $.each($scope.summary.botInfo.botEvents,function(key,value){
                 if(value.enabled){
                     value.key=key;
                    $scope.botEvents.push(value);
                 }
             });
             if($scope.summary.botInfo.codevelopers && $scope.summary.botInfo.codevelopers.users){
                $.each($scope.summary.botInfo.codevelopers.users,function(i,user){
                    if(user.roleInfo[0].role == "Bot Owner"){
                        user.order=1;
                        user.roleInfo[0].role = "Owner";
                    }else{
                        if(user.roleInfo[0].role == "Bot Developer"){
                            user.roleInfo[0].role = "Developer";
                        }
                        if(user.roleInfo[0].role == "Bot Tester"){
                            user.roleInfo[0].role = "Tester";
                        }
                        user.order=user.firstName;
                    }
                });
             }
            //  if($scope.callbacks && $scope.callbacks.invokeSetUp){
            //     $scope.callbacks.setupTheBot($scope.stream);
            //     $scope.callbacks.invokeSetUp =  false;
            //  }
             preparePermissions();
            },function(err){
                NotificationService.notify(i18n.i18nString('error_summary'), 'error');
                $scope.fetchingSummary = false;
                $scope.apiFailed=true;
            });
        };
        $scope.getBotSummary($scope.stream._id);
        $scope.getChanageLogs = function(){
            $scope.loading  = true;
            BTStreamsService.getChangeLog($scope.stream._id)
            .then(function(res){
                $scope.logs = res.data.btlogs.map(function(log){
                    log.createdDate = new moment(log.createdOn).format('MM/DD/YYYY');
                    log.createdTime = new moment(log.createdOn).format('hh:mm A');
                    log.username = _.isObject(log.userId) ? (log.userId.firstName + ' ' + log.userId.lastName) : log.userId;
                    return log;
                });
                $timeout(function(){
                    if(grid &&  grid.refreshItems){
                        grid.refreshItems();
                    }
                  },3000);
                $scope.loading = false;
            },function(err){
                $scope.logs = [];
                $scope.loading = false;
            });
        };

        $scope.getChanageLogs();
        function updateLanguages(){
            if($scope.callbacks && $scope.callbacks.supportedLanguages){
                $scope.supportedLanguages = $scope.callbacks.supportedLanguages;
            }
        }
        $scope.updateStateForSummary=function(){
            $scope.botState = $scope.botDetails.streamState=='indevelopment'?"configured":"published";
            // $scope.fetchingSummary = true;
            $scope.getBotTaskSummary($scope.stream._id);
            $scope.getBotSummary($scope.stream._id);
            $scope.getChanageLogs();
            updateLanguages();
        };
        var streamUPdate = $rootScope.$on('updateStreamState',$scope.updateStateForSummary);
      
        var summaryTasksUpdate = $rootScope.$on('updateSummaryData',$scope.updateStateForSummary);
        $scope.$on('$destroy', function () {
            streamUPdate();
            summaryTasksUpdate();
       });
// Api calls session ends here..............................................................................................................//






        // Variable declearation session .................................................................................................................//
            
            $scope.availableWidgets=[
                // {
                //     widgetId:'botLifeCycle',
                //     name:'Bot Building Lifecycle',
                //     selected:true,
                //     position:1
                // },
                {
                    widgetId:'tasks',
                    name:i18n.i18nString('tasks'),
                    selected:true,
                    position:1
                },
                {
                    widgetId:'knowledgeCollection',
                    name: i18n.i18nString('knowledge_collection_label'),
                    selected:true,
                    position:2
                },
                {
                    widgetId:'naturalLanguage',
                    name: i18n.i18nString('natural_langname'),
                    selected:true,
                    position:3
                },
                {
                    widgetId:'channels',
                    name: i18n.i18nString('channels'),
                    selected:true,
                    position:4
                },
                {
                    widgetId:'developers',
                    name: i18n.i18nString('developers'),
                    selected:true,
                    position:5
                },
                {
                    widgetId:'changeLogs',
                    name: i18n.i18nString('change_logs'),
                    selected:true,
                    position:6
                },
                {
                    widgetId:"authorization",
                    name: i18n.i18nString('authorization_label'),
                    selected:true,
                    position:7
                },
                {
                    widgetId:'events',
                    name: i18n.i18nString('events_label'),
                    selected:true,
                    position:8
                },{
                    widgetId:'language',
                    name: i18n.i18nString('language_label'),
                    selected:true,
                    position:9
                },{
                    widgetId:'holdNResume',
                    name: i18n.i18nString('hold_and_resume_label'),
                    selected:true,
                    position:10
                },
                {
                    widgetId:'botVariables',
                    name: i18n.i18nString('bot_variables') ,
                    selected:true,
                    position:11
                },
                {
                    widgetId:'others',
                    name: i18n.i18nString('others'),
                    selected:true,
                    position:12
                }
            ];
                
                  
        $scope.$emit('nestedComponentLoaded',{'id':'dashboard','flag':false});
        $scope.assetsPath = env_conf['context-url'];
        $scope.botsIcon = env_conf['context-url']+'/assets/icons/botsIcon.svg';
        $scope.searchIconGreen = env_conf['context-url']+'/assets/icons/searchIconGreen.svg';
        $scope.devAvatar = env_conf['context-url']+'/assets/icons/devAvatar.svg';
        $scope.arrowGreen = env_conf['context-url']+'/assets/icons/arrowGreen.svg';
        $scope.channelIcon = env_conf['context-url']+'/assets/botIcons/1.svg';
        $scope.upgradeUniversalIcon = env_conf['context-url']+'/assets/ub2/universal2.svg';
        $scope.variableKeys={
            'env':'Global',
            'locale':'Content'
        };
        $scope.allInterruptOptions = {
            developer: i18n.i18nString('allinterruptoptions_developer'),
            false: i18n.i18nString('allinterruptions_false'),
            endUser: i18n.i18nString('allinterruptions_endusers'),
            holdCurrTask: i18n.i18nString('allinterruptions_holdcurrtask'),
            discardCurrTask: i18n.i18nString('allinterruptions_discardcurrtask'),
            continueCurrTask: i18n.i18nString('allinterruptions_continuecurrtask'),
            confFromUser: i18n.i18nString('allinterruptions_conffromuser'),
            notifyUser: i18n.i18nString('allinterruptions_notifyuser'),
            noConfFromUser: i18n.i18nString('allinterruptions_noconffromuser'),
            discardCurrTaskNoNotify:i18n.i18nString('allinterruptions_discardtasknonotify')
        };
            
        // Variable declearation session ends................................................................................................................//




        // permissions session ..............................................................................................................................//


        
        // Navigation calls session.........................................................................................................................//


        $scope.selectComponent = function(activeType,innerRightViewElement,cb,subtype){
            if(checkActiveTypePermisions(activeType,innerRightViewElement) || true) { //not required since we are disabling the UI and here mappings seems wrong
                if(subtype){
                    $scope.setSubTabToOpen(innerRightViewElement,subtype);
                }else if(innerRightViewElement){
                    $scope.setSubMenuToOpen(innerRightViewElement);
                }

                // $scope.setSubMenuToOpen(activeType);
                if(cb){
                    cb();
                }
            }else{
                NotificationService.notify(i18n.i18nString('alert_access_session'), 'error');
            }
        };
                $scope.openForms = function(){
                    $scope.selectComponent("botTasks","uiForms");
                };

                $scope.openPanelsWidgets = function(){
                    $scope.selectComponent("botTasks","widgets");
                };
                
                $scope.importBot = function () {
                        $scope.selectComponent("management","botImportExport");
                };

                $scope.openTasks = function (taskType) {
                        $scope.selectComponent("botTasks",'dialogTasks');
                };


                $scope.createTask = function (taskType) {
                        $scope.selectComponent("botTasks",taskType);
                        $scope.showForm(null,taskType);
                };

                var cb = function(){
                    setTimeout(function(){
                        $('#groupName').focus();
                        angular.element('#create-group').modal('show');
                    },2000);
                    
                };

                $scope.createSmallTalk = function() {
                    $scope.selectComponent('botTasks', 'smallTalk',cb);
                };


                $scope.openTask = function (task,type,quary) {
                    $scope.information =i18n.i18nString('information_label');
                    var identified_task={};
                    var botState = $scope.botDetails.streamState || $workflowService.selectedStreamState();
                    if(task && task.type==='dialog'){
                        $scope.callbacks.getFlowTasks($workflowService.selectedStream()._id).then(function(){
                            identified_task=_.find($scope.dialogTasks,{_id:task._id});
                            if(identified_task){
                                if($scope.summary.botInfo.permissions.BOTBUILDER_TASKS[0]=='VIEW' || (( $scope.summary.botInfo.state=='setup') && $workflowService.selectedStream().sbStreamId)){
                                    $scope.callbacks.viewWorkflow(identified_task,'flowtaskView');
                                }else{
                                    $scope.callbacks.editOrViewWorkflow(identified_task,'dialog');
                                }
                                
                            }
                        });
                    }
                    if(task && task.type==='action'){
                        $scope.callbacks.getActions($workflowService.selectedStream()._id).then(function(){
                            identified_task=_.find($scope.actionTasks,{_id:task._id});
                            if(identified_task){
                                if($scope.summary.botInfo.permissions.BOTBUILDER_TASKS[0]=='VIEW'|| (( $scope.summary.botInfo.state=='setup') && $workflowService.selectedStream().sbStreamId)){
                                    $scope.callbacks.viewWorkflow(identified_task,'action');
                                } else{
                                $scope.callbacks.editOrViewWorkflow(identified_task,'action');
                            }
                        }
                        }); 
                    }
                    if(task && task.type==='alert' && !task.isReport){
                        $scope.callbacks.getAlerts($workflowService.selectedStream()._id).then(function(){
                            identified_task=_.find($scope.allAlerts,{_id:task._id});
                            if(identified_task){
                                if($scope.summary.botInfo.permissions.BOTBUILDER_TASKS[0]=='VIEW' || (( $scope.summary.botInfo.state=='setup') && $workflowService.selectedStream().sbStreamId)){
                                    $scope.callbacks.viewWorkflow(identified_task,'alert');
                                } else{
                                $scope.callbacks.editOrViewWorkflow(identified_task,'alert');
                                }
                            }
                        }); 
                    }
                    if(task && task.type==='information' && task.isReport){
                        $scope.callbacks.getActions($workflowService.selectedStream()._id).then(function(){
                            identified_task=_.find($scope.informationTasks,{_id:task._id});
                            if(identified_task){
                                if($scope.summary.botInfo.permissions.BOTBUILDER_TASKS[0]=='VIEW' || (( $scope.summary.botInfo.state=='setup') && $workflowService.selectedStream().sbStreamId)){
                                    $scope.callbacks.viewWorkflow(identified_task,'information');
                                } else{
                                $scope.callbacks.editOrViewWorkflow(identified_task,'information');
                                }
                            }
                        }); 
                    }
                    if(type==='smallTalkGp') {
                        if(botState=="indevelopment"){
                            botState = 'configured';  
                        }
                        BTStreamsService.getSmallTalkGroups($workflowService.selectedStream()._id).then(function(response){
                            var gp = response.data.filter(function(val){
                                return val.groupId === quary.groupId;
                            });
                            if(gp && gp[0]) {
                                $scope.callbacks.openGroup(gp[0]);
                            }
                            else {
                                NotificationService.notify(i18n.i18nString('error_smalltalk'), 'error');
                            }
                        },function(err){
                            NotificationService.notify(i18n.i18nString('error_smalltalk_data'), 'error');
                        });
                    }

                    if(type==='knowledgeTask'){
                        botState = $scope.botDetails.streamState || $workflowService.selectedStreamState();
                        if(botState=="indevelopment"){
                            botState = 'configured';  
                        }
                        $scope.callbacks.getKnowledgeTasks($workflowService.selectedStream()._id).then(function(){
                            identified_task=_.find($scope.knowledgeTasks,{state:botState});
                            if(identified_task){
                                if(quary){
                                    $workflowService.storeSearchQry({
                                        'userSearchQueryFlag': true,
                                        'searchQry': quary
                                    });
                                }
                                if(botState=='configured'){
                                    if($scope.summary.botInfo.permissions.BOTBUILDER_KNOWLEDGE_GRAPH[0]=='VIEW' || (( $scope.summary.botInfo.state=='setup') && $workflowService.selectedStream().sbStreamId)){
                                        $scope.callbacks.viewWorkflow(identified_task,'knowledgeTask');
                                    }else{
                                        $scope.callbacks.editWorkflow(identified_task,'knowledgeTask');
                                    }
                                    $scope.callbacks.getFlowTasks($workflowService.selectedStream()._id);
                                }
                                if(botState=='published'){
                                    $scope.callbacks.viewWorkflow(identified_task,'knowledgeTask');
                                    $scope.callbacks.getFlowTasks($workflowService.selectedStream()._id);
                                }
                            }else{
                                $scope.selectComponent("botTasks",'knowledgeCollection');
                            }
                        }); 
                    }
                };

                $scope.manageNL = function (selection,subtab) {
                        $scope.selectComponent("training",selection,null,subtab);
                };

                $scope.openKt = function () {
                        $scope.selectComponent("botTasks",'knowledgeCollection');
                };

                $scope.openLinkedBots = function () {
                    $scope.selectComponent("botTasks",'linkedBots');
                };
               
                $scope.exportBot = function () {
                    $workflowService.storeSearchQry({
                        'userNavigateFlag': true,
                        'navigateTo': 'export',
                    });
                        $scope.selectComponent("management","botImportExport");
                };
                $scope.manageDebugLogs= function () {
                    $workflowService.storeSearchQry({
                        'userNavigateFlag': true,
                        'navigateTo': 'debugLog',
                    });
                        $scope.selectComponent("analyze",'metrics');
                };

                $scope.manageChannels = function (channel) {
                    if(channel){
                        $workflowService.storeSearchQry({
                            'userNavigateFlag': true,
                            'navigateTo': channel,
                        });
                    }
                        $scope.selectComponent("channels",'channels');
                };

                $scope.manageBotVariables = function () {
                        $scope.selectComponent("configurations","variableManagement");
                };

                $scope.manageContentVariables = function () {
                    $scope.selectComponent("configurations","variableManagementContent");
            };

                $scope.manageBotInterruption = function () {
                        $scope.selectComponent("intelligence","advancedSettings");
                };

                $scope.manageDeveloperShare = function () {
                        $scope.selectComponent("management","developerShare");
                };

                $scope.manageLanguage = function () {
                        $scope.selectComponent("configurations","languageManagement");
                };

                $scope.manageEvents = function () {
                        $scope.selectComponent("defaultConversation","eventsManage");
                };

                $scope.manageAuthorizationProfile = function () {
                        $scope.selectComponent("configurations","authorization");
                };
                $scope.manageBotFunctions = function () {
                    $scope.selectComponent("configurations","botFunctions");
                };

                $scope.manageApiExtensions  = function (innerRightViewElement) {
                    $scope.selectComponent("agents",innerRightViewElement);
                 };

                $scope.manageIvrOptions  = function () {
                    $workflowService.storeSearchQry({
                        'userNavigateFlag': true,
                        'navigateTo': 'ivrVoice',
                        'step':3,
                    });
                        $scope.selectComponent("channels","channels");
                };

                $scope.managePiiSettings= function () {
                    $scope.selectComponent("configurations","IIPMasking");
                  };
                $scope.manageChangeLogs = function () {
                        $scope.selectComponent("management","changeLogs");
                };

        // Navigation calls session ends..................................................................................................................//


        // all function modules for widjet data.....................................................................................................//
       $scope.checkForDropDown= function(){
           var isOpen =$(".taskCreateList").hasClass('open');
           return isOpen;
       };
        // languages....//
        function mapSupportedLanguages() {
            // var seedData = $workflowService.seedData();
            // return _.compact(_.map(seedData.supportedLanguages, function (lang) {
            //     if (_.indexOf($scope.stream.supportedLanguages, lang.value) !== -1) {
            //         return lang;
            //     }
            // }));
            var availableLanguages = _.cloneDeep($workflowService.seedData().supportedLanguages);
             $scope.configuredLanguages = $workflowService.selectedStream().languageConfigurations;  
            if($workflowService.selectedStreamState() === 'indevelopment'){
              $scope.languages = _.filter(availableLanguages,function(lan){
                       if(lan.value===$scope.stream.defaultLanguage){
                            lan.order=1;
                            $scope.defaultLanguage= lan;
                        }else{
                            lan.order=lan.name;
                        }
                       if($scope.configuredLanguages && $scope.configuredLanguages[lan.value] && $scope.configuredLanguages[lan.value].hasOwnProperty('enabled'))
                           {
                               lan.enabled = $scope.configuredLanguages[lan.value]['enabled'];
                               return lan;
                          }
                     });
                     if($scope.languages && $scope.languages.length < $scope.showlanguageCount) {
                        $scope.showlanguageCount =  $scope.languages.length;
                     }
            return $scope.languages;
          }else if($workflowService.selectedStreamState()  === 'published'){
              $scope.taskApprovedLanguages = $workflowService.selectedStream().taskApprovedLanguages;
              $scope.taskDisabledLanguages = $workflowService.selectedStream().publishedDisabledLangs;
              $scope.languages = _.filter(availableLanguages,function(lan){
                       if(lan.value===$scope.stream.defaultLanguage){
                            lan.order=1;
                            $scope.defaultLanguage= lan;
                        }else{
                            lan.order=lan.name;
                        }
                       if($scope.taskApprovedLanguages && $scope.taskApprovedLanguages.indexOf(lan.value) !== -1)
                           {
                               lan.enabled = true;
                               return lan;
                                
                         }
                         if($scope.taskDisabledLanguages && $scope.taskDisabledLanguages.indexOf(lan.value) !== -1)
                           {
                               lan.enabled = false;
                               return lan;
                                
                         }
                     });
              return $scope.languages;          }
            
            // $scope.languages = _.filter(availableLanguages,function(lan){
            //            if(lan.value===$scope.stream.defaultLanguage){
            //                 lan.order=1;
            //                 $scope.defaultLanguage= lan;
            //             }else{
            //                 lan.order=lan.name;
            //             }
            //            if($scope.configuredLanguages && $scope.configuredLanguages[lan.value] && $scope.configuredLanguages[lan.value].hasOwnProperty('enabled'))
            //                {
            //                    lan.enabled = $scope.configuredLanguages[lan.value]['enabled'];
            //                    return lan;
                                
            //              }
            //          });
            // return $scope.languages;

        }
        $scope.supportedLanguages = mapSupportedLanguages();
        $workflowService.supportedLanguages($scope.supportedLanguages);
        $scope.callbacks.supportedLanguages = $scope.supportedLanguages;
        var availableLanguages = $workflowService.seedData().supportedLanguages;
        $scope.enabledLanguages = $scope.stream.supportedLanguages;
        if($workflowService.selectedStream().supportedLanguages){
            var genericLanguage  = {};
            var genericlang = false;
            _.forEach($workflowService.selectedStream().supportedLanguages,function(valueLang){
                if(valueLang === "ge"){
                 genericLanguage = {
                        "value":"ge",
                        "dvalue":"ge",
                        "name":"Generic",
                        "enabled":true
                    };
                    genericlang = true;
                }
            });
            if(!$rootScope.seedLanguages){
                $rootScope.seedLanguages = {};
            }
            $rootScope.seedLanguages.ge = {};
            if (genericlang) {
                $scope.callbacks.supportedLanguages.push(genericLanguage); 
                $rootScope.seedLanguages.ge = {
                    "value": "ge",
                    "dvalue": "ge",
                    "name": "Generic",
                    "enabled": true
                };
            }
        }
        // $scope.languages = _.filter(availableLanguages, function (lang){
        //     if(lang.value===$scope.stream.defaultLanguage){
        //         lang.order=1;
        //         $scope.defaultLanguage= lang;
        //     }else{
        //         lang.order=lang.name;
        //     }
        //     if(_.indexOf($scope.enabledLanguages, lang.value) !== -1){
        //         return lang;
        //     } 
        // });
        // languages....//
        
            $scope.checkForUniVersion = function(){
                $timeout(function(){
                 if($scope.stream && (!$scope.stream['universalBotVersion'] || $scope.stream['universalBotVersion'] === 1) && ($scope.stream.type === 'universalbot') && ($scope.botState === 'configured') && ( $scope.builderState && !$scope.builderState.universalSeen)){
                    $element.find('#upgradeUniModal').removeClass('fade').addClass('show');
                    $scope.upgradeUniProgress = 'initial';
                    $workflowService.universalModalShowStatus(true);
                    $scope.builderState.universalSeen = true;
                    window.localStorage.setItem("previousState",JSON.stringify($scope.builderState));
                }
            });
            };
        
        

        $scope.closeUpgradeUniModal = function(){
            $element.find('#upgradeUniModal').removeClass('show').addClass('fade');
        };

        $scope.redirectToLink= function(link,e){
            if(e){
              e.preventDefault();
              e.stopImmediatePropagation();
              e.stopPropagation();
            }
            $rootScope.redirectToLink(link, e);
        };

        $scope.upgradeUni = function(){
         var _payload = {
            'universalBotVersion' : 2
         };
         $scope.upgradeUniProgress = 'pending';
         NotificationService.notify(i18n.i18nString('bot_upgrade_progress'),'success');
          BTStreamsService.upgradeUniversalBot($applicationService.userInfo().userId,$scope.stream ._id,_payload).then(function(response){
               if(response){
                    $scope.stream['universalBotVersion'] = response.data.universalBotVersion;
                    $workflowService.selectedStream(response.data);
                    $scope.stream = $workflowService.selectedStream();
                    $workflowService.selectedStream($scope.stream);
                    NotificationService.notify(i18n.i18nString('bot_switch_success'),'success');
                    $scope.callbacks.navigateTo(null,'linkedBots',true);
                    $timeout(function(){
                        $scope.upgradeUniProgress = 'success';
                        $element.find('#upgradeUniModal').removeClass('show').addClass('fade');
                        NotificationService.notify(i18n.i18nString('bot_upgrade_success'),'success');
                    },500);
                    
                    
                }
            },function(err){
                $scope.upgradeUniProgress = 'failed';
                NotificationService.notify('Something went wrong','error');
            });
        };

        $scope.closeNotification = function() {
            $scope.notificationEnabled = false;
            $timeout(function(){
                if(grid){
                    // grid.refreshItems();
                    gridInit();
                }
            },500);
        };

        $scope.openPlanUsage = function(planType){
            if(planType === 'plan') {
                $scope.planSelectionCb.planSelection = true;
                $scope.planSelectionCb.supportSelection = false;
            } else if(planType === 'reload') {
                $scope.planSelectionCb.planSelection = false;
                $scope.planSelectionCb.reloadAmount = true;
            } 
            // else if(planType === 'support') {
            //     $scope.planSelectionCb.planSelection = false;
            //     $scope.planSelectionCb.supportSelection = true;
            // }
            $scope.planSelectionCb.license = $scope.license;
            $scope.planSelectionCb.supportPlan = $scope.supportPlan;
            $scope.planSelectionCb.plansSlider = true;
        };
        $scope.planSelectionCb.close = function() {
            $scope.closeModalSlider('#managePlanSelectionSlider');
            $scope.planSelectionCb = {};
        };

        $scope.getLicenseInfo = function() {
            if($scope.selectedStream) {
                if($scope.selectedStream.license) {
                    $scope.license = $scope.selectedStream.license;
                    $scope.license.totalCredits = (($scope.license.baseAllowedCredits + $scope.license.extraCredits) - $scope.license.creditsUsed) || 0;
                    $scope.license.totalSessions = (($scope.license.baseAllowedSessions + $scope.license.extraSessions) - $scope.license.sessionsUsed) || 0;
                    $scope.license.totalRequests = ($scope.license.baseAllowedRequests - $scope.license.requestsUsed) || 0;
                }
                if($scope.selectedStream.supportplan) {
                    $scope.supportPlan = $scope.selectedStream.supportplan;
                    if($scope.supportPlan.endDate) {
                        var currentDate = moment();
                        var endDate = moment($scope.supportPlan.endDate);
                        $scope.supportPlan.remainingDays = endDate.diff(currentDate, 'days');
                    }
                }
                if($scope.selectedStream.planValidationDetails) {
                    $scope.notificationEnabled = true;
                    $scope.planValidationDetails = $scope.selectedStream.planValidationDetails;
                    if($scope.planValidationDetails) {
                        planDisplayName($scope.planValidationDetails.exceededData);
                    }
                }
            }
        };
        $scope.getLicenseInfo();
        function planDisplayName(data) {
            var keys = Object.keys(data);
            if(keys) {
                var headers =[];
                keys.forEach(function(key){
                    if($scope.license.planId === key) {
                        if(data[key] && data[key][0]) {
                            headers.push({planName : data[key][0].planName, id: key});
                        }
                    }
                });
                var selectedValid = _.find(headers,function(item) {
                    return item.id === $scope.license.planId;
                });
                if(selectedValid) {
                    $scope.planValHeaders = selectedValid;
                }
            }
        }
        $scope.openLanguageGenericModal = function(){
            $('#languageModalGeneric').modal('show');
        };
        $scope.checkForGenericLanguage = function () {
            $scope.showGenericProtip = false;
            $scope.seedDataNluSupportedLanguages = $workflowService.seedData().nluSupportedLanguages;
              _.forEach($scope.stream.supportedLanguages,function(value){
                if (value === "ge") {
                    $scope.showGenericProtip = true;
                }
            });
            if ($workflowService.selectedStream().enableInputTranslation && !$workflowService.selectedStream().multiLingualConfigurations) {
                $scope.inputTranslation = true;
            } else{
                if($workflowService.selectedStream().multiLingualConfigurations){
                    $scope.inputTranslation = false;
                }
            }
            $scope.showSelectedLanguage = "";
                _.forEach($scope.stream.supportedLanguages,function(value){
                    if (value === "ge") {
                        $('#languageModalGeneric').modal('show');
                    }
                });
        };
        $scope.checkForGenericLanguage();
        $scope.setLanguageCode = function (lang) {
            $scope.showSelectedLanguage = lang;
        };
        $scope.openLanguageSlider = function(){
            if($scope.rightPanel && $scope.rightPanel.innerRightPanel && $scope.rightPanel.innerRightPanel.showView ){
                $workflowService.storeSearchQry({
                    'userSearchQueryFlag': true,
                    'searchQry': 'openLanguageTranslation'
                });
                $scope.rightPanel.innerRightPanel.showView('languageManagement');
                $scope.inputTranslation= false;
            }       
        };
        var addNewSupportedLanguage = function () {
            var payload = {
                preferredData: [
                    "definition",
                    "training",
                    "faqs",
                    "ontology",
                    "smalltalk",
                    "traits"
                  ],
                baseLanguage: "ge",
            };
            payload.multiLingualConfigurations = {};
            payload.multiLingualConfigurations[$scope.showSelectedLanguage.value] = {
                nluLanguage: $scope.showSelectedLanguage.value,
                // inputTranslation: $scope.multiLingual.inputTranslation,
                // responseTranslation: $scope.multiLingual.responseTranslation
            };
            var selectedNluLanguage = false;
            _.forEach($scope.seedDataSupportedLanguages, function (eachLanguage) {
                if (eachLanguage.value === $scope.showSelectedLanguage.value) {
                    selectedNluLanguage = true;   
                }
            });
            if(selectedNluLanguage){
                payload.multiLingualConfigurations[$scope.showSelectedLanguage.value] = {
                    nluLanguage: $scope.showSelectedLanguage.value
                };
            }else{
                payload.multiLingualConfigurations[$scope.showSelectedLanguage.value] = {
                    nluLanguage: "ge"
                };
            }
            BTStreamsService.addSupportedLanguage($workflowService.selectedStream()._id, $scope.showSelectedLanguage.value, payload)
                .then(function (res) {
                    $('#languageModalGeneric').modal('hide');
                    $scope.showGenericProtip = false;
                    $scope.inputTranslation = false;
                    var index = $scope.callbacks.supportedLanguages.findIndex(function (lang) {
                        return lang.value === "ge";
                    });
                    $scope.callbacks.supportedLanguages.splice(index, 1);
                    console.log($scope.callbacks.supportedLanguages);
                })
                .catch(function (res) {
                });
        };
        $scope.proceedLanguageEnable = function () {
            BTStreamsService.disableLanguage($workflowService.selectedStream()._id, 'ge').then(function (response) {
                if (response) {
                    $scope.selectedStream = response.data;
                    NotificationService.notify('Generic language is now changed to ' + $scope.showSelectedLanguage.name, 'success');
                    $workflowService.selectedStream(response.data);
                    addNewSupportedLanguage();
                }
            }, function (errors) {
                if(errors && errors.data && errors.data.errors && errors.data.errors.length && errors.data.errors[0] && errors.data.errors[0].msg){
                    NotificationService.notify(errors.data.errors[0].msg, 'error');
                   }
            });

        };
    }]);

     _module.filter('removeSpaces', function(){
        return function(input) {
            if(input) {
                return input.replace(/\s\s+/g, ' ');
            }
        };
    });
    _module.filter('localString', function(){
        return function(number, type) {
            if(number && type === 'sessions') {
                return number.toLocaleString();
            }else if(number) {
                var abs = Math.abs(number);
                var rounder = Math.pow(10, 1);
                var isNegative = number < 0; // will also work for Negetive numbers
                var key = '';
        
                var powers = [
                    {key: 'Q', value: Math.pow(10, 15)},
                    {key: 'T', value: Math.pow(10, 12)},
                    {key: 'B', value: Math.pow(10, 9)},
                    {key: 'M', value: Math.pow(10, 6)},
                    {key: 'K', value: 1000}
                ];
        
                for (var i = 0; i < powers.length; i++) {
                    var reduced = abs / powers[i].value;
                    reduced = Math.round(reduced * rounder) / rounder;
                    if (reduced >= 1) {
                        abs = reduced;
                        key = powers[i].key;
                        break;
                    }
                }
                return (isNegative ? '-' : '') + abs.toLocaleString() + key;
                // return input.toLocaleString();
            } else {
                return number;
            }
        };
    });
}(angular));



;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTToimageCtrl', ['$scope', '$modalInstance', '$workflowService', 'config', 'BTFlowtaskService', 'urlutil','NotificationService', '$timeout','i18n',
        function ($scope, $modalInstance, $workflowService, config, BTFlowtaskService, urlutil,NotificationService, $timeout,i18n) {
            function init() {
                $scope.stream = $workflowService.selectedStream();
                $scope.task=$workflowService.taskEditInfo();
                $scope.component = config.component.nodeInfo;
                $scope.saveInProgress = false;
                $scope.sampleResCB={};
                $scope.options = {
                    aceMode:"ace/mode/xml",
                    mode: $scope.displayMode === "view" ? 'tree' : 'code',
                    ace: window.ace                   
                };
                $scope.props = {
                    headers: [],
                    endPoint: {}
                };
                $scope.invalidPayload = true;
                $scope.authCB = 'none';
                $scope.idpConfig = {};
                $scope.saving = i18n.i18nString('saving');
                $scope.add =    i18n.i18nString('add');
                // Timeout is added because ace editor is discarding data if data is pushed in it at the time of creation - Ashish 
                $timeout(function () {
                    $scope.props.headers.push({key: "", value: ""});
                    $scope.props.endPoint.requestUrl = processUIEndPoint($scope.component.endPoint);
                    $scope.props.endPoint.method = 'get';
                    $scope.props.htmlData = $scope.component.htmlData && $scope.component.htmlData[0] && $scope.component.htmlData[0].text || '';
                    $scope.props.htmlData = $scope.props.htmlData.replace(/&lt;/gi,'<').replace(/&gt;/gi, '>');
                    $scope.props.paramType = "application/xml";
                }, 400);
                if ($scope.component.renderSize === undefined || $scope.component.renderSize === []) {
                    $scope.component.renderSize = [
                        {
                            name: 'Mobile',
                            width: 320,
                            height: 480
                        },
                        {
                            name: 'Desktop',
                            width: 1366,
                            height: 768
                        }
                    ];
                }
            }
            function processUIEndPoint(endPoint) {
                if (!endPoint) {
                    return "";
                }
                var _url = urlutil.concat({
                    host: endPoint.host,
                    path: endPoint.path,
                    port: endPoint.port ? (endPoint.port + '') : '',
                    protocol: endPoint.protocol
                });

                return _url;
            }
            function deProcessUIEndPoint(url, method) {
                var uriParser = window.URI;
                var components = uriParser.parse(url);
                var endPoint = {
                    host: components.host,
                    port: components.port ? (components.port + '') : '',
                    path: components.path,
                    protocol: components.scheme,
                    method: method
                };
                endPoint.path += (components.query) ? ('?' + components.query) : '';
                endPoint.path += (components.fragment) ? ('#' + components.query) : '';
                return endPoint;
            }
            function bindEvent() {
                $scope.sampleResCB.onBlur = function (editor) {
                    var _value = editor.getText();
                    if (_value === '') {
                        $scope.props.htmlData = '';
                    }
                    $scope.fieldEdit();
                };
            }
            $scope.fieldEdit = function () {
                var _isInvalid = false;
                $.each($scope.component.renderSize, function (k, size) {
                    if (size.name === '' || size.width === '' || size.height === '') {
                        _isInvalid = true;
                    }
                });
                if (_isInvalid) {
                    $scope.invalidPayload = true;
                } else {
                    $scope.invalidPayload = false;
                }
            };
            $scope.checkPosNumber = function (valNum, key, index) {
                if ($scope.component.renderSize && $scope.component.renderSize[index]) {
                    if (isNaN(valNum)) {
                        $scope.component.renderSize[index][key] = 1;
                    } else {
                        if (valNum < 1) {
                            $scope.component.renderSize[index][key] = 1;
                        } else if (valNum % 1 !== 0) {
                            $scope.component.renderSize[index][key] = parseInt(valNum);
                        }
                        if ($scope.component.renderSize[index][key] > 1920) {
                            $scope.component.renderSize[index][key] = 1920;
                        }
                    }
                }
            };
            $scope.saveRequest = function () {
                if (!$scope.invalidPayload) {
                    var _payload = {};
                    if ($scope.component.serviceNodeType === 'urltoimage') {
                        _payload.headers = {type: "raw", value: '{}'};
                        _payload.payload = {type: "raw", value: '{}'};
                        _payload.idp = 'none';
                        _payload.authRequired = false;
                        _payload.endPoint = deProcessUIEndPoint($scope.props.endPoint.requestUrl, $scope.props.endPoint.method);
                        _payload.endPoint.connectorEnabled = false;
                    } else {
                        _payload.htmlData = [{
                            text: $scope.props.htmlData,
                            type: 'uxmap'
                        }];
                    }
                    _payload.renderSize = [];
                    $.each($scope.component.renderSize, function (k, size) {
                        if (size && size.name && size.width && size.height) {
                            _payload.renderSize.push({
                                name: size.name,
                                width: parseInt(size.width),
                                height: parseInt(size.height)
                            });
                        }
                    });
                    saveToServer(_payload);
                } else {
                    NotificationService.notify(i18n.i18nString('bt_to_img_please_provide_valid_payload'), 'warning');
                }
            };
            
            function saveToServer(_payload) {
                $scope.saveInProgress = true;
                BTFlowtaskService.updateComponent($scope.stream._id, $scope.component._id, _payload).then(function (res) {
                    if (res && res.data) {
                        if (config && config.cbBridge && config.cbBridge.onServiceSave) {
                            config.cbBridge.onServiceSave(res.data);
                        }
                        $scope.closeModal();
                    }
                    $scope.saveInProgress = false;
                }, function () {
                    $scope.saveInProgress = false;
                });
            }
            $scope.addRenderSize = function () {
                if ($scope.component.renderSize && $scope.component.renderSize.length < 3) {
                    $scope.component.renderSize.push({
                        name: '',
                        width: '',
                        height: ''
                    });
                } else {
                    NotificationService.notify(i18n.i18nString('bt_to_img_cannot_add_more_than_3_render'), 'warning');
                }
                $scope.fieldEdit();
            };
            
            $scope.removeRenderSize = function (index) {
                if ($scope.component.renderSize && $scope.component.renderSize.length > 1) {
                    if ($scope.component.renderSize && $scope.component.renderSize[index]) {
                        $scope.component.renderSize.splice(index, 1);
                    }
                }
                $scope.fieldEdit();
            };
            
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            
            (function () {
                init();
                bindEvent();
            })();
        }]);

})(angular);


;(function (ng) {

    var _module = ng.module('bt-train-bot', []);

    _module.filter('taskNameFormat', function () {
        return function (input, data) {
            input = input || '';
            var out = '';
            out = input;
//            if (data.parentId) {
//                out = out + " @development";
//            }
            return out;
        };
    });

    _module.directive('btTrainBot', function () {
        return {
            restrict: 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-train-bot/bt-train-bot.html',
            controller: 'BTTrainBotCtrl',
            scope: {
                trainOffset: '=',
                callFrom: '=',
                analyzerecord: '=',
                cb: '='
            }
        };

    })
            .controller('BTTrainBotCtrl',
                    ['$scope', '$rootScope', '$workflowService', '$location', '$sce', '$sanitize', '_constants_', 'BTStreamsService', '$timeout', '$routeParams', 'NotificationService', '$modal', 'BTAlertsService', 'BTActionsService', 'BTFlowtaskService', '$q', 'form_util', '$applicationService', 'env_conf','accessControlService','i18n','mixPanel',
                        function ($scope, $rootScope, $workflowService, $location, $sce, $sanitize, _constants_, BTStreamsService, $timeout, $routeParams, NotificationService, $modal, BTAlertsService, BTActionsService, BTFlowtaskService, $q, form_util, $applicationService, env_conf,accessControlService,i18n,mixPanel) {
                            $scope.$emit('nestedComponentLoaded', { 'id': 'testTrain', 'flag': false });
                            //Add below whenever nestedComponentLoaded is FINALLY emitted.
                            $timeout(function(){
                                $scope.$emit('gSearchLoad');
                            });
                            $scope.displayMode = accessControlService.getAccessRight('BOTBUILDER_NATURAL_LANGUAGE');
                            var API_URL_PREFIX = "/api/" + env_conf['version'],
                                    API_SERVER_URL = env_conf['API_SERVER_URL'],
                                    parms = $workflowService.nlpTrainInput();

                            var emptySpace = String.fromCharCode(160);


                            var getSpaceByCount = function (count) {
                                var tempEmptySpace = "";
                                for (var i = 0; i < count; i++) {
                                    tempEmptySpace = tempEmptySpace + emptySpace;
                                }

                                return tempEmptySpace;
                            };
                            $scope.allDialogTasks = [];
                            $scope.assetsBase = env_conf['assets-url'];
                            $scope.trainbotintent = {};
                            $scope.multipleIntent = {};
                            $scope.multipleIntent.selectedTask = "";
                            $scope.debuggerConsole = {};
                            $scope.upgradedTasks=[];
                            $scope.debugkeys = {
                                "utteranceReady":  i18n.i18nString('connected_ready_for_utterance'),
                                "utteranceSent":  i18n.i18nString('utterance_sent_waiting_for_response'),
                                "utteranceRecieve":  i18n.i18nString('response_received_success'),
                                "intentMatch": getSpaceByCount(2) +  i18n.i18nString('intent_match_label'),
                            };
                            $scope.smallTalkIcon = env_conf['context-url']+'/assets/smalltalk/faq.svg';
                            $scope.debugInfo = {
                            };
                            $scope.running_label =  i18n.i18nString('running_label');
                            $scope.save_And_run_label =   i18n.i18nString('save_And_run_label');
                            $scope.faq= i18n.i18nString('faq');
                            $scope.intent_label= i18n.i18nString('intent_label');
                            $scope.selected_label =  i18n.i18nString('selected_label');
                            $scope.matched_label = i18n.i18nString('matched_label');
                            $scope.utterence = null;
                            var entityColors = {};

                            $scope.openAccordion = function () {
                                alert("openAccordion");
                            };
                            $scope.offsetHeightDefault = $scope.trainOffset || -70;
                            $scope.rightPanelHeightDefault = $scope.trainOffset || -57;
                            $scope.rightEditPanelHeightDefault = $scope.trainOffset || -57;
                            $scope.verifying = false;
                            $scope.pattern = {};
                            $scope.synonym = {};
                            $scope.addmeta = {};
                            $scope.constants = _constants_;
                            $scope.stream = $workflowService.selectedStream();
                            // console.log($scope.stream);
                            $scope.universalbot = $scope.stream.type === 'universalbot';
                            var streamId = $workflowService.selectedStream()._id;
                            var _selectedLanguage = $workflowService.currentLanguage();
                            if($scope.displayMode === 'VIEW'){
                            $(document).keydown(function (e) {
                                var keycode1 = (e.keyCode ? e.keyCode : e.which);
                                if (keycode1 === 0 || keycode1 === 9) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                                });
                            }

                            $scope.allStreams = $workflowService.streamsAll() || [];
                            if ($scope.cb) {
                                $scope.cb.initMethod = function () {
                                    $scope.verifying = false;
                                    $scope.intent = {};
                                    $scope.runInProgress = false;
                                    $scope.testing = false;
                                    $(".keyword_highlight").html("");
                                    parms = $workflowService.nlpTrainInput();
                                    init();
                                };
                            }
                            $scope.universalStreams = $scope.allStreams.filter(function (bot) {
                                if (_.find($scope.$parent.$parent.linkedBots, {_id: bot._id})) {
                                    return true;
                                } else {
                                    return false;
                                }
                            });
                            var tasksArray = [];
                            $scope.tasks = [];
                            var synonyms = [];
                            $scope.showNlpEditPanel = false;
                            $scope.showUserSaysError = false;
                            $scope.tasksByType = [];
                            $scope.iconContextPath = env_conf['context-url'] + '/img';
                            $scope.imageContext = env_conf['context-url'] + '/assets/icons';
                            $scope.bulbIcon = window.appConfig.CONTEXT_PATH + '/assets/images/24x29-bulbicon.png';
                            $scope.infoIcon = env_conf['context-url'] + '/assets/icons-new/info/info-gray.svg';
                            $scope.nlp = $scope.nlp || {
                                text: ''
                            };
                            $scope.context = {
                                api: {}
                            };
                            $scope.parentIntent = {};
                            $scope.dialogIntents = {};
                            $scope.selectedTask = null;
                            $scope.debugInfoLogs = [];
                            $scope.intentTabs = [
                                {name:  i18n.i18nString('machine_learning'), id: "machineLearning"},
                                {name:  i18n.i18nString('synonyms_and_patterns_label'), id: "synonymsPatterns"}
                            ];
                            $scope.activeType = "machineLearning";

                            $scope.isCollapsed = function (ele) {
                                return $(ele).hasClass("collapsed");
                            };
                            $scope.multipleIntentModels = false;
                            // If multiple intents are enabled set 'multipleIntentModels' true
                            function getSavedConfiguration() { 
                                BTStreamsService.getSavedConfiguration($workflowService.selectedStream()._id).then(function(response){
                                    if(response && response.data){ 
                                        if(response.data && response.data.length) {
                                            var findMultiIntents = response.data.find(function(item) {
                                                return item.configurationKeyName === "Multiple_Intent_Models";
                                            });
                                            if(findMultiIntents && findMultiIntents.configurationValue) {
                                                $scope.multipleIntentModels = findMultiIntents.configurationValue;
                                            }
                                        }
                                    }  
                                });
                            }
                            getSavedConfiguration();


                            $scope.richEditorInitialStage = "init";
                            $scope.intentVerified = false;

                            $scope.identifiedTask = null;

                            $scope.newSynonym = {};
                            $scope.newSynonym.show = false;
                            $scope.addSynonym = function (form) {
                                if (form.$invalid) {
                                    form_util.touch(form);
                                    return;
                                }
                                var key = "state";
                                if ($scope.identifiedTask.taskType === 'DialogIntent') {
                                    key = "status";
                                }
                                if ($scope.identifiedTask[key] == "published") {
                                    $scope.currentCb = "addSynonym";
                                    $scope.currentPatternData = angular.copy(form);
                                    NotificationService.alert('', $scope.upgrade, {okText:  i18n.i18nString('upgrade')}, "", undefined,  i18n.i18nString('add_utter_published_noty'));
                                } else{
                                $scope.synonyms.push(angular.copy($scope.newSynonym));
                                $scope.hideAddSynonym();
                                $scope.newSynonym.key = '';
                                $scope.newSynonym.value = [];
                                }
                            };
                            $scope.showAddSynonym = function () {
                                $scope.newSynonym.key = '';
                                $scope.newSynonym.value = [];
                                $scope.AddTaskSynonymsForm.$setPristine();
                                $scope.newSynonym.show = true;
                                $timeout(function () {
                                    $('.key-phrase').focus();
                                }, 350);

                            };
                            $scope.hideAddSynonym = function () {
                                $scope.newSynonym.show = false;
                            };
                            $scope.trainBotCB = {};
                            $scope.trainBotCB.openEditPanel = function (type, expandIndex) {
                                $scope.showNlpEditPanel = true;
                                $scope.nlpEditData = $scope.nlpData.type;
                                $scope.trainBotCB.loading = true;
                                $scope.trainBotCB.type = type;
                                $timeout(function(){
                                    $scope.trainBotCB.initEditPanel($scope.nlpData,$scope.trainBotCB.type,expandIndex);
                                },600);
                                

                            };
                            $scope.trainBotCB.closeEditPanel = function () {
                                $scope.showNlpEditPanel = false;
                                $('.model').removeClass('active');
                            };
                            $scope.nlpData = {};

                            $scope.newPattern = {};
                            $scope.newPattern.show = false;
                            $scope.showAddPattern = function () {
                                $scope.newPattern.value = '';
                                $scope.newPattern.show = true;
                            };
                            $scope.hideAddPattern = function () {
                                $scope.newPattern.show = false;
                            };



                            $scope.newFieldPattern = {};
                            $scope.newFieldPattern.show = false;

                            $scope.showAddFieldPattern = function (field) {
                                $scope.selectedField = field;
                                $scope.newFieldPattern.show = true;
                            };
                            $scope.hideAddFieldPattern = function () {
                                $scope.selectedField = null;
                                $scope.newFieldPattern.show = false;
                            };

                            var keyValueSetter = function (obj, prop, val) {
                                prop = (prop + "").toLowerCase();
                                if (!_.isEmpty(obj)) {
                                    for (var p in obj) {
                                        if (obj.hasOwnProperty(p) && prop == (p + "").toLowerCase()) {
                                            obj[p] = val;
                                            break;
                                        } else {
                                            obj[prop] = val;
                                        }
                                    }
                                } else {
                                    obj = {};
                                    obj[prop] = val;
                                }

                            };

                             $scope.upgrade = function () {
                   $scope.isGlobalWorkProgress= true;
                   $scope.loaderMessage =  i18n.i18nString('upgrading_task_label');
                var taskType = $scope.getTaskType($scope.identifiedTask);
                $scope.upgradeWorkflow($scope.identifiedTask, taskType);
                if($scope.publishedMode){
                    $scope.saveOrUpdateUtterance("","hidePublishedMode");
                }
            };
            // $scope.checkForTaskVisibility=function(task){
            //     var hidden = false;
            //     if(task.activityType=="dialog"){
            //         $.each($scope.dialogTasksData,function(i,item){
            //             if(task.taskId==item._id){
            //                 hidden = item.isHidden;
            //             }
            //         });
            //     }
            //     return hidden;
            // };
            var prepareEntityMatchInfo = function(matchInfo){
                if(matchInfo){
                    var identifiedBy = matchInfo.entityIdentifiedBy;
                    var identifiedUsing = matchInfo.entityIdentifiedUsing;
                    var identifiedEngine = identifiedBy.split(" ")[0];
                    var identifiedLabel,nerScore;
                    if(identifiedBy === 'FM Engine'){
                        identifiedLabel = identifiedUsing.split(":")[0];
                    }else{
                        identifiedLabel = identifiedUsing;
                        nerScore = matchInfo.entityNERConfidenceScore;
                    }

                    // $scope.initializePopover();
                    
                    return{
                        'identifiedEngine':identifiedEngine,
                        'identifiedUsing':identifiedUsing,
                        'identifiedLabel':identifiedLabel,
                        'nerScore':nerScore
                    };
                }
                
            };
            $scope.getTraitsGroupsApi = function () {
                BTStreamsService.getTraitGroups($applicationService.userInfo().userId,$workflowService.selectedStream()._id).then(function (res) {
                    $scope.traitGroups = angular.copy(res.data);
                    $scope.allTraits={
                        traits:[],
                        negativeTraits:[]
                    };
                    var alltraitsArr=[];
                    var allTraitsNegations = [];
                    $.each($scope.traitGroups,function(i,traits){
                        $.each(traits.traits,function(j,trait){
                            var obj = {
                            'groupId': traits._id,
                            'traitId': trait.traitId || j,
                            'traitName': trait.traitName
                            };
                            alltraitsArr.push(trait.traitName);
                            allTraitsNegations.push(('!'+trait.traitName));
                        });
                    });
                    $scope.allTraits.traits = _.uniq(alltraitsArr);
                    $scope.allTraits.negativeTraits = _.uniq(allTraitsNegations);
                },
                    function (err) {
                        $scope.loadingTraits = false;
                        if (accessControlService.getAccessRight('BOTBUILDER_NATURAL_LANGUAGE') !== "NO") {
                            NotificationService.notify( i18n.i18nString('failed_traits'), 'error');
                        }
                    });
            };
        if (accessControlService.getAccessRight('BOTBUILDER_NATURAL_LANGUAGE') !== "NO") {
            $scope.getTraitsGroupsApi();
        }
            $scope.getTaskType = function (task) {
                if (task && task.hasOwnProperty('alertFieldsDefinition')) {
                    return "alert";
                } else if (task && task.hasOwnProperty('isReport')) {
                    if(task.isReport){
                         return "information";
                    }else{
                        return "action";
                    }
                 } else if (task && task.taskType == "dialog") {
                    return "flowtask";
                } else {
                    return "";
                }
            };
           $scope.getAlltasks= function(){
               loadingEntities(streamId,'true');
           };
            $scope.upgradeWorkflow = function (task, type) {
                
                if (type === "alert") {
                    BTAlertsService.upgradeBTAlert(task._id).then(function (response) {
                        BTAlertsService.upgradeMPAlert(task._id, response.data._id).then(function (upgradeRes) {
                            BTAlertsService.configured(upgradeRes.data._id).then(function (configRes) {
                           $scope.identifiedTask = configRes.data[0];
                           loadingEntities(streamId,'true');
//                           if($scope.currentCb === "addSynonym"){
//                               $scope.addSynonym($scope.currentPatternData);
//                           }else if($scope.currentCb === "updateSynonyms"){
//                               $scope.updateSynonyms($scope.currententityData);
//                           }
                            $scope.verify();
                             $rootScope.$broadcast('upadteTaskData','alert',configRes.data[0]);
                           $scope.isGlobalWorkProgress = false;
                           }, function (err) {
                                $scope.isGlobalWorkProgress= false;
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                                return;
                            });

                        }, function (err) {
                            $scope.isGlobalWorkProgress= false;

                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;

                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                } else if (type === "action" || type === "information") {
                    BTActionsService.upgradeBTAction(task._id).then(function (response) {
                        BTActionsService.upgradeMPAction(task._id, response.data._id).then(function (upgradeRes) {
                         BTActionsService.configured(upgradeRes.data._id).then(function(configRes){
                                $scope.identifiedTask = configRes.data[0];
                           loadingEntities(streamId,'true');
                           $rootScope.$broadcast('upadteTaskData','action',configRes.data[0]);
                                 $scope.isGlobalWorkProgress = false;
					},function(err){
                                            $scope.isGlobalWorkProgress= false;
						NotificationService.notify(err.data.errors[0].msg,'error');
						return;
					});
                        }, function (err) {
                           $scope.isGlobalWorkProgress= false;
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;
                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                } else if (type === "flowtask") {
                    BTFlowtaskService.upgradeFlowtask($workflowService.selectedStream()._id, task._id).then(function (res) {
                           res.data.taskType="dialog";
                            $rootScope.$broadcast('upadteTaskData','flowTask',res.data);
                           $scope.identifiedTask = res.data;
                           loadingEntities(streamId,'true');
                          
                          $scope.isGlobalWorkProgress = false;
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;
                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                }    
                
            };
            function mixpanelEvent (type){
                var _botInfo = {
                    streamId: $workflowService.selectedStream()._id,
                    "Bot Name": $workflowService.selectedStream().name,
                    "Level":"Engagement L3",
                    "Category":"Engagement L3",
                };
                var event = "";
                if(type === 'createUtterance') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Intent Utterance Added";
                 }
                 if(type === 'createPattern') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Intent Pattern Added";
                 }
                 if(type === 'createEntitySynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Entity Synonym added";
                 }
                 if(event && event.trim()) {
                    mixPanel.postEvent(event, _botInfo);
                 }
             }
                            $scope.updateSynonyms = function (entityData) {
                                var key = "state";
                    if ($scope.identifiedTask.taskType === 'DialogIntent') {
                        key = "status";
                    }
                    if($scope.identifiedTask[key] == "published"){
                         $scope.currentCb = "updateSynonyms";
                        $scope.currententityData = entityData;
                    NotificationService.alert('', $scope.upgrade, {okText:  i18n.i18nString('upgrade')}, "", undefined,  i18n.i18nString('add_utter_published_noty'));
                }else{
                    var streamId = $scope.stream._id;
                    if($scope.stream.type === "universalbot") {
                        streamId = $scope.currUniversalBotStreamId;
                    }
                    var cmpId = entityData._id;
                    var synonyms = entityData.synonyms;
                    BTFlowtaskService.updateComponentSynonyms(streamId, cmpId, {synonyms: synonyms}).then(function (res) {
                        mixpanelEvent("createEntitySynonyms");
                        $scope.editEntitySynonym = null;
                        $scope.editEntitySynonymId = null;
                        NotificationService.notify( i18n.i18nString('entity_synonyms_added_sucess_noty'), "success");
                    }, function (err) {
                        var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg ||  i18n.i18nString('adding_as_entity_synonym_failed');
                        NotificationService.notify(msg, 'error');
                    });
                }
            };

                            $scope.updatePatterns = function (cmpId, patterns, entityData, fromDelete) {
                                var key = "state";
                    if ($scope.identifiedTask.taskType === 'DialogIntent') {
                        key = "status";
                    }
                    if($scope.identifiedTask[key] == "published"){
                        $scope.currentCb = "updatePatterns";
                        $scope.cmpId = angular.copy(cmpId);
                        $scope.currentPatterns = angular.copy(patterns);
                        $scope.currentEntityData = angular.copy(entityData);
                        $scope.currentDeleteFormdetails = angular.copy(fromDelete);
                    NotificationService.alert('', $scope.upgrade, {okText:  i18n.i18nString('upgrade')}, "", undefined,  i18n.i18nString('add_utter_published_noty'));
                }else{
                                var streamId = $scope.stream._id;
                                BTFlowtaskService.updateComponentPatterns(streamId, cmpId, {patterns: patterns}).then(function (res) {
                                    mixpanelEvent("createPattern");
                                    if (res && res.data) {
                                        entityData.patterns = res.data.patterns;
                                    }
                                    $scope.addFieldPatternSaving = false;

                                    $scope.newFieldPattern.value = '';
                                    if (fromDelete) {
                                        NotificationService.notify( i18n.i18nString('pattern_deleted_sucessfully_noty'), "success");
                                    }

                                }, function (error) {
                                    $scope.addFieldPatternSaving = false;
                                    var msg = i18n.i18nString('patrn_module_dup_patrn_err');
					                 NotificationService.notify(msg,"error");
                                });
                            }
                            };

                            $scope.addFieldPattern = function (form, newPatternData, entityData) {
                    var key = "state";
                    if ($scope.identifiedTask.taskType === 'DialogIntent') {
                        key = "status";
                    }
                    if($scope.identifiedTask[key] == "published"){
                        $scope.currentCb = "addPattern";
                        $scope.currentNewPatternData = angular.copy(newPatternData);
                        $scope.currententityData = angular.copy(entityData);
                    NotificationService.alert('', $scope.upgrade, {okText:  i18n.i18nString('upgrade')}, "", undefined,  i18n.i18nString('add_utter_published_noty'));
                }else{
                                var taskId, field, input;
                                if (form.$invalid) {
                                    form_util.touch(form);
                                    return;
                                }

                                $scope.selectedField = newPatternData;

                                var task = $scope.identifiedTask;

                                var type = (taskId || task._id)[0] == 'l' ? "alert" : (taskId || task._id)[0] == 'd' ? "dialog" : "action";

                                var payload = {
                                    fieldName: field || $scope.selectedField.title,
                                    input: input || $scope.newFieldPattern.value
                                };

                                taskId = taskId || task._id;
                                field = field || $scope.newFieldPattern;

                                $scope.addFieldPatternSaving = true;

                                if (type == 'alert') {

                                    BTAlertsService.createFieldPattern(taskId, payload.fieldName, payload)
                                            .then(function (res) {
                                                keyValueSetter($scope.identifiedTask.fieldPatterns, $scope.selectedField.title, res.data);
                                                // $scope.identifiedTask.fieldPatterns[$scope.selectedField.title.toLowerCase()]=res.data;
                                                $scope.addFieldPatternSaving = false;

                                                $scope.newFieldPattern.value = '';
                                            }, function (err) {
                                                var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg ||  i18n.i18nString('adding_as_field_pattern_failed_err');
                                                NotificationService.notify(msg, 'error');
                                                $scope.addFieldPatternSaving = false;
                                            });

                                } else if (type == "action") {

                                    BTActionsService.createFieldPattern(taskId, payload.fieldName, payload)
                                            .then(function (res) {
                                                keyValueSetter($scope.identifiedTask.fieldPatterns, $scope.selectedField.title, res.data);
                                                // $scope.identifiedTask.fieldPatterns[$scope.selectedField.title.toLowerCase()]=res.data;
                                                $scope.addFieldPatternSaving = false;

                                                $scope.newFieldPattern.value = '';
                                            }, function (err) {
                                                var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg ||  i18n.i18nString('adding_as_field_pattern_failed_err');
                                                NotificationService.notify(msg, 'error');
                                                $scope.addFieldPatternSaving = false;
                                            });

                                } else if (type == "dialog") {
                                    var patterns = [];
                                    patterns.push($scope.newFieldPattern.value);
                                    if (entityData.patterns) {
                                        entityData.patterns.map(function (obj) {
                                            patterns.push(obj.original);
                                        });
                                    }

                                    $scope.updatePatterns(entityData._id, patterns, entityData);
                                    return;
                                }
                            }
                            };
                            $scope.deleteFieldPattern = function deleteFieldPattern(pattern, field, entityData, index) {
                                var key = "state";
                                if ($scope.identifiedTask.taskType === 'DialogIntent') {
                                    key = "status";
                                }
                                if ($scope.identifiedTask[key] == "published") {
                                    $scope.currentCb = "addPattern";
                                    $scope.currentPattern = angular.copy(pattern);
                                    $scope.currentField = angular.copy(field);
                                    $scope.currentEntitydata = angular.copy(entityData);
                                    $scope.currnetIndex = angular.copy(index);
                                    NotificationService.alert('', $scope.upgrade, {okText:  i18n.i18nString('upgrade')}, "", undefined,  i18n.i18nString('add_utter_published_noty'));
                                } else{
                                var msg =  i18n.i18nString('do_you_want_to_delete_this_pattern');
                                $rootScope.showConfirmationPopup(msg, confirmDeletePattern);
                                }
                                function confirmDeletePattern() {

                                    var intent = $scope.identifiedTask;
                                    var type = intent._id[0] == 'l' ? "alert" : intent._id[0] == 'd' ? "dialog" : "action";
                                    var context = {};
                                    var patternsToDelete = [];


                                    if (type == "alert") {

                                        context = {
                                            alertId: intent._id,
                                            patternId: pattern.key,
                                            streamId: $scope.stream._id,
                                            fieldName: field.title
                                        };

                                        BTAlertsService.deleteFieldPattern(context)
                                                .then(function (res) {
                                                    $scope.identifiedTask.fieldPatterns[field.title] = _.filter($scope.identifiedTask.fieldPatterns[field.title], function (_pattern) {
                                                        return _pattern.key !== pattern.key;
                                                    });
                                                }, function (err) {

                                                    NotificationService.notify( i18n.i18nString('field_pattern_delete_failed'), "error");

                                                });

                                    } else if (type == "action") {

                                        context = {
                                            actionId: intent._id,
                                            patternId: pattern.key,
                                            streamId: $scope.stream._id,
                                            fieldName: field.title
                                        };

                                        BTActionsService.deleteFieldPattern(context)
                                                .then(function (res) {
                                                    $scope.identifiedTask.fieldPatterns[field.title] = _.filter($scope.identifiedTask.fieldPatterns[field.title], function (_pattern) {
                                                        return _pattern.key !== pattern.key;
                                                    });
                                                }, function (err) {

                                                    NotificationService.notify( i18n.i18nString('field_pattern_delete_failed'), "error");

                                                });

                                    } else if (type == "dialog") {
                                        entityData.patterns.splice(index, 1);
                                        var patterns = [];
                                        if (entityData.patterns) {
                                            entityData.patterns.map(function (obj) {
                                                patterns.push(obj.original);
                                            });
                                        }

                                        $scope.updatePatterns(entityData._id, patterns, entityData, true);
                                        return;
                                    }


                                }
                            };


                            if (!_.isObject($scope.stream) || (_.isObject($scope.stream) && Object.keys($scope.stream).length === 0)) {
                                goBack();
                                return;
                            }


                            $scope.getComponentsByDialogID = function (universalBotStreamId) {
                                var streamId = $workflowService.selectedStream()._id;
                                if($scope.universalbot && $scope.selectedBot) {
                                    var curr_stream = JSON.parse($scope.selectedBot);
                                    streamId = curr_stream._id;
                                }
                                else if($scope.universalbot && universalBotStreamId) {
                                    streamId = universalBotStreamId;
                                }
                                BTFlowtaskService.getFlowtaskComponents(streamId, $scope.identifiedTask._id).then(function (res) {
                                    $scope.identifiedTask.entitiesArray = _.filter(res.data, {type: "entity"}) || [];

                                    var entities = [];
                                    data = angular.copy($scope.intent);

                                    var mergedEntites = _.filter((($scope.identifiedTask && $scope.identifiedTask.entitiesArray) || []), function (item) {
                                        if(data.response.finalResolver && data.response.finalResolver.connectedNodes && data.response.finalResolver.connectedNodes.indexOf(item._id) !== -1){
                                            return _.extend(item, _.findWhere(((data.response.finalResolver.entities && data.response.finalResolver.entities.length && data.response.finalResolver.entities) || []), {componentID: item._id}));
                                        }else{
                                            return _.extend(item, _.findWhere(((data.response.finalResolver.entities && data.response.finalResolver.entities.length && data.response.finalResolver.entities) || []), {componentID: item._id}));   
                                        }
                                        
                                    });

                                    data.response.finalResolver.entities = angular.copy(mergedEntites);
                                    if (data.response.finalResolver.entities) {
                                        data.response.finalResolver.entities.map(function (entity) {
                                            entity.field = entity.field || entity.name;
                                            if (entity.field) {
                                                var obj = {};
                                                obj.name = entity.field;
                                                obj.isArray = entity.isArray || "";
                                                obj._id = entity._id;
                                                obj.type = entity.entityType || entity.metadata || entity.fieldType;
                                                obj.componentId = entity.componentID || entity._id;
                                                obj.value = entity.value;
                                                obj.dataType = entity.entityType;
                                                obj.taskType = entity.taskType;
                                                obj.patterns = entity.patterns;
                                                obj.synonyms = entity.synonyms;
                                                obj.color = entity.color;
                                                obj.class = entity.class;
                                                obj.position = entity.position;
                                                obj.matchInfo = prepareEntityMatchInfo(entity.entityMatchInfo && entity.entityMatchInfo[0]) || {};
                                                entities.push(obj);
                                            }
                                        });
                                    }

                                    data.response.finalResolver.entities = entities;
                                    $scope.intent = data;

                                    ($scope.intent.response.finalResolver.entities || []).map(function (entity, i) {
                                        entity.color = entity.color || "#ddd";
                                    });

                                });
                            };

                            $scope.editEntityType = function (task, field) {
                                $scope.addmeta = {
                                    task: task,
                                    field: field
                                };
                                $scope.openEntity();
                            };

                            $scope.cancelEntity = function () {
                                $timeout(function () {
                                    $('.add-meta').modal('hide');
                                });
                            };

                            $scope.openEntity = function () {
                                $timeout(function () {
                                    $('.add-meta').modal('show');
                                });
                            };

                            $scope.eventHandlers = {
                                onKeyDown: function onKeyDown(event) {
                                    if (event.keyCode == 13 && event.type == 'keydown') {
                                        $timeout($scope.verify);
                                    }
                                }
                            };
                            function decodePattern(msg) {
                                try {
                                    return msg.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                } catch (e) {
                                    return msg;
                                }
                     }
        
                            var prepareTreeData = function(startIndex,treeArray){
                                var depth = treeArray.length - 1;
                                var leaf = [
                                        {
                                            title: treeArray[startIndex]
                                        }
                                    ];
                                if (depth > startIndex) {
                                    leaf[0].tree = prepareTreeData(startIndex+1,treeArray);
                                }
                                if(leaf[0].tree && leaf[0].tree[0]){
                                    leaf[0].tree[0].title = decodePattern(leaf[0].tree[0].title); 
                                }else{
                                    leaf[0].tree = decodePattern(leaf[0].tree);
                                }
                                leaf[0].title=decodePattern(leaf[0].title);
                                return leaf;
                            };

                            $scope.intentRecongnized = false;
                            $scope.runInProgress = false;
                            $scope.verify = function (manualTrigger) {
                                $scope.nlp.text = getNLPText();
                                $(".keyword_highlight").html(getSanitizedText($scope.nlp.text));

                                if (!$scope.nlp.text) {
                                    $scope.showUserSaysError = true;//manualTrigger;
                                    return;
                                }
                                $scope.testing = true;
                                entityColors = {};
                                $scope.utterence = null;
                                $scope.intentNotFound = false;
                                $scope.verifying = false;
                                var payload = {
                                    input: $scope.nlp.text && $scope.nlp.text.trim(),
                                    streamName: $scope.stream.name,
                                    timezone: moment.tz.guess(),
                                    isDeveloper:$workflowService.selectedStreamState() === 'indevelopment'?true:false
                                };
                                if($scope.parentIntent.name && $scope.parentIntent.name !== i18n.i18nString('bot_level_intent_model_label')) {
                                    payload.parentIntent = $scope.parentIntent.name;
                                }
                                $(".testbotscroll").scrollTop(0);
                                $scope.runInProgress = true;
                                $scope.debugInfo[$scope.debugkeys.utteranceSent] = payload;
                                $scope.debuggerConsole.requestData = payload;
                                $scope.identifiedTask = null;
                                BTStreamsService.testNlp($scope.stream._id, payload)
                                        .then(function (res) {
                                            console.log($scope.allDialogTasks);
                                            $scope.trainBotCB.closeEditPanel();
                                            // removing duplicates in winning intent and ranking as well
                                            if(res.data.response && res.data.response.finalResolver && res.data.response.finalResolver.ranking){
                                                res.data.response.finalResolver.ranking = _.uniq(res.data.response.finalResolver.ranking, 'taskId');
                                            }
                                            if(res.data.response && res.data.response.finalResolver && res.data.response.finalResolver.winningIntent){
                                                var winningIntents = [];

                                                 angular.forEach(res.data.response.finalResolver.winningIntent,function(task){
                                                    if(task.activityType === 'FAQ'){
                                                       winningIntents.push(task);
                                                    }else{
                                                       var idx = _.findIndex(winningIntents,function(winningIntent){
                                                                return winningIntent.taskId === task.taskId;
                                                        });
                                                        if(idx === -1){
                                                            winningIntents.push(task);
                                                        }
                                                        
                                                    }
                                                });
                                                res.data.response.finalResolver.winningIntent = winningIntents;
                                            }
                                            
                                            if(res.data.response && res.data.response.finalResolver && res.data.response.finalResolver.winningIntent && res.data.response.finalResolver.winningIntent.length === 1){
                                                if($scope.universalbot) {
                                                    $scope.currUniversalBotStreamId = res.data.response.finalResolver.winningIntent[0].streamId;
                                                    loadingEntities(res.data.response.finalResolver.winningIntent[0].streamId,"false",function(){
                                                        var _obj = {'response':$scope.nlpData};
                                                        $scope.intent = arrangeData(_obj,$scope.currUniversalBotStreamId);
                                                    });
                                                }
                                            }
                                            $scope.nlpData = res.data.response;
                                            if($scope.nlpData) {
                                                $scope.nlpData.input = res.data.input || [$scope.nlp.text];
                                            }
                                            if(res.data && res.data.response && res.data.response.hasOwnProperty('intentRescoring') && !res.data.response.intentRescoring && $scope.stream.type === 'universalbot'){
                                                $scope.nlpData.showIntentRankResolve = true;
                                            }
                                            if(res.data && res.data.response && res.data.response.hasOwnProperty('intentRescoring') && !res.data.response.intentRescoring && $scope.stream.type !== 'universalbot'){
                                                $scope.nlpData.intentRescoringDisabled = true;
                                            }
                                            if(res.data && res.data.response && res.data.response.hasOwnProperty('isPreferDefinitiveMatch') && !res.data.response.isPreferDefinitiveMatch && $scope.stream.type !== 'universalbot'){
                                                $scope.nlpData.isPreferDefinitiveMatchDisabled = true;
                                            }
                                            $scope.trainBotCB.loadData($scope.nlpData);
                                            $scope.showNote = false;
                                            $scope.debuggerConsole.responseData = res.data;
                                            $scope.debugInfo[$scope.debugkeys.utteranceRecieve] = res.data;
                                            //$scope.getTrainLogs(payload);
                                            $scope.chooseTask = "";
                                            $scope.selectedTask = null;
                                            $scope.knowledgeData = {};
                                            $scope.knowledgeData.questions = [];
                                            $scope.richEditorInitialStage = "esc";
                                            $scope.intentVerified = true;
                                            var data = JSON.stringify(res.data);
                                            data = data.replace(/emptystring/g, '');
                                            data = JSON.parse(data);
                                            $scope.intent = arrangeData(data);
                                            /**
                                             * getting request and response from find intent api
                                             */
                                            delete $scope.debugInfo["Intent Match Analysis"];
                                            $scope.debugInfo["Intent Match Analysis"] = $scope.formatIntentMatchData(res.data.response) || [];
                                            $scope.debuggerConsole.requestData = res.data.request;
                                            $scope.debuggerConsole.responseData = res.data.response;
                                            /**
                                             * End of response request read
                                             */
                                            $scope.intent.nlptext = $scope.nlp.text;
                                            $scope.intent.pattern =  i18n.i18nString('intent_identified_based_on_pattern_match');
                                            $scope.verifying = true;
                                            (($scope.intent.response.finalResolver && $scope.intent.response.finalResolver.entities) || []).map(function (entity, i) {
                                                entity.color = "#ddd";
                                            });
                                            if (data.response.finalResolver && data.response.finalResolver.winningIntent && data.response.finalResolver.winningIntent.length > 0 && data.response.finalResolver.winningIntent[0].intent) {
                                                $scope.intentRecongnized = true;
                                                $scope.addTrainBotIntentLogs(payload, data);
                                                $scope.debugInfo[$scope.debugkeys.intentMatch + ' Successful'] = data.response.finalResolver.winningIntent[0].intent;
                                                delete $scope.debugInfo[$scope.debugkeys.intentMatch];
                                                if(data.response.finalResolver.winningIntent[0].activityType === 'smalltalk'){
                                                    var treeArray = data.response.finalResolver.winningIntent[0].graph;
                                                    $scope.tree = prepareTreeData(0,treeArray);
                                                }
                                                if (data.response.finalResolver.winningIntent.length > 1) {
                                                    delete $scope.debugInfo[$scope.debugkeys.intentMatch + ' Successful'];
                                                    $scope.debugInfo[$scope.debugkeys.intentMatch] = 'None';
                                                }
                                                $scope.intentNotFound = false;
                                            } else {
                                                $scope.debugInfo[$scope.debugkeys.intentMatch] = "None";
                                                delete $scope.debugInfo[$scope.debugkeys.intentMatch + ' Successful'];
                                                $scope.intentNotFound = true;
                                            }

                                            $scope.testing = false;
                                            $scope.runInProgress = false;
                                            $scope.multipleIntent = {};
                                            $scope.multipleIntent.selectedTask = "";
                                            if($scope.intent.response && $scope.intent.response.finalResolver && $scope.intent.response.finalResolver.winningIntent && $scope.intent.response.finalResolver.winningIntent[0] && $scope.intent.response.finalResolver.winningIntent[0].matchedPattern){
                                                $scope.intent.response.finalResolver.winningIntent[0].matchedPattern=decodePattern($scope.intent.response.finalResolver.winningIntent[0].matchedPattern);
                                            }
                                            if($scope.nlpData && $scope.nlpData.finalResolver && $scope.nlpData.finalResolver.winningIntent && $scope.nlpData.finalResolver.winningIntent[0] && $scope.nlpData.finalResolver.winningIntent[0].intent){
                                                $scope.nlpData.finalResolver.winningIntent[0].intent=decodePattern($scope.nlpData.finalResolver.winningIntent[0].intent);
                                            }
                                            if($scope.intent.response && $scope.intent.response.finalResolver && $scope.intent.response.finalResolver.winningIntent && $scope.intent.response.finalResolver.winningIntent.length > 1) {
                                                $scope.multipleIntent.selectedTask = "none";
                                            }
                                        }, function (err) {
                                            $scope.debuggerConsole.responseData = err;
                                            $scope.nlp.text = '';
                                            $scope.verifying = false;
                                            $scope.intent = {};
                                            $scope.runInProgress = false;
                                            $scope.testing = false;
                                            if(err && err.data && err.data.errors && err.data.errors.length && err.data.errors[0] && err.data.errors[0].code && err.data.errors[0].code === 4291){
                                                return ;
                                            }else{
                                            var msg = getErrorMsg(err,  i18n.i18nString('nlp_verification_failed'));
                                            NotificationService.notify(msg, "error");
                                            }
                                        });
                            };

                            /*$scope.getTrainLogs = function (payload) {

                                BTStreamsService.getTrainLogs($scope.stream._id, payload)
                                        .then(function (res) {
                                            delete $scope.debugInfo["Intent Match Analysis"];
                                            $scope.debugInfo["Intent Match Analysis"] = $scope.formatIntentMatchData(res.data.response) || [];
                                            $scope.debuggerConsole.requestData = res.data.request;
                                            $scope.debuggerConsole.responseData = res.data.response;
                                        }, function (err) {

                                        });
                            };*/

                            $scope.formatIntentMatchData = function (intentMatchLogs) {

                                var intentMatchData = intentMatchLogs.intentMatch || [];

                                // if(($scope.intent && $scope.intent.intent && $scope.intent.intent.length > 0 && $scope.intent.intent[0].type == 'FAQ')){
                                //     return intentMatchData;
                                // }

                                var _tempIntentMatchData = [];

                                function modifyObject(key1, key2, value, data) {

                                    if (!data[value]) {
                                        return;
                                    }

                                    if (key2) {
                                        data[key1] = data[key1] || {};
                                        data[key1][key2 + " (" + data[value].debugTitle.slice(data[value].debugTitle.indexOf(":") + 2) + ") "] = data[value];

                                    } else if (!key2) {
                                        data[key1] = data[value];
                                    }

                                    if (value == "taskNameAnalysis") {
                                        var _wordBreakDown = data[value].wordBreakdown || [];
                                        var _wordBreakDownTemp = [];

                                        $.each(_wordBreakDown, function (i, wordBreak) {
                                            var serializedString = Object.keys(wordBreak).map(function (k) {
                                                return k + ": " + wordBreak[k];
                                            }).join(", ");
                                            _wordBreakDownTemp[serializedString] = undefined;
                                        });

                                        data[value].wordBreakdown = _wordBreakDownTemp;
                                        data[key1][key2 + " (" + data[value].debugTitle.slice(data[value].debugTitle.indexOf(":") + 2) + ") "] = data[value];

                                    }

                                    if (key2) {
                                        delete data[value].debugTitle;
                                    }

                                    delete data[value];
                                }

                                $.each(intentMatchData, function (i, data) {

                                    modifyObject( i18n.i18nString('machine_modal_classification_score'), "",  i18n.i18nString('ml_score'), data);
                                    modifyObject( i18n.i18nString('rule_engine_score'), "",  i18n.i18nString('total_score'), data);

                                    modifyObject( i18n.i18nString('rules_applied'),  i18n.i18nString('word_scoring_rules'),  i18n.i18nString('word_scoring'), data);
                                    modifyObject( i18n.i18nString('rules_applied'),  i18n.i18nString('bonus_scoring_rules'),  i18n.i18nString('bonus_scoring'), data);
                                    modifyObject( i18n.i18nString('rules_applied'),  i18n.i18nString('penality_scoring_rules'),  i18n.i18nString('penality_scoring'), data);
                                    modifyObject( i18n.i18nString('rules_applied'),  i18n.i18nString('task_naming_rules'),  i18n.i18nString('task_name_analysis'), data);

                                    _tempIntentMatchData["Number of intents matched"] = (intentMatchData || []).length;

                                    if (data.name == ($scope.intent && $scope.intent.intent.length == 1 && $scope.intent.intent[0].name)) {
                                        _tempIntentMatchData[data.name + " (Winning Intent) "] = data;
                                    } else {
                                        _tempIntentMatchData[data.name] = data;
                                    }

                                    delete data.debugTitle;
                                    delete data.foundInSentence;
                                    delete data.activityType;
                                    delete data.type;
                                    delete data.name;




                                });

                                return _tempIntentMatchData;

                            };


                            $scope.addTrainBotIntentLogs = function (payloadData, responseDetails, isFromDone) {
                                var payload = {};
                                if ($scope.callFrom && $scope.callFrom === 'analyzeTrain') {
                                    payload = {
                                        result: "success",
                                        time: Date.now(),
                                        mainbot: "kora",
                                        bot: $workflowService.selectedStream().name,
                                        task: responseDetails.response.finalResolver.winningIntent[0].intent,
                                        input: [payloadData.input],
                                        output: responseDetails.response.finalResolver.winningIntent[0].intent,
                                        server: API_SERVER_URL + API_URL_PREFIX,
                                        userid: $applicationService.userInfo().userId,
                                        botid: $workflowService.selectedStream()._id,
                                        logSequenceId: $scope.analyzerecord.koralogstatusId,
                                        taskId: $scope.analyzerecord.taskId
                                    };
                                    BTStreamsService.trainBotIntentLogs($scope.stream._id, payload)
                                            .then(function (res) {
                                                var data = JSON.stringify(res.data);
                                                data = data.replace(/emptystring/g, '');
                                                data = JSON.parse(data);
                                                $scope.trainbotintent = {};
                                                $scope.trainbotintent.logid = data._id;
                                                if (isFromDone) {
                                                    $scope.trainBot();
                                                }
                                            }, function (err) {

                                            });
                                }
                                else {
                                    payload = [];
                                    responseDetails.response.finalResolver.winningIntent.forEach(function(val){
                                        var obj = {
                                            result: "success",
                                            time: Date.now(),
                                            mainbot: "kora",
                                            bot: $workflowService.selectedStream().name,
                                            task: val.intent,
                                            input: [payloadData.input],
                                            output: val.intent,
                                            server: API_SERVER_URL + API_URL_PREFIX,
                                            userid: $applicationService.userInfo().userId,
                                            botid: $workflowService.selectedStream()._id,
                                            logSequenceId: responseDetails.seqLogId,
                                            taskId: val.taskId
                                        };
                                        payload.push(obj);
                                    });
                                    
                                    BTStreamsService.trainBotIntentBunchLogs($scope.stream._id, payload)
                                            .then(function (res) {
                                                var data = JSON.stringify(res.data);
                                                data = data.replace(/emptystring/g, '');
                                                data = JSON.parse(data);
                                                $scope.trainbotintent = {};
                                                $scope.trainbotintent.logid = data._id;
                                                if (isFromDone) {
                                                    $scope.trainBot();
                                                }
                                            }, function (err) {

                                            });
                                }
                            };

                            $scope.learnInProgress = false;

                            $scope.$watch("nlp.text", function (newVal, oldVal) {
                                if (newVal && newVal.trim()) {
                                    $scope.showUserSaysError = false;
                                    if (!oldVal) {
                                        $scope.richEditorInitialStage = "enter";
                                    }
                                } else {
                                    $scope.clear();
                                    $scope.intentVerified = false;
                                }
                            });

                            $scope.addUtteranceAndTrainBot = function () {

                                if (!$scope.selectedTask) {

                                    return;
                                }
                                if (!($scope.nlp.text && $scope.nlp.text.trim())) {

                                    $scope.showUserSaysError = true;
                                    $(".testbotscroll").scrollTop(0);
                                    return;
                                }

                                if ($scope.selectedTask.taskType === "knowledge") {
                                    if (!$scope.selectedQuestion) {
                                        NotificationService.notify( i18n.i18nString('selected_collection_doesnt_have_faq'), "error");
                                        return;
                                    }
                                    $scope.selectedQuestion.subQuestions.push($scope.nlp.text.trim());
                                    $scope.updateQuestionAnswers();
                                    return;
                                }

                                var payload = {
                                    taskId: $scope.selectedTask.taskType !== "dialog" ? $scope.selectedTask._id : $scope.selectedTask.nodes[0].componentId,
                                    taskName: $scope.selectedTask.name,
                                    sentence: $scope.nlp.text.trim(),
                                    streamId: $scope.stream._id,
                                    type: $scope.selectedTask.taskType !== "dialog" ? $scope.selectedTask.taskType : "DialogIntent"
                                };
                                $scope.ml.utteranceText = "";
                                $scope.learnInProgress = true;
                                BTStreamsService.createUtterances(payload)
                                        .then(function (res) {
                                            mixpanelEvent("createUtterance");
                                             $scope.$emit("updateChecklist", "machineLearningUtterances");
                                            $scope.trainBot();

                                            $scope.learnInProgress = false;
                                            NotificationService.notify( i18n.i18nString('utterance_created_sucess_noty'), "info");
                                        },
                                                function (err) {
                                                    $scope.learnInProgress = false;
                                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                                });
                            };


                            $scope.removeTrainBotIntentLogs = function () {
                                var logids = [];
                                logids.push($scope.trainbotintent.logid);
                                var loader = NotificationService.loader(i18n.i18nString('pleasewait'));
                                BTStreamsService.removeTrainBotIntentLogs($scope.stream._id, logids)
                                        .then(function (res) {
                                            loader();
                                            var responseData = {"_id": null, "name": null, "intent": [{"name": null}], "Entities": [],"response":{'finalResolver':{'winningIntent':[]}}};
                                            var data = JSON.stringify(responseData);
                                            data = data.replace(/emptystring/g, '');
                                            data = JSON.parse(data);
                                            $scope.identifiedTask = null;
                                            $scope.intent = arrangeData(data);
                                            $scope.intent.nlptext = $scope.nlp.text;
                                            $scope.intent.pattern = i18n.i18nString('intent_identified_based_on_pattern_match');
                                            $scope.verifying = true;
                                            ($scope.intent.response.finalResolver.entities || []).map(function (entity, i) {
                                                entity.color = "#ddd";
                                            });
                                            $scope.testing = false;

                                            $scope.nlp.text = getNLPText();
                                            $(".keyword_highlight").html(getSanitizedText($scope.nlp.text));


                                        }, function (err) {
                                            loader();
                                        });
                            };

                            function getSanitizedText(text) {

                                text = text || '';


                                text = text.replace(/<img(.+?)\/>/g, '&lt;img $1 /&gt;');
                                // text = text.replace(/<script (.+?)>(.+?)<\/script>/g,'&lt;script$1&gt;$2&lt;/script&gt;');

                                return text.escapeHTML();

                            }


                            String.prototype.escapeHTML = function () {
                                //'&': '&amp;',
                                var escapeTokens = {
                                    '<': '&lt;',
                                    '>': '&gt;',
                                    '"': '&quot;',
                                    "'": '&#x27;'
                                };
                                var htmlTags = /[<>"']/g;
                                return ('' + this).replace(htmlTags, function (match) {
                                    return escapeTokens[match];
                                });
                            };


                            function getNLPText() {
                                return ($(".keyword_highlight").text() && $(".keyword_highlight").text().trim()) || ($scope.nlp.text && $scope.nlp.text.trim()) || $workflowService.nlpText();
                            }



                            $scope.getTextColor = function (value) {
                                if (value == "Not Found" || !value) {
                                    return "#ddd";
                                }
                                return "#999";
                            };

                            $scope.getClassName = function (value)
                            {
                                if (value == "Not Found" || !value) {
                                    return "valuenotmatch";
                                }
                                return "valuematch";
                            };

                            function getColorByEntity(entityName, forMapping) {

                                if (forMapping) {
                                    return (entityColors[entityName] || "");
                                }

                                if (entityColors[entityName]) {
                                    return entityColors[entityName];
                                } else {
                                    entityColors[entityName] = $scope.constants.entityColors[Math.floor(Math.random() * 12) + 1];
                                }

                                return entityColors[entityName];
                            }

                            $scope.getColorByEntity = getColorByEntity;

                            $scope.context.mapColorEntityToWord = mapColorEntityToWord;

                            function mapColorEntityToWord(utterance) {


                                if (utterance.entities && utterance.entities.length) {
                                    var _parentArray = [];
                                    $.each(utterance.entities, function (i, entity) {

                                        var _childArray = [entity.startIndex, entity.endIndex, '<span contenteditable="true" class="spantags" entityIndex="' + i + '" startIndex="' + entity.startIndex + '" endIndex="' + entity.endIndex + '"  entityId="' + entity.entityId + '" style="cursor:pointer;color:' + getColorByEntity(entity.entityName) + '">' + utterance.sentence.substring(entity.startIndex, entity.endIndex) + '</span>'];
                                        _parentArray.push(_childArray);

                                    });

                                    utterance.sentence = getSentenceByEntity(_parentArray, utterance.sentence);
                                    $(".keyword_highlight").html(utterance.sentence);
                                    //    var regEx = new RegExp(" (?![^<]*>)", "gi");
                                    //    utterance.sentence = utterance.sentence.replace(regEx, "&nbsp;");
                                } else {
                                    $(".keyword_highlight").html(utterance.sentence);
                                }



                                function getSentenceByEntity(triplets, str) {

                                    String.prototype.replaceBetween = function (start, end, what) {
                                        return this.substring(0, start + 1) + what + this.substring(end);
                                    };


                                    triplets.sort(function (a, b) {
                                        return b[0] - a[0];
                                    });

                                    for (var ii = 0, triplet; !!(triplet = triplets[ii]); ii++) {
                                        str = str.replaceBetween(triplet[0] - 1, triplet[1], triplet[2]);
                                    }

                                    return str;

                                }


                            }


                            function getUtterances(payload) {
                                var selectedTaskID = $scope.identifiedTask.taskType == "dialog" ? $scope.identifiedTask.nodes[0].componentId : $scope.identifiedTask._id;
                                BTStreamsService.getUtterances(selectedTaskID, 0, 3000)
                                        .then(function (res) {
                                            $scope.utterences = [];
                                            $scope.utterences = $scope.utterences.concat(res.data.Sentences);

                                            $.each($scope.utterences, function (i, utterance) {
                                                if (utterance.sentence == ($scope.nlp.text && $scope.nlp.text.trim())) {
                                                    $scope.utterence = utterance;
                                                    $scope.utterenceCopy = angular.copy(utterance);
                                                    //mapColorEntityToWord($scope.utterence);
                                                    return false;
                                                }
                                            });

                                            if (payload) {

                                                if ($scope.utterence && $scope.utterence._id) {
                                                    if ($scope.utterence.entities && $scope.utterence.entities.length) {
                                                        var isExistingEntityUpdate = false;
                                                        $.each($scope.utterence.entities, function (i, entity) {
                                                            $.each(payload.entities, function (j, payloadEntity) {

                                                                //           if(entity.startIndex == payloadEntity.startIndex && entity.endIndex == payloadEntity.endIndex){
                                                                //         entity.entityId = payloadEntity.entityId;
                                                                //         isExistingEntityUpdate = true;
                                                                //         if(isExistingEntityUpdate){
                                                                //     payload.entities.splice(j,1);
                                                                //     return false;
                                                                // }

                                                                //     }

                                                                if (
                                                                        (entity.startIndex <= payloadEntity.startIndex && entity.endIndex >= payloadEntity.startIndex) || (entity.startIndex <= payloadEntity.endIndex && entity.endIndex >= payloadEntity.endIndex) || (entity.startIndex >= payloadEntity.startIndex && entity.endIndex <= payloadEntity.endIndex) || (entity.startIndex <= payloadEntity.startIndex && entity.endIndex >= payloadEntity.endIndex)
                                                                        ) {
                                                                    delete $scope.utterence.entities[i];
                                                                }

                                                            });


                                                        });


                                                        var tempEntitesArray = $scope.utterence.entities || [];
                                                        tempEntitesArray = _.without(tempEntitesArray, null);
                                                        tempEntitesArray = _.without(tempEntitesArray, undefined);
                                                        payload.entities = [].concat(payload.entities, tempEntitesArray);


                                                        // payload.entities = [].concat(payload.entities, $scope.utterence.entities);
                                                        $scope.utterence = payload;
                                                    } else {
                                                        payload.entities = [].concat(payload.entities, $scope.utterence.entities) || [];
                                                    }

                                                    $scope.editUtterence(payload,true);
                                                } else {
                                                    $scope.addUtterance(payload);
                                                }

                                            }




                                        },
                                                function (err) {
                                                    $scope.fetching = false;
                                                });
                            }

                            $scope.entityCmpt = {};
                            $scope.context.api.mapEntityToWord = function (selectedSentence, entityID) {
                                console.log(selectedSentence);
                                console.log(entityID);
                                var focusedUtterance = $scope.nlp.text && $scope.nlp.text.trim();
                                console.log(focusedUtterance);
                                console.log($scope.entityCmpt.startEndIndex);

                                $.each($scope.intent.response.finalResolver.entities, function (i, intentEntity) {
                                    if (entityID == intentEntity.componentId) {
                                        if (intentEntity.isArray) {
                                            if (intentEntity.value instanceof Array) {
                                                intentEntity.value.push(selectedSentence);
                                            } else {
                                                var value = angular.copy(intentEntity.value);
                                                intentEntity.value = [];
                                                if (value) {
                                                    intentEntity.value.push(value);
                                                }

                                                intentEntity.value.push(selectedSentence);
                                            }

                                        } else {
                                            intentEntity.value = selectedSentence;
                                        }
                                    }
                                });

                                var selectedTaskID = $scope.identifiedTask.taskType == "dialog" ? $scope.identifiedTask.nodes[0].componentId : $scope.identifiedTask._id;
                                var selectedTaskType = $scope.identifiedTask.taskType == "dialog" ? "DialogIntent" : $scope.identifiedTask.taskType;
                                var payload = {
                                    taskId: selectedTaskID,
                                    sentence: focusedUtterance,
                                    streamId: streamId,
                                    taskName: $scope.identifiedTask.name,
                                    type: selectedTaskType
                                };

                                selectedSentence = focusedUtterance.substring($scope.entityCmpt.startEndIndex.start, $scope.entityCmpt.startEndIndex.end);

                                var indexAfterTrim = selectedSentence.length - selectedSentence.trim().length;

                                payload.entities = [];
                                var sentenceEntObject = {
                                    "startIndex": $scope.entityCmpt.startEndIndex.start,
                                    "endIndex": $scope.entityCmpt.startEndIndex.end - indexAfterTrim,
                                    "entityId": entityID
                                };


                                payload.entities.push(sentenceEntObject);

                                if ($scope.utterence) {
                                    if ($scope.utterence.entities && $scope.utterence.entities.length) {
                                        var isExistingEntityUpdate = false;
                                        $.each($scope.utterence.entities, function (i, entity) {

                                            // if(entity.startIndex == sentenceEntObject.startIndex && entity.endIndex == sentenceEntObject.endIndex){
                                            //     entity.entityId = entityID;
                                            //     isExistingEntityUpdate = true;
                                            //     return false;
                                            // }

                                            //  if(!entity){
                                            //     i = i-1;
                                            //     entity = $scope.utterences[$scope.entityCmpt.selectedUtteranceIndex].entities[i];
                                            // }

                                            if (
                                                    (sentenceEntObject.startIndex <= entity.startIndex && sentenceEntObject.endIndex >= entity.startIndex) || (sentenceEntObject.startIndex <= entity.endIndex && sentenceEntObject.endIndex >= entity.endIndex) || (sentenceEntObject.startIndex >= entity.startIndex && sentenceEntObject.endIndex <= entity.endIndex) || (sentenceEntObject.startIndex <= entity.startIndex && sentenceEntObject.endIndex >= entity.endIndex)
                                                    ) {
                                                delete $scope.utterence.entities[i];
                                            }

                                        });

                                        // if(isExistingEntityUpdate){
                                        //     payload.entities = [];
                                        // }

                                        var tempEntitesArray = $scope.utterence.entities || [];
                                        tempEntitesArray = _.without(tempEntitesArray, null);
                                        tempEntitesArray = _.without(tempEntitesArray, undefined);
                                        payload.entities = [].concat(payload.entities, tempEntitesArray);

                                        $scope.utterence = payload;
                                    }
                                } else {
                                    // getUtterances(payload);
                                    // return;
                                    $scope.utterence = payload;
                                }

                                //mapColorEntityToWord($scope.utterence);

                                //saveEditedUtterance(payload);
                            };


                            /*knowledge task related code*/

                            $scope.knowledgeData = {};
                            $scope.knowledgeData.questions = [];


                            $scope.getFaqsByKnowledge = function (knowledgeTaskId) {

                                var searchParam = "";

                                var loader = NotificationService.loader( i18n.i18nString('please_wait_noty'));
                                BTStreamsService.getOrSearchFAQS($applicationService.userInfo.userId, knowledgeTaskId, searchParam, 0, 1000)
                                        .then(function (response) {



                                            loader();

                                            $scope.knowledgeData = $scope.knowledgeData || {};

                                            $.each(response.data.faqs, function (i, questionsObject) {
                                                response.data.faqs[i].subQuestionsToView = [];
                                                response.data.faqs[i].subQuestionsToView.push(response.data.faqs[i].question);
                                                questionsObject.subQuestions = questionsObject.subQuestions || [];
                                                $.each(questionsObject.subQuestions, function (j, subQuestionItem) {
                                                    response.data.faqs[i].subQuestionsToView.push(subQuestionItem);

                                                });

                                                /*for subanswers to view*/
                                                response.data.faqs[i].subAnswersToView = [];
                                                response.data.faqs[i].subAnswersToView.push(response.data.faqs[i].answer);
                                                questionsObject.subAnswers = questionsObject.subAnswers || [];
                                                $.each(questionsObject.subAnswers, function (j, subAnswerItem) {
                                                    response.data.faqs[i].subAnswersToView.push(subAnswerItem);

                                                });

                                            });


                                            $scope.knowledgeData.questions = response.data.faqs;



                                        });
                            };


                            $scope.updateQuestionAnswers = function () {


                                var qaObject = {
                                    "question": $scope.selectedQuestion.question,
                                    "answer": $scope.selectedQuestion.answer,
                                    "_id": $scope.selectedQuestion._id,
                                    "knowledgeTaskId": $scope.selectedTask._id,
                                    "subQuestions": $scope.selectedQuestion.subQuestions,
                                    "subAnswers": $scope.selectedQuestion.subAnswers,
                                    "streamId": $workflowService.selectedStream()._id
                                };




                                $scope.learnInProgress = true;
                                BTStreamsService.updateFAQ($applicationService.userInfo().userId, qaObject, qaObject._id)
                                        .then(function (response) {
                                            response.data.subQuestionsToView = response.data.subQuestionsToView || [];
                                            angular.copy(response.data.subQuestions, response.data.subQuestionsToView);
                                            response.data.subQuestionsToView.unshift(response.data.question);

                                            response.data.subAnswersToView = response.data.subAnswersToView || [];
                                            angular.copy(response.data.subAnswers, response.data.subAnswersToView);
                                            response.data.subAnswersToView.unshift(response.data.answer);



                                            $scope.trainBot();
                                            $scope.learnInProgress = false;

                                            $scope.selectedQuestion = response.data;

                                            var index = "";

                                            $.each($scope.knowledgeData.questions, function (i, questonsData) {
                                                if ($scope.selectedQuestion._id === questonsData._id) {
                                                    index = i;
                                                    $scope.knowledgeData.questions[i] = $scope.selectedQuestion;
                                                }
                                            });

                                            console.log($scope.knowledgeData.questions);
                                            $('#select3').select2('data', index);
                                            console.log($('#select3').select2('data'));
                                            $timeout(function () {
                                                $('#select3').trigger("change");
                                            });

                                            NotificationService.notify( i18n.i18nString('question_and_answers_updated_sucess'), "success");
                                        }, function (res) {

                                            $scope.learnInProgress = false;

                                            $scope.selectedQuestion.subQuestions.splice($scope.selectedQuestion.subQuestions.length - 1, 1);

                                            var $pickQuestionID = $("#select3");
                                            console.log($pickQuestionID.select2('data'));
                                            $pickQuestionID.select2('data', "");
                                            $timeout(function () {
                                                $pickQuestionID.trigger('change');
                                            });


                                            NotificationService.notify(res.data.errors[0].msg, 'error');
                                        });


                            };

                            $scope.selectQuestion = function (question) {
                                if (question || question === 0) {
                                    question = $scope.knowledgeData.questions[question];
                                    $scope.selectedQuestion = question;
                                }
                            };

                            /*End of knowledge task related code*/
                            $scope.selecTask = function (task) {
                                setTimeout(function () {
                                    $scope.selectedTask = JSON.parse(task);
                                    if ($scope.selectedTask.taskType === "knowledge") {

                                        $timeout(function () {
                                            $scope.closeTrainBotModal($scope.ktData);
                                            $scope.$emit("openOntology");
                                        }, 100);

                                        // $scope.getFaqsByKnowledge($scope.selectedTask._id);
                                        return;
                                    } else {
                                        $scope.knowledgeData.questions = [];
                                        $scope.selectedQuestion = null;
                                        $scope.$broadcast("reloadML");
                                    }
                                }, 70);
                            };
                            $scope.openOntology = function(){
                                $timeout(function () {
                                            $scope.closeTrainBotModal($scope.ktData);    
                                            $scope.$emit("openOntology");
                                        }, 100);
                            };
                            $scope.selectIntentFromMultiple = function(taskId) {
                                if(taskId === 'none') {
                                   $scope.selectedTask = null;
                                   $scope.chooseTask = "";
                                }
                                else {
                                    $scope.selectedTask = null;
                                    $scope.chooseTask = "";
                                    $scope.tasksByType.forEach(function(eachTask,index){
                                        for(var i=0;i<eachTask.tasks.length;i++) {
                                            if(eachTask.tasks[i]._id === taskId) {
                                                $scope.chooseTask = JSON.stringify(eachTask.tasks[i]);
                                                $scope.selecTask($scope.chooseTask); 
                                            }
                                        }
                                    });
                                }
                            };
                            $scope.selectBot = function (bot) {
                                if($scope.universalbot) {
                                    loadingEntities(JSON.parse(bot)._id,"true");
                                }
                                else{
                                    loadingEntities(JSON.parse(bot)._id);
                                }
                            };
                            $scope.selectUniversalBot = function(taskId, streamId) {
                              loadingEntities(streamId,"false",function(){
                                  $scope.selectIntentFromMultiple(taskId);
                              });
                            };


                            $scope.$watch('tasks', function (newVal, oldVal) {
                                saveSynonymAtBot(newVal);
                            }, true);


                            $scope.saveEntity = function () {
                                var task = $scope.tasks.filter(function (task) {
                                    return task.name == $scope.addmeta.task;
                                })[0];
                                var id = task._id, payload;
                                if (task.alertFieldsDefinition) {
                                    task.alertFieldsDefinition.map(function (field) {
                                        if (field.title === $scope.addmeta.field) {
                                            field.metadata = $scope.addmeta.metadata;
                                        }
                                    });
                                    payload = {
                                        alertFieldsDefinition: task.alertFieldsDefinition,
                                        allowEdit: true
                                    };
                                    BTAlertsService.createBTAlertUp(id, payload)
                                            .then(function (res) {
                                                $scope.cancelEntity();
                                                NotificationService.notify( i18n.i18nString('entity_type_added_sucess_noty'), "success");
                                            }, function (err) {
                                                var msg = getErrorMsg(err,  i18n.i18nString('synonyms_adding_failed'));
                                                NotificationService.notify(msg, "error");
                                            });
                                } else {
                                    task.payloadField.map(function (field) {
                                        if (field.title === $scope.addmeta.field) {
                                            field.metadata = $scope.addmeta.metadata;
                                        }
                                    });
                                    task.queryField.map(function (field) {
                                        if (field.title === $scope.addmeta.field) {
                                            field.metadata = $scope.addmeta.metadata;
                                        }
                                    });
                                    payload = {
                                        payloadField: task.payloadField,
                                        queryField: task.queryField,
                                        allowEdit: true
                                    };
                                    BTActionsService.updateBTAction(id, payload)
                                            .then(function (res) {
                                                $scope.cancelEntity();
                                                NotificationService.notify( i18n.i18nString('entity_type_added_sucess_noty'), "success");
                                            }, function (err) {
                                                var msg = getErrorMsg(err, i18n.i18nString('synonyms_adding_failed'));
                                                NotificationService.notify(msg, "error");
                                            });
                                }
                            };

                            function saveSynonymAtBot(newVal) {

                                newVal.map(function (task, i) {
                                    var oldTask = $scope.oldTasks[i];
                                    var fields = compareSynonyms(oldTask, task);
                                    if (fields.length > 0) {
                                        var payload = {};
                                        fields.map(function (field) {
                                            var name = getFieldName(field, task);
                                            if (name) {
                                                payload[name] = task.fieldSynonyms[field];
                                            }
                                        });
                                        Object.keys(payload).map(function (fieldName) {
                                            triggerFieldSynonymSave(task._id, fieldName, payload[fieldName]);
                                        });
                                    }
                                });
                            }
                            function compareSynonyms(source, destination) {
                                var keys = [];
                                source.fieldSynonyms = source.fieldSynonyms || {};
                                destination.fieldSynonyms = destination.fieldSynonyms || {};
                                Object.keys(destination.fieldSynonyms).map(function (key) {
                                    source.fieldSynonyms[key] = source.fieldSynonyms[key] || [];
                                    destination.fieldSynonyms[key] = destination.fieldSynonyms[key] || [];
                                    if (source.fieldSynonyms[key].join(',') != destination.fieldSynonyms[key].join(',')) {
                                        keys.push(key);
                                    }
                                });
                                return keys;
                            }
                            function getFieldName(field, task) {
                                var name;
                                for (var i = 0; i < task.fields.length; i++) {
                                    if (task.fields[i].title.toLowerCase() == field) {
                                        return task.fields[i].title;
                                    }
                                }
                                return name;
                            }
                            function triggerFieldSynonymSave(taskId, fieldName, synonyms) {
                                var payload = {}, deferred = $q.defer();
                                var type = taskId[0] == 'l' ? "alert" : taskId[0] == 'l' ? "dialog" : "action";
                                synonyms = synonyms.map(function (synonym) {
                                    return (synonym || '').toLowerCase();
                                });
                                payload[fieldName] = synonyms;
                                if (type === "alert") {
                                    return BTStreamsService
                                            .createAlertFieldSynonyms(taskId, fieldName, payload)
                                            .then(function (res) {
                                                $scope.oldTasks = clone($scope.tasks);
                                                return deferred.resolve();
                                            }, function (err) {
                                                return deferred.resolve();
                                            });
                                } else if (type === "action") {
                                    return BTStreamsService
                                            .createActionsFieldSynonyms(taskId, fieldName, payload)
                                            .then(function (res) {
                                                $scope.oldTasks = clone($scope.tasks);
                                                return deferred.resolve();
                                            }, function (err) {
                                                return deferred.resolve();
                                            });
                                }
                            }

                            $scope.clear = function clear() {
                                $scope.nlp = {
                                    text: ''
                                };
                                $scope.intent = {};
                                $scope.verifying = false;
                                $scope.testing = false;
                                $scope.intentNotFound = false;
                                $scope.selectedTask = null;
                                $scope.knowledgeData = {};
                                $scope.knowledgeData.questions = [];
                                $scope.identifiedTask = null;
                                $scope.utterence = null;
                            };

                            function getDate(timestamp) {
                                var date = new Date(timestamp).toLocaleString();
                                var dateOnly = date.split(", ")[0];
                                dateOnly = dateOnly.replace(/\//g, '-');
                                return moment(dateOnly).format('MM-DD-YYYY');
                            }
                            function getTime(timestamp) {
                                if (!timestamp) {
                                    return "---";
                                }
                                var dateStr = new Date(timestamp).toLocaleString().split(", ")[1];
                                return dateStr.split(":")[0] + ":" + dateStr.split(":")[1] + " " + dateStr.split(" ")[1];
                            }
                            $scope.trainBotCB.getEntityValue = function (entityObject) {

                                var entityValue = entityObject.value;

                                if ((!entityValue && entityValue !== 0) || (typeof entityValue === "undefined") || (entityValue === undefined) ) {
                                    return "Not Found";
                                }

                                if (entityValue instanceof Array) {
                                    if(entityObject.fieldType == "currencyv2" || entityObject.type == "currencyv2"){
                                        var res = (entityValue[0][0].amount).toLocaleString('en-US', {style: 'currency', currency: entityValue[0][0].code});
                                        return res;
                                        //return res[0]+""+entityValue[0].amount;
                                    }
                                    if(entityValue[0] instanceof Array){
                                        return entityValue.join(",");
                                    }else if(entityValue[0] instanceof Object){
                                        return Object.values(entityValue[0]).join(",");
                                    }
                                    return entityValue.join(",");
                                } else if (entityValue instanceof Object) {
                                    if (entityObject.fieldType == "location" || entityObject.type == "location") {
                                        entityValue = entityValue.formatted_address;
                                    }
                                    else if (entityObject.fieldType == "country" || entityObject.type == "country") {
                                        entityValue = entityValue.shortName;
                                    }
                                    else {
                                        entityValue = entityValue[(Object.keys(entityValue))];
                                    }
                                    return entityValue;
                                } 
                                else if(entityObject.type === "date") {
                                    var date = new Date(entityObject.value);
                                    return moment(date).format('MM-DD-YYYY');
                                }
                                else if(entityObject.type === "datetime") {
                                    return getDate(entityObject.value)+" "+getTime(entityObject.value);
                                }
                                else {
                                    return entityValue;
                                }

                            };

                            $scope.isEntity = function(task) {
                                if(task._id) {
                                    return task._id.indexOf("dc")!==-1;
                                }
                                return false;
                            };

                            $scope.initializePopover = function(id,index){
                                var _id  = '#'+id;
                                if((index !== undefined) && (index !== null)){
                                    _id = _id+ index;
                                }
                                setTimeout(function(){
                                     $(_id).popover();
                                },200);
                            };

                            function arrangeData(data, universalBotStreamId) {
                                data = angular.copy(data);
                                if (data.response.finalResolver && data.response.finalResolver.winningIntent && data.response.finalResolver.winningIntent.length && data.response.finalResolver.winningIntent[0] && data.response.finalResolver.winningIntent[0].taskId && $scope.tasks) {
                                    var _index = _.findIndex($scope.tasks, function (task) {
                                        /*task.name === intent.name || */  /* When faq is identified by dialog we need to consider linkedDialogID rather than taskid since taskid refers to knowledge task id*/
                                        if(!data.response.finalResolver.winningIntent[0].linkedDialog){
                                           return (task._id === data.response.finalResolver.winningIntent[0].taskId); 
                                        }else if(data.response.finalResolver.winningIntent[0].linkedDialog && data.response.finalResolver.winningIntent[0].showfaqDialog === 'dialog'){
                                            return (task._id === data.response.finalResolver.winningIntent[0].linkedDialogID); 
                                        }else if(data.response.finalResolver.winningIntent[0].linkedDialog && data.response.finalResolver.winningIntent[0].showfaqDialog === 'faq'){
                                            return (task._id === data.response.finalResolver.winningIntent[0].taskId); 
                                        }
                                        
                                    });
                                    if (_index > -1) {
                                        $scope.identifiedTask = $scope.tasks[_index];
                                        if ($scope.identifiedTask.taskType == "dialog") {
                                            $scope.getComponentsByDialogID(universalBotStreamId);
                                        }
                                        //getUtterances();

                                        //return;//currently supports one intent
                                    }
                                }
                                /*if (data.intent) {
                                 data.intent.map(function (intent) {
                                 if (intent.name && $scope.tasks) {
                                 var _index = _.findIndex($scope.tasks, function (task) {
                                 return (task._id === intent.taskId);
                                 });
                                 if (_index > -1) {
                                 $scope.identifiedTask = $scope.tasks[_index];
                                 if ($scope.identifiedTask.taskType == "dialog") {
                                 $scope.getComponentsByDialogID();
                                 }
                                 //getUtterances();
                                 
                                 return;//currently supports one intent
                                 }
                                 }
                                 });
                                 
                                 }*/

                                var entities = [];
                                if ($scope.identifiedTask && $scope.identifiedTask.taskType !== "dialog") {

                                    var mergedEntites = _.map((($scope.identifiedTask && $scope.identifiedTask.entitiesArray) || []), function (item) {
                                        return _.extend(item, _.findWhere(((data.response.finalResolver.entities && data.response.finalResolver.entities.length && data.response.finalResolver.entities) || []), {field: item.title}));
                                    });

                                    data.response.finalResolver.entities = angular.copy(mergedEntites);
                                    if (data.response.finalResolver.entities) {
                                        data.response.finalResolver.entities.map(function (entity) {
                                            entity.field = entity.field || entity.title;
                                            if (entity.field) {
                                                var obj = {};
                                                obj.name = entity.field;
                                                entity._id = entity.key;
                                                obj.type = entity.metadata || entity.type || entity.fieldType;
                                                obj.isArray = entity.isMultiSelect || "";
                                                obj.componentId = entity.componentID || entity.key;
                                                //obj.type = entity.type;
                                                obj.value = entity.value;
                                                obj.dataType = entity.type || entity.entityType || entity.metadata || entity.fieldType;
                                                obj.taskType = entity.taskType;
                                                entities.push(obj);

                                            }
                                        });
                                    }

                                    data.response.finalResolver.entities = entities;
                                }


                                return data;
                            }
                            function clone(obj) {
                                return JSON.parse(JSON.stringify(obj));
                            }
                            $scope.dialogTasksData=[];
                            function loadingEntities(id,verifyCB,arrangeDataCB) {
                                $scope.tasks = [];
                                var tasksArray = [];
                                $scope.oldTasks = [];
                                var prepareTaskData = function(res){
                                            
                                    $workflowService.alertTasks(res[0].data);
                                    $workflowService.actionTasks(res[1].data);
                                    $scope.allDialogTasks = res[2].data;
                                    //$workflowService.dialogTasks(res[2].data);
                                    res[0].data = res[0].data.map(function (task) {
                                        if (_.isArray(task.alertFieldsDefinition)) {
                                            task.fields = _.clone(task.alertFieldsDefinition || []);
                                        } else if (_.isArray(task.payloadField) && _.isArray(task.queryField)) {
                                            task.fields = (task.payloadField || []).concat(task.queryField);
                                        }
                                        task.taskType = "alert";
                                        return task;
                                    });
                                    res[1].data = res[1].data.map(function (task) {
                                        if (_.isArray(task.alertFieldsDefinition)) {
                                            task.fields = _.clone(task.alertFieldsDefinition || []);
                                        } else if (_.isArray(task.payloadField) && _.isArray(task.queryField)) {
                                            task.fields = (task.payloadField || []).concat(task.queryField);
                                        }
                                        task.taskType = "action";
                                        return task;
                                    });

                                    res[2].data = res[2].data.map(function (task) {
                                        if (_.isArray(task.alertFieldsDefinition)) {
                                            task.fields = _.clone(task.alertFieldsDefinition || []);
                                        } else if (_.isArray(task.payloadField) && _.isArray(task.queryField)) {
                                            task.fields = (task.payloadField || []).concat(task.queryField);
                                        }
                                        task.taskType = "dialog";
                                        return task;
                                    });
                                    if(res && res[2].data) {
                                        var state = $workflowService.selectedStreamState();
                                        $scope.dialogIntents = _.filter(res[2].data,function(task){
                                            if(state === 'published') {
                                                return ((task.state === 'published') || (task.state === 'suspended'));
                                            } else {
                                                return ((task.state === 'configured') || (task.state === 'awaitingApproval'));
                                            }
                                        });
                                    }
                                      $scope.dialogTasksData = res[2].data;
                                    $scope.ktData = angular.copy(res[4].data);
                                    res[4].data = res[4].data.map(function (task) {
                                        task.taskType = "knowledge";
                                        return task;
                                    });


                                    $.each(res[0].data, function (i, alertTask) {
                                        alertTask.entitiesArray = alertTask.alertFieldsDefinition;
                                    });

                                    $.each(res[1].data, function (i, actionTask) {
                                        actionTask.entitiesArray = [].concat(actionTask.payloadField, actionTask.queryField);
                                    });



                                    tasksArray = tasksArray.concat(res[0].data);
                                    tasksArray = tasksArray.concat(res[1].data);
                                    tasksArray = tasksArray.concat(res[2].data);
                                    tasksArray = tasksArray.concat(res[4].data);
                                    
                                    $scope.tasks = tasksArray;

                                    //    $scope.tasks = $scope.tasks.map(function (task) {
                                    //     if (_.isArray(task.alertFieldsDefinition)) {
                                    //         task.fields = _.clone(task.alertFieldsDefinition || []);
                                    //     } else if (_.isArray(task.payloadField) && _.isArray(task.queryField)) {
                                    //         task.fields = (task.payloadField || []).concat(task.queryField);
                                    //     }
                                    //     return task;
                                    // });

                                    //    patterns


                                    $scope.tasks.map(function (task) {
                                        delete task.task_patterns;
                                    });
                                    var alertTasks = [];
                                    var actionTasks = [];
                                    var dialogTasks = [];
                                    var knowledgeTasks = [];
                                    res[3].data.map(function (pattern) {
                                        var obj = {};
                                        Object.keys(pattern).map(function (key) {
                                            if (key === "resourceId") {
                                                obj._id = pattern.resourceId;
                                            } else {
                                                obj.name = key;
                                                obj.patterns = pattern[key];
                                            }
                                        });

                                        $scope.tasks.map(function (task) {
                                            if (task._id === obj._id) {
                                                task.task_patterns = ng.copy(obj.patterns);
                                            }
                                            //field patterns
                                            var patterns = [];
                                            Object.keys(task.fieldPatterns || {})
                                                    .map(function (field) {
                                                        patterns.push({
                                                            key: task.fieldPatterns[field].map(function (pattern) {
                                                                return pattern.key;
                                                            }),
                                                            fieldName: field,
                                                            value: task.fieldPatterns[field].map(function (pattern) {
                                                                return pattern.value;
                                                            }),
                                                            oldPatterns: task.fieldPatterns[field]
                                                        });
                                                    });
                                            task.field_patterns = patterns;
                                            task.fieldPatterns = task.fieldPatterns || {};


                                        });

                                    });
                                    $.each($scope.tasks, function (i, task) {
                                        if (task.hasOwnProperty('parentId')) {
                                            $scope.upgradedTasks.push(task.parentId);
                                        }
                                    });
                                    $.each($scope.tasks, function (i, task) {
                                        $.each($scope.upgradedTasks, function (j, upgradedId) {
                                            if (task._id === upgradedId) {
                                                task.isParent = true;
                                            }
                                        });
                                    });
                                    $scope.tasks.map(function (task) {
                                        if (task.taskType === "alert" && task.state !== "inProgress" && !task.isParent) {
                                            alertTasks.push(task);
                                        } else if (task.taskType === "action" && task.state !== "inProgress" && !task.isParent) {
                                            actionTasks.push(task);
                                        } else if (task.taskType === "knowledge" && !task.isParent) {
                                            knowledgeTasks.push(task);
                                        } else if (task.taskType === "dialog" && !task.isParent){
                                            dialogTasks.push(task);
                                        }
                                    });
                                    
                                    $scope.tasksByType = [];
                                    if (alertTasks.length) {
                                        $scope.tasksByType.push({type:  i18n.i18nString('alert_tasks'), tasks: alertTasks});
                                    }
                                    if (actionTasks.length) {
                                        $scope.tasksByType.push({type: i18n.i18nString('constants.actions'), tasks: actionTasks});
                                    }
                                    if (dialogTasks.length) {
                                        $scope.tasksByType.push({type:  i18n.i18nString( 'ddval_dialog'), tasks: dialogTasks});
                                    }
                                    if (knowledgeTasks.length) {
                                        var _tempTasks = [];
                                        knowledgeTasks.forEach(function(task){
                                            _tempTasks.push({'_id':task._id, name:  i18n.i18nString( 'to_train_your_knowledge_desc'), taskType:  i18n.i18nString( 'knowledge_label')});
                                        });
                                        $scope.tasksByType.push({type:  i18n.i18nString( 'knowledge_collection_label'),knowledgeTasks:knowledgeTasks, tasks: _tempTasks});
                                    }

                                    $scope.oldTasks = clone($scope.tasks);
                                    if(verifyCB == "true"){
                                        $scope.verify();
                                    }
                                    if($scope.cb && $scope.cb.onTasksLoaded){
                                        $scope.cb.onTasksLoaded();
                                    }
                                    if(arrangeDataCB) {
                                        arrangeDataCB();
                                    }
                                };
                                /*knowledge task related*/
                                var requestData = {"streamId": id};
                                 if($scope.callFrom === 'analyzeTrain'){
                                    $q.all([BTStreamsService.getPatterns(id)])
                                    .then(function (response) {
                                    
                                    var res = [];
                                   var alertData ={
                                       data: $workflowService.alertTasks()
                                   };
                                   var actionData = {
                                       data:   $workflowService.actionTasks()
                                   };
                                   var dialogTasks= {
                                       data:$workflowService.dialogTasks()
                                   };
                                 
                                   var KnowledegData = {
                                       data: $workflowService.knowledgeTasks()
                                   };
                                   res.push(alertData);
                                   res.push(actionData);
                                   res.push(dialogTasks);
                                   if(response && response.length && response[0]){
                                   var patternsData = response[0];
                                   res.push(patternsData);
                                   }
                                   res.push(KnowledegData);
                                   prepareTaskData(res);
                                    });
                           
                                   

                                 }else{
                                $q.all([BTAlertsService.getAlerts(id), BTActionsService.getActions(id), BTFlowtaskService.getFlowtaksByState(id), BTStreamsService.getPatterns(id), BTStreamsService.getAllKtsList($applicationService.userInfo().userId, requestData)])
                                        .then(function (res) {
                                            prepareTaskData(res);
                                        });
                                }
                            }


                            $scope.$on("checkAndRemoveUtterance", function (evt, id) {
                                if ($scope.utterence._id == id) {
                                    $scope.utterence = null;
                                }
                            });
                            $scope.startTrain = function() {
                                $scope.trainBot('intentNotMatch');
                            };

                            $scope.isLearnSuccess = false;
                            $scope.learnSuccessStatus = false;
                            $scope.trainBot = function (from) {
                                $scope.trainFrom = 'intentMatch';
                                if(from) {
                                    $scope.trainFrom = 'intentNotMatch';
                                }
                                var selectedTaskType = ($scope.selectedTask && $scope.selectedTask.taskType) || ($scope.identifiedTask && $scope.identifiedTask.taskType);

                                if (selectedTaskType === "knowledge") {
                                    BTStreamsService.trainFaq($workflowService.selectedStream()._id)
                                            .then(function (res) {
                                                $scope.isLearnSuccess = true;
                                                $scope.learnSuccessStatus = true;
                                                $timeout(function () {
                                                    $scope.learnSuccessStatus = false;
                                                }, 1000);
                                                $rootScope.$emit('triggerAutoTrainStatusPoll');
                                                NotificationService.notify( i18n.i18nString('knowledge_task_utterance_trained_initiated_noty'), "info");
                                            },
                                                    function (err) {
                                                        if (err.data.errors.length > 0) {
                                                            NotificationService.notify(err.data.errors[0].msg, "error");
                                                        } else {
                                                            NotificationService.notify( i18n.i18nString('problem_in_training_knowledge_task_noty'), "error");
                                                        }
                                                        $scope.$broadcast("trainFinished");
                                                    });
                                    return;
                                }


                                BTStreamsService.trainUtterances($workflowService.selectedStream()._id)
                                        .then(function (res) {
                                            $scope.isLearnSuccess = true;
                                            $rootScope.$emit('triggerAutoTrainStatusPoll');
                                            NotificationService.notify(i18n.i18nString('utterance_train'), "info");
                                        },
                                                function (err) {
                                                    if (err.data.errors.length > 0) {
                                                        NotificationService.notify(err.data.errors[0].msg, "error");
                                                    } else {
                                                        NotificationService.notify( i18n.i18nString('problem_in_training_knowledge_task_noty'), "error");
                                                    }
                                                    $scope.$broadcast("trainFinished");
                                                });
                            };
                            function updateTrainedInfo(task) {
                                task.trained = true;
                                var payload = {'trained': task.trained, 'index': task._index};
                                BTStreamsService.updateAnalyzeRecord($scope.stream._id, task._id, payload).then(function (res) {
                                    NotificationService.notify( i18n.i18nString('utterance_trained_information_updated_sucess_noty'), 'success');
                                }, function (error) {
                                    if (error && error.data && error.data.errors) {
                                        var _msg = error.data.errors[0].msg;
                                        NotificationService.notify(_msg, 'error');
                                    } else if (error.errors && _.isArray(error)) {
                                        var msg = error.errors[0].msg;
                                        NotificationService.notify(msg, 'error');
                                    } else {
                                        NotificationService.notify( i18n.i18nString('error_handle'), 'error');
                                    }
                                });
                            }
                            $rootScope.$on('clearTestTrainText', function($evenr){
                                $scope.nlp.text = "";
                            });
                            $rootScope.$on('TestTrainUtterencesTrainFinished', function ($event) {
                                finishSaving('.utteranceInput');
                                if($scope.callFrom && $scope.callFrom === 'analyzeTrain') {
                                    updateTrainedInfo($scope.analyzerecord);
                                }
                                if($scope.trainFrom === 'intentNotMatch'){
                                    $scope.trainFrom = "";
                                    $scope.$broadcast("trainFinished");
                                    return;
                                }
                                if (!$scope.nlp.text && $scope.nlp.text.trim()) {
                                    return;
                                }
                                else {
                                    $scope.verify();
                                }
                            });

// Utterance Save related code
                            function startSaving() {
                                $scope.uSaveInProgress = true;
                            }

                            function finishSaving() {
                                $scope.uSaveInProgress = false;
                            }

                            $scope.saveOrUpdateUtterance = function (options,value) {
                                var _streamId;
                                if (!$scope.nlp.text && $scope.nlp.text.trim()) {
                                    return;
                                }
                                if($scope.stream.type === 'universalbot'){
                                    _streamId = $scope.intent.response.finalResolver.winningIntent[0].streamId;
                                }else{
                                    _streamId = $workflowService.selectedStream()._id;
                                }

                                $scope.publishedMode = false;
                                var selectedTaskID = $scope.identifiedTask.taskType == "dialog" ? $scope.identifiedTask.nodes[0].componentId : $scope.identifiedTask._id;
                                if ($scope.identifiedTask.isPublishedVersion && !value) {
                                    $scope.identifiedTask.actualId = $scope.identifiedTask._id ;
                                    $scope.identifiedTask._id = $scope.identifiedTask.parentId;
                                    NotificationService.alert(i18n.i18nString('add_utter_published_noty'), [$scope.upgrade, $scope.cancelUpgrade], { okText: i18n.i18nString('upgrade') }, "", undefined, i18n.i18nString('sure_msg'));
                                    $scope.publishedMode = true;
                                }


                                var payload = {
                                    taskId: selectedTaskID,
                                    sentence: $scope.nlp.text.trim(), //$scope.utterence.sentence,
                                    entities: ($scope.utterence && $scope.utterence.entities) || [],
                                    streamId: _streamId,
                                    type: $scope.identifiedTask.taskType,
                                    taskName: $scope.identifiedTask.name

                                };

                                if (payload.type === "dialog") {
                                    payload.type = "DialogIntent";
                                }
                                $scope.utterence = null;
                                if ($scope.utterence && $scope.utterence._id) {
                                    $scope.editUtterence(payload,true);
                                } else  if(!$scope.publishedMode){
                                    getUtterances(payload);
                                    // $scope.addUtterance(payload);
                                }
                            };

                            $scope.$watchCollection("utterence", function (newVal, oldVal) {
                                var nlpText = $scope.nlp.text && $scope.nlp.text.trim();
                                if (nlpText && $scope.utterence) {

                                    $.each($scope.intent.response.finalResolver.entities, function (i, entity) {

                                        $.each($scope.utterence.entities, function (i, uEntity) {

                                            if ($scope.identifiedTask.taskType == "dialog") {
                                                if (uEntity.entityId == entity._id) {
                                                    // entity.value = nlpText.substring(uEntity.startIndex, uEntity.endIndex);
                                                    // entity.class = "color-circle";
                                                    return;
                                                }

                                            } else {
                                                if (uEntity.entityId == entity._id) {
                                                    // entity.value = nlpText.substring(uEntity.startIndex, uEntity.endIndex);
                                                    // entity.class = "color-circle";
                                                    return;
                                                }
                                            }


                                        });

                                    });

                                }

                            });

                            $scope.$watch("entity", function (oldVal, newVal) {
                                console.log("entity changed");
                            }, true);


                            $scope.$watchCollection("intent.response.finalResolver.entities", function (newVal, oldVal) {
                                var nlpText = $scope.nlp.text && $scope.nlp.text.trim();
                                if (nlpText && $scope.utterence && $scope.utterence._id && $scope.intent.response.finalResolver.entities && $scope.intent.response.finalResolver.entities.length) {

                                    $.each($scope.intent.response.finalResolver.entities, function (i, entity) {

                                        $.each($scope.utterence.entities, function (i, uEntity) {

                                            if ($scope.identifiedTask.taskType == "dialog") {
                                                if (uEntity.entityId == entity._id) {
                                                    entity.value = nlpText.substring(uEntity.startIndex, uEntity.endIndex);
                                                    entity.class = "color-circle";
                                                    return;
                                                }

                                            } else {
                                                if (uEntity.entityId == entity.key) {
                                                    entity.value = nlpText.substring(uEntity.startIndex, uEntity.endIndex);
                                                    entity.class = "color-circle";
                                                    return;
                                                }
                                            }


                                        });

                                    });

                                }

                            });


                            $scope.addUtterance = function (payload) {



                                if ($scope.activeType === "information") {
                                    payload.type = "action";
                                }
                                startSaving('.mainUtteranceInput');

                                BTStreamsService.createUtterances(payload)
                                        .then(function (res) {
                                            mixpanelEvent("createUtterance");
                                             $scope.$emit("updateChecklist", "machineLearningUtterances");
                                            finishSaving('.mainUtteranceInput');
                                            $scope.utterence = res.data;
                                            //mapColorEntityToWord($scope.utterence);
                                            $scope.utterenceCopy = angular.copy($scope.utterence);
                                            $scope.utteranceText = "";
                                            $scope.count++;
                                            NotificationService.notify( i18n.i18nString('utterance_created_sucess_noty'), "info");
                                            $scope.verify();
                                        },
                                                function (err) {
                                                    finishSaving('.mainUtteranceInput', 'error');
                                                    if (err.data && err.data.errors && err.data.errors.length > 0) {
                                                        NotificationService.notify(err.data.errors[0].msg, "error");
                                                    } else {
                                                        NotificationService.notify( i18n.i18nString('problm_in_training_utter_noty'), "error");
                                                    }
                                                });
                            };
                            $scope.editUtterence = function (payload ,dontTrain) {

                                startSaving('.utteranceInput' + $scope.utterence._id);
                                saveEditedUtterance(payload,dontTrain);

                            };

                            function saveEditedUtterance(payload,dontTrain) {
                                BTStreamsService.editUtterances(payload, $scope.utterenceCopy._id).then(function (res) {
                                    NotificationService.notify( i18n.i18nString('utterance_updated_sucess_noty'), "info");
                                    $scope.utterence = res.data;
                                    //mapColorEntityToWord($scope.utterence);
                                    //$scope.verify();
                                    if(!dontTrain){
                                        $scope.trainBot();
                                    }
                                    if(dontTrain){
                                        finishSaving();
                                    }
                                    setTimeout(function () {
                                        $scope.editId = -1;
                                    }, 500);
                                }, function (err) {
                                    if (err.status === 409) {
                                        finishSaving('.utteranceInput' + $scope.utterence._id, 'error');
                                        $scope.utterence.sentence = $scope.utterenceCopy.sentence;
                                        NotificationService.notify( i18n.i18nString('duplicate_utterance'), "error");
                                        setTimeout(function () {
                                            $scope.editId = -1;
                                        }, 500);
                                    }
                                });
                            }

// End of Utterance related code


                            $scope.closeTrainBotModal = function (knowledgetasks) {
                                $(document).off("click.entity");
                                $(document).off("click.train");
//                                $scope.$parent.closeFullPageModal();
//                                $scope.$parent.modalType = 'createBot';
                                if(knowledgetasks[0].state == "configured"){
                                   $workflowService.taskEditInfo(knowledgetasks[0]);
                                }else {
                                    $workflowService.taskEditInfo(knowledgetasks[1]);
                                }
                            };

                            $scope.expand = function expand(index) {
                                $scope.showIndex = $scope.showIndex == index ? -1 : index;
                            };

                            function getErrorMsg(err, defaultMsg) {
                                err = err && err.data;
                                return (err && err.errors && err.errors[0] && err.errors[0].msg) || defaultMsg;
                            }
                            $scope.validateFieldPattern = (function () {
                                return {
                                    test: function (value) {
                                        if (value && (value.split("*").length - 1) === 1) {
                                            return true;
                                        } else {
                                            return false;
                                        }
                                    }
                                };
                            })();

                            function init() {
                                if (parms && parms.log && parms.log.input) {
                                    $scope.nlp.text = parms.log.input[0];
                                    $scope.verify();
                                } else {
                                    $scope.nlp.text = "";
                                    $scope.debugInfo[$scope.debugkeys.utteranceReady] = "";
                                    $scope.showNote = true;
                                }

                                
                            }

                            (function pulldata(id) {
                                init();
                                if (!$scope.universalbot) {
                                    loadingEntities(id);
                                }


                            }(streamId));
                            //used while builder is resuming//
                            
                        }]);

}(angular));

;(function (ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTUtterancesCtrl', ['$scope', '$rootScope', '$translator', '$modalInstance', '$workflowService', 'BTStreamsService', 'config', 'BTFlowtaskService', 'NotificationService', 'mixPanel',
        function ($scope, $rootScope, $translator, $modalInstance, $workflowService, BTStreamsService, config, BTFlowtaskService, NotificationService,mixPanel) {
            function init() {
                $scope.stream = $workflowService.selectedStream();
                $scope.component = config.component.nodeInfo;
                $scope.firstNodeComponentId = config.component.dialogInfo.firstNodeComponentId;
                $scope.saveInProgress = false;
                $scope.utterances = [];
                $scope.utterancesCopy = [];
                getUtterances($scope.component.utterances);
                $scope.enterpriseLicenseType = $rootScope.licenseType;
                $scope.props = {
                    headers: [],
                    params: [],
                    endPoint: {}
                };
                $scope.utterancesCopy = angular.copy($scope.utterances);

            }

            $scope.training = i18n.i18nString('training_label2');
            $scope.train    =    i18n.i18nString('train');


            function getUtterances(utterances) {
                if (utterances) {
                    for (var i = 0; i < utterances.length; i++) {
                        if (utterances[i].sentence === "") {
                            utterances.splice(i, 1);
                            i--;
                        }
                    }
                }
                $scope.utterances = utterances;
                // adding default last utterance empty object
                var obj = {sentence: ""};
                if (!$scope.utterances) {
                    $scope.utterances = [];
                }
                $scope.utterances.push(obj);
            }
            function startSaving(className) {
                $(className).addClass('fa fa-refresh fa-spin');
            }
            function finishSaving(className, isError) {
                $(className).removeClass('fa fa-refresh fa-spin');
                setTimeout(function () {
                    if (isError === 'error') {
                        $(className).addClass('fa fa-times');
                    } else {
                        $(className).addClass('fa fa-check');
                    }
                }, 10);

                setTimeout(function () {
                    $(className).removeClass('fa fa-check fa-times');
                }, 3000);
            }
            function focusElement(initPageload){
                if(initPageload){
                    setTimeout(function () {
                        $('.sentenceInputEle'+($scope.utterances.length-1)).show().focus();
                        $('.sentenceInputEle'+($scope.utterances.length-2)).show().focus();
                    }, 50);
                }
                else{
                    for(var i=0;i<$scope.utterances.length;i++){
                        if($scope.utterances[i].sentence === ""){
                            setTimeout(function () {
                                $('.sentenceInputEle'+i).show().focus();
                            }, 100);
                            break;
                        }
                    }
                    
                }
            }
            setTimeout(function () {
                focusElement(true);
            }, 500);
            
            $scope.addUtterance = function (index) {
                if ($scope.utterances.length - 1 === index) {
                    var obj = {sentence: ""};
                    $scope.utterances.push(obj);
                }
            };
            $scope.removeUtterance = function (utterance, index) {
                startSaving('.saveUtterance' + index);
                if (utterance._id) {
                    $scope.deleteUtterance(utterance, index);
                } else {
                    $scope.utterances.splice(index, 1);
                }
            };
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.trainBot = function () {
                $scope.traingInProgress = true;
                BTStreamsService.trainUtterances($workflowService.selectedStream()._id)
                        .then(function (res) {
                            $scope.traingInProgress = false;
                            NotificationService.notify(i18n.i18nString('utterances_trained_sucessfully'), "info");
                            $scope.closeModal();
                        },
                                function (err) {
                                    $scope.traingInProgress = false;
                                    if (err.data.errors.length > 0) {
                                        NotificationService.notify(err.data.errors[0].msg, "error");
                                    } else {
                                        NotificationService.notify(i18n.i18nString('utterences_training_intiated_err'), "error");
                                    }

                                });
            };
            $scope.pendingAction = [];
            $scope.save = function () {
                if (!$scope.isReqPending) {

                    var sentences = [];
                    for (var i = 0; i < $scope.utterances.length; i++) {
                        if ($scope.utterances[i].sentence !== "") {
                            sentences.push($scope.utterances[i]);
                        }
                    }
                    if (config && config.cbBridge && config.cbBridge.onServiceSave) {
                        config.cbBridge.onServiceSave(sentences);
                    }
                    $scope.trainBot();
                } else {
                    $scope.pendingAction.push($scope.save);
                }
            };

            $scope.$watch('isReqPending', function (newval, oldval) {
                if (newval === false) {
                    if ($scope.pendingAction.length) {
                        $scope.pendingAction[0].call();
                    }
                }
            });
            $scope.saveUtterance = function (utterance, index) {
                if (utterance.sentence !== "") {
                    startSaving('.saveUtterance' + index);
                    if (utterance._id) {
                        $scope.editUtterence(utterance, index);
                    } else {
                        $scope.saveUtteranceToServer(utterance, index);
                    }
                }
            };
            function mixpanelEvent (type){
                var _botInfo = {
                    streamId: $workflowService.selectedStream()._id,
                    "Bot Name": $workflowService.selectedStream().name,
                    "Level":"Engagement L3",
                    "Category":"Engagement L3",
                };
                var event = "";
                if(type === 'createUtterance') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Intent Utterance Added";
                 }
                 if(event && event.trim()) {
                    mixPanel.postEvent(event, _botInfo);
                 }
             }

            $scope.saveUtteranceToServer = function (utterance, index) {
                $scope.saveInProgress = true;
                var payload = {
                    taskId: $scope.component._id,
                    sentence: utterance.sentence,
                    streamId: $scope.component.streamId,
                    type: 'DialogIntent'
                            //componentId: $scope.component._id
                };
                BTStreamsService.createUtterances(payload)
                        .then(function (res) {
                            mixpanelEvent("createUtterance");
                            $scope.$emit("updateChecklist", "machineLearningUtterances");
                            finishSaving('.saveUtterance' + index);
                            $scope.utterances[index] = res.data;
                            $scope.utterancesCopy[index] = res.data;
                            $scope.saveInProgress = false;
                            focusElement(false);
                        },
                                function (err) {
                                    $scope.saveInProgress = false;
                                    finishSaving('.saveUtterance' + index, 'error');
                                    if (err.data.errors.length > 0 && err.data.errors[0].code === 409 && err.data.errors[0].msg === 'Utterance already exists with same name') {
                                        NotificationService.notify(err.data.errors[0].msg, "error");
                                    } else if (error.errors && _.isArray(error)) {
                                        var msg = error.errors[0].msg;
                                        NotificationService.notify(msg, 'error');
                                    } else {
                                        NotificationService.notify(err.data.errors[0].msg, "error");
                                    }
                                    $scope.utterances[index].sentence = "";
                                    $scope.utterancesCopy[index] = "";
                                });

            };
            $scope.deleteUtterance = function (utterance, index) {
                $scope.saveInProgress = true;
                var payload = {
                    taskId: $scope.component._id,
                    streamId: $scope.component.streamId,
                    type: 'DialogIntent'
                            //componentId: $scope.component._id
                };
                BTStreamsService.deleteUtterances(payload, utterance._id)
                        .then(function (res) {
                            finishSaving('.saveUtterance' + index);
                            $scope.saveInProgress = false;
                            $scope.utterances.splice(index, 1);
                            $scope.utterancesCopy.splice(index, 1);
                            focusElement(false);
                        },
                                function (err) {
                                    finishSaving('.saveUtterance' + index, 'error');
                                    focusElement(true);
                                });
            };
            $scope.editUtterence = function (utterance, index) {
                $scope.saveInProgress = true;
                var payload = {
                    taskId: $scope.component._id,
                    sentence: utterance.sentence,
                    streamId: $scope.component.streamId,
                    type: 'DialogIntent'
                            //componentId: $scope.component._id
                };
                $scope.isReqPending = true;
                BTStreamsService.editUtterances(payload, utterance._id)
                        .then(function (res) {
                            $scope.isReqPending = false;
                            $scope.utterancesCopy[index].sentence = utterance.sentence;
                            finishSaving('.saveUtterance' + index);
                            $scope.saveInProgress = false;
                            focusElement(false);
                        },
                                function (err) {
                                    $scope.pendingAction=[];
                                    $scope.isReqPending = false;
                                    if (err.status === 409) {
                                        utterance.sentence = $scope.utterancesCopy[index].sentence;
                                        $scope.editUtterence(utterance, index);
                                        NotificationService.notify(i18n.i18nString('duplicate_utterance'), "error");
                                    }
                                    finishSaving('.saveUtterance' + index, 'error');
                                });

                $scope.editId = -1;
            };

            (function () {
                init();
            })();
        }]);

})(angular);


;(function (ng) {
    var _module = angular.module("bt-variable-management", ['ngSanitize', 'ngCsv']);
    _module.directive("btVariableManagement", function () {
        return {
            restrict: "EA",
            scope: {
                callback: "=?",
                btcallback: "=",
                context:"="
            },
            templateUrl: window.appConfig.TMPLT_PRE_PATH + "js/modules/bt-variableManagement/bt-variableManagement.html",
            controller: ['$scope', '$workflowService', '$element', 'BTFlowtaskService', '$timeout', 'NotificationService', '$location', '$endpoints', '$applicationService', 'env_conf', 'BTStreamsService', 'BTFileUploadService', '$interval', '$rootScope', '$filter', 'accessControlService','_constants_','i18n',
                function ($scope, $workflowService, $element, BTFlowtaskService, $timeout, NotificationService, $location, $endpoints, $applicationService, env_conf, BTStreamsService, BTFileUploadService, $interval, $rootScope, $filter, accessControlService,_constants_,i18n) {
                    $scope.displayMode = accessControlService.getAccessRight('BOTBUILDER_BOT_SETTINGS');
                    $scope.assetsBase = env_conf['assets-url'];
                    $scope.infoIcon = env_conf['context-url']+'/assets/icons/info.png'; 
                    $scope.trashIcon = env_conf['context-url']+'/assets/icons/trashIcon.svg'; 
                    $scope.editIcon = env_conf['context-url']+'/assets/icons-new/edit-pencil/pencil-gray.svg'; 
                    $scope.help = env_conf['context-url']+"/assets/icons-new/help/help-dark.svg";
                    $scope.emptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/k-folder.png';
                    $scope.environmentEmptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/empty-env-variables.png';
                    $scope.contentEmptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/empty-content-variables.png';
                    $scope.$emit('nestedComponentLoaded',{'id':'variableManagement','flag':false});
                    var _selectedStream = $workflowService.selectedStream();
					$scope.allowNamespace = $workflowService.selectedStream().enableNameSpace;
                    $scope.selectedStream =_selectedStream;
                    if ($workflowService.selectedStreamState() === 'published') {
                        $scope.displayMode = "VIEW";
                    }
                    $scope.dropdownValueIndex = 0;
                    $scope.isNamespaceLoading = true;
                    $scope.selectBots=i18n.i18nString('select_bot');
                    $scope.nobots=i18n.i18nString('no_bots_caps');
                    $scope.constants = _constants_;
                    $scope.callback = $scope.callback || {};
                    $scope.showNameSearch = false;
                    $scope.showValueSearch = false;
                    $scope.showEditFooter = true;
                    $scope.manageVarTabEnable = false;
                    $scope.bt_var_manage_cb = {};
                    $scope.openVarManSlid = false;
                    // $scope.type = {
                    //     typeSelected: 'global'
                    // };
                    if($scope.context === "content"){
                        $scope.botVariableType = "locale";
                    }else{
                        $scope.botVariableType = "env";
                    }
                    $scope.sampleBot =  ($workflowService.selectedStream().type ==="sample")? true:false;
                    $scope.varGroup = [];
                    $scope.varNamespace = [];
                    $scope.namespacesList = [];
                    $scope.addNewGroup = i18n.i18nString('add_new_group');
                    $scope.add = {
                        newVar: "",
                        newName: ""
                    };
                    $scope.ascendingOrder = true;
                    $scope.decendingOrder = false;
                    $scope.ascendingOrderNS = true;
                    $scope.decendingOrderNS = false;
                    $scope.sortKey = 'group';
                    $scope.sortKeyNS = 'namespace';
                    $scope.variableForm = {};
                    $scope.variableForm.collectionVal = {};
                    $scope.variableForm.variableKey = "";
                    $scope.variableForm.variableVal = "";
                    $scope.variableForm.variableGroup = "";
                    $scope.langVal = {};
                    $scope.variableForm.variableHint = "";
                    $scope.variableForm.scope = "prePopulated";
                    $scope.variableForm.propagateValue = false;
                    $scope.variableForm.linkedBotId = "";
                    $scope.showEditVariables = true;
                    $scope.botVariables = [];
                    $scope.tempBotVariables = [];
                    $scope.tempSearchBtVar = [];
                    $scope.showInlineEditDiv = false;
                    $scope.showFooter = true;
                    $scope.currentPage = 1;
                    $scope.callback.showLoading = true;
                    $scope.saving = false;
                    $scope.newVariableCreating = false;
                    $scope.rightClass = "right500";
                    $scope.ellipsisVert = false;
                    $scope.importBot = "";
                    $scope.dragDropIcon = window.appConfig.CONTEXT_PATH + '/assets/images/import.png';
                    $scope.wentWrongIcon = window.appConfig.CONTEXT_PATH + '/assets/images/wentwrong.png';
                    $scope.importingIcon = env_conf['context-url'] + '/assets/images/importing.png';
                    $scope.closeCross= env_conf['context-url']+'/assets/landingImages/closeCross.png';
                    $scope.importStep = 0;
                    $scope.importDoneIcon = env_conf['context-url'] + '/img/import-success.png';
                    $scope.componentId = "";
                    $scope.audioTagShow = false;
                    $scope.audioColShow = {};
                    $scope.isLoading = true;
                    var totalLinkedBots = [];
                    $scope.inpTags = {
                        text: [{tag: 'default'}]
                    };
                    $scope.searchQry = {
                        name: "",
                        value: ""
                    };
                    $scope.selectedVariableDataType  = 'string';
                    $scope.dropdownValues = [''];
                    $scope.dataTypes = [
                        {
                            dataType: "string",
                            displayName: "String"
                        },
                        {
                            dataType: "date",
                            displayName: "Date"
                        },
                        {
                            dataType: "dropDown",
                            displayName: "Dropdown"
                        },
                    ];

                    $scope.dataTypesObj =  {};
                    $.each($scope.dataTypes,function(i,val){
                        $scope.dataTypesObj[val.dataType] = val.displayName;
                    });
                    $scope.char_remaining = i18n.i18nString('char_remaining');
                    $scope.edit_content_variable = i18n.i18nString('edit_content_variable');
                    $scope.add_content_variable = i18n.i18nString('add_content_variable');
                    $scope.edit_global_variable =i18n.i18nString('edit_environment_variable');
                    $scope.add_global_variable = i18n.i18nString('add_environment_variable');
                    $scope.savingLabel = i18n.i18nString('saving');
                    $scope.saveLabel=i18n.i18nString('save');
                    $scope.manageCollectionVarEnable = false;
                    $scope.btCollectionVariables = {};
                    $scope.collectionVariableForm = {};
                    $scope.btCollectionVariables.collectionList = [];
                    $scope.btCollectionVariables.useCollections = false;
                    $scope.btCollectionVariables.collectionType = 'EMPTY';
                    $scope.audio = {
                        tagLocation: "",
                        collection: {}
                    };
                    $scope.volumeShow = true;
                    $scope.error = {
                        mess: ""
                    };
                    $scope.modalText = "Please Wait";
                    if ($workflowService.selectedStream().sbStreamId) {
                        $scope.isChildBot = true;
                    }
                    $scope.isSearching = false;

                    $scope.$watch('searchQry.name', function (newName, oldName) {
                        $scope.tempSearchBtVar = angular.copy($scope.tempBotVariables);
                        if (newName !== undefined) {
                            $scope.isSearching = newName !== "";
                        }
                        if ($scope.isSearching) {
                            $scope.tempSearchBtVar = $filter('filter')($scope.tempSearchBtVar, { originalKey: newName });
                        }
                    });

                    $scope.$watch('searchQry.value', function (newName, oldName) {
                        $scope.tempSearchBtVar = angular.copy($scope.tempBotVariables);
                        if (newName !== undefined) {
                            $scope.isSearching = newName !== "";
                        }
                        if ($scope.isSearching) {
                            $scope.tempSearchBtVar = $filter('filter')($scope.tempSearchBtVar, { value: newName });
                        }
                    });

                    /* Filter search code */
                    if (_selectedStream.type === 'solution' || _selectedStream.type === 'sample') {
                        $scope.showSetupOptions = true;
                    } else {
                        $scope.showSetupOptions = false;
                    }
                    $('.dropdown-submenu a.dropdownExport').on("click", function (e) {
                        $(this).next('ul').toggle();
                        e.stopPropagation();
                        e.preventDefault();
                    });
                    $scope.bt_var_manage_cb.updateNsList = function(list) { $scope.namespacesList = list; };

                    BTStreamsService.getBTStream(_selectedStream._id).then(function (res) {
                        $scope.volumeShow = res.data.ivrSettings && res.data.ivrSettings.enable;
                        $scope.botName = res.data.name;
                        // $element.find('.csvClass').attr('filename', $scope.botName+".csv");
                    }, function (error) {
                        console.error('getStreams Failed', error);
                    });
                    $scope.removeFile = function () {
                        $scope.fileName = "";
                    };

                    $scope.proceedFirst = function () {
                        $scope.importStep = 1;
                        $timeout(function () {
                            initDragDropFile();
                        }, 500);
                    };
                    $scope.dropdownClickHandler = function () {
                        $('.dropdown-sub-nav').hide();
                        $scope.modalText = i18n.i18nString('please_wait_label2');
                    };
                    $scope.audioTagClickHandler = function () {
                        $scope.audioTagShow = !$scope.audioTagShow;
                    };
                    $scope.audioColClickHandler = function(item, index) {
                        if($scope.audioColShow[index]) {
                            $scope.audioColShow[index] = false;
                        } else {
                            $scope.audioColShow[index] = true;
                        }
                    };
                    $scope.onCancel = function () {
                        $('.import-utterance-modal').modal('hide');
                        $scope.fileName = "";
                    };
                    $scope.moveForward = function (stepNo) {
                        $scope.importStep = stepNo;
                        if (stepNo == 1) {
                            $scope.removeFile();
                        }
                    };
                    $scope.goToStep = function (stepNo) {
                        $scope.error.mess = "";
                        if (stepNo == 1) {
                            $scope.moveForward(stepNo);
                        }
                    };
                    function startPollImportStatus(timeout) {
                        return setInterval(function () {
                            BTStreamsService.btImportVariablesStatus($applicationService.userInfo().userId, _selectedStream._id, $scope.streamRefId)
                                .then(function (res) {
                                    if (res && res.data) {
                                        $scope.statusLogs = res.data.statusLogs || [];
                                        if (res.data.status === 'success' && $scope.statusLogs[0].logType === 'info') {
                                            $scope.showSuccessMsg=true;
                                            $(".downloadLogFile").hide();
                                            $scope.logMessage=$scope.statusLogs[0].log;
                                            stopImportBotPolling('success');
                                        }else if(res.data.status === 'success'){
                                            $scope.showSuccessMsg=false;
                                            $(".downloadLogFile").show();
                                            stopImportBotPolling('success');
                                        }
                                        else if (res.data.status === 'failed') {
                                            $scope.showSuccessMsg=false;
                                            $scope.importmessage = res.data.message;
                                            $scope.error.mess = res.data.message;
                                            $scope.showFailedErrors = false;
                                            stopImportBotPolling('failed');
                                        }
                                    }

                                }, function (err) {
                                    stopImportBotPolling();
                                    var _msg = i18n.i18nString('err_on_fetching_bot_variables');
                                    if (err.data && err.data.errors && err.data.errors.length > 0) {
                                        _msg = err.data.errors[0].msg;
                                    }
                                    NotificationService.notify(_msg, "error");
                                });

                        }, timeout);
                    }
                    function stopImportBotPolling(_status) {
                        if ($scope._importStatusInit) {
                            clearTimeout($scope._importStatusInit);
                            $scope._importStatusInit = null;
                        }
                        if (_status === 'success') {
                            $scope.importStep = 4;
                            $scope.getBotVariables();
                        }
                        else if (_status === 'failed') {
                            $scope.importStep = 2;
                        }
                    }
                    $scope.startImport = function () {
                        $scope.importStep = 3;
                        BTStreamsService.uploadBotFunctionsFile($applicationService.userInfo().userId, $scope.data)
                            .then(function (response) {
                                var fileUploaded = {
                                    fileName: $scope.fileObject.name,
                                    fileId: response.data.fileId
                                };
                                var _extension = $scope.fileObject.name.substring($scope.fileObject.name.lastIndexOf('.') + 1);
                                BTStreamsService.btImportVariables($applicationService.userInfo().userId, _selectedStream._id, fileUploaded, _extension)
                                    .then(function (res) {
                                        if (res && res.data) {
                                            $scope.streamRefId = res.data._id || "";
                                            $scope.statusLogs = res.data.statusLogs || [];
                                            if (res.data.status === 'pending') {
                                                $scope.importing = res.data.status;
                                                $scope._importStatusInit = startPollImportStatus(3000);
                                            }
                                            else if (res.data.status === 'success') {
                                                stopImportBotPolling('success');
                                            }
                                            else {
                                                stopImportBotPolling('failed');
                                            }
                                        }
                                    }, function (err) {
                                        $scope.importStep = 2;
                                        $scope.errorMsg = err.data.errors;
                                    });

                            }, function (err) {
                                if (err && err.data && err.data.errors) {
                                    $scope.importStep = 2;
                                    $scope.errorMsg = err.data.errors;
                                }
                                else {
                                    $scope.importStep = 2;
                                    $scope.errorMsg = i18n.i18nString('unablle_to_import');
                                }
                                /*                                var _message = err;
                                                                 NotificationService.notify(_message, "error");*/
                            });
                    };

                    function writeAndDownloadLog(filename,data)
                    {
                        var element = document.createElement('a');
                        element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(data));
                        element.setAttribute('download', filename);

                        element.style.display = 'none';
                        document.body.appendChild(element);
                        
                        element.click();

                        document.body.removeChild(element);
                    }

                    $scope.downloadLog = function() {
                        writeAndDownloadLog('botVariablesLog', JSON.stringify($scope.statusLogs));
                    };

                    $scope.uploadJSONFile = function (fileObject) {
                        var _ext = "";
                        if (fileObject.name) {
                            _ext = fileObject.name.substring(fileObject.name.lastIndexOf('.'));
                            _ext.slice(1).toUpperCase();
                            var supportingFileFormats = [".json", ".csv"];
                            if ($.inArray(_ext, supportingFileFormats) === -1) {
                                NotificationService.notify(i18n.i18nString('upload_only_csv_json_error_noty'), "error");
                                $scope.fileExtensionError = true;
                                return;
                            }
                        }




                        var reader = new FileReader();
                        reader.readAsText(fileObject);

                        reader.onload = function (e) {
                            var respnoseData = reader.result;
                            $scope.jsonData = respnoseData;
                            if (!respnoseData || respnoseData && !respnoseData.length) {
                                NotificationService.notify(i18n.i18nString('please_upload_a_Valid') + _ext.slice(1).toUpperCase() + i18n.i18nString('file_label'), "error");
                                $scope.fileEmptyError = true;
                            } else {
                                console.log("fileobject", fileObject.name);
                                $scope.fileName = fileObject.name;
                                $scope.fileExtensionError = false;

                                var data = new FormData();
                                data.append('file', fileObject);
                                data.append('fileContext', 'bulkImport');
                                data.append('fileExtension', _ext.substring(_ext.lastIndexOf('.') + 1));
                                data.append('Content-Type', fileObject.type);
                                $scope.data = data;
                                $scope.fileObject = fileObject;

                            }
                        };

                    };

                    $scope.importVariables = function () {
                        $scope.importStep = 0;
                        $scope.ellipsisVert = false;
                        $('.import-utterance-modal').modal('show');
                    };

                    function initDragDropFile() {
                        (function (window) {
                            function triggerCallback(e, callback) {
                                if (!callback || typeof callback !== 'function') {
                                    return;
                                }
                                var files;
                                if (e.dataTransfer) {
                                    files = e.dataTransfer.files;
                                } else if (e.target) {
                                    files = e.target.files;
                                }
                                callback.call(null, files);
                            }
                            function makeDroppable(ele, callback) {
                                if ($element.find('[type="file"]').length > 0) {
                                    return;
                                }
                                var input = document.createElement('input');
                                input.setAttribute('type', 'file');
                                input.setAttribute('multiple', true);
                                input.style.display = 'none';
                                input.id = "fileInputID";
                                input.addEventListener('change', function (e) {
                                    triggerCallback(e, callback);
                                });
                                ele = ele[1];
                                ele.appendChild(input);
                                ele.addEventListener('dragover', function (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    ele.classList.add('dragover');
                                });

                                ele.addEventListener('dragleave', function (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    ele.classList.remove('dragover');
                                });

                                ele.addEventListener('drop', function (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    ele.classList.remove('dragover');
                                    triggerCallback(e, callback);
                                });
                                $(ele).find(".browseBtn")[0].addEventListener('click', function () {
                                    input.value = null;
                                    input.click();
                                });
                            }
                            window.makeDroppable = makeDroppable;
                        })(window);
                        (function (window) {
                            window.makeDroppable($('.fileDropContainer'), function (files) {
                                $scope.uploadJSONFile(files[0]);
                            });
                        })(window);
                    }

                    $scope.activateNameSearch = function (show) {
                        $scope.showValueSearch = false;
                        $scope.searchQry.name = "";
                        $scope.searchQry.value = "";
                        $scope.tempBotVariables = angular.copy($scope.botVariables);
                        $scope.tempSearchBtVar = angular.copy($scope.tempBotVariables);
                        setTimeout(function () {
                            $('.focusNameSearch').focus();
                        }, 100);
                        if (show) {
                            $scope.showNameSearch = true;
                            /*                            $('.focusNameSearch').on('focusout', function() {
                                                            $scope.activateNameSearch(false);
                                                        });*/
                        }
                        else {
                            $scope.showNameSearch = false;
                        }
                    };
                    $scope.manageNamespacesSlider = function(){
                        $scope.manageVarTabEnable = true;
                        setTimeout(function(){
                            $scope.openModalSlider('#manageVarNamespaceTable');
                        }, 500);
                    };

                    $scope.bt_var_manage_cb.close = function() {
                        $scope.closeModalSlider('#manageVarNamespaceTable');
                        $scope.manageVarTabEnable = false;
                    };

                    // Collection variables sliders
                    $scope.manageCollectionsSlider = function(){
                        $scope.manageCollectionVarEnable = true;
                        setTimeout(function(){
                            $scope.openModalSlider('#manageCollectionsSlider');
                        }, 500);
                    };

                    $scope.btCollectionVariables.close = function() {
                        $scope.closeModalSlider('#manageCollectionsSlider');
                        $scope.manageCollectionVarEnable = false;
                        $scope.btCollectionVariables.collectionType = 'EMPTY';
                        checkCollectionsExist(); // reload collections
                    };

                    // search query
                    $scope.searchQuery = function() {
                        var term = $scope.collectionVariableForm.searchQuery.trim();
                        // if(term) {
                        //     var filterObj = $scope.tempBotVariables.filter(function(res) {
                        //         return (term.includes(res.key)) || (term.includes(res.value));
                        //     });
                        //     if(filterObj) {
                        //         $scope.tempBotVariables = filterObj;
                        //     }
                        //     console.log(filterObj);
                        // } else {
                        //     $scope.getBotVariables();
                        // }
                        // BTStreamsService.btGetAllCollections($applicationService.userInfo().userId, $workflowService.selectedStream()._id).then(function(res){

                        // }, function (err) {
                        //     if (err && err.data && err.data.errors) {
                        //         NotificationService.notify(err.data.errors[0].msg, 'error');
                        //     } else {
                        //         NotificationService.notify('Failed to search', 'error');
                        //     }
                        // });
                    };
                    // Sort by collection Id
                    $scope.sortByCollection = function(col) {
                        $scope.collectionVariableForm.activeCollection = col;
                        $scope.isLoading = true;
                        var collectionRefId = col.refId  || '';
                        BTFlowtaskService.getVariablesByCollection($applicationService.userInfo().userId, _selectedStream._id,$scope.botVariableType, collectionRefId).then(function (res) {
                            $workflowService.botEnvVariables(res.data.variables);
                            $scope.botVariables = res.data.variables;
                            $scope.varGroup = _.uniq(_.pluck(res.data.variables, 'group'));
                            $scope.varGroup.unshift($scope.addNewGroup);
                            $scope.botVariables.forEach(function (obj) {
                                obj.originalKey = obj.key;
                                if(obj.vNameSpace && obj.vNameSpace.length && $scope.varNamespace.length) {
                                    var nsTempList = $scope.varNamespace.filter(function(val){ return obj.vNameSpace.indexOf(val._id) > -1; });
                                    obj.namespace = _.pluck(nsTempList, 'name').join(',');
                                    // obj.namespace =  _.findWhere($scope.varNamespace, {'_id': obj.vNameSpace[0]}).name;
                                }
                            });
                            if($scope.isChildBot) {
                                $scope.botVariables = $scope.botVariables.filter(function(val){ return val.scope !== 'hidden'; });
                            }
                            $scope.tempBotVariables = angular.copy($scope.botVariables);
                            $scope.callback.showLoading = false;
                            $scope.isLoading = false;
                        }, function (error) {
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('unexpected_error_while_fetching_bot_variables'), 'error');
                            }
                            $scope.callback.showLoading = false;
                            $scope.isLoading = false;
                        });
                    };
                    // Autocomplete fields
                    $scope.autoCompleteCollection = function(event, index, col) {
                        if(index === 0) {
                            $scope.btCollectionVariables.collectionList.forEach(function(item, i) {
                                if(i > 0 && !$scope.variableForm.collectionVal[item.refId]) {
                                    $scope.variableForm.collectionVal[item.refId] = $scope.variableForm.collectionVal[col.refId];
                                }
                            });
                        }
                    };
                    // Get all collections
                    function getAllCollections() {
                        BTStreamsService.btGetAllCollections($applicationService.userInfo().userId, $workflowService.selectedStream()._id)
                        .then(function(res){
                            if(res && res.data) {
                                $scope.btCollectionVariables.collectionList = res.data;
                                if($scope.btCollectionVariables.collectionList && $scope.btCollectionVariables.collectionList.length) {
                                    $scope.btCollectionVariables.collectionType = 'LIST';
                                    $scope.btCollectionVariables.collectionList.forEach(function(item, index) {
                                        if(item.isActive) {
                                            $scope.collectionVariableForm.activeCollection = item;  
                                        }
                                    });
                                } else {
                                    $scope.btCollectionVariables.collectionType = 'EMPTY';
                                }
                            }
                        },function(err){
                            if (err && err.data && err.data.errors) {
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('failed_collections'), 'error');
                            }
                        });
                    }
                    // Check customSettings.useCollections flag exist in appControl 
                    function checkCollectionsExist() {
                        var selectedAccount = $workflowService.selectedAccount();
                        if(selectedAccount && selectedAccount.customSettings && selectedAccount.customSettings.useCollections === true && $scope.botVariableType === 'env') {
                            getAllCollections();
                            $scope.btCollectionVariables.useCollections = selectedAccount.customSettings.useCollections;
                            $scope.add_global_variable = i18n.i18nString('add_global_variable');
                            $scope.edit_global_variable = i18n.i18nString('edit_global_variable');
                        } 
                    }
                    checkCollectionsExist();

                    $scope.activateValueSearch = function (show) {
                        $scope.showNameSearch = false;
                        $scope.searchQry.name = "";
                        $scope.searchQry.value = "";
                        $scope.tempBotVariables = angular.copy($scope.botVariables);
                        setTimeout(function () {
                            $('.focusValueSearch').focus();
                        }, 100);
                        if (show) {
                            $scope.showValueSearch = true;
                            /*                            $('.focusValueSearch').on('focusout', function() {
                                                            $scope.activateValueSearch(false);
                                                        });*/
                        }
                        else {
                            $scope.showValueSearch = false;
                        }
                    };
                    $scope.trackSearch = function (event) {
                        if (event.keyCode === 27) {
                            $scope.showValueSearch = false;
                            $scope.showNameSearch = false;
                            $scope.searchQry.name = "";
                            $scope.searchQry.value = "";
                            $scope.tempBotVariables = angular.copy($scope.botVariables);
                        }
                    };
                    // $scope.searchRecords = function(key) {
                    //     if($scope.searchQry.name !== "" && ($scope.showNameSearch || $scope.showValueSearch )) {
                    //         $scope.tempBotVariables = $scope.tempBotVariables.filter(function(variable){
                    //             if(key === "key") {
                    //                 return(variable.key.indexOf($scope.searchQry.name) === 0);
                    //             }
                    //             else{
                    //                 return(variable.value.indexOf($scope.searchQry.name) === 0);
                    //             }
                    //         });
                    //     }
                    //     else{
                    //         $scope.tempBotVariables = angular.copy($scope.botVariables);
                    //     }
                    // };
                    /* End filter search code */
                    $scope.btcallback.stopFetching = function () {
                        setTimeout(function () {
                            $scope.callback.showLoading = false;
                        }, 1000);
                    };
                    $scope.closeSlider = function(form) {
                        $scope.openVarManSlid = false;
                        $scope.selectedVariableDataType = 'string';
                        $scope.closeModalSlider('#variableManagementSlider');
                        form.$setPristine();
                        form.$setUntouched();
                    };
                    $scope.selectDataType =  function(type){
                        $scope.dropdownValueIndex =  0;
                        if(type === 'date') {
                            $scope.variableForm.variableVal =  null;
                        } else {
                            $scope.variableForm.variableVal = '';
                        }
                        $scope.selectedVariableDataType = type;
                    };
                    $scope.selectDefaultDropDownValue =  function(index){
                        $scope.dropdownValueIndex = index;
                    };
                    $scope.removeDropDownValue =  function(index){
                        if($scope.dropdownValueIndex === index){
                            NotificationService.notify('Cannot delete selected value','error');
                            return;
                        }
                        if($scope.dropdownValues.length > 1){
                            $scope.dropdownValues.splice(index,1);
                        } else{
                            NotificationService.notify('At least one value is required','error');
                        }
                    };
                    $scope.initDate =  function(containerId){
                        var container = $('#'+containerId);
                        $timeout(function () {
                                daterangepickerInput = container.daterangepicker({
                                "singleDatePicker": true,
                                "showDropdowns": true,
                                "opens": "right",
                                // "drops": 'down',
                                customClass: "bot-dash-datepicker",
                                locale: {
                                    applyLabel: i18n.i18nString('apply'),
                                    cancelLabel: i18n.i18nString('cancel'),
                                }
                            });
                            // container.on('apply.daterangepicker', function (ev, picker) {
                            //     if (ev) {
                            //         var timezone = moment.tz.guess();
                            //         if (timezone === "America/Los_Angeles") { // Check PST timezone addition by 1hour
                            //             ev.currentTarget.value = moment.parseZone(picker.startDate, timezone).add({ hour: 1, day: 0 });
                            //             $(ev.currentTarget).trigger('change');
                            //         } else {
                            //             ev.currentTarget.value = moment.parseZone(picker.startDate, timezone);
                            //             $(ev.currentTarget).trigger('change');
                            //         }
                            //     }
                            // });
                        }, 300);
                    };
                    $scope.cancelCreateVariable = function (form) {
                        $scope.openVarManSlid = false;
                        $scope.selectedVariableDataType = 'string';
                        $scope.closeModalSlider('#variableManagementSlider');
                        if(form) {
                            form.$setPristine();
                            form.$setUntouched();
                        }
                        setTimeout(function () {
                            $scope.showEditFooter = true;
                            $scope.showEditVariables = true;
                            $scope.newVariableCreating = false;
                        }, 500);

                    };
                    $scope.checkLengthValidation = function (val, limit, event) {
                        if (val && val.length >= limit) {
                            event.preventDefault();
                            return;
                        }
                        //                        var pattern = /^[a-zA-Z0-9- ]*$/;                   
                        //                        if (pattern.test(val) === false || / /.test(val)) {
                        //                            $scope.invalidText = true;
                        //                        } else {
                        //                            $scope.invalidText = false;
                        //                        }
                    };
                    $scope.handleLengthValidation = function (type, limit, event) {
                        setTimeout(function () {
                            event.stopImmediatePropagation();
                            if (event.currentTarget.value.length >= limit) {
                                event.currentTarget.value = event.currentTarget.value.slice(0, limit);
                                $(event.currentTarget).trigger('change');
                            }
                        }, 10);

                        var availableTags =[];
                        $scope.tempBotVariables.forEach(function(item){
                            if(item.group === undefined){
                                return false;
                            }else{
                                availableTags.push(item.group);
                            }
                        });

                        $( "#tags" ).autocomplete({
                            source: _.uniq(availableTags)
                        });
                    };

                    $scope.checkKey = function(ev) {
                        if(ev.which == 13) {
                            ev.preventDefault();
                            createNamespace();
                            return;
                        }
                    };
                
                    var createNamespace = function() {
                        if($scope.namespacesList.indexOf($scope.add.newName) > -1) {
                            NotificationService.notify(i18n.i18nString('dup_not_allowed'), 'error');
                            return;
                        }
                        payload = {
                            name: $scope.add.newName
                        };
                        $('#dropdownMenuButton').parent().removeClass('open');
                        var promise = new Promise(function(resolve, reject){
                            BTStreamsService.createNamespace($applicationService.userInfo().userId, _selectedStream._id, payload).then(function(res){ 
                                $scope.varNamespace.push(_.pick(res.data, 'name', '_id'));
                                $scope.namespacesList.push($scope.add.newName);
                                $scope.inpTags.text.push({tag: $scope.add.newName});
                                $scope.add.newName = '';
                                NotificationService.notify('"'+res.data.name+'"'+i18n.i18nString('ns_created'), 'success');
                                resolve(res.data._id);
                            }, function(err){ reject(err); });
                        });
                        return promise;
                    };

                    $scope.createNamespace = createNamespace;

                    var createNewVariable = function(nsId) {
                        var _obj = { 'key': $scope.variableForm.variableKey, 'value': $scope.variableForm.variableVal, 'hint': $scope.variableForm.variableHint, 'audioTag': $scope.audio.tagLocation };
                        _obj.variableType = $scope.botVariableType;
                        _obj.group = $scope.variableForm.variableGroup == $scope.addNewGroup?$scope.add.newVar.trim():$scope.variableForm.variableGroup;
                        if (_selectedStream.type === 'solution' || _selectedStream.type === 'sample') {
                            _obj.scope = $scope.variableForm.scope;
                        }
                        if(_selectedStream.type === 'universalbot'){
                            if($scope.variableForm.propagateValue){
                               _obj.linkedBotId = $scope.variableForm.linkedBotId; 
                            }
                            _obj.propagateValue = $scope.variableForm.propagateValue;
                        }
                        if(nsId) {
                            _obj.vNameSpace = nsId;
                        }
                        if($scope.variableForm.collectionVal && Object.keys($scope.variableForm.collectionVal).length && $scope.btCollectionVariables.useCollections) {
                            var keys = Object.keys($scope.variableForm.collectionVal);
                            var colPayload = [];
                            if(keys.length) {
                                keys.forEach(function(col) {
                                    colPayload.push({
                                    "collectionRefId": col || '',
                                    "value":$scope.variableForm.collectionVal[col] || '',
                                    "audioTag":$scope.audio.collection[col] || ''
                                    });
                                });
                                _obj.value = colPayload;
                            }
                        }
                        // $scope.tempBotVariables.push(_obj);
                        $scope.saveBotVariables(false, false, null, _obj);
                        $scope.saving = true;
                    };

                    $scope.createVariable = function (form) {
                        if($scope.variableForm.propagateValue && ($scope.variableForm.linkedBotId === undefined || $scope.variableForm.linkedBotId === "")){
                            NotificationService.notify(i18n.i18nString('please_provide_linked_bot'),'error');
                            return;
                        }
                        form.$setPristine();
                        form.$setUntouched();
                        $scope.saving = true;
                        if($scope.inpTags.text.length > 0){
                            var nsList = _.pluck($scope.inpTags.text, 'tag');
                            var tempFiltered = $scope.varNamespace.filter(function(val){ return nsList.indexOf(val.name) > -1; });
                            var idTemp = _.pluck(tempFiltered, '_id');
                            createNewVariable(idTemp);
                        } else { createNewVariable(); }
                    };

                    $scope.inputNewGroup = function(name) {
                        $scope.variableForm.variableGroup = name;
                        setTimeout(function(){
                            $('#inputGroup').focus();
                        });
                    };

                    $scope.addNewVariable = function () {
                        $scope.isEditVariable = false;
                        $scope.variableForm.variableKey = "";
                        $scope.variableForm.collectionVal = {};
                        $scope.variableForm.variableVal = "";
                        $scope.audioTagShow = false;
                        $scope.variableForm.variableHint = "";
                        $scope.variableForm.variableGroup = "";
                        $scope.variableForm.propagateValue = false;
                        $scope.variableForm.linkedBotId = "";
                        $scope.audio.tagLocation = "";
                        $scope.audio.collection = {};
                        $scope.audioColShow = {};
                        $scope.inpTags.text = [{tag: 'default'}];
                        // $scope.type.typeSelected = "global";
                        $element.find('.saveButton').removeClass('disabled');
                        $scope.variableForm.scope = "prePopulated";
                        $scope.selectedVariableDataType = 'string';
                        $scope.showEditFooter = false;
                        // $scope.showEditVariables = false;
                        $scope.newVariableCreating = true;
                        $("textarea.autoGrowTA").css("height",'32px');
                        if($scope.allowNamespace) {
                            getAllNamespaces().then(function(res){
                                $scope.isNamespaceLoading = false;
                            }, function (err){
                                $scope.isNamespaceLoading = false;
                                NotificationService.notify(i18n.i18nString('failed_fetch_ns'), 'error');
                            });
                        }
                        $scope.openVarManSlid = true;
                        $timeout(function () {
                            $scope.openModalSlider('#variableManagementSlider');
                            attachTooltip();
                        });
                    };
                    $scope.saveButtonChange = function () {
                        $element.find('.saveButton').removeClass('disabled');
                    };
                    function processBotVariables(data) {
                        $workflowService.botEnvVariables(data);
                        $scope.botVariables = data;
                        if ($scope.botVariables instanceof Array) {
                            $scope.botVariables.forEach(function (obj) {
                                obj.originalKey = obj.key;
                            });
                        }
                        else {
                            $scope.botVariables.originalKey = $scope.botVariables.key;
                        }
                        $scope.tempBotVariables = angular.copy($scope.botVariables);
                    }
                    // var saveByteArray = (function () {
                    //     return function (data, name) {
                    //         var blob = null,url="";
                    //         if (navigator.msSaveBlob) {
                    //             blob = new Blob(data, { type: 'octet/stream' });
                    //             return window.navigator.msSaveOrOpenBlob(blob, name);
                    //         }
                    //         else{
                    //             var a = document.createElement("a");
                    //             document.body.appendChild(a);
                    //             a.style = "display: none";
                    //             blob = new Blob(data, {type: "octet/stream"});
                    //             url = window.URL.createObjectURL(blob);
                    //             a.href = url;
                    //             a.download = name;
                    //             a.click();
                    //             window.URL.revokeObjectURL(url);
                    //         }
                    //     };
                    // }());
                    // function writeAndDownloadDialog(data,filename){
                    //     saveByteArray([data], filename);
                    // }
                    function btExportVarStatus() {
                        return BTStreamsService.btExportVariablesStatus($applicationService.userInfo().userId, _selectedStream._id).then(function (res) {
                            if (res.data.status == 'pending') {
                                return;
                            }
                            else if (res.data.status == 'success') {
                                var element = document.createElement('a');
                                element.setAttribute('href', res.data.downloadURL);
                                element.setAttribute('target', '_blank');
                                element.style.display = 'none';
                                document.body.appendChild(element);
                                element.click();
                                document.body.removeChild(element);
                                $scope.modalText = "Downloading";
                                $timeout(function () {
                                    $element.find('.export-utterance-modal').removeClass('show').addClass('fade');
                                }, 4000);
                                $interval.cancel(expStatusReq);
                            }
                        }, function (error) {
                            $element.find('.export-utterance-modal').removeClass('show').addClass('fade');
                            console.log(error);
                        });
                    }

                    $scope.exportVariables = function (format) {
                        function startExport(){
                        BTStreamsService.btExportVariables($applicationService.userInfo().userId, _selectedStream._id, format).then(function (response) {
                            if (response.data.status === "PENDING" || response.data.status === "SUCCESS") {
                                NotificationService.notify('Exporting Variables ...', 'success');
                                $rootScope.$broadcast('getProgressDockStatus');
                                $rootScope.$broadcast('startTimer');
                                $(".trainingProgress").addClass('open');
                                // $scope.downloadURL = response.data.url;
                                // if($scope.downloadURL) {
                                //     $element.find('.export-utterances-modal-body span')[0].innerHTML = "Downloading Please Wait...";
                                //     setTimeout(function(){
                                //         $element.find('#downloadButton')[0].click();
                                //     });
                                //     setTimeout(function(){
                                //         $element.find('.export-utterance-modal').removeClass('show').addClass('fade');
                                //         $element.find('.export-utterances-modal-body span')[0].innerHTML = "Please wait... Fetching Response";
                                //     },3500);
                                //     clearInterval($scope.statusInit);
                                // } else {
                                //     alert('Please allow popups for this website');
                                // }
                            } else if (response.data.status === "failed") {
                                NotificationService.notify(i18n.i18nString('exporting_variables_failed'), 'error');
                                $rootScope.$broadcast('getProgressDockStatus');
                                $rootScope.$broadcast('startTimer');
                                // $element.find('.export-utterances-modal-body span')[0].innerHTML = "Failed to fetch the data.";
                                // clearInterval($scope.statusInit);
                                // setTimeout(function(){
                                //     $element.find('.export-utterance-modal').removeClass('show').addClass('fade');
                                //     $element.find('.export-utterances-modal-body span')[0].innerHTML = "Please wait... Fetching Response";
                                // },2000);
                            }
                        }, function (error) {
                            if (error.data.errors[0].code === 'RequestExists') {
                                var msg = error.data.errors[0].code;
                                NotificationService.notify(msg, "warning");
                            } else if (error && error.data && error.data.errors[0].code) {
                                NotificationService.notify(error.data.errors[0].msg, "error");
                            } else {
                                NotificationService.notify(error.data.errors[0].msg, "error");
                            }
                        });
                        }
                     function cancleExport(){
                         return;
                     }
                     function checkBoxCb(checkValue){
                       console.log(checkValue);
                       $scope.constants.updateDownloadPopUppreferance(checkValue);
                     }
                     if($scope.constants.config.showDownloadPopUps){
                      NotificationService.userConfirm($scope.constants.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined,i18n.i18nString('export_variables'));  
                     }else{
                         startExport();
                     }

                    };

                    $scope.attachOpenDropdown = function() {
                        $('#namespace_var_slider .dropdown').off();
                        $('#namespace_var_slider .dropdown').on('show.bs.dropdown', function(event){
                            $scope.add.newName = '';
                            setTimeout(function(){
                                $('#namespaceInp').focus();
                            }, 200);
                        });
                    };

                    $scope.onDone = function () {
                        $('.import-utterance-modal').modal('hide');
                        $scope.fileName = "";
                        $scope.callback.showLoading = true;
                        $scope.getBotVariables();
                       // $scope.$emit("loadBots", $workflowService.selectedStream());
                    };

                    function attachTooltip() {
                        setTimeout(function(){
                            $('[data-toggle="popover"]').popover({
                                trigger: 'hover',
                                placement: 'top'
                            });
                            if($scope.displayMode !== "VIEW"){
                              $("[name='variableName']").focus();
                            }
                            $('[data-toggle="tooltip"]').tooltip();   
                        }, 200);
                    }

                    var getAllNamespaces = function() {
                        var promise = new Promise(function(resolve, reject) {
                            BTStreamsService.getAllNamespaces($applicationService.userInfo().userId, _selectedStream._id).then(function(res){
                                $scope.varNamespace = _.map(res.data, function(v) { return _.pick(v, "name", "_id");});
                                $scope.namespacesList = _.pluck(res.data, 'name');
                                resolve();
                            }, function(err){
                                $scope.getBotVariables(); // if namespace api fails then call variables api
                                NotificationService.notify('Failed to get namespaces', 'error');
                                reject();
                            });
                        });
                        return promise;
                    };
                    $scope.bt_var_manage_cb.getAllNamespaces = getAllNamespaces;
                    $scope.getBotVariables = function () {
                        $scope.isLoading = true;
                        // if($scope.btCollectionVariables.useCollections && $scope.btCollectionVariables.collectionList) {
                        //     $scope.sortByCollection($scope.collectionVariableForm.activeCollection);
                        // } else {
                            
                        // }
                        BTFlowtaskService.getVariables($applicationService.userInfo().userId, _selectedStream._id,$scope.botVariableType).then(function (res) {
                            $workflowService.botEnvVariables(res.data.variables);
                            $scope.botVariables = res.data.variables;
                            $scope.varGroup = _.uniq(_.pluck(res.data.variables, 'group'));
                            $scope.varGroup.unshift($scope.addNewGroup);
                            $scope.botVariables.forEach(function (obj) {
                                obj.originalKey = obj.key;
                                if(obj.vNameSpace && obj.vNameSpace.length && $scope.varNamespace.length) {
                                    var nsTempList = $scope.varNamespace.filter(function(val){ return obj.vNameSpace.indexOf(val._id) > -1; });
                                    obj.namespace = _.pluck(nsTempList, 'name').join(',');
                                    // obj.namespace =  _.findWhere($scope.varNamespace, {'_id': obj.vNameSpace[0]}).name;
                                }
                            });
                            if($scope.isChildBot) {
                                $scope.botVariables = $scope.botVariables.filter(function(val){ return val.scope !== 'hidden'; });
                            }
                            $scope.tempBotVariables = angular.copy($scope.botVariables);
                            $scope.callback.showLoading = false;
                            $scope.isLoading = false;
                        }, function (error) {
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('unexpected_error_while_fetching_bot_variables'), 'error');
                            }
                            $scope.callback.showLoading = false;
                            $scope.isLoading = false;
                        });
                    };
                    $scope.bt_var_manage_cb.getBotVariables = $scope.getBotVariables;
                    if($scope.allowNamespace) {
                        getAllNamespaces().then(function(res){
                            $scope.getBotVariables();
                        }, function(err){
                            NotificationService.notify(i18n.i18nString('failed_fetch_ns'), "error");
                        });
                    }
                    else {
                        $scope.getBotVariables();
                    }
                    $scope.addDropdownValue =  function(){
                        $scope.dropdownValues.push(''); 
                    };
                    $scope.saveDropDownValues  =  function(index){
                        if((index > -1) && ($scope.defaultDropdown === index)) {
                            $scope.variableForm.variableVal = $scope.dropdownValues[index];
                        } else {
                            $scope.variableForm.variableVal = $scope.dropdownValues[0];
                        }
                    };
                    $scope.saveBotVariables = function (_fromEdit, _frmDelete, index, payload) {
                        var _tmpVariables = angular.copy($scope.tempBotVariables);
                        _tmpVariables = _tmpVariables.map(function (item) {
                            if (_selectedStream.type === 'solution' || _selectedStream.type === 'sample') {
                                return _.pick(item, 'key', 'value', 'hint', 'variableType', '_id', 'scope', 'audioTag', 'group', 'vNameSpace');
                            }
                            else if(_selectedStream.type === 'universalbot'){
                                return _.pick(item, 'key', 'value', 'hint', 'variableType', '_id', 'audioTag', 'group', 'propagateValue', 'linkedBotId');
                            }
                            else {
                                return _.pick(item, 'key', 'value', 'hint', 'variableType', '_id', 'audioTag', 'group', 'vNameSpace');
                            }
                        });
                        if($scope.sampleBot){
                            if(payload && !_fromEdit && !_frmDelete) {
                                payload.meta = {
                                    dataType:$scope.selectedVariableDataType || 'string',
                                    values:[]
                                };
                                if($scope.selectedVariableDataType === 'dropDown') {
                                    payload.meta.values = $scope.dropdownValues || [];
                                } else {
                                    payload.meta.values = [];
                                    payload.meta.values.push(payload.value);
                                }
                            } 
                            if(($scope.currEditKeyIndex > -1) &&  _tmpVariables.length && _tmpVariables[$scope.currEditKeyIndex] && _fromEdit){
                                _tmpVariables[$scope.currEditKeyIndex].meta = {
                                    dataType:$scope.selectedVariableDataType || 'string',
                                    values:[]
                                };
                                if($scope.selectedVariableDataType === 'dropDown') {
                                    _tmpVariables[$scope.currEditKeyIndex].meta.values = $scope.dropdownValues || [];
                                } else {
                                    _tmpVariables[$scope.currEditKeyIndex].meta.values = [];
                                    _tmpVariables[$scope.currEditKeyIndex].meta.values.push(_tmpVariables[$scope.currEditKeyIndex].value);
                                }
                            }
                        }
                        if((_fromEdit && !_frmDelete)) {
                            if($scope.variableForm.collectionVal && Object.keys($scope.variableForm.collectionVal).length && $scope.btCollectionVariables.useCollections) {
                                var keys = Object.keys($scope.variableForm.collectionVal);
                                var colPayload = [];
                                if(keys.length) {
                                    keys.forEach(function(col) {
                                        if(isCollectionActive(col)) {
                                            colPayload.push({
                                                "collectionRefId": col || '',
                                                "value":$scope.variableForm.collectionVal[col] || '',
                                                "audioTag":$scope.audio.collection[col] || '',
                                                isActive: true
                                                });
                                        } else {
                                            colPayload.push({
                                                "collectionRefId": col || '',
                                                "value":$scope.variableForm.collectionVal[col] || '',
                                                "audioTag":$scope.audio.collection[col] || ''
                                                });
                                        }
                                    });
                                    _tmpVariables[$scope.currEditKeyIndex].value = colPayload;
                                }
                            }
                        }
                        if (_fromEdit && !_frmDelete) {
                            BTFlowtaskService.editVariable($applicationService.userInfo().userId, _selectedStream._id, $scope.componentId, _tmpVariables[$scope.currEditKeyIndex]).then(function (res) {
                                $scope.saving = false;
                                $scope.showEditFooter = true;
                                $scope.showEditVariables = true;
                                $workflowService.botEnvVariables(res.data);
                                NotificationService.notify(i18n.i18nString('bot_variable_updated'), 'success');
                                $scope.getBotVariables();
                                $scope.activateValueSearch();
                                $scope.openVarManSlid = false;
                                $scope.closeModalSlider('#variableManagementSlider');
                            }, function (err) {
                                $scope.saving = false;
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                            });
                        }

                        if (_fromEdit && _frmDelete) {
                            BTFlowtaskService.deleteVariable($applicationService.userInfo().userId, _selectedStream._id, _tmpVariables[$scope.currEditKeyIndex]._id).then(function (res) {
                                $scope.saving = false;
                                $scope.showEditFooter = true;
                                $scope.showEditVariables = true;
                                _tmpVariables.splice($scope.currEditKeyIndex, 1);
                                // $workflowService.botEnvVariables(res.data);
                                //console.log(res.data);
                                $('botVariable' + $scope.currEditKeyIndex).removeClass('saving');
                                $scope.botVariables = res.data;
                                $scope.tempBotVariables.splice($scope.currEditKeyIndex, 1);
                                $scope.activateValueSearch();
                                $scope.getBotVariables();
                                NotificationService.notify(i18n.i18nString('bot_Variable_deleted'), 'success');
                            }, function (err) {
                                $scope.saving = false;
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                            });
                        }
                        if (!_fromEdit && !_frmDelete) {
                            BTFlowtaskService.addVariables($applicationService.userInfo().userId, _selectedStream._id, payload).then(function (res) {
                                $scope.saving = false;
                                $scope.showEditVariables = $scope.showEditFooter = true;
                                $workflowService.botEnvVariables(res.data);
                                $scope.getBotVariables();
                                NotificationService.notify(i18n.i18nString('bot_variable_added'), 'success');
                                $scope.cancelCreateVariable();
                            }, function (error) {
                                $scope.saving = false;
                                if (_frmDelete) {
                                    $('botVariable' + index).removeClass('saving');
                                }
                                else {
                                    processBotVariables($scope.botVariables);
                                }
                                if (error && error.data && error.data.errors) {
                                    var _msg = error.data.errors[0].msg;
                                    NotificationService.notify(_msg, 'error');
                                    // $element.find('.saveButton').addClass('disabled');
                                } else if (error.errors && _.isArray(error)) {
                                    var msg = error.errors[0].msg;
                                    NotificationService.notify(msg, 'error');
                                } else {
                                    NotificationService.notify(i18n.i18nString('unexpected_error_while_saving'), 'error');
                                }
                                $scope.newVariableCreating = false;
                                $scope.saving = false;
                            });
                        }
                    };
                    // check is collectionActive
                    function isCollectionActive(refId) {
                        if($scope.collectionVariableForm.activeCollection.refId === refId) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                    // If collection & useCollections is true
                    function editCollections(i, value) {
                        if($scope.btCollectionVariables.useCollections) {
                            if($scope.tempBotVariables[i].value && $scope.tempBotVariables[i].value.length) {
                                $scope.audio.collection = {};
                                $scope.audioColShow = {};
                                BTStreamsService.btEditVariableCollection($applicationService.userInfo().userId, $workflowService.selectedStream()._id, value.key)
                                .then(function(res){
                                    if (res && res.data && res.data.length) {
                                        res.data.forEach(function(item) {
                                            $scope.variableForm.collectionVal[item.refId] = item.value;
                                            $scope.audio.collection[item.refId] = item.audioTag;
                                        });
                                    }
                                    if($scope.btCollectionVariables.collectionList && $scope.btCollectionVariables.collectionList.length) {
                                        $scope.btCollectionVariables.collectionList.forEach(function(item, index) {
                                            if($scope.audio.collection[item.refId]) {
                                                if(index !== -1) {
                                                    $scope.audioColShow[index] = true;
                                                }
                                            }
                                        });
                                    }
                                },function(err){
                                    if (err && err.data && err.data.errors) {
                                        NotificationService.notify(err.data.errors[0].msg, 'error');
                                    } else {
                                        NotificationService.notify('Failed to edit collection', 'error');
                                    }
                                });
                            }
                        }
                    }
                    $scope.editVariable = function (index, key) {
                        $scope.isEditVariable = true;
                        $scope.dropdownValues =  [];
                        $scope.selectedVariableDataType = "string";
                        $.each($scope.tempBotVariables, function (i, value) {
                            $scope.tempBotVariables[i].showEditDiv = false;
                            if (value.key === key) {
                                 var pattern = /\&gt/g;
                                if(pattern.test(JSON.stringify($scope.tempBotVariables[i]))){
                                    $scope.tempBotVariables[i] = JSON.parse(JSON.stringify($scope.tempBotVariables[i]).replace(/&gt;/g, '>').replace(/&lt;/g, '<'));
                                }
                                $scope.variableForm.variableKey = $scope.tempBotVariables[i].key;
                                $scope.variableForm.variableVal = $scope.tempBotVariables[i].value;
                                $scope.variableForm.variableHint = $scope.tempBotVariables[i].hint;
                                $scope.variableForm.scope = $scope.tempBotVariables[i].scope;
                                if($scope.tempBotVariables[i].meta && $scope.tempBotVariables[i].meta.dataType && $scope.sampleBot) {
                                    $scope.selectedVariableDataType = $scope.tempBotVariables[i].meta.dataType;
                                    if( $scope.tempBotVariables[i].meta.dataType === 'dropDown'){
                                        $scope.dropdownValues = $scope.tempBotVariables[i].meta.values || [];
                                        $.each($scope.dropdownValues,function(i,val){
                                          if(val === $scope.variableForm.variableVal){
                                              $scope.dropdownValueIndex = i;
                                          }
                                        });
                                    }
                                }
                                $scope.variableForm.variableGroup =  $scope.tempBotVariables[i].group;
                                editCollections(i, value);
                                if($scope.tempBotVariables[i].vNameSpace) {
                                    var nsListTemp = $scope.varNamespace.filter(function(val){ return $scope.tempBotVariables[i].vNameSpace.indexOf(val._id) > -1; });
                                    $scope.inpTags.text = _.pluck(nsListTemp, 'name');
                                    if($scope.inpTags.text.indexOf('default') > 0) {
                                        var tempIndDef = $scope.inpTags.text.indexOf('default');
                                        var tempValFirst = $scope.inpTags.text[0];
                                        $scope.inpTags.text[0] = 'default';
                                        $scope.inpTags.text[tempIndDef] = tempValFirst;
                                    }
                                }
                                else {
                                    $scope.inpTags.text = [{tag: 'default'}];
                                }
                                // if($scope.tempBotVariables[i].vNameSpace && $scope.tempBotVariables[i].vNameSpace.length && $scope.varNamespace.length) {
                                //     $scope.variableForm.variableNamespace = _.findWhere($scope.varNamespace, {'_id':  $scope.tempBotVariables[i].vNameSpace[0]}).name;
                                // }
                                // else {
                                //     $scope.variableForm.     = "";
                                // }
                                $scope.audio.tagLocation = $scope.tempBotVariables[i].audioTag;
                                // $scope.type.typeSelected = $scope.tempBotVariables[i].variableType === 'env' ? 'global' : 'lang';
                                $scope.currentIndexValuetoEdit = i;
                                $scope.componentId = $scope.tempBotVariables[i]._id;
                                if($scope.selectedStream.type === 'universalbot'){
                                    $scope.variableForm.propagateValue = $scope.tempBotVariables[i].propagateValue;
                                    $scope.variableForm.linkedBotId  = $scope.tempBotVariables[i].linkedBotId;
                                    setTimeout(function(){
                                        $('.kr-sg-dropdowns .dropdown').find('.dropdown-toggle .selectfield').html('<span class="botName" style="padding-left:10px;">'+$scope.tempBotVariables[i].linkedBotName?$scope.tempBotVariables[i].linkedBotName:selectBots+'</span>'); 
                                    }, 100);
                                }
                                
                            }
                        });
                        $scope.isNamespaceLoading = false;
                        $scope.openVarManSlid = true;
                        $timeout(function () {
                            $scope.openModalSlider('#variableManagementSlider');
                            attachTooltip();
                        });
                        //                        $scope.showFooter = false;
                    };
                    $scope.cancelEditDiv = function (index, key) {
                        $.each($scope.tempBotVariables, function (i, value) {
                            if (value.key === key) {
                                $scope.tempBotVariables[i].showEditDiv = false;
                            }
                        });
                        $scope.tempBotVariables = angular.copy($scope.botVariables);
                        $scope.showFooter = true;
                    };
                    $scope.saveVariables = function (index, key) {
                        if (key === "") {
                            NotificationService.notify(i18n.i18nString('please_provide_variable_name'), 'error');
                            return;
                        }
                        if ($scope.variableForm.variableKey === "") {
                            NotificationService.notify(i18n.i18nString('please_provide_variable_name'), 'error');
                            return;
                        }
                        if ($scope.variableForm.variableVal === "") {
                            if($scope.sampleBot && $scope.selectedVariableDataType === 'dropDown') {
                                NotificationService.notify(i18n.i18nString('please_provide_variable_value'), 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('please_provide_variable_value'), 'error');
                            }
                            return;
                        }
                        function editVarNamespace(_id) {
                            if ($('input[ng-model="botVariableType"]:checked').attr('id') === 'globalType') {
                                if ($scope.tempBotVariables[$scope.currEditKeyIndex].value === "") {
                                    NotificationService.notify(i18n.i18nString('please_provide_variable_value'), 'error');
                                    return;
                                }
                            }
                            $scope.saving = true;
                            $scope.tempBotVariables[$scope.currEditKeyIndex].originalKey = $scope.tempBotVariables[$scope.currEditKeyIndex].key;
                            if(_id) {
                                $scope.tempBotVariables[$scope.currEditKeyIndex].vNameSpace = _id;
                            }
                            $scope.saveBotVariables(true, false);
                            $scope.cancelEditDiv(index, key);
                        }
                        if (index > -1) {
                            $scope.currEditKeyIndex = index;
                            $scope.tempBotVariables[index].key = $scope.variableForm.variableKey;
                            $scope.tempBotVariables[index].value = $scope.variableForm.variableVal;
                            $scope.tempBotVariables[index].audioTag = $scope.audio.tagLocation;
                            $scope.tempBotVariables[index].variableType = $scope.botVariableType;
                            $scope.tempBotVariables[index].group = $scope.variableForm.variableGroup == $scope.addNewGroup?$scope.add.newVar.trim():$scope.variableForm.variableGroup;
                            $scope.tempBotVariables[index].hint = $scope.variableForm.variableHint;
                            $scope.tempBotVariables[index].scope = $scope.variableForm.scope;
                            if($scope.selectedStream.type === 'universalbot'){
                              $scope.tempBotVariables[index].propagateValue = $scope.variableForm.propagateValue;
                              $scope.tempBotVariables[index].linkedBotId = $scope.variableForm.linkedBotId;     
                            }
                            if($scope.inpTags.text.length > 0){
                                var nsList = _.pluck($scope.inpTags.text, 'tag');
                                var tempFiltered = $scope.varNamespace.filter(function(val){ return nsList.indexOf(val.name) > -1; });
                                var idTemp = _.pluck(tempFiltered, '_id');
                                editVarNamespace(idTemp);
                            } else { editVarNamespace(null); }
                        } else {
                            $.each($scope.tempBotVariables, function (i, value) {
                                if (value.key === key) {
                                    $scope.currEditKeyIndex = i;
                                }
                            });
                            editVarNamespace();
                        }
                    };
                    $scope.showDropDown = function (e) {
                        e.stopPropagation();
                        if (e.currentTarget) {
                            var _currEle = $(e.currentTarget);
                            _currEle.siblings().removeClass('active');
                            _currEle.addClass('active');
                            _currEle.find('.dropdown').addClass('open');
                        }
                    };

                    $(function () {
                        $('[data-toggle="popover"]').popover();
                    });

                    $scope.getLinkedBots = function(){
                        if(_selectedStream.type === 'universalbot'){
                            var confRecords = [],publishedRecords = [];
                             confRecords = _.uniq(totalLinkedBots.concat(_selectedStream.configuredBots,_selectedStream.awaitingApprovalBots));
                             publishedRecords = _selectedStream.publishedBots.filter(function (bot) {
                                if(!_.filter(_selectedStream.unpublishedBots,{'_id':bot._id}).length){
                                    return bot;
                                }
                            });
                            $scope.totalLinkedBots = confRecords.concat(publishedRecords);

                        }
                    };

                    $scope.selectedBot = function(bot){
                         $('.kr-sg-dropdowns .dropdown').find('.dropdown-toggle .selectfield').html('<span class="botName" style="padding-left:10px;">'+bot.botName+'</span>');   
                         $('.dropdown-menu.content-menu').prev().dropdown('toggle');
                         $scope.variableForm.linkedBotId = bot._id;
                    
                    };

                    $scope.deleteVariable = function (index, key) {
                        NotificationService.alert(i18n.i18nString('do_you_want_to_delete_this_bot_Variable'), function () {
                            $.each($scope.tempBotVariables, function (i, value) {
                                if (value.key === key) {
                                    $scope.currEditKeyIndex = i;
                                }
                            });
                            $('botVariable' + index).addClass('saving');
                            $scope.saveBotVariables(true, true, index);
                        }, { okText: i18n.i18nString('ok_uppercase') });
                    };
                    //used while builder is resuming//
                    $scope.$emit('nestedComponentLoaded', { 'id': 'variableManagement', 'flag': false });
                    //Add below whenever nestedComponentLoaded is FINALLY emitted.
                    $timeout(function () {
                        $scope.$emit('gSearchLoad');
                    });
                    $scope.sortByGroup = function(){
                        $scope.sortKey = $scope.sortKey == 'group'?'-group':'group';
                        if($scope.sortKey === '-group'){
                            $scope.decendingOrder = true;
                            $scope.ascendingOrder = false;
                        }else{
                            $scope.ascendingOrder = true;
                            $scope.decendingOrder = false;
                        }
                    };

                    $scope.sortByNamespace = function() {
                        $scope.sortKey = $scope.sortKey == 'namespace'?'-namespace':'namespace';
                        if($scope.sortKey === '-namespace'){
                            $scope.decendingOrderNS = true;
                            $scope.ascendingOrderNS = false;
                        }else{
                            $scope.ascendingOrderNS = true;
                            $scope.decendingOrderNS = false;
                        }
                    };
                }]
        };
    });
    _module.filter('dispTypeFilter', function () {
        return function (input) {
            if (input === 'env') {
                return "Global";
            }
            else if (input === 'locale') {
                return "Content";
            }
        };
    });
    _module.filter('patternChangeVariable', function () {
        return function (input) {
            if(typeof input === 'object') {
                return input;
            }
            if (input) {
                return input.replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&Gt;/g, '>').replace(/&Lt;/g, '<');
            }
        };
    });
})(angular);

;(function (ng) {
    'use strict';
    var _module = ng.module("bt-kore-components");
    _module.directive('btWatchVideos', function () {
        return {
            restrict: 'EA',
            scope:{
               videoId: "=?"
            },
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-watch-videos/bt-watch-videos.html',
            controller: ['$window', '$element', '$rootScope','$scope', '$workflowService', '$location', '$routeParams', 'NotificationService', 'form_util','indexerUtil','accessControlService','env_conf',"$timeout",'i18n',
                function ($window, $element, $rootScope, $scope, $workflowService, $location, $routeParams, NotificationService, form_util, indexerUtil,accessControlService,env_conf,$timeout,i18n) {
                    $scope.backToLanding = window.appConfig.CONTEXT_PATH+'/assets/landingImages/backArrow.svg';
                    $scope.videoPlayIcon = window.appConfig.CONTEXT_PATH+'/assets/icons/videoPlayIcon.svg';
                    $scope.hideLoadMore = false;
                    $scope.paginate = {};
                    $scope.paginate.size = 4;
                    $("html").addClass("onBoardVideoMobileView");
                    $scope.loadMoreVideos= function(previoisSize){
                        previoisSize = previoisSize + 4;
                        if(previoisSize >= $scope.videoObject.videos.length){
                            $scope.hideLoadMore = true;
                        }
                        return previoisSize;
                    };
                    $scope.selectVideoToPlay= function(videoLink){
                        $scope.videoObject.selectedVideo=window.appConfig.CONTEXT_PATH+'/assets/icons/koreAiDefaultIcon.png';
                        $timeout(function () {
                           var link = angular.copy(videoLink);
                        link.link = link.link+"?controls=1&autoplay=1&rel=0";
                        $scope.videoObject.selectedVideo = angular.copy(link);
                        },500);
                         
                    };
                    $scope.closeVideo=function(){
                         $("html").removeClass("onBoardVideoMobileView");
                        $scope.callback.closeFullPageModal();
                    };
                    $scope.videoObject={
                         'videos':[
                             {   "id":"getstarted",
                                 "link":"https://www.youtube.com/embed/9FM1RnBmY_8",
                                 "title":i18n.i18nString('bt_watch_videos_get_started_label'),
                                 "disc":i18n.i18nString('bt_watch_videos_get_started_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/9FM1RnBmY_8/mqdefault.jpg"
                             },
                             {   "id":"overview",
                                 "link":"https://www.youtube.com/embed/wH079pMroRs",
                                 "title":i18n.i18nString('bt_watch_videos_overview_label'),
                                 "disc":i18n.i18nString('bt_watch_videos_overview_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/wH079pMroRs/mqdefault.jpg"
                             },
                             {   "id":"createnewbot",
                                 "link":"https://www.youtube.com/embed/5AHi-Hz21Kw",
                                 "title": i18n.i18nString('standard_name'),
                                 "disc":i18n.i18nString('bt_watch_videos_create_new_bot_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/5AHi-Hz21Kw/mqdefault.jpg"
                             },
                             {   "id":"tasktypes",
                                 "link":"https://www.youtube.com/embed/ta15UkwWLaQ",
                                 "title":i18n.i18nString('bt_watch_videos_task_type_label'),
                                 "disc":i18n.i18nString('bt_watch_videos_task_type_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/ta15UkwWLaQ/mqdefault.jpg"
                             },
                             {   "id":"builddialog",
                                 "link":"https://www.youtube.com/embed/zF7k17SuG5U",
                                 "title":i18n.i18nString('bt_watch_videos_build_a_dialog_label'),
                                 "disc":i18n.i18nString('bt_watch_videos_build_a_dialog_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/zF7k17SuG5U/mqdefault.jpg"
                             },
                             {   "id":"buildkt",
                                 "link":"https://www.youtube.com/embed/8aUhwYKE-Q8",
                                 "title":i18n.i18nString('bt_watch_videos_build_knowledge_task_label'),
                                 "disc":i18n.i18nString('bt_watch_videos_build_knowledge_task_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/8aUhwYKE-Q8/mqdefault.jpg"
                             },
                             {   "id":"nlptraining",
                                 "link":"https://www.youtube.com/embed/8kRYauJQE8U",
                                 "title":i18n.i18nString('bt_watch_videos_build_nlp_training_label'),
                                 "disc":i18n.i18nString('bt_watch_videos_build_nlp_training_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/8kRYauJQE8U/mqdefault.jpg"
                             }
                         ],
                         'selectedVideo':{
                                 "link":"https://www.youtube.com/embed/9FM1RnBmY_8?controls=1&autoplay=1&rel=0",
                                 "title":i18n.i18nString('bt_watch_videos_get_started_label'),
                                 "disc":i18n.i18nString('bt_watch_videos_get_started_desc'),
                                 "tumbnail":"https://i.ytimg.com/vi/9FM1RnBmY_8/mqdefault.jpg"
                             }
                            };
                    function load(){
                        if ($scope.videoId) {
                            var _selectVideo = _.find($scope.videoObject.videos, {id: $scope.videoId});
                             $scope.selectVideoToPlay(_selectVideo);
                        }
                    }        
                    load();
                }]
        };
    });
})(angular);

;(function(ng) {

	'use strict';

	var _module = ng.module('bt-wf-create', ['app.helpers', 'bt-forms']);

	_module.directive("btWfCreate", function(){
		return{
			restrict: "EA",
			templateUrl: window.appConfig.TMPLT_PRE_PATH + "js/modules/bt-wf-create/bt-wf-create.html",
			controller: 'BTWFCreateCtrl'
		};
		
	});

	_module.controller('BTWFCreateCtrl', ['$scope','$filter','$rootScope', '$routeParams', '$timeout', '$location', '$workflowService', 'BTSeedDataService', 'NotificationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService','i18n',
	function($scope,$filter,$rootScope, $routeParams, $timeout, $location, $workflowService, BTSeedDataService, NotificationService, BTAlertsService, BTActionsService, BTStreamsService,i18n) {


		$rootScope.$on("initTaskCreation", function() {
			$scope.initiateTaskCreationFlow();
		});

		$scope.initiateTaskCreationFlow = function() {
			$rootScope.saveAndExit = false;

			$scope.displayMode = '';

			$scope.wftype = $workflowService.workflowType();

			$scope.selectedStream = $workflowService.selectedStream();

			if(!$workflowService.workflowType()){
				$location.path(window.appConfig.CONTEXT_PATH);
				return;
			}

			$scope.callbacks = {
				basic : {},
				auth  : {},
				requestObj : {},
				responseObj : {},
				errorMsgs : {},
				settings : {},
				finishForm : {}
			};

			$scope.sections = {
				basic:true,
				auth:false,
				requestObj:false,
				responseObj:false,
				errorMsgs:false,
				settings:false,
				finishForm:false
			};

			$scope.entityObj={};

			$scope.currentStage = rss_webservice_stages.basic;
			$scope.currentStep  = 1;

			if($scope.wftype === 'alert'){
				$scope.stages={
					webhook    : webhook_stages,
					rss        : rss_webservice_stages,
					webservice : rss_webservice_stages
				};
			}else if($scope.wftype === 'action' ){
                            resource = $workflowService.actionInfo();
			      $scope.resource=resource;
				$scope.stages = {
					webservice : action_stages
				};
			}

			navigateTo($scope.currentStage.curr);

		};


		var rss_webservice_stages = {
			basic:{
				prev:'start',
				curr:'basic',
				next:'auth',
				no:1
			},auth:{
				prev:'basic',
				curr:'auth',
				next:'requestObj',
				no:2
			},requestObj:{
				prev:'auth',
				curr:'requestObj',
				next:'responseObj',
				no:3
			},responseObj:{
				prev:'requestObj',
				curr:'responseObj',
				next:'settings',
				//next:'errorMsgs',
				no:4
			},errorMsgs:{
				prev:'responseObj',
				curr:'errorMsgs',
				next:'settings',
				no:5
			},settings:{
				/*prev:'errorMsgs',*/
				prev:'responseObj',
				curr:'settings',
				next:'finishForm',
				no:6
			},
			finishForm:{
				prev:'settings',
				curr:'finishForm',
				next:'end',
				no:7
			}
		};

		var action_stages = {
			basic:{
				prev:'start',
				curr:'basic',
				next:'auth',
				no:1
			},auth:{
				prev:'basic',
				curr:'auth',
				next:'requestObj',
				no:2
			},requestObj:{
				prev:'auth',
				curr:'requestObj',
				next:'responseObj',
				no:3
			},responseObj:{
				prev:'requestObj',
				curr:'responseObj',
				/*next:'errorMsgs',*/
				next:'finishForm',
				no:4
			},errorMsgs:{
				prev:'responseObj',
				curr:'errorMsgs',
				next:'finishForm',
				no:5
			},
			finishForm:{
				prev:'responseObj',
				/*prev:'errorMsgs',*/
				curr:'finishForm',
				next:'end',
				no:6
			}
		};

		var webhook_stages = {
			basic:{
				prev:'start',
				curr:'basic',
				next:'requestObj',
				no:1
			},
			requestObj:{
				prev:'basic',
				curr:'requestObj',
				next:'responseObj',
				no:2
			},
			responseObj:{
				prev:'requestObj',
				curr:'responseObj',
				/*next:'errorMsgs',*/
				next:'finishForm',
				no:3
			},
			errorMsgs:{
				prev:'responseObj',
				curr:'errorMsgs',
				next:'finishForm',
				no:4
			},
			finishForm:{
				prev:'responseObj',
				/*prev:'errorMsgs',*/
				curr:'finishForm',
				next:'end',
				no:5
			}
		};



		$scope.nextStep = function(){
			var section;
			if($scope.currentStep < $scope.stages[$scope.entityObj.type][$scope.currentStage.curr]['next'].no){
				$scope.currentStep = $scope.stages[$scope.entityObj.type][$scope.currentStage.curr]['next'].no;
			}
			hideSections();
			section = $scope.stages[$scope.entityObj.type][$scope.currentStage.curr]['next'];
			$scope.currentStage = $scope.stages[$scope.entityObj.type][section];
			$scope.currentStep  = $scope.currentStage.no;
			if(section !== 'end' && $scope.stages[$scope.entityObj.type][$scope.currentStage.prev].visited){
				$scope.sections[section] = true;
			}
		};

		$scope.previousStep = function(){
			var section;
			hideSections();
			section = $scope.stages[$scope.entityObj.type][$scope.currentStage.curr]['prev'];
			$scope.currentStage = $scope.stages[$scope.entityObj.type][section];
			if(section !== 'start'){
				$scope.sections[section] = true;
			}
		};

		$scope.getStepNo = function(section){
			if($scope.entityObj && $scope.entityObj.type){
				return $scope.stages[$scope.entityObj.type][section].no;
			}else if($scope.wftype === 'action'){
				return $scope.stages['webservice'][section].no;
			}else{
				return 1;
			}
		};

		function hideSections(){
			Object.keys($scope.sections).map(function(key){
				$scope.sections[key] = false;
			});
		}

		$scope.onIntroFormResponse = function(wftype) {
			$scope.entityObj =  wftype === 'alert' ? $workflowService.alertInfo() : $workflowService.actionInfo();
			triggerNextStep();
		};

		$scope.onAuthFormResponse = function() {
			triggerNextStep();
		};

		$scope.onReqObjectFormResponse = function(wftype) {
			triggerNextStep();
		};

		$scope.onResObjectFormResponse = function(wftype) {
			triggerNextStep();
		};

		$scope.onSettingsFormResponse = function() {
			triggerNextStep();
		};

		$scope.onSlashCommandsFormResponse = function() {
			triggerNextStep();
		};

		$scope.finishSetup = function() {
			$scope.markItConfigured($scope.wftype);
		};

		$scope.errorMsgSave=function(errors,cb){
			if($scope.wftype==='alert'){
				var alert =  {} || $workflowService.alertInfo();
				alert.errorCodes={
					pollError:errors
				};
				BTAlertsService.createBTAlertUp($workflowService.alertInfo()._id,alert)
				        .then(function(res) {
				            $workflowService.alertInfo(res.data);
				            errorSaveHandler();
				            cb();
				        },function(res) {
				        	cb();
				            if (res.data.errors && res.data.errors[0] && res.data.errors[0].code === 409) {
				                NotificationService.notify(res.data.errors[0].msg, 'error');
				            } else {
				                NotificationService.notify(i18n.i18nString('bt_wf_create_failed_to_update',{dyn: $scope._constants_.alert}), "error");
				            }
				        });
			}else{
				var action = {} || $workflowService.actionInfo();
				action.errorCodes={
					pollError:errors
				};
				BTActionsService.updateBTAction($workflowService.actionInfo()._id,action)
				        .then(function(res) {
				            $workflowService.actionInfo(res.data);
				            errorSaveHandler();
				            cb();
				        }, function(res) {
				        	cb();
				            if (res.data.errors && res.data.errors[0] && res.data.errors[0].code === 409) {
				                NotificationService.notify(res.data.errors[0].msg, 'error');
				            } else {
				                NotificationService.notify(i18n.i18nString('bt_wf_create_failed_to_update',{dyn: $scope._constants_.action}), "error");
				            }
				        });
			}

		};

		function errorSaveHandler(){
			triggerNextStep();
		}

		function triggerNextStep(){
			$scope.stages[$scope.entityObj.type][$scope.currentStage.curr].visited = true;
			$scope.nextStep();
		}

		$scope.gotostream = function() {
			$location.path(window.appConfig.CONTEXT_PATH);
		};

		$scope.isItRestType = function(){

			var subtype;

			if($scope.wftype === 'alert'){
				subtype = $workflowService.alertInfo() && $workflowService.alertInfo().subtype;
			}else{
				subtype = $workflowService.actionInfo() && $workflowService.actionInfo().subtype;
			}

			return (subtype !== 'soap');

		};


		function navigateTo(screen) {
			if($scope.entityObj && $scope.entityObj.type){
				if($scope.currentStep >= $scope.stages[$scope.entityObj.type][screen].no){
					hideSections();
					$scope.sections[screen] = true;
					$scope.currentStage = $scope.stages[$scope.entityObj.type][screen];
					$('html, body').animate({ scrollTop: 0 }, 'fast');
				}
			}
			// $("body").removeClass("modal-open");
		}


		$scope.onCancel = function(){
			//$location.path(window.appConfig.CONTEXT_PATH);
			$("#taskCreateOrEditModal").modal("hide");
		};

		$scope.onSaveAndExit = function(){
			$rootScope.saveAndExit = true;
			switch($scope.currentStage.curr){
				case 'basic':
					$rootScope.$broadcast('evt:nextActintro');
					break;
				case 'auth':
					$rootScope.$broadcast('evt:nextActAuth');
					break;
				case 'requestObj':
					$rootScope.$broadcast('evt:nextActReq');
					break;
				case 'responseObj':
					$rootScope.$broadcast('evt:nextActRes');
					break;
				case 'errorMsgs':
					$roooScope.$broadcast('evt:nextActErr');
					break;
				case 'settings':
					$rootScope.$broadcast('evt:exitActSetng');
					break;
			}
		};

		$scope.navigateTo=function(screen){
			

			var isChanged = (($scope.callbacks[$scope.currentStage.curr] || {}).isChanged || angular.noop)();
			var callback  = (($scope.callbacks[$scope.currentStage.curr] || {}).triggerSave || angular.noop);

			if(isChanged){
				NotificationService.confirm({
				    msg       : i18n.i18nString('bt_wf_proceeding_noty'),
				    successCb : _.partial(triggerCurrentStageSave,startNavigation),
				    failCb    : startNavigation,
                    cancelCb: function () {
                        return false;
                    },
				    isModal   : true,
				    btnTexts  : {
				      success : i18n.i18nString('save'),
				      fail    : i18n.i18nString('discard_label')
				    }
				});
				return;
			}else{
				startNavigation();
			}

			function triggerCurrentStageSave(navCb){
				if(callback == angular.noop){
					startNavigation();
				}else{
					callback(navCb || angular.noop);
				}
			}

			function startNavigation() {

				window.onbeforeunload = angular.noop;

				$rootScope.saveAndExit = false;
				navigateTo(screen);
			
			}


		};

		$scope.$on('evt:nextSucc',function(evt,data){
			if($rootScope.saveAndExit){
				$location.path(window.appConfig.CONTEXT_PATH);
			}
		});

		$scope.isFinshSetupLoading = false;

		$scope.markItConfigured=function(type){

			var isChanged = (($scope.callbacks[$scope.currentStage.curr] || {}).isChanged || angular.noop)();
			var callback  = (($scope.callbacks[$scope.currentStage.curr] || {}).triggerSave || angular.noop);

			if(isChanged){
				if(callback !=  angular.noop){
					callback(triggerCall);
				}else{
					triggerCall();
				}
			}else{
				triggerCall();
			}

			function triggerCall(){

				$scope.isFinshSetupLoading = true;

				if(type === 'alert'){
					return BTAlertsService.configured($workflowService.alertInfo()._id).then(function(res){
						$scope.isFinshSetupLoading = false;
						$location.path(window.appConfig.CONTEXT_PATH);
						return res;
					},function(err){
						NotificationService.notify(err.data.errors[0].msg,'error');
						$scope.isFinshSetupLoading = false;
						return;
					});
				}else if(type === 'action'){
					return BTActionsService.configured($workflowService.actionInfo()._id).then(function(res){
						$scope.isFinshSetupLoading = false;
						$location.path(window.appConfig.CONTEXT_PATH);
						return res;
					},function(err){
						$scope.isFinshSetupLoading = false;
						NotificationService.notify(err.data.errors[0].msg,'error');
						return;
					});
				}

			}

		};

		$scope.getAlertType = function(){
			return $workflowService.alertInfo().type;
		};

		$scope.isThisSectionRequired=function(section){

			if(section  ==='basic'){
				return true;
			}

			var type = ($scope.wftype === 'alert')? $scope.entityObj.type : 'webservice';

			return $scope.stages && $scope.stages[type] && $scope.stages[type][section];

		};

		// navigateTo($scope.currentStage.curr);

	}]);

})(angular);


;(function(ng) {

	'use strict';

	var _module = ng.module('bt-wf-edit', ['app.helpers', 'bt-forms']);

	_module.directive("btWfEdit", function(){
		return{
			restrict: "EA",
			templateUrl: window.appConfig.TMPLT_PRE_PATH + "js/modules/bt-wf-edit/bt-wf-edit.html",
			controller: 'BTWFEditCtrl'
		};
		
	});

	_module.controller('BTWFEditCtrl', ['$scope', '$rootScope', '$routeParams', '$timeout', '$location', '$workflowService', 'BTSeedDataService', 'NotificationService', 'BTAlertsService', 'BTActionsService', 'BTStreamsService','i18n', "env_conf","mixPanel",'BTFlowtaskService','$applicationService',
	function($scope, $rootScope, $routeParams, $timeout,$location, $workflowService, BTSeedDataService, NotificationService, BTAlertsService, BTActionsService, BTStreamsService,i18n, env_conf,mixPanel,BTFlowtaskService,$applicationService) {

		$scope.gotostream = function() {
			$location.path(window.appConfig.CONTEXT_PATH);
		};

		$rootScope.saveAndExit = false;
                $scope.tmpltPrePath=$scope.$root.tmpltPrePath;

		$scope.junk=null;
		$scope.taskEditInfo = $workflowService.taskEditInfo();
		$scope.wftype=$scope.taskEditInfo.taskType;
		var action = $workflowService.taskMode();

		$scope.action = action;


		$scope.selectedStream = $workflowService.selectedStream();

		$scope.showSaveAndExit=false;

		$scope.workflowSidebarData = {};
		$scope.workflowSidebarData.stream = $workflowService.selectedStream();
		$scope.workflowSidebarData.wfType = $scope.wftype;

		$scope.currentSection = 'introForm';
		$scope.chevronLeftGray = env_conf['context-url']+'/assets/icons-new/chevron/chevron-left-gray.svg';
		$scope.callbacks = {
			introForm : {},
			authForm  : {},
			reqObjForm : {},
			resObjForm : {},
			settingsForm : {},
			soapreqform : {}
		};

		$scope.displayMode = action;

		$scope.forms= {
			introFormDisplayMode    : action,
			authFormDisplayMode     : action,
			reqObjFormDisplayMode   : action,
			resObjFormDisplayMode   : action,
			settingsFormDisplayMode : action,
			streamFormDisplayMode   : action,
			errorFormDisplayMode    : action,
			finishFormDisplayMode   : action
		};

		$scope.sections={
			introForm    : true,
			authForm     : false,
			reqObjForm   : false,
			resObjForm   : false,
			settingsForm : false,
			streamForm   : false,
			errorForm    : false,
			finishForm   : false
		};


		$scope.helplinks = {
			introForm    : {
				alert: 'ALERTS_TASK_BASIC',//$rootScope.helpLinks.ALERTS_TASK_BASIC,
				action: 'ACTIONS_TASK_BASIC',//$rootScope.helpLinks.ACTIONS_TASK_BASIC,
				report: 'INFORMATION_TASK_BASIC'//$rootScope.helpLinks.INFORMATION_TASK_BASIC
			},
			reqObjForm   : {
				alert: {
					rest:'ALERT_REQ_REST',//$rootScope.helpLinks.ALERT_REQ_REST,
					soap:'ALERT_REQ_SOAP',//$rootScope.helpLinks.ALERT_REQ_SOAP,
					webhook:'ALERT_REQ_WEBHOOK',//$rootScope.helpLinks.ALERT_REQ_WEBHOOK,
					rss:'ALERT_REQ_RSS'//$rootScope.helpLinks.ALERT_REQ_RSS
				},
				action: {
					rest:'ACTIONS_REQ_REST',//$rootScope.helpLinks.ACTIONS_REQ_REST,
					soap:'ACTIONS_REQ_SOAP'//$rootScope.helpLinks.ACTIONS_REQ_SOAP
				},
				report: {
					rest:'INFORMATION_REQ_REST',//$rootScope.helpLinks.INFORMATION_REQ_REST,
					soap:'INFORMATION_REQ_SOAP'//$rootScope.helpLinks.INFORMATION_REQ_SOAP
				}
			},
			resObjForm   : {
				alert: 'ALERT_RES',//$rootScope.helpLinks.ALERT_RES,
				action: 'ACTIONS_RES',//$rootScope.helpLinks.ACTIONS_RES,
				report: 'INFORMATION_RES'//$rootScope.helpLinks.INFORMATION_RES,
			},
			settingsForm : {
				alert: 'ALERT_SETTING'//$rootScope.helpLinks.ALERT_SETTING			
			}
		};

		/*helplink urls*/
			$scope.updateHelpLink = function(){
				var taskType = $scope.wfType === 'alert' ? $scope.wfType : (resource.isReport ? 'report' : 'action');
				var currentSection = $scope.currentSection === 'soapreqform' ?  'reqObjForm' : $scope.currentSection;
				var connectionType = resource.type === 'webservice' ? resource.subtype : resource.type;
				if(currentSection === "reqObjForm"){
					return $scope.helplinks[currentSection][taskType][connectionType];
				}else{
					return $scope.helplinks[currentSection][taskType];
				}
			};
		/*end of helplink urls*/
		$scope.getBotVariables = function(){
			BTFlowtaskService.getAllVariables($applicationService.userInfo().userId, $workflowService.selectedStream()._id).then(function (res) {
					   $workflowService.botEnvVariables(res.data.variables);
		   });
	    };
	    $scope.getBotVariables();
		$scope.showFinishSetup = function() {
			if($scope.currentSection !== "soapreqform"){
				return true;
			}else{
				return $scope.callbacks.soapreqform.showSave();
			}
		};

        var resource;
		if($scope.wftype==='alert'){
			resource= $workflowService.alertInfo();
			$scope.resource=resource;
		}else if($scope.wftype==='action' || $scope.wftype==='report'){
			resource = $workflowService.actionInfo();
			$scope.resource=resource;
		}

		$scope.$on("resourceUpdate", function(){
			if($scope.wftype==='alert'){
				resource= $workflowService.alertInfo();
				$scope.resource=resource;
			}else if($scope.wftype==='action'){
				resource = $workflowService.actionInfo();
				$scope.resource=resource;
			}
		});

		$scope.$on("mpResourceUpdate", function(event, resourceInfo){
			if(resourceInfo.taskType === "alert"){
				var mpalert = {};
				mpalert._id = resourceInfo._id;
				mpalert.shortDesc = resourceInfo.shortDesc;
				BTAlertsService.updateMPAlert(resourceInfo._id, mpalert)
				.then(function (res) {
					$scope.saveInProgress = false;
					$workflowService.mpAlertInfo(res.data);
					$rootScope.$emit("insertOrUpdateTask", "alert", $workflowService.alertInfo(), false);
				}, function (res) {
					console.log("res");
				});

			}else if(resourceInfo.taskType === "action"){
				var mpAction = {};
				mpAction._id = resourceInfo._id;
				mpAction.shortDesc = resourceInfo.shortDesc;
				BTActionsService.updateMPAction(resourceInfo._id, mpAction)
				.then(function (res) {
					$scope.saveInProgress = false;
					$workflowService.mpActionInfo(res.data);
					$rootScope.$emit("insertOrUpdateTask", "action", $workflowService.actionInfo(), false);
				}, function (res) {
					console.log("res");
				});
			}
			
		});

		if(!(_.isObject(resource) && Object.keys(resource).length>0)){
			$location.path(window.appConfig.CONTEXT_PATH);
			return;
		}

		// $scope.sections.introForm  = $scope.resource.state === 'published' && action !== 'view';
		// $scope.sections.finishForm = $scope.resource.state !== 'published' || action === 'view';

		$scope.streamDataId=resource.streamId;

		$scope.handleIntroForm=function(){
			var entity = ($scope.workflowSidebarData.wfType.toLowerCase() === 'action' || $scope.workflowSidebarData.wfType.toLowerCase() === 'report') ? $scope._constants_.action : $scope._constants_.alert;
			NotificationService.notify(i18n.i18nString('saved'),"success");
		};

		$scope.handleAuthForm     = angular.noop();

		$scope.handleReqObjForm   = angular.noop();

		$scope.handleResObjForm   = angular.noop();

		$scope.handleSettingsForm = angular.noop();

		$scope.handleStreamForm   = angular.noop();

		$scope.handleErrorForm = function(){
			$rootScope.$broadcast('evt:nextSucc');
		};

		$scope.errorMsgSave=function(errors,cb){

			if($scope.wftype==='alert'){

				var alert = {} || $workflowService.alertInfo();
				alert.errorCodes={
					pollError:errors
				};
				BTAlertsService.createBTAlertUp($workflowService.alertInfo()._id,alert)
				        .then(function(res) {
							NotificationService.notify(i18n.i18nString('err_messages_saved_sucess'),"success");
				            $workflowService.alertInfo(res.data);
				            $scope.handleErrorForm();
				            cb();
				        }, function(res) {
				            cb();
				        	$rootScope.saveAndExit = false;
				            if (res.data.errors && res.data.errors[0] && res.data.errors[0].code === 409) {
				                NotificationService.notify(res.data.errors[0].msg, 'error');
				            } else {
				                NotificationService.notify(i18n.i18nString('err_messages_saved_err'), "error");
				            }
				    });

			}else{

				var action = {} || $workflowService.actionInfo();
				action.errorCodes={
					pollError:errors
				};
				BTActionsService.updateBTAction($workflowService.actionInfo()._id,action)
				        .then(function(res) {
				            cb();
							NotificationService.notify(i18n.i18nString('err_messages_saved_sucess'),"success");
				            $workflowService.actionInfo(res.data);
				            $scope.handleErrorForm();
				        }, function(res) {
				            cb();
				        	$rootScope.saveAndExit = false;
				            if (res.data.errors && res.data.errors[0] && res.data.errors[0].code === 409) {
				                NotificationService.notify(res.data.errors[0].msg, 'error');
				            } else {
				                NotificationService.notify(i18n.i18nString('err_messages_saved_err'), "error");
				            }
				    });

			}

		};

		$scope.isItRestType = function(){

			var subtype;

			if($scope.wftype === 'alert'){
				subtype = $workflowService.alertInfo() && $workflowService.alertInfo().subtype;
			}else{
				subtype = $workflowService.actionInfo() && $workflowService.actionInfo().subtype;
			}

			return (subtype !== 'soap');

		};

		$scope.isItSoapType = function(){

			var subtype;

			if($scope.wftype === 'alert'){
				subtype = $workflowService.alertInfo() && $workflowService.alertInfo().subtype;
			}else{
				subtype = $workflowService.actionInfo() && $workflowService.actionInfo().subtype;
			}

			return (subtype === 'soap');

		};

		$scope.isFinshSetupLoading = false;

		$scope.markItConfigured=function(type){

			var isChanged = (($scope.callbacks[$scope.currentSection] || {}).isChanged || angular.noop)();
			var callback  = (($scope.callbacks[$scope.currentSection] || {}).triggerSave || angular.noop);

			var notify = NotificationService.notify.bind(NotificationService);

			NotificationService.notify = angular.noop;

			if(isChanged){
				if(callback !=  angular.noop){
					callback(triggerCall);
				}else{
					triggerCall();
				}
			}else{
				triggerCall();
			}
			if ($scope.wfType === 'alert') {
				$scope.alerttypes = $workflowService.seedData().alertTypes || [];
				if ($scope.alerttypes.length) {
					if ($scope.alerttypes[0].name !== "Webservice") {
						$scope.alerttypes.reverse();
					}
				}
				for (var i = 0; i < $scope.alerttypes.length; i++) {
					if ($scope.alerttypes[i].value === "email") {
						$scope.alerttypes.splice(i, 1);
						break;
					}
				}
			}
			$scope.subtypes = $workflowService.seedData().webserviceTypes;
			var connectionType = {};
			var connectionMode = {};
			$scope.alerttypes.forEach(function(value) {
				connectionType[value.value] =  value.name;
			});
			$scope.subtypes.forEach(function(value) {
				connectionMode[value.value] =  value.name;
			});
			function triggerCall(){

				$scope.isFinshSetupLoading = true;
				if(type === 'alert' && $workflowService.alertInfo().state !== "published" && $workflowService.alertInfo().state !== "suspended"){
					return BTAlertsService.configured($workflowService.alertInfo()._id).then(function(res){
						var eventInfo = {
							"streamId":$workflowService.selectedStream()._id,
							"BotName":$workflowService.selectedStream().name,
							"BotLanguage":$workflowService.currentLanguage(),
							"Level":"Engagement L2",
							"Category":"Engagement L2",
							"Sub Category":"Conversation - Alert Task",
							"Connection Type":connectionType[$workflowService.alertInfo().type],
							"Connection Mode":connectionMode[$workflowService.alertInfo().subtype]
						};
						mixPanel.postEvent('Conversation - Alert Task completed',eventInfo);
						$scope.isFinshSetupLoading = false;
						NotificationService.notify = notify;
						$scope.onCancel();
						//$location.path(window.appConfig.CONTEXT_PATH);
						return res;
					},function(err){
						NotificationService.notify = notify;
						NotificationService.notify(err.data.errors[0].msg,'error');
						$scope.isFinshSetupLoading = false;
						if(err.data.errors[0].msg === "Authentication : Authentication is not defined" || err.data.errors[0].msg === "Request : Request is not defined" || err.data.errors[0].msg === "Request : Sample response data is not defined"){
							for(var key in $scope.sections){
									if($scope.sections.hasOwnProperty(key)){
										$scope.sections[key]=false;
									}
								}
								$scope.sections.reqObjForm = true;
								$scope.navigate("reqObjForm");
								$timeout(function(){
									$rootScope.$emit("goToAuthTab");
								});
						}else if(err.data.errors[0].msg === "Response : Channel UX map is not defined" || err.data.errors[0].msg === "Response : Response message is not defined"){
								for(var key1 in $scope.sections){
									if($scope.sections.hasOwnProperty(key1)){
										$scope.sections[key1]=false;
									}
								}
								$scope.sections.resObjForm = true;
								$scope.navigate("resObjForm");
						}else if(err.data.errors[0].msg === "Schedule : Schedule Options not defined"){
							for(var key2 in $scope.sections){
									if($scope.sections.hasOwnProperty(key2)){
										$scope.sections[key2]=false;
									}
								}
							$scope.sections.settingsForm = true;
							$scope.navigate("settingsForm");
						}
							
						return;
					});
				}else if(type === 'action' &&  $workflowService.actionInfo().state !== "published" && $workflowService.actionInfo().state !== "suspended"){
					return BTActionsService.configured($workflowService.actionInfo()._id).then(function(res){
						$scope.isFinshSetupLoading = false;
						NotificationService.notify = notify;
						$scope.onCancel();
						//$location.path(window.appConfig.CONTEXT_PATH);
						return res;
					},function(err){
						$scope.isFinshSetupLoading = false;
						NotificationService.notify = notify;
						NotificationService.notify(err.data.errors[0].msg,'error');
						if(err.data.errors[0].msg === "Authentication : Authentication is not defined" ||  err.data.errors[0].msg === "Request : Request is not defined" || err.data.errors[0].msg === "Request : Sample response data is not defined"){
							
							for(var key in $scope.sections){
								if($scope.sections.hasOwnProperty(key)){
									$scope.sections[key]=false;
								}
							}
							$scope.sections.reqObjForm = true;
							$scope.navigate("reqObjForm");
							$timeout(function(){
								$rootScope.$emit("goToAuthTab");
							});
						}else if(err.data.errors[0].msg === "Response : Channel UX map is not defined" || err.data.errors[0].msg === "Response : Response message is not defined"){
								for(var key1 in $scope.sections){
									if($scope.sections.hasOwnProperty(key1)){
										$scope.sections[key1]=false;
									}
								}
								$scope.sections.resObjForm = true;
								$scope.navigate("resObjForm");
						}else if(err.data.errors[0].msg === "Schedule : Schedule Options not defined"){
							for(var key2 in $scope.sections){
									if($scope.sections.hasOwnProperty(key2)){
										$scope.sections[key2]=false;
									}
								}
							$scope.sections.settingsForm = true;
							$scope.navigate("settingsForm");
						}
						return;
					});
				} else{
					$scope.isFinshSetupLoading = false;     //markItConfigured api call removed if task is published since api will throw error//
					NotificationService.notify = notify;
					$scope.onCancel();
					NotificationService.notify(i18n.i18nString('setup_added_success'),'success');
				}
				
			}

		};

		function toggleRemainingFormsState(form){
			for(var key in $scope.forms){
				if($scope.forms.hasOwnProperty(key) && key!==form){
					$scope.forms[key]='view';
				}
			}
		}

		$scope.navigate=function(section){

			if($scope.resource.state === 'published' && action !== 'view'){
				NotificationService.notify(i18n.i18nString('bt_wf_edit_bascic_Settings_published_state'),'warning');
				return;
			}

			if($scope.resource.state === 'suspended' && action !== 'view'){
				NotificationService.notify(i18n.i18nString('bt_wf_edit_bascic_Settings_suspended_state'),'warning');
				return;
			}

			var isChanged = (($scope.callbacks[$scope.currentSection] || {}).isChanged || angular.noop)();
			var callback  = (($scope.callbacks[$scope.currentSection] || {}).triggerSave || angular.noop);

			if(isChanged && (action !== 'view')){
                NotificationService.confirm({
                    msg: i18n.i18nString('bt_wf_proceeding_noty'),
                    successCb: _.partial(triggerCurrentStageSave, startNavigation),
                    failCb: startNavigation,
                    cancelCb: function () {
                        return false;
                    },
                    isModal: true,
                    btnTexts: {
                        success: i18n.i18nString('save'),
                        fail: i18n.i18nString('discard_label')
                    }
                });
				return;
			}else{
				startNavigation();
			}

			function triggerCurrentStageSave(navCb){
				if(callback == angular.noop){
					startNavigation();
				}else{
					callback(navCb || angular.noop);
				}
			}

			function startNavigation() {

				window.onbeforeunload = angular.noop;

				if(section === 'finishForm'){
					$scope.showSaveAndExit=false;
				}else{
					$scope.showSaveAndExit=true;
				}

				for(var key in $scope.sections){
					if($scope.sections.hasOwnProperty(key)){
						$scope.sections[key]=false;
					}
				}

				$scope.sections[section]=true;
				
				$scope.currentSection = section;

				if($scope.isItSoapType() && $scope.currentSection === "reqObjForm"){
					$scope.currentSection = "soapreqform";
				}
				
				$('html, body').animate({ scrollTop: 0 }, 'fast');
				$("#btFullpageModal .main-content").animate({ scrollTop: 0 }, 'fast');
				PerfectScrollbar.update($("#btFullpageModal .main-content")[0]);
			
			}


		};

		$scope.isWebhook=function(){
			return $scope.resource.type === 'webhook';
		};

		$workflowService.reigisterModalShownEvent();
		$scope.clearSetUpLocalStorageFortask =function(setTaskId){
			var localPath = window.localStorage.getItem("previousState");
			if(localPath){
				localPath = JSON.parse(localPath);
				if(localPath.selectedTaskType && !setTaskId){
					delete localPath.selectedTaskType;
				}
				if(localPath.selectedTaskId && !setTaskId){
					delete localPath.selectedTaskId;
				}
				if(setTaskId){// used if ther is internal task switching from this page like in dailogs//
					localPath.selectedTaskId =setTaskId;
				}
				window.localStorage.setItem("previousState",JSON.stringify(localPath));
			}
		   };
		$scope.onCancel=function(){
			$rootScope.$emit('updateSummaryData');
			//$location.path(window.appConfig.CONTEXT_PATH);
			// $("#taskCreateOrEditModal").modal("hide");
			$scope.clearSetUpLocalStorageFortask();
			$("#btFullpageModal").modal("hide");
			$("body").removeClass("bt-modal-open");
			$rootScope.$emit("insertOrUpdateTask", $scope.wftype, $scope.taskEditInfo, false);
			$rootScope.$emit("showContent");
			$rootScope.$broadcast("updateEditTask", false);
		};

		$scope.onSaveAndExit=function(){
			$rootScope.saveAndExit = true;
			if($scope.sections.introForm){
				$rootScope.$broadcast('evt:nextActintro');
			}else if($scope.sections.authForm){
				$rootScope.$broadcast('evt:nextActAuth');
			}else if($scope.sections.reqObjForm){
				$rootScope.$broadcast('evt:nextActReq');
			}else if($scope.sections.resObjForm){
				$rootScope.$broadcast('evt:nextActRes');
			}else if($scope.sections.errorForm){
				$rootScope.$broadcast('evt:nextActErr');
			}else if($scope.sections.settingsForm){
				$rootScope.$broadcast('evt:exitActSetng');
			}
		};

		$scope.$on('evt:nextSucc',function(evt,data){
			if($rootScope.saveAndExit){
				$location.path(window.appConfig.CONTEXT_PATH);
			}
		});

		$('html, body').animate({ scrollTop: 0 }, 'fast');
		$scope.$emit('nestedComponentLoaded',{'id':'alertsActionsForm','flag':false});
	}]);

})(angular);


;(function(ng) {

    'use strict';

    var btstreams = ng.module('bt-wf-logs', []);
    btstreams.directive('wfLogs',[function(){

        return {
            restrict : 'EA',
            scope    : {
                activeTask  : '='
            },
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-wf-logs-view/bt-wf-logs-view.html',
            controller  : 'BTWfLogsViewCtrl'

        };

    }]);
    
    btstreams.controller('BTWfLogsViewCtrl',
	['$scope','BTActionsService','BTAlertsService','$routeParams','$workflowService','$location','i18n',
	function($scope,BTActionsService,BTAlertsService,$routeParams,$workflowService,$location,i18n){
                var offset = 0, limit = 5, moreAvailable = false;
		$scope.currentPage = 1;
		$scope.selectedStream=$workflowService.selectedStream();
		var taskId = $scope.activeTask._id;
		var taskType = $scope.activeTask.taskType;
		$scope.options={
		    mode:'text',
		    ace:window.ace
		};

		$scope.context = {
			bot  : $scope.selectedStream.name,
			task : $scope.activeTask.name
		};
                $scope.loadingMore = false;
                $scope.refreshLogs = function () {
                    offset = 0;
                    limit = 5;
                    moreAvailable = false;
                    $scope.getLogs();
                };
                $scope.getLogs = function () {
                    $scope.loading = true;
                    $scope.currentPage = 1;
                    $scope.logs = [];
                    var apiCall;
                    if (taskType === 'action') {
                        apiCall = BTActionsService.getApiLogs(taskId, offset, limit);
                    }
                    else { // taskType === 'alert'
                        apiCall = BTAlertsService.getApiLogs(taskId, offset, limit);
                    }
                    apiCall.then(function (res) {
                        var _logs = [];
                        offset = offset + limit;
                        if (res.data && res.data.moreAvailable) {
                            moreAvailable = res.data.moreAvailable;
                        } else {
                            moreAvailable = false;
                        }
                        if (res.data.result) {
                            _logs = res.data.result;
                        } else {
                            _logs = res.data;
                        }

                        $scope.logs = _logs.map(function (log) {
                            delete log.actionId;
                            delete log.alertId;
                            // log.responseData = parse(log.responseData || '');
                            if (log.hasOwnProperty('responseData')) {
                                log.responseData = parse(log.responseData);
                            }
                            var tmpDate = new Date(log.createdOn).toLocaleString();
                            tmpDate = tmpDate.replace(/\//g, '-');
                            log.createdOn = tmpDate;
                            delete log.$$hashKey;
                            return log;
                        });
                        $scope.loading = false;

                    }, function (err) {
                        $scope.logs = [];
                        $scope.loading = false;
                    });
                };
                
                $scope.getMoreLogs = function () {
                    if (moreAvailable && !$scope.loadingMore) {
                        $scope.loadingMore = true;
                        var apiCall;
                        if (taskType === 'action') {
                            apiCall = BTActionsService.getApiLogs(taskId, offset, limit);
                        }
                        else { // taskType === 'alert'
                            apiCall = BTAlertsService.getApiLogs(taskId, offset, limit);
                        }
                        apiCall.then(function (res) {
                            var _logs = res.data.result;

                            offset = offset + limit;
                            if (res.data && res.data.moreAvailable) {
                                moreAvailable = res.data.moreAvailable;
                            } else {
                                moreAvailable = false;
                            }
                            $scope.loadingMore = false;

                            var _moreLogs = _logs.map(function (log) {
                                delete log.actionId;
                                delete log.alertId;
                                // log.responseData = parse(log.responseData || '');
                                if (log.hasOwnProperty('responseData')) {
                                    log.responseData = parse(log.responseData);
                                }
                                delete log.$$hashKey;
                                return log;
                            });

                            if (_logs && _logs.length) {
                                $scope.logs = $scope.logs.concat(_moreLogs);
                            }
                            $scope.loading = false;

                        }, function (err) {
                            $scope.loadingMore = false;
                        });


                    }
                };
		function  parse(string) {
			try{
				return JSON.parse(string);
			}catch(ex){
				return string;
			}
		}

		$scope.getLogs();
                $('wf-logs .logs-page').on("scroll", function (event) {
                    if ($(this).scrollTop() + $(this).innerHeight() >= $(this)[0].scrollHeight * 0.9) {
                        if ($("wf-logs .logs-page").is(":visible")) {
                            $scope.getMoreLogs();
                        }
                    }
                });
		$scope.exit=function() {
			$location.path(window.appConfig.CONTEXT_PATH);
		};

	}]);

}(angular));




;(function acify(ng) {

    'use strict';
    var _module = ng.module('bt-kore-components');

    _module.controller('BTWFMappingJSEditorCtrl', ['$scope', 'soap', '$rootScope', '$translator', '$modalInstance', '$workflowService', 'config','NotificationService','i18n',
        function ($scope, soap, $rootScope, $translator, $modalInstance, BTFlowtaskService,config, NotificationService,i18n) {
            function init() {
                $scope.mappingScriptObj = config.component  || '';
                $scope.jsEditorCbs={};
            }
            $scope.closeModal = function () {
                $modalInstance.close();
            };
            $scope.codeCallback = function (data) {};
            
            
            $scope.saveScript = function() {
                if (config && config.cbBridge) {
                    config.cbBridge($scope.mappingScriptObj);
                }
                $scope.closeModal();
            };

            (function () {
                init();
            })();
        }]);

})(angular);


;(function(ng) {

        var _module = ng.module('bt-wf-mapping', []);
        
        
    _module.directive('btWfMapping', [function () {
            return {
                restrict: 'EA',
                scope: {
                    onClose: "=",
                    activeEntity: "=",
                    component:"=",
                    footerMappingid:"@"

                },
                templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/bt-wf-mapping/bt-wf-mapping.html',
                controller: 'BTWFMappingCtrl'
            };
        }]);

        _module.controller('BTWFMappingCtrl', ['$scope','$modal','$filter','BTStreamsService','$q', '$rootScope', '$routeParams', '$applicationService', '$translator', '$workflowService', '$util', 'NotificationService', 'BTParamMapService', '$location', 'form_util', '$timeout','i18n',
                                                function($scope,$modal,$filter,BTStreamsService,$q, $rootScope, $routeParams, $applicationService, $translator, $workflowService, $util, NotificationService, BTParamMapService, $location, form_util, $timeout,i18n) {
            var $win = window; 
           $scope.stream      = $workflowService.selectedStream();
           $scope.$emit('nestedComponentLoaded', { 'id': 'flows', 'flag': false });
           $scope.form = {};
           $scope.activeEntity = $scope.activeEntity || {};
           $scope.footerMappingid = $scope.activeEntity._id ? $scope.footerMappingid : 'tasks-create-mapping';
           $scope.isAlertToDialogMapping = false;
           $scope.bulbIcon = window.appConfig.CONTEXT_PATH+'/assets/images/24x29-bulbicon.png';
           $scope.tmpltPrePath=$scope.$root.tmpltPrePath;


           $scope.save_exit    =i18n.i18nString('save_exit');
           $scope.update       = i18n.i18nString('update');
           $scope.edit         = i18n.i18nString('edit');
           $scope.create       = i18n.i18nString('create_label');




            if($scope.activeEntity && $scope.activeEntity.mapId){
             
                 $scope.resource = $scope.activeEntity;
                     if($scope.activeEntity.alertStreamId === $scope.stream._id){
                        $scope.resourceType = 'alert' ;
                    }else{
                         $scope.resourceType = 'action';
                    }

                    $scope.mapId = $scope.activeEntity.mapId;
                
            }
            else if($scope.activeEntity && $scope.activeEntity._id && $scope.activeEntity.sourceResourceStreamId){
                $scope.resource = $scope.activeEntity;
                if($scope.activeEntity.sourceResourceStreamId === $scope.stream._id){
                    $scope.resourceType = 'alert' ;
                }
                $scope.mapId = $scope.activeEntity._id;
                if($scope.activeEntity.targetResourceId[0] === 'd') {
                    $scope.isAlertToDialogMapping = true;
                }
            }
            else if($scope.resource && $scope.resource.targetResourceId) {
                if($scope.resource.targetResourceId[0] === 'd') {
                    $scope.isAlertToDialogMapping = true;
                }
                if($scope.resource.sourceResourceId[0] === 'l') {
                    $scope.resourceType = 'alert' ;
                }
                $scope.mapId = $scope.resource._id;
            }
            else if($scope.activeEntity &&  $scope.activeEntity.taskType){
                 $scope.resourceType = $scope.activeEntity.taskType ;
            }
            
            $scope.resource           = $scope.resource || {};
            $routeParams.mapId        = $scope.mapId;
            var _resourceType = $scope.resourceType,
                _apConstants =  $applicationService.getAppConstants();
            var _resourceId = "";
            if($scope.isAlertToDialogMapping){
                _resourceId =  $scope.mapId ? (($scope.resourceType === 'alert')?$scope.resource.sourceResourceId:$scope.resource.targetResourceId): $scope.activeEntity._id;
            }
            else{
                _resourceId =  $scope.mapId ? (($scope.resourceType === 'alert')?$scope.resource.alertId:$scope.resource.actionId): $scope.activeEntity._id;
            }   
            $scope.editMode = false;
            $scope.wfType = _resourceType;
            $scope.listMappings = false;
            var _newDialogMappingCount = 1;
            $scope.currentStep = 1;

            $scope._constants_ = $rootScope._constants_;
 

            var loader = angular.noop;

            if($scope.mapId  && $scope.component){
                loader = NotificationService.loader('Please wait');
            }

            if($routeParams.mapId){
                $scope.currentStep=2;
                $scope.editMode=true;
                if($scope.isAlertToDialogMapping){
                    getMappedAlertDialog();
                }
                else{
                    getMappedAlertAction();
                }
            }else{
                if (_resourceType === _apConstants.RESOURCE_TYPE_ALERT) {
                    if(_resourceId){
                        getAlert(_resourceId);
                    }
                } else if (_resourceType === _apConstants.RESOURCE_TYPE_ACTION) {
                    if(_resourceId){
                        getAction(_resourceId);
                    }
                }
                $scope.selectedAlertStream = $workflowService.selectedStream();
            }

            function getAlert(_resourceId){
                var type = _resourceId[0] === 'l' ? "alert" : "action";
                if(type === "alert"){
                    $translator.translate('bt.alertsId.get', {alertId: _resourceId})
                        .then(function(res) {
                            $scope.selectedAlert = res.data;
                        if(!$scope.isAlertToDialogMapping){
                            initMappingStep2();
                        }
                        }).then(function(){
                            BTStreamsService.getMPStream($scope.selectedAlert.streamId)
                                .then(function(res){
                                    $scope.selectedAlertStream=res.data;
                            });
                    });
                }else if(type === "action"){
                    $translator.translate('bt.actionsId.get', {actionId: _resourceId})
                        .then(function(res) {
                            $scope.selectedAlert = res.data;
                            initMappingStep2();
                        }).then(function(){
                            BTStreamsService.getMPStream($scope.selectedAlert.streamId)
                                .then(function(res){
                                    $scope.selectedAlertStream=res.data;
                            });
                        });
                }
            }

            function getAction(_resourceId){
                $translator.translate('bt.actionsId.get', {actionId: _resourceId})
                    .then(function(res) {
                        $scope.selectedAction = res.data;
                        initMappingStep2();
                    }).then(function(){
                        BTStreamsService.getMPStream($scope.selectedAction.streamId)
                            .then(function(res){
                                $scope.selectedActionStream=res.data;
                        });
                    });
            }
            function getDialog(_streamId, _dialogId){
                $translator.translate('bt.dialog.get',{streamId: _streamId, dialogId: _dialogId})
                    .then(function(res) {
                        $scope.selectedAction = res.data;
                    }).then(function(){
                        BTStreamsService.getMPStream($scope.selectedAction.streamId)
                            .then(function(res){
                                $scope.selectedActionStream=res.data;
                                /* Fetching dialog task full component data */
                                $translator.translate('bt.components.get', {streamId: $scope.selectedAction.streamId})
                                .then(function(res) {
                                    var components = res.data.filter(function (obj) {
                                        return (obj.status === 'published');
                                    });
                                    $.each($scope.selectedAction.nodes, function (index, component) {
                                        var result = components.filter(function (o) {
                                            return o._id === component.componentId;
                                        });
                                        $scope.selectedAction.nodes[index] = result[0];
                                        if ($scope.selectedAction.nodes.length - 1 === index) {
                                            initMappingStep2();
                                        }
                                    });
                                });
                        });
                    });
            }
            $scope.clearSetUpLocalStorageFortask =function(setTask){
                var localPath = window.localStorage.getItem("previousState");
                if(localPath){
                    localPath = JSON.parse(localPath);
                    if(localPath.selectedTaskType && !setTask){
                        delete localPath.selectedTaskType;
                    }
                    if(localPath.selectedTaskId && !setTask){
                        delete localPath.selectedTaskId;
                    }
                    window.localStorage.setItem("previousState",JSON.stringify(localPath));
                }
                
               };
            $scope.mapping={};
            function getMappedAlertDialog() {
                BTParamMapService.getMappedAlertDialog($routeParams.mapId).then(function(res){
                    $scope.mapping=res.data;
                    getAlert(res.data.sourceResourceId);
                    getDialog(res.data.targetResourceStreamId,res.data.targetResourceId);
                    loader();
                },function(){
                    $scope.mapping={};
                    loader();
                });
            }
            function getMappedAlertAction() {
                BTParamMapService.getMappedAlertAction($routeParams.mapId).then(function(res){
                    $scope.mapping=res.data;
                    getAlert(res.data.alertId);
                    getAction(res.data.actionId);
                    loader();
                },function(){
                    $scope.mapping={};
                    loader();
                });
            }

            $scope.resourceDetails = {};
            $scope.mappingObj = {};
            $scope.noAlertFields = false;

            $scope.changeStream = function(type) {
                if (type === _apConstants.RESOURCE_TYPE_ALERT) {
                    $scope.selectedAlert = null;
                    $scope.selectedAlertStream = null;
                    $scope.showAlertStreamChooser = true;
                    $scope.showTypeaheadForAlert = false;
                } else if (type === _apConstants.RESOURCE_TYPE_ACTION) {
                    $scope.selectedAction = null;
                    $scope.selectedActionStream = null;
                    $scope.showActionStreamChooser = true;
                    $scope.showTypeaheadForAction = false;
                }
            };

            $scope.changeResource = function(type) {
                if (type === _apConstants.RESOURCE_TYPE_ALERT) {
                    $scope.selectedAlert = null;
                    $scope.showTypeaheadForAlert = true;
                } else if (type === _apConstants.RESOURCE_TYPE_ACTION) {
                    $scope.selectedAction = null;
                    $scope.showTypeaheadForAction = true;
                }
                initMappingStep2();
            };

            $scope.toggleActionStreamChooser = function() {
                $scope.showTypeaheadForAction = false;
                $scope.showActionStreamChooser = !$scope.showActionStreamChooser;
            };

            $scope.toggleActionResourceChooser = function() {
                $scope.showActionStreamChooser = false;
                $scope.showTypeaheadForAction = !$scope.showTypeaheadForAction;
            };

            $scope.toggleAlertStreamChooser = function() {
                $scope.showTypeaheadForAlert = false;
                $scope.showAlertStreamChooser = !$scope.showAlertStreamChooser;
            };

            $scope.toggleAlertResourceChooser = function() {
                $scope.showAlertStreamChooser=false;
                $scope.showTypeaheadForAlert = !$scope.showTypeaheadForAlert;
            };

            $scope.setSelectedActionStream = function(data) {
                $scope.showActionStreamChooser = false;
                $scope.selectedActionStream = data.stream;
            };

            $scope.setSelectedAction = function(data) {
                $scope.showTypeaheadForAction = false;
                $scope.selectedAction = data.action;
                $scope.isAlertToDialogMapping = $scope.selectedAction.isAlertToDialogMapping;
                checkForCompatibility();
                initMappingStep2();
            };

            $scope.setSelectedAlertStream = function(data) {
                $scope.showAlertStreamChooser = false;
                $scope.selectedAlertStream = data.stream;
            };

            $scope.setSelectedAlert = function(data) {
                $scope.showTypeaheadForAlert = false;
                $scope.selectedAlert = data.alert;
                checkForCompatibility();
                initMappingStep2();
            };

            function checkForCompatibility(){
                var alertVisibility  = ($scope.selectedAlert  && $scope.selectedAlert.visibility) || '';
                var actionVisibility = ($scope.selectedAction && $scope.selectedAction.visibility) || '';
                if(alertVisibility && actionVisibility){
                    $scope.notCompatible = ($scope.selectedAlert && $scope.selectedAction && !_.isEqual($scope.selectedAlert.visibility,$scope.selectedAction.visibility));
                }else{
                    $scope.notCompatible = false;
                }
            }

            $scope.cancel = function(step) {
                $location.path(window.appConfig.CONTEXT_PATH+'/workflows');
            };

            $scope.stepBack = function(event, steptogoto) {
                $scope.currentStep = 2;
                $scope.isStepNext = false;
            };

            $scope.isStepNext = false;

            $scope.stepNext = function(from, to) {
                var constraints =[{
                    prop:'selectedAlertStream',
                    msg: i18n.i18nString('bt_wf_mapping_ppls_select_alert_task_stream')
                },{
                    prop:'selectedActionStream',
                    msg: i18n.i18nString('bt_wf_mapping_ppls_select_action_task_stream')
                },{
                    prop:'selectedAlert',
                    msg: i18n.i18nString('bt_wf_mapping_ppls_select_alert_task')
                },{
                    prop:'selectedAction',
                    msg:i18n.i18nString('bt_wf_mapping_ppls_select_action_task')
                }];

                if($scope.currentStep===1){
                    for(var i=0;i<constraints.length;i++){
                        if(!($scope[constraints[i].prop] && $scope[constraints[i].prop].name && Object.keys($scope[constraints[i].prop]).length>0)){
                            NotificationService.notify(constraints[i].msg,'error');
                            return;
                        }
                    }
                }

                var fields                     = $scope.actionFields.filter(function(field){return field.isRequired;});
                fields                         = _.pluck(fields,'key');
                var mappedfields               = _.pluck(getParamMap(),'actionKey');
                $scope.canbeAutomated          = canBeAutomated(fields,mappedfields);

                $scope.isStepNext              = true;
                $scope.currentStep = 3;
            };

            function canBeAutomated(actionFields,mappedFields){

                var obj = {};

                mappedFields.map(function(key){
                    obj[key] = key;
                });

                return actionFields.reduce(function(prev,curr){
                    return (((prev && obj[curr]) || false) && true);
                },true);

            }

            $scope.$watch(function(){
                if(!$scope.selectedAction){
                    return;
                }
                var fields = [];
                if($scope.selectedAction.payloadField) {
                    $scope.actionFields    = $scope.selectedAction.payloadField
                                                    .concat($scope.selectedAction.queryField)
                                                    .filter(function(field){
                                                        return field.visibility !== 'hidden';
                                                    });
                    fields                 = $scope.actionFields.filter(function(field){return field.isRequired;});
                    fields                 = _.pluck(fields,'key');
                }
                else if($scope.editMode && $scope.isAlertToDialogMapping){
                    if($scope.actionFields && $scope.actionFields.length && $scope.actionFields[$scope.actionFields.length-1].title !== "") {
                        $scope.addNewDialogFlowMapping();
                    }
                }
                else{
                    if($scope.actionFields.length === 0) {
                        $scope.actionFields = $scope.selectedAction.nodes.filter(function(node){return node.type === 'entity';});
                        $scope.addNewDialogFlowMapping(); // when dialogs doesn't have any entities
                    }
                    if($scope.actionFields.length && $scope.actionFields[$scope.actionFields.length-1].title !== "") {
                        $scope.addNewDialogFlowMapping();
                    }
                    fields = $scope.actionFields.slice();
                    fields                 = _.pluck(fields,'name');
                }
                var mappedfields       = _.pluck(getParamMap(),'actionKey');
                $scope.canbeAutomated  = canBeAutomated(fields,mappedfields);
            });

            function initMappingStep2() {

                if($scope.notCompatible){
                    NotificationService.notify(i18n.i18nString('bt_wf_mapping_both_entities_not_published_same_destination'),"error");
                    return;
                }

                $scope.mappingObj={
                        mapping:{},
                        issuggestedaction:$scope.mapping.markAsSuggested,
                        markAsAutomated:$scope.mapping.markAsAutomated,
                        mappingname:$scope.mapping.name
                };

                if(_.isObject($scope.selectedAlert)){
                    $scope.selectedAlert.sample = ($scope.selectedAlert && $scope.selectedAlert.sample) || {} ;
                }

                if ($scope.selectedAlert && $scope.selectedAlert.sample){
                    var data = getSampleResKeys($scope.selectedAlert,$scope.selectedAlert.sample);
                    delete data.metainfo;
                    $translator.translate('bt.dotKeys.post', {}, data).then(
                        function(res){
                            $scope.alertFields = res.data;
                            $scope.noAlertFields = false;
                        },
                        function(res){
                        }
                    );
                }

                if($scope.selectedAction && $scope.selectedAction.payloadField){

                    $scope.actionFields = $scope.selectedAction.payloadField.concat($scope.selectedAction.queryField);

                    if($scope.mapping.map){

                        for(var i=0;i<$scope.mapping.map.length;i++){
                            var obj = $scope.mapping.map[i];
                            $scope.mappingObj.mapping[obj.actionKey]=obj.value || "";
                            $scope.mappingObj.mapping[obj.actionKey+'label']=obj.label || "";
                            $scope.mappingObj.mapping[obj.actionKey+'visibility']=obj.visibility || "";
                        }

                    }else{

                        for (var j = 0; j < $scope.actionFields.length; j++) {
                            var field = $scope.actionFields[j];
                            $scope.mappingObj.mapping[field.key]=field.mapping;
                        }

                    }

                }
                else if($scope.selectedAction && $scope.selectedAction.nodes){  // to handle dialog tasks
                    $scope.actionFields = $scope.selectedAction.nodes.filter(function(node){return node.type === 'entity';});
                    $.each($scope.actionFields, function( index, value ) {
                        value.key = value.name;
                        value.title = value.name;
                        value.showKeyTextArea = false;
                    });
                    if($scope.editMode && $scope.mapping.map && ($scope.actionFields.length !== $scope.mapping.map.length)){
                        for(var counter=0;counter<$scope.mapping.map.length;counter++){
                            var map = $scope.mapping.map[counter];
                            map.destinationKey = map.destinationKey.replace("context.entities.","");
                            var result  = $scope.actionFields.filter(function(o){return o.key === map.destinationLabel;} );
                            if(!result.length) {
                                var _actionFieldObj = {fieldType: "textbox",isRequired: false,key: map.destinationKey,name: map.destinationKey, title: map.destinationKey, type: "entity", showKeyTextArea: true};
                                $scope.actionFields.push(_actionFieldObj);
                            }
                            if($scope.mapping.map.length-1 === counter){
                                $scope.addNewDialogFlowMapping();
                            }
                        }
                    }
                    if($scope.mapping.map){

                        for(var mapCounter=0;mapCounter<$scope.mapping.map.length;mapCounter++){
                            var _obj = $scope.mapping.map[mapCounter];
                            _obj.destinationKey = _obj.destinationKey.replace("context.entities.","");
                            $scope.mappingObj.mapping[_obj.destinationKey]=_obj.value || "";
                            $scope.mappingObj.mapping[_obj.destinationKey+'label']=_obj.destinationLabel || "";
                        }

                    }else{

                        for (var mapCounter1 = 0; mapCounter1 < $scope.actionFields.length; mapCounter1++) {
                            var _actionField = $scope.actionFields[mapCounter1];
                            $scope.mappingObj.mapping[_actionField.key]=_actionField.mapping;
                        }

                    }
                }

            }

            function getParamMap() {
                if($scope.isAlertToDialogMapping && !$scope.actionFields){
                    return;
                }
                var map = [],
                    mapping = $scope.mappingObj.mapping;
                var actionFields = [];    
                if($scope.isAlertToDialogMapping){
                    actionFields = $scope.actionFields.slice();
                    $.each(actionFields, function( index, value ) {
                        value.key = value.name;
                    });
                }
                else{
                    actionFields = $scope.selectedAction.payloadField.concat($scope.selectedAction.queryField);
                }
                if($scope.isAlertToDialogMapping){ // for dialog tasks
                    for (var j=0; j<actionFields.length; j++){

                        if (mapping[actionFields[j].key]){
                            var _mapItem = {};
                            _mapItem.destinationKey = actionFields[j].key;
                            _mapItem.destinationLabel = actionFields[j].title;
                            _mapItem.value = $util.unescape(mapping[actionFields[j].key]+'');
                            map.push(_mapItem);
                        }
                    }
                }
                else{
                    for (var i=0; i<actionFields.length; i++){

                        if (mapping[actionFields[i].key]){ //commented inorder to send mappings which don't have values but they might be editable,hidden,readonly.
                            var mapItem = {};
                            mapItem.actionKey = actionFields[i].key;
                            mapItem.actionKeyLabel = actionFields[i].title;
                            mapItem.value = $util.unescape(mapping[actionFields[i].key]+'');
                            mapItem.label = $util.unescape(mapping[actionFields[i].key+'label']+'');
                            mapItem.visibility = mapping[actionFields[i].key+'visibility'] || 'hidden';
                            map.push(mapItem);
                        }

                    }
                }

                for(k=0;k<map.length;k++){
                    var obj = map[k];
                    if((map[k].actionKey==="workspace" || map[k].actionKey==="projects") && !map[k].value){
                        map.splice(k,1);
                    }
                }

                return map;

            }
            
            function getDialogParamsMapping() {
                var map = [],
                mapping = $scope.mappingObj.mapping;
                var actionFields = [];
                actionFields = $scope.actionFields.slice();
                $.each(actionFields, function( index, value ) {
                    value.key = value.name;
                });
                for (var j=0; j<actionFields.length; j++){
                    if (mapping[actionFields[j].key]){
                        var _mapItem = {};
                        _mapItem.destinationKey = actionFields[j]._id?"context.entities."+actionFields[j].key : actionFields[j].key;
                        _mapItem.destinationLabel = actionFields[j].title;
                        _mapItem.value = $util.unescape(mapping[$scope.actionFields[j].key]+'');
                        map.push(_mapItem);
                    }
                }
                for(k=0;k<map.length;k++){
                    var obj = map[k];
                    if((map[k].actionKey==="workspace" || map[k].actionKey==="projects") && !map[k].value){
                        map.splice(k,1);
                    }
                }
                return map;
            }
            
            function saveDialogFlowMap(){
                /* Processing the newly added custom dialog flow entity mapping fields */
                $.each($scope.actionFields, function(index,value){
                   if(value.name === "key"+(_newDialogMappingCount-1) || value.title === ""){
                        delete $scope.mappingObj.mapping[$scope.actionFields[index].key];
                        delete $scope.mappingObj.mapping[$scope.actionFields[index].key+'label'];
                        $scope.actionFields.splice(index,1);
                   }
                   else{
                       if(value.showKeyTextArea){
                           $scope.mappingObj.mapping[value.title] = $scope.mappingObj.mapping[value.key];
                           $scope.mappingObj.mapping[value.title+'label'] = $scope.mappingObj.mapping[value.key+'label'];
                            $scope.actionFields[index].key = $scope.actionFields[index].title;
                            $scope.actionFields[index].name = $scope.actionFields[index].title;
                       }
                   }
                });
                saveMapping();
            }
            $scope.saveAndExit = function(valid,form) {

                if(!$scope.form.mapping_form.$valid){
                    form_util.touch($scope.form.mapping_form);
                    return;
                }
                var _customMapMissingKeysCount = 0;
                /* Processing the newly added custom dialog flow entity mapping fields */
                if($scope.isAlertToDialogMapping) {
                    $.each($scope.actionFields, function (index, value) {
                        if (value.title === "") {
                            _customMapMissingKeysCount = _customMapMissingKeysCount+1;
                        }
                    });
                }
                if($scope.isAlertToDialogMapping && _customMapMissingKeysCount > 1) {
                    NotificationService.alert(i18n.i18nString('bt_wf_mapping_custom_fields_discarded'),saveDialogFlowMap,arguments);
                }
                else if($scope.isAlertToDialogMapping){
                    saveDialogFlowMap();
                }
                else{
                    saveMapping();
                }
            };

            $scope.mappingInProgress = false;

            function saveMapping() {

                if($scope.notCompatible){
                    NotificationService.notify(i18n.i18nString('bt_wf_mapping_both_entities_not_published_same_destination'),"error");
                    return;
                }

                $scope.mappingInProgress = true;
                var mappingData = {};
                if($scope.isAlertToDialogMapping){
                    mappingData.name             =  $scope.mappingObj.mappingname;
                    mappingData.sourceResourceId =  $scope.selectedAlert._id;
                    mappingData.sourceResourceVersion     =  $scope.selectedAlert.version;
                    mappingData.sourceResourceStreamId    =  $scope.selectedAlertStream._id;
                    
                    mappingData.targetResourceId         =  $scope.selectedAction._id;
                    mappingData.targetResourceVersion    =  "1.0";
                    mappingData.targetResourceStreamId   =  $scope.selectedActionStream._id;
                    mappingData.map              =  getDialogParamsMapping();
                    mappingData.state            =  'configured';
                    mappingData.markAsSuggested  =  $scope.mappingObj.issuggestedaction && true;
                }
                else{
                    mappingData.name             =  $scope.mappingObj.mappingname;
                    mappingData.alertStreamId    =  $scope.selectedAlertStream._id;
                    mappingData.alertId          =  $scope.selectedAlert._id;
                    mappingData.actionStreamId   =  $scope.selectedActionStream._id;
                    mappingData.actionId         =  $scope.selectedAction._id;
                    mappingData.alertVersion     =  $scope.selectedAlert.version;
                    mappingData.actionVersion    =  $scope.selectedAction.version;
                    mappingData.map              =  getParamMap();
                    mappingData.state            =  'active';
                    mappingData.markAsSuggested  =  $scope.mappingObj.issuggestedaction && true;
                    mappingData.markAsAutomated  =  $scope.mappingObj.markAsAutomated   && true;
                }
                if ($scope.editMode){
                    if($scope.isAlertToDialogMapping){ // alert to dialog mapping
                        BTParamMapService.updateAlertDialogParamMap($routeParams.mapId,mappingData)
                        .then(function(res) {
                            $scope.mappingInProgress = false;
                            NotificationService.notify(i18n.i18nString('flow_updated_sucessfully',{dyn: mappingData.name}), "success");
                            goHome();
                        },function(err){
                            $scope.mappingInProgress = false;
                            var msg =  (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || i18n.i18nString('some_thing_went_wrong_tryAgain');
                            if(err.status===409){
                                NotificationService.notify(msg,'error');
                                $scope.currentStep=1;
                            }else{
                                NotificationService.notify(msg,'error');
                            }
                        });
                    }
                    else{
                        BTParamMapService.updateParamMap($routeParams.mapId,mappingData)
                        .then(function(res) {
                            $scope.mappingInProgress = false;
                            NotificationService.notify(i18n.i18nString('flow_updated_sucessfully',{dyn: mappingData.name}), "success");
                            goHome();
                        },function(err){
                            $scope.mappingInProgress = false;
                            var msg =  (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || i18n.i18nString('some_thing_went_wrong_tryAgain');
                            if(err.status===409){
                                NotificationService.notify(msg,'error');
                                $scope.currentStep=1;
                            }else{
                                NotificationService.notify(msg,'error');
                            }
                        });
                    }
                }
                else{
                    if($scope.isAlertToDialogMapping){ // alert to dialog mapping
                        $translator.translate('bt.paramDialogMap.post', {actionId: mappingData.targetResourceId}, mappingData)
                        .then(function(res) {
                            $scope.mappingInProgress = false;
                            NotificationService.notify(i18n.i18nString('flow_saved_sucessfully',{dyn: mappingData.name}), "success");
                            goHome();
                        },function(err){
                            $scope.mappingInProgress = false;
                            var msg =  (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || i18n.i18nString('some_thing_went_wrong_tryAgain');
                            if(err.status===409){
                                NotificationService.notify(msg,'error');
                                $scope.currentStep=1;
                            }else{
                                NotificationService.notify(msg,'error');
                            }
                        });
                    }
                    else{
                        $translator.translate('bt.paramMap.post', {actionId: mappingData.actionId}, mappingData)
                        .then(function(res) {
                            $scope.mappingInProgress = false;
                            NotificationService.notify(i18n.i18nString('flow_saved_sucessfully',{dyn: mappingData.name}), "success");
                            goHome();
                        },function(err){
                            $scope.mappingInProgress = false;
                            var msg =  (err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg) || i18n.i18nString('some_thing_went_wrong_tryAgain');
                            if(err.status===409){
                                NotificationService.notify(msg,'error');
                                $scope.currentStep=1;
                            }else{
                                NotificationService.notify(msg,'error');
                            }
                        });
                    }
                }
            }

            $scope.deleteMapping = function(){
                NotificationService.alert(i18n.i18nString('you_really_want_to_delete_this_flow') ,deleteMapping,arguments);
            };
            
            $scope.addNewDialogFlowMapping = function() {
                var actionFieldObj = {fieldType: "textbox",isRequired: false,key: "key"+_newDialogMappingCount,name: "key"+_newDialogMappingCount, title: "", type: "entity", showKeyTextArea: true};
                $scope.actionFields.push(actionFieldObj);
                $scope.mappingObj.mapping[actionFieldObj.key]=actionFieldObj.mapping;
                _newDialogMappingCount = _newDialogMappingCount + 1;
            };
            $scope.removeDialogFlowMapping = function(index) {
                delete $scope.mappingObj.mapping[$scope.actionFields[index].key];
                delete $scope.mappingObj.mapping[$scope.actionFields[index].key+'label'];
                $scope.actionFields.splice(index,1);
            };
            function deleteMapping(){
                BTParamMapService.deleteMappedAlertAction($routeParams.mapId).then(function(res){
                    NotificationService.alertNotify(i18n.i18nString('flow_deleted_success'), "success");
                    goHome();
                },function(err){
                    NotificationService.alertNotify(i18n.i18nString('flow_deleted_failed'),"error");
                });
            }
            $scope.onDrop = function(key) {
                    $rootScope.$broadcast('after-drop');
                    $scope.mappingObj.mapping[key] = event.currentTarget.value;
            };

            $scope.goToStreams = function() {
                $location.path(window.appConfig.CONTEXT_PATH+'/streamnew');
            };

            function getSampleResKeys(alert,data){

                var _sKey;
                var _sampleResponse = parse(data);
                var _sReqChain      = alert.requestChain;

                if(alert.type === 'webhook'){
                    _sKey = alert.alertsPath;
                }else{
                    _sReqChain.map(function(chain){
                        if(chain.linkType === "processor" && chain.linkDefinition.type === "_extract"){
                            _sKey = chain.linkDefinition.key;
                        }
                    });
                }

                if(_sKey && data){

                    return ((_sampleResponse && _sKey)?
                                            resolveObjectPath(_sampleResponse,_sKey)
                                            :_sampleResponse);
                }else{

                    return (parse(data));

                }

            }

            function resolveObjectPath(source,path,result){

                if(typeof source === 'string'){
                    source = parse(source);
                }

                if(path.indexOf('$.')===-1){
                    path = '$..'+path;
                }

                result = JSONPath({json:source,path:path})[0];

                if(result instanceof Array){
                    return result[0];
                }else if(typeof result === 'object'){
                    return result;
                }else{
                    return source;
                }

            }

            function parse(json){

                if(typeof json === 'string'){
                    try{
                        return JSON.parse(json);
                    }catch(ex){
                        return {};
                    }
                }else if(typeof json === 'object'){
                    return json;
                }

            }

            function goHome(){
                if(!$scope.component){
                   $scope.exit(true);
                }
            }
            function mappingJSEditorCB(res){
                $scope.mappingObj.mapping[res.fieldKey] = res.msgText;
            }
            $scope.openMappingTextAreaModalDialog = function (field, type, fieldKey) {
                var msgText = $scope.mappingObj.mapping[fieldKey] ? $scope.mappingObj.mapping[fieldKey] : "";
                var _field = $scope.actionFields.filter(function (field) {
                    return field.key === fieldKey;
                });
                //var _placeHolderText = _field && _field[0].showKeyTextArea?"Eg: context.<variable>.<variable>":"";
                var prompt = $win.bootbox.prompt({
                    title: field + ' - ' + type,
                    className: 'textareaModal',
                    inputType: 'textarea',
                    value: msgText,
                    //placeholder: _placeHolderText,
                    buttons: {
                        confirm: {
                            label: 'Done'
                        }
                    },
                    callback: function (result) {
                        if (result !== null) {
                            $scope.mappingObj.mapping[fieldKey] = result;
                        }
                    }
                });
                prompt.init(function(){
                    setTimeout(function(){
                        prompt.find('.bootbox-form').prepend('<div class="jsEditorPromptHeader">Editor</div>');
                    }, 100);
                });
            };
            $scope.exit = function exit(reload){
                $scope.clearSetUpLocalStorageFortask();
              $rootScope.$broadcast('closeMappingWorkflowEvent');
              $scope.$parent.callback.onFlowDialogClosed(reload);
            };
            $scope.updateFooterHeader = function () {
                if(!$scope.footerMappingid){
                    return false;
                }
                $scope.footerInfoTitle = i18n.i18nString('create_new_flow');
                $scope.footerHeaderId = $scope.footerMappingid;
                $scope.footerPanelId = $scope.footerMappingid+"-panel";
                $scope.nameDescription = i18n.i18nString('resource.bb053');
                return true;
            };
            $timeout(function(){
                $("body").removeClass("modal-open");
                $("body").removeClass("bt-modal-open");
                $scope.$apply();
            });

        }]);

})(angular);


; (function(ng) {

    'use strict';

        var _module = ng.module('ml-threshold',[]);
    _module.directive('stopPropagation', function () {
            return {
                restrict: 'A',
                link: function (scope, element) {
                    element.bind('click', function (event) {
                        event.stopPropagation();
                    });
                }
            };
    });
    _module.directive('mlThreshold',[function(){

        return {
            restrict : 'EA',
            templateUrl: window.appConfig.TMPLT_PRE_PATH + 'js/modules/ml-threshold/ml-threshold.html',
            controller  :'MlThresholdController' ,
            link:function(scope, el, attrs) {

            },
            scope    : {
                selectedStream:'=',
                streamUpdateCb:'=',
                gSearchCb: '='
            }

        };

    }]);
    _module.directive('slideBottomMl',function(){
        return {
            restrict : 'EA',
            link:function(scope,el,attrs){
                $(el).on('click',function(){
                    setTimeout(function(){
                         var _ele = $(el).parents('.ps-container').first();
                         var dropDownHeight = $(el).siblings('.dropdown-menu').children('.content-menu').outerHeight();
                         $(el).parents('.ps-container').first().animate({'scrollTop': $(_ele)[0].scrollHeight + dropDownHeight});
                         $(el).siblings('.dropdown-menu').children('.content-menu').animate({'scrollTop':10});
                    },200);

                    
                });
            }
        };
    });
  _module.controller('MlThresholdController', ['$scope','$translator', '$rootScope', '$workflowService', 'BTStreamsService', 'BTFlowtaskService','NotificationService','$timeout','accessControlService','$element', 'env_conf','$interval','$applicationService','botOntologyService','i18n','$http','$q',
        function ($scope, $translator, $rootScope, $workflowService, BTStreamsService, BTFlowtaskService,NotificationService,$timeout,accessControlService,$element,env_conf,$interval,$applicationService,botOntologyService,i18n,$http,$q) {
            $scope.displayMode=accessControlService.getAccessRight('BOTBUILDER_NATURAL_LANGUAGE');
             $scope.closeArrow = env_conf['context-url']+'/assets/landingImages/closeCross.png';
            var _trainOntology = false;
            var obj = {
                confidenceConfig: [ {"mode": "ml", "isActive": true, "threshold": 0, "minThreshold": 0, "maxThreshold": 0},
                                    {"mode": "faq", "isActive": true, "threshold": 0, "minThreshold": 60, "maxThreshold": 80},
                                    {"mode": "cs", "isActive": true, "threshold": 0, "minThreshold": 0, "maxThreshold": 0},
                                    {"mode": "rr", "isActive": true, "threshold": 0, "minThreshold": 0, "maxThreshold": 0}]
            };

            var restoreConfigurationPath = {
                'it' : '/resources/dependency_sample_it.json',
                'fr' : '/resources/dependency_sample.json',
                'de' : '/resources/dependency_sample.json',
                'ru' : '/resources/dependency_sample_ru.json'
            };

            var searchInAnsLang = ['en','de','es','fr','it','pt','id','nl','fi','pl','sv','ca','te','mr','ta','kk','nb'];
            var minMatchVal = 0.5;
            
            $scope.payload = {};
            $scope.payload1 = {};
            $scope.searchWord={};
            $scope.faqLong = {};
            $scope.faqSearch = {};
            $scope.autoCorrectLangs = ["en", "kk", "nl", "ru", "ja","fr"];
            $scope.selectedStream = $workflowService.selectedStream();
            $scope.knowledgeTask = $workflowService.knowledgeTasksByState() || [];
            $scope.selectedLanguage = $workflowService.selectedLanguage();
            if($scope.selectedStream.multiLingualConfigurations && $scope.selectedLanguage.value && $scope.selectedStream.multiLingualConfigurations[$scope.selectedLanguage.value]) {
                $scope.nluLanguage = $scope.selectedStream.multiLingualConfigurations[$scope.selectedLanguage.value].nluLanguage || 'en';
            } else {
                $scope.nluLanguage = $scope.selectedStream.defaultLanguage;
            }
            $scope.trashIcon = env_conf['context-url'] +'/assets/icons-new/delete-trash/trash-red-delete.svg';
            $rootScope.statusInterval = $rootScope.statusInterval || {};
            $rootScope.ontologyTrainInProgress = $rootScope.ontologyTrainInProgress || {};
            $rootScope.ontologyTrainInProgress[$scope.knowledgeTask._id] = $rootScope.ontologyTrainInProgress[$scope.knowledgeTask._id] || false;
            var _userInfo = $applicationService.userInfo();
            if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs.length && $scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].longResponses && Object.keys($scope.selectedStream.confidenceConfigs[1].longResponses).length > 0){
                $scope.faqLong = angular.copy($scope.selectedStream.confidenceConfigs[1].longResponses);
            }else{
                $scope.faqLong.readMore = false;
            }
            if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs.length && $scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].searchInAnswer && Object.keys($scope.selectedStream.confidenceConfigs[1].searchInAnswer).length > 0){
                $scope.faqSearch = angular.copy($scope.selectedStream.confidenceConfigs[1].searchInAnswer);
            }else{
                $scope.faqSearch.enabled = false;
            }
            $scope.helpIcon = window.appConfig.CONTEXT_PATH+'/assets/icons/helpIcon.svg';
            $scope.emptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/k-folder.png';
            $scope.searchIcon =  env_conf['context-url'] + '/assets/icons/search_gray.svg';
            $scope.tagClose =  env_conf['context-url'] + '/assets/icons/close.svg';
            $scope.searchWord.search='';
            $scope.constants = $rootScope._constants_;
            $scope.intentParams={
                "useSynonyms":false
            };
            $scope.currLang = {
                'langVal': $workflowService.currentLanguage()
            };
            $scope.supportedLanguages = $workflowService.supportedLanguages();
            $scope.assetsBase = env_conf['assets-url'];
            $scope.detectMultiIntent = false;
            $scope.filterToggle = 'enabled';
            $scope.intentToggle = 'enabled';
            $scope.negativeToggle = 'enabled';
            $scope.rightClass = "right400";
            $scope.refreshIcon = env_conf['context-url']+'/assets/icons/refreshIcon.svg';
            $scope.closeCross = env_conf['context-url']+'/assets/icons/closeCross.png';
            $scope.trainShow = false;
            $scope.showKgTrainingDiv = false;
            $scope.showTrainSavingDiv = false;
            $scope.rightClass = 'right700';
            $scope.bulbicon= env_conf['context-url']+'/assets/images/24x29-bulbicon.png';
            $scope.chevronRight= env_conf['context-url']+'/assets/icons-new/chevron/chevron-right-gray.svg';
            var s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,fmSlider,dualS,nGram,skipGramSeq,skipGramMax,customSlider;
            $scope.mlthreshold={};
            $scope.contextObj={qualifyContextualPaths:false};
            $scope.dependencyDesc = i18n.i18nString('dependencyDesc');
            $scope.editConfiguration = i18n.i18nString('edit_configuration');
            $scope.viewConfiguration = i18n.i18nString('view_configuration');
            $scope.settings_label = i18n.i18nString('settings_label');
            $scope.setting_label = i18n.i18nString('setting_label');
            $scope.reloadIcon = env_conf['context-url']+'/assets/icons-new/reload/reloadIcon.svg';
            $scope.checkGreenIcon = env_conf['context-url']+'/assets/icons-new/check-mark/check-green.svg';
            $scope.closeDarkIcon = env_conf['context-url']+'/assets/icons-new/close/close-dark.svg';
            $scope.refreshStatus = '';
            $scope.refreshStatus2 = '';
            $scope.intentParams = {
                features:"n_gram"
            };
            $scope.search = {};
            $scope.dialogSearch = {};
            $scope.multipIntentModels = {
                name: "",
                customConfigText: "",
                configurationValue: false,
                dialogIntentsList: [],
                dialogIntents: [],
                defaultIntents: [],
                intentParams: [],
                intentData: {},
                formType: "",
                selectedModel: {},
                nerParams: {type: "corenlp"}
            };
            $scope.getDialogIntents = [];
            $scope.getAllDialogIntents = [];
            var mapClass = {
                            'FM' : 'tags',
                            "ML" : 'tags warning-tag',
                            "KG": "tags green-tag",
                            "RR":"tags warning-tag-lite",
                            "SmallTalk":"tags blue-tag"
                        };
            var engineList = ["ml","kg","fm","rr","st"];
            var mapEngines = {
                "ml":"ML",
                "kg":"KG",
                "fm":"FM",
                "rr":"RR",
                "st":"SmallTalk",
                "un":"Universal"
            };
            var originalCopy = [];
            $scope.configurationList = [];
            var serverConfigOb = {};
            $scope.savedConfigurations = $workflowService.savedConfigurationsList() || [];
            $scope.uiConfiguration = $workflowService.configurationList() || [];
            if($scope.savedConfigurations && $scope.savedConfigurations.length){
                checkNetworkType();
                $scope.totalConfigCount = $scope.savedConfigurations.length;
            }
            $scope.options = {
                        mode: $scope.displayMode==='view' ? 'view':'code',
                        ace:window.ace
                    };
            $scope.configCB = {};
            $scope.trainStatus = {
                'success': false,
                'failed': false,
                'saving': false
            };
            $scope.kgTrainStatus = {
                'success':false,
                'failed':false,
                'saving':false
            };
            $scope.hideRestore = false;
            $scope.networkTypeList = [];
            $scope.fmSettingsCount = 0;
            $scope.mlSettingsCount = 0;
            $scope.RRSettingsCount = 0;
            $scope.savedConfigurationsCM = [];
            $scope.showEmptyConfigCM = false;
            $scope.FMPopover = 'Intent detection by FM engine using Patterns will continue to work even when this setting is disabled.';
            // $scope.langConditions = {
            //     fmCount: i18n.i18nString('ml_threshold_1_settings')
            //     //showMinMatch: false
            // };
            $scope.loadConfiguration = {};
            $scope.preferDefinitiveDesc = i18n.i18nString('prefer_definitive_matches_desc');
            $scope.preferDefinitiveDescLimit = 100;
            // if($scope.currLang.langVal == 'fr' || $scope.currLang.langVal == 'de') {
            //     $scope.langConditions.fmCount = "2 Settings";
            //     $scope.langConditions.showMinMatch = true;
            // }
            $scope.FMPopover =  i18n.i18nString('intent_detection_by_fm_engine');
            $scope.two_settings = i18n.i18nString('ml_threshold_2_settings');
            $scope.seven_settings = i18n.i18nString('ml_threshold_7_settings');
            $scope.one_setting = i18n.i18nString('ml_threshold_1_settings');
            if($scope.selectedStream && $scope.selectedStream.confidenceConfigs) {
                var confidenceFaq = $scope.selectedStream.confidenceConfigs.filter(function(val){
                    return val.mode === 'faq';
                })[0];
                 var rrValues = $scope.selectedStream.confidenceConfigs.filter(function(val){
                    return val.mode === 'rr';
                })[0];

                if(confidenceFaq) {
                    $scope.kgCollection = {
                        'autoCorrect': confidenceFaq.autoSpellCorrectEnabled,
                        'useBotSynonyms': confidenceFaq.useBotSynonyms,
                        'enPatternLemma':confidenceFaq.enPatternLemma
                    };
                }
                else {
                    $scope.kgCollection = {
                        'autoCorrect': false,
                        'useBotSynonyms': false,
                        'enPatternLemma':false
                    };                    
                }

                if(rrValues){
                     $scope.rankResolveEngine = {
                    'useDependencyParser':rrValues.useDependencyParser
                    };   
                }else{
                     $scope.rankResolveEngine = {
                    'useDependencyParser':false
                };
                }
            }
            else {
                $scope.kgCollection = {
                    'autoCorrect': false,
                    'useBotSynonyms':false,
                    'useKgSyns': false,
                    'enPatternLemma':false
                };

                $scope.rankResolveEngine = {
                    'useDependencyParser':false
                };
            }

            function registerSlider(ele,obj){
            var slider =$(ele).bootstrapSlider(obj);
              $(ele).slider().on('slideStop ', function (ev) {
              onSliderChanged(ele,ev.value);
            });
            $(ele).slider().on('slide', function (ev) {
                formatTooltip(ele, ev.value);
            });
             return slider;
            }
            function deRegisterSlider(ele) {
                $(ele).slider().off('slideStop ');
                $(ele).slider().off('slide');
//                $(ele).bootstrapSlider('distroy');
//                $(ele).slider('distroy');
            }
            function formatTooltip(mode,val){
                switch(mode){
//                    case "#slider1":
//                        $("#word-slider").find(".tooltip-inner").text(val+'%');
//                        break;
                    case "#slider2":
                        $("#proxMatch-slider").find(".tooltip-inner").text(val+'%');
                        break;
                    case "#slider3":
                        $("#mlThreshold-slider").find(".tooltip-inner").text(val);
                        break;
                    case "#slider4":
                        $("#defIntent-slider").find(".tooltip-inner").text(val+'%');
                        break;
/*                    case "#slider5":
                        $("#defKG-slider").find(".tooltip-inner").text(val+'%');
                        break;*/
                    case "#slider6":
                        $("#suggestionKG-slider").find(".tooltip-inner").text(val);
                        break;
                    case "#slider7":
                        $("#matchProx-slider").find(".tooltip-inner").text(val+'%');
                        break;
                    case "#slider8":
                        $("#path-slider").find(".tooltip-inner").text(val+'%');
                        break;
                    case "#slider9":
                        $('#auto-correct-slider').find('.tooltip-inner').text(val+'%');
                        break;
                    case "#slider10":
                        $('#minMatch-slider').find('.tooltip-inner').text(val);
                        break;
                    case "#nGramSlider":
                        $("#nGram-slider").find(".tooltip-inner").text(val);
                        break;
                    case "#matchScore-slider":
                        $('#minMatchScore-slider').find(".tooltip-inner").text(val);
                        break;
                    case "#dual-slider":
                        $('.dual-slider').find(".tooltip-min").find('.tooltip-inner').text('<'+val[0]+'%');
                        $('.dual-slider').find(".tooltip-max").find('.tooltip-inner').text('<' +val[1]+'%');
                        break;
                    case "#slider3CM":
                        $("#mlThreshold-sliderCM").find(".tooltip-inner").text(val);
                        break;
                    case "#slider4CM":
                        $("#defIntent-sliderCM").find(".tooltip-inner").text(val+'%');
                        break;
                    case "#nGramSliderCM":
                        $("#nGram-sliderCM").find(".tooltip-inner").text(val);
                        break;
                    case "#slider11":
                        if(!val) {
                            val = 0;
                        }
                        $("#fmThreshold-slider").find(".tooltip-inner").text(val+'%');
                        break;
                }
            }
            $scope.knowledgeTasksList = function(){
                var requestData = { "streamId": $workflowService.selectedStream()._id };
                BTStreamsService.getAllKtsList(_userInfo.userId, requestData)
                .then(function (res) {
                    var identified_task = {};
                    $scope.knowledgeTasks = res.data;
                    identified_task =_.find($scope.knowledgeTasks,{state:'configured'});
                    if(isObjEmpty(identified_task)) {
                        identified_task=_.find($scope.knowledgeTasks,{state:'awaitingApproval'});
                    }
                    if(!isObjEmpty(identified_task)){
                       $scope.knowledgeTask = identified_task;
                    }
                });
            };
            
            function isObjEmpty(obj) {
                for(var key in obj) {
                    if(obj.hasOwnProperty(key)) {
                        return false;
                    }
                }
                return true;
            }

            // update RR engine values
            function updateRREngineData() {
                if(obj.confidenceConfig[3].isPreferDefinitiveMatch) {
                    $scope.rankResolveEngine.isPreferDefinitiveMatch = obj.confidenceConfig[3].isPreferDefinitiveMatch;
                }
                if(obj.confidenceConfig[3].intentRescoring) {
                    $scope.rankResolveEngine.intentRescoring = obj.confidenceConfig[3].intentRescoring;
                }
                if(obj.confidenceConfig[2].isFMThreshold) {
                    $scope.intentDetect.isFMThreshold = obj.confidenceConfig[2].isFMThreshold;
                }
                checkFMSettingCount();
                checkRRSettingCount();
            }


            $scope.prepareStopWords= function(dataObj){
                $scope.mlthreshold.stopWords = [];
                if(dataObj && dataObj.intentData && dataObj.intentData.stopwords){
                    $scope.mlthreshold.stopWords = dataObj.intentData.stopwords.replace(/\s\s+/g, ' ').split(" ");
                    $scope.mlthreshold.stopWords = $scope.constants.getAlphabeticallySortedArray($scope.mlthreshold.stopWords);
                }
            };

            $scope.updateFaqSearch = function(_trainOntology){
                var faqSearchObj = {};
                var mode ="faqSearch";
                $timeout(function(){
                if($scope.faqSearch && $scope.faqSearch.enabled !== undefined){
                    faqSearchObj['enabled'] = $scope.faqSearch.enabled;
                }
                if($scope.faqSearch && $scope.faqSearch.notifyUser){
                    faqSearchObj['notifyUser'] = $scope.faqSearch.notifyUser;
                }
                if($scope.faqSearch && $scope.faqSearch.responseType){
                    faqSearchObj['responseType'] = $scope.faqSearch.responseType; 
                }
                if($scope.faqSearch && $scope.faqSearch.enabled && $scope.faqSearch.responseType === 'relevantWithReadMore' && $scope.faqSearch.useCustomReadMoreURL !== undefined){
                    faqSearchObj['useCustomReadMoreURL'] = $scope.faqSearch.useCustomReadMoreURL; 
                }
                if($scope.faqSearch && $scope.faqSearch.enabled && $scope.faqSearch.useCustomReadMoreURL && $scope.faqSearch.responseType === 'relevantWithReadMore' && $scope.faqSearch.customReadMoreURL !== undefined){
                    faqSearchObj['customReadMoreURL'] = $scope.faqSearch.customReadMoreURL; 
                }
                obj.confidenceConfig[1].searchInAnswer = faqSearchObj;
                if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs[1].longResponses){
                        obj.confidenceConfig[1].longResponses = $scope.selectedStream.confidenceConfigs[1].longResponses;
                }
                doServiceCalls(obj,_trainOntology);
                });
                

            };


            $scope.manageResponseCB = {};
            $scope.openManageResponse = function (key,event) {
                $scope.showStandardResponses= true;
                event.preventDefault();
                event.stopImmediatePropagation();
                event.stopPropagation();
//                        $(".advancedControlManageResponse").modal("show");
                setTimeout(function(){
                    $scope.manageResponseCB.title = i18n.i18nString('ml_threshold_confirmation_dialog_for_component');
                    $scope.manageResponseCB.conditionKey = $scope.constants.pauseResumeMessages[key];
                    var _btnValue = 'close';
                    $scope.manageResponseCB.openManageResponse(_btnValue);
                   $scope.manageResponseCB.initMessages($scope.displayMode);  
                },200);
            };

            $scope.manageResponseCB.closeResponseScreen = function () {
                        $scope.manageResponseCB.conditionKey = {};
                        $scope.showStandardResponses = false;
                      setTimeout(function (){
                          $(".builderMaincontainer").addClass("bt-modal-open");  
                        },300);
                    };

            $scope.getTrainStatus = function () {
                $scope.showKgTrainingDiv = true;
                var callName = "streams/" + $workflowService.selectedStream()._id + "/knowledgetask/" + $scope.knowledgeTask._id + "/trainBot";
                botOntologyService.getTrainStatus($applicationService.userInfo.userId, $workflowService.selectedStream()._id, callName)
                  .then(function (response) {

                    if (response.data.status == "success") {
                      $interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                      $rootScope.statusInterval[$scope.knowledgeTask._id] = "";
                      $rootScope.ontologyTrainInProgress[$scope.knowledgeTask._id] = false;
                      $scope.kgTrainStatus.success = true;
                      $scope.kgTrainStatus.saving = false;
                      $scope.kgTrainStatus.failed = false;
                      NotificationService.notify(i18n.i18nString('kg_train_success'), "success");
                    }else if(response.data.status == "in-progress"){
                        $scope.kgTrainStatus.failed = false;
                        $scope.kgTrainStatus.success = false;
                        $scope.kgTrainStatus.saving = true;
                    }
                    else if(response.data.status == "failure"){
                      $interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                      if(response.data.heavyNodeCount){
                        NotificationService.notify(i18n.i18nString('training_heavynode'), 'error');
                      }
                      $rootScope.statusInterval[$scope.knowledgeTask._id] = "";
                      $rootScope.ontologyTrainInProgress[$scope.knowledgeTask._id] = false;
                      $scope.kgTrainStatus.success = false;
                      $scope.kgTrainStatus.saving = false;
                      $scope.kgTrainStatus.failed = true;
                      NotificationService.notify( i18n.i18nString('kg_graph_training_failed'), "error");
                    }

                  }, function (response) {
                    $interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                    $rootScope.statusInterval[$scope.knowledgeTask._id] = "";
                    $rootScope.ontologyTrainInProgress[$scope.knowledgeTask._id] = false;
                    $scope.kgTrainStatus.failed = true;
                    $scope.kgTrainStatus.success = false;
                    $scope.kgTrainStatus.saving = false;
                    NotificationService.notify(i18n.i18nString('problem_train'), "error");
                  });
            };

            $scope.trainBotOntology = function () {
                $scope.showKgTrainingDiv = true;
                $element.find('#warningKgModal').removeClass('show').addClass('fade');
               // $rootScope.ontologyTrainInProgress[$scope.knowledgeTask._id] = true;
                if($scope.knowledgeTask && $scope.knowledgeTask._id){
                    BTStreamsService.trainFaq($workflowService.selectedStream()._id, $scope.knowledgeTask._id)
                  .then(function (res) {
                    $scope.kgTrainStatus.failed = false;
                    $scope.kgTrainStatus.success = false;
                    $scope.kgTrainStatus.saving = true;
                    if(res.data.status.toLowerCase() === 'in_progress'){
                       NotificationService.notify( i18n.i18nString('kg_train'), "success"); 
                       $rootScope.$broadcast('getProgressDockStatus');
                       $rootScope.$broadcast('startTimer');
                    }
                    // $rootScope.statusInterval[$scope.knowledgeTask._id] = $interval(function () {
                    //   $scope.getTrainStatus();
                    // }, 20000);
                    
                  },
                  function (err) {
                    if (err.data.errors && err.data.errors.length > 0) {
                      var _msg = err.data.errors[0].msg;
                      NotificationService.notify(_msg, 'error');
                    } else {
                      NotificationService.notify( i18n.i18nString('problem_train'), "error");
                    }
                    $scope.kgTrainStatus.failed = true;
                    $scope.kgTrainStatus.success = false;
                    $scope.kgTrainStatus.saving = false;
                    //$interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                    //$rootScope.ontologyTrainInProgress[$scope.knowledgeTask._id] = false;
                  });
                }
                
            };

            var cleanUpFunc = $rootScope.$on('kgTrainingStatus',function(e,data){
                if(data){
                     $scope.trainOntologyStatus = data.status.toLowerCase();
                      if($scope.trainOntologyStatus === 'success'){
                        NotificationService.notify(i18n.i18nString('kg_train_success'), "success");
                         $scope.kgTrainStatus.success = true;
                          $scope.kgTrainStatus.saving = false;
                          $scope.kgTrainStatus.failed = false;
                    }else if($scope.trainOntologyStatus === 'in_progress'){
                          $scope.kgTrainStatus.success = false;
                          $scope.kgTrainStatus.saving = true;
                          $scope.kgTrainStatus.failed = false;
                    }else{
                          $scope.kgTrainStatus.success = false;
                          $scope.kgTrainStatus.saving = false;
                          $scope.kgTrainStatus.failed = true;
                    }
                }
            });

            $scope.$on('$destroy', function() {
                cleanUpFunc();
            });

            $scope.showKgModal = function(){
              $element.find('#warningKgModal').removeClass('fade').addClass('show');  
            };

            $scope.proceedAutoCorrectModal = function() {
                $element.find('#warningAutoCorrectModal').removeClass('show').addClass('fade');
                _trainOntology = $scope.kgCollection.autoCorrect;
                $scope.saveToggleSwitch(_trainOntology);
                if($rootScope.statusInterval[$scope.knowledgeTask._id]) {
                    $interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                }
            };

            $scope.closeAutoCorrectModal = function() {
                 $scope.kgCollection.autoCorrect = !$scope.kgCollection.autoCorrect;
                $element.find('#warningAutoCorrectModal').removeClass('show').addClass('fade');
            };

            $scope.showAutoCorrectModal = function(){
                $element.find('#warningAutoCorrectModal').removeClass('fade').addClass('show');  
            };

            function updateChangeLogs(obj,_trainOntology){
                   var _payload = {
                    "updatedConfig":"useBotSynonyms",
                    "useBotSynonyms": $scope.kgCollection.useBotSynonyms,
                    "mode":"faq"
                };
                BTStreamsService.updateThresholds($workflowService.selectedStream()._id, _payload).then(function(response){
                    if(response){
                        $scope.selectedStream.confidenceConfigs = response.data.confidenceConfigs;
                        $workflowService.selectedStream($scope.selectedStream, response.data);
                         if(_trainOntology && $scope.knowledgeTask._id) {
                                $scope.trainBotOntology();
                            }
                         _trainOntology = false;
                          NotificationService.notify(i18n.i18nString('settings_saved_sucessfully'), "success");
                    }
                },function(err){
                        if(err.data && err.data && err.data.errors[0] && err.data.errors[0].msg){
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            }else{
                                NotificationService.notify( i18n.i18nString('some_thing_wrong_label'), "error");
                            }  
                });
            }

            $scope.saveBotSynonymToggleSwitch = function(_trainOntology){
                       $timeout(function(){
                        obj.confidenceConfig[1].useBotSynonyms = $scope.kgCollection.useBotSynonyms;
                        updateChangeLogs(obj,_trainOntology);
                    },250);
            };

            $scope.proceedKgSynonyms = function(){
                $element.find('#warningKgSynonymModal').removeClass('show').addClass('fade');
                _trainOntology = $scope.kgCollection.useBotSynonyms;
                $scope.saveBotSynonymToggleSwitch(_trainOntology);
                if($rootScope.statusInterval[$scope.knowledgeTask._id]) {
                    $interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                }
            };

            $scope.toggleLemPattern = function(){
                $scope.saveToggleSwitch(true);
                if($rootScope.statusInterval[$scope.knowledgeTask._id]) {
                    $interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                }
            };

            $scope.closeKgSynonymModal = function() {
                 $scope.kgCollection.useBotSynonyms = !$scope.kgCollection.useBotSynonyms;
                $element.find('#warningKgSynonymModal').removeClass('show').addClass('fade');
            };

            $scope.showKgSynonymModal = function(){
                $element.find('#warningKgSynonymModal').removeClass('fade').addClass('show');  
            };

            $scope.closeKgModal = function(){
                $element.find('#warningKgModal').removeClass('show').addClass('fade');
                $scope.faqSearch.enabled = !$scope.faqSearch.enabled;
                if($scope.faqSearch.enabled === true){
                    $scope.faqSearch.responseType = 'complete';
                }
            };

            $scope.proceedFaqSearch = function(){
                if($rootScope.statusInterval[$scope.knowledgeTask._id]) {
                    $interval.cancel($rootScope.statusInterval[$scope.knowledgeTask._id]);
                }
                if($scope.faqSearch.enabled === true){
                    $scope.faqSearch.responseType = 'complete';
                }
                _trainOntology = $scope.faqSearch.enabled;
                $element.find('#warningKgModal').removeClass('show').addClass('fade');
                $scope.updateFaqSearch(_trainOntology);
            };

            $scope.toggleCheck = function(){
                $timeout(function(){
                    if($scope.faqLong.useCustomReadMoreURL === false){
                        $scope.updateFaqLongResponse();   
                    }    
                },0);
                

            };

            $scope.toggleCheckSearch = function(){
                $timeout(function(){
                if($scope.faqSearch.useCustomReadMoreURL === false){
                        $scope.updateFaqSearch();
                    }
                },0);
               
            };


            $scope.updateFaqLongResponse = function(){
                var faqObject = {};
                $timeout(function(){
                if($scope.faqLong && $scope.faqLong.readMore !== undefined){
                    faqObject['readMore'] = $scope.faqLong.readMore;
                }
                if($scope.faqLong.readMore && $scope.faqLong.useCustomReadMoreURL !== undefined){
                     faqObject['useCustomReadMoreURL'] = $scope.faqLong.useCustomReadMoreURL;
                }
                if($scope.faqLong.readMore && $scope.faqLong.useCustomReadMoreURL && $scope.faqLong.customReadMoreURL !== undefined){
                     faqObject['customReadMoreURL'] = $scope.faqLong.customReadMoreURL;
                }
                obj.confidenceConfig[1].longResponses = faqObject;
                if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs[1].searchInAnswer){
                    obj.confidenceConfig[1].searchInAnswer = $scope.selectedStream.confidenceConfigs[1].searchInAnswer;
                }
                if($scope.kgCollection.useBotSynonyms){
                    $scope.selectedStream.confidenceConfigs[1].useBotSynonyms = $scope.kgCollection.useBotSynonyms;
                    obj.confidenceConfig[1].useBotSynonyms = $scope.kgCollection.useBotSynonyms;
                }
                doServiceCalls(obj);
                });
               

            };

              
            $scope.setWordsscrollToBottom = function(){
                setTimeout(function () {
                        $('.input').first().focus();
                    }, 1000);
                setTimeout(function(){
                    $('.searchBar').off('click').on('click',function () {
                        $scope.searchWord.search='';
                if ($(this).hasClass('fa-remove')) {
                    $('.stopWordsSearch').removeClass('searchExpand');
                    $(this).removeClass('fa-remove');
                    $(this).addClass('fa-search');
                    $scope.searchWord.search='';
                } else {
                    $('.stopWordsSearch').addClass('searchExpand');
                    $(this).addClass('fa-remove');
                    $(this).removeClass('fa-search');
                     $timeout(function () {
                    $('.stopWordsSearchInput').focus();
                }, 350);
                }
            });
                     var ele=$('.stopWordsBody');
                var bodyHeight = ele[0].scrollHeight;
                ele.scrollTop(bodyHeight);
                },500);
            };
            $scope.activateWordSearch = function(){
                $(".stopWordsBody").scrollTop(0);
            };
            $scope.deleteStopWordInSearch = function(text){
                $scope.lodingStopWords = true;
                if($scope.payload && $scope.payload.intentData && $scope.payload.intentData.stopwords){
                    $scope.payload.intentData.stopwords = $scope.payload.intentData.stopwords.replace(text,'');
                }
                saveMLSynonymSetting(null,false);
            };
            $scope.manageStopWords=function(){
                $scope.showStopwordsModal=true;
                $scope.openModalSlider("#manageStopWords");
                $scope.setWordsscrollToBottom();
            };
            $scope.resetDefaultStopWords = function(){
                function resetStopwords(){
                    saveMLSynonymSetting(null,true,"intentData.stopwords");
                }
                function cancel(){
                   return;
                }
                NotificationService.userConfirm( i18n.i18nString('reset_default_delete'), [resetStopwords, cancel], {okText:  i18n.i18nString('confirm_and_reset'),btnClass:"redBtn"}, "", undefined,  i18n.i18nString('confirm_proceed'));   
            };
            $scope.editStopWords=function(){
                var tempStopwords='';
                setTimeout(function(){
                 $.each($scope.mlthreshold.stopWords,function(i,stopword){
                     tempStopwords= tempStopwords + stopword+ " "; 
                });   
                $scope.payload.intentData.stopwords = tempStopwords.trim();
                saveMLSynonymSetting(null,false);
                },100);
            };
            $scope.closeManageStopWordsModalSlider=function(){
                $scope.closeModalSlider('#manageStopWords');
                $scope.showStopwordsModal=false;
            };

            
            function getMLParams() {
                BTStreamsService.getMLSynonym($workflowService.selectedStream()._id)
                .then(function (res) {
                    var type3List = [];
                    if(res.data && res.data.length) {
                        res.data.forEach(function(item, i) {
                            if(item.type === 1) { // Network type
                                $workflowService.mlPharams(item);
                                $scope.payload = item;
                                $scope.prepareStopWords(item);
                                $scope.originalMlData = angular.copy(item);
                                $scope.intentParams = item.intentParams;
                                $timeout(function(){
                                    clearSliders('ML');
                                    prepareSliders('ML');
                                });
                            }
                            if(item.type === 2 && item.advancedMLConfigurations) { // Default intent models
                                $scope.multipIntentModels.defaultIntents = item;
                                if(item && item.advancedMLConfigurations && item.advancedMLConfigurations.length) {
                                    $scope.multipIntentModels.defaultIntents.networkType = item.advancedMLConfigurations[0].configurationValue;
                                } else if(!item.advancedMLConfigurations.length) {
                                    $scope.multipIntentModels.defaultIntents.networkType = $scope.networkTypeList.defaultValue;
                                } else {
                                    $scope.multipIntentModels.defaultIntents.networkType = $scope.networkTypeList.defaultValue || 'Standard';
                                }
                            }
                            if(item.type === 3 && item.advancedMLConfigurations) { // Dialog intent models
                                var dialogIntents = [];
                                if(item.dialogIntents) {
                                    item.dialogIntents.forEach(function(intent) {
                                        if(intent) {
                                            dialogIntents.push($scope.dialogRefIdObj(intent, item));
                                        }
                                    });
                                }
                                if(item.advancedMLConfigurations && item.advancedMLConfigurations.length) { // find network
                                    var findNetwork = item.advancedMLConfigurations.find(function(item) {
                                        return item.configurationKeyName === "network";
                                    });
                                    if(findNetwork) {
                                        item.network = findNetwork.configurationValue;
                                    }
                                } else if(!item.advancedMLConfigurations.length) {
                                    item.network = $scope.networkTypeList.defaultValue;
                                } else {
                                    item.network = $scope.networkTypeList.defaultValue|| 'Standard';
                                }
                                item.dialogIntents = dialogIntents;
                                type3List.push(item);
                            }
                        });
                        $scope.multipIntentModels.dialogIntents = type3List;
                    }
                    if($scope.intentParams && $scope.intentParams.useSynonyms){
                        $scope.filterToggle = 'disabled';
                    }
                    if($scope.intentParams && !$scope.intentParams.features){
                        $scope.intentParams.features = 'n_gram';
                    }
                    checkMultipIntentModel();
                }, function (err) {
                    $scope.intentParams.useSynonyms = false;
                });
            }

            $scope.showModal = function() {
                $element.find('#warningModal').removeClass('fade').addClass('show');
            };

            $scope.closeModal = function () {
                if($scope.multipIntentModels.intentParams) {
                    $scope.multipIntentModels.intentParams.useSynonyms = !$scope.multipIntentModels.intentParams.useSynonyms;
                } else {
                    $scope.intentParams.useSynonyms = !$scope.intentParams.useSynonyms;
                }
                if($scope.intentParams.useSynonyms) {
                    $scope.intentParams.useSynonyms = !$scope.intentParams.useSynonyms;
                } else {
                    $scope.intentParams.useSynonyms = !$scope.intentParams.useSynonyms;
                }
                $element.find('#warningModal').removeClass('show').addClass('fade');  
            };
            
            $scope.enableDisableSynonym = function() {
                if($scope.intentParams && $scope.intentParams.useSynonyms){
                    $scope.filterToggle = 'enabled';
                }
                else{
                    $scope.filterToggle = 'disabled';
                }
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    if($scope.multipIntentModels.intentParams && $scope.multipIntentModels.intentParams.useSynonyms){
                        $scope.filterToggle = 'enabled';
                    }else{
                        $scope.filterToggle = 'disabled';
                    }
                    $element.find('#warningModal').removeClass('show').addClass('fade');
                    return;
                }
                $scope.payload.intentParams = $scope.intentParams;
                saveMLSynonymSetting(null, false, '', true);
            };
            $scope.enableDisableStopWords = function() {
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    // if($scope.multipIntentModels.intentParams.useStopwords) {
                    //     $scope.multipIntentModels.intentParams.useStopwords = false;
                    // } else {
                    //     $scope.multipIntentModels.intentParams.useStopwords = true;
                    // }
                    return;
                }
                // if($scope.intentParams.useStopwords){
                //     $scope.intentParams.useStopwords= false;
                // }
                // else{
                //     $scope.intentParams.useStopwords= true;
                // }
                $scope.payload.intentParams = $scope.intentParams;
                saveMLSynonymSetting(null,false);
            };

            $scope.enableDisablePlaceholders = function(){
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    return;
                }
                // if($scope.intentParams.usePlaceholders){
                //     $scope.intentParams.usePlaceholders =false;
                // }else{
                //     $scope.intentParams.usePlaceholders=true;
                // }
                $scope.payload.intentParams = $scope.intentParams;
                saveMLSynonymSetting(null,false);
            };
            // NER model
            $scope.savenerParams = function(type){
                $scope.payload.nerParams = $scope.payload.nerParams;
                saveMLSynonymSetting(null,false);
            };


            $scope.redirectToLink= function(link,e){
                if(e){
                  e.preventDefault();
                  e.stopImmediatePropagation();
                  e.stopPropagation();
                }
                $rootScope.redirectToLink(link, e);
            };
            $scope.upgradeML = function(type){
                function upgrade(){
                  $scope.intentParams.type = type;
                $scope.payload.intentParams = $scope.intentParams;
                if(type==='V3'){
                    saveMLSynonymSetting(type,true,'',true); 
                }else{
                     saveMLSynonymSetting(type,false, '', true); 
                }
                }
                function cancel(){
                    return;
                }
                if(type==="V3"){

                 var msg= i18n.i18nString( 'new_version_of_ml_model')+' <span class="marginLeft5 bthelpLinksTextcolor pointer-hand"><a class="knowmore" target="_blank" href="https://developer.kore.ai/docs/bots/nlp/user-utterances/#ML-upgrade">'+i18n.i18nString( 'know_more')+'</a></span></br></br><span class="grayInfoText">'+ i18n.i18nString( 'older_version_of_ml_model')+'</span>' ;
                    
                  NotificationService.userConfirm(msg, [upgrade, cancel], {okText:  i18n.i18nString( 'upgrade_and_train') ,addHtmlContent:true}, "", undefined,  i18n.i18nString('confirm_proceed'));   
                }else{
                    NotificationService.userConfirm('<strong>'+ i18n.i18nString( 'older_version_of_ml_model')+'</strong></br>'+  i18n.i18nString( 'we_strongle_recommend_to_stay'), [upgrade, cancel], {okText:  i18n.i18nString( 'downgrade_label'),btnClass:"redBtn",addHtmlContent:true}, "", undefined,  i18n.i18nString('confirm_proceed'));   
                }
                
                
            };
            $scope.resetNgram = function(){
                saveMLSynonymSetting('V3',true,"intentParams.ngram"); 
            }; 
            if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs.length>0){
                //obj.confidenceConfig[0].threshold = $scope.selectedStream.confidenceConfigs[0].threshold;
                 obj.confidenceConfig[1].minThreshold = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].minThreshold !== undefined )? $scope.selectedStream.confidenceConfigs[1].minThreshold : 60;
                 obj.confidenceConfig[1].maxThreshold = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].maxThreshold !== undefined )? $scope.selectedStream.confidenceConfigs[1].maxThreshold : 80;
                 obj.confidenceConfig[2].wordCoverage = $scope.selectedStream.confidenceConfigs[2] === undefined ? 60 : ($scope.selectedStream.confidenceConfigs[2].wordCoverage !== undefined ? $scope.selectedStream.confidenceConfigs[2].wordCoverage : 60);

                 obj.confidenceConfig[2].isFMThreshold = $scope.selectedStream.confidenceConfigs[2] === undefined ? false : ($scope.selectedStream.confidenceConfigs[2].isFMThreshold !== undefined ? $scope.selectedStream.confidenceConfigs[2].isFMThreshold : false);
                 obj.confidenceConfig[2].fmThreshold = $scope.selectedStream.confidenceConfigs[2] === undefined ? 2 : ($scope.selectedStream.confidenceConfigs[2].fmThreshold !== undefined ? $scope.selectedStream.confidenceConfigs[2].fmThreshold : 2);

                 obj.confidenceConfig[3].taskMatchTolerance = $scope.selectedStream.confidenceConfigs[3] === undefined ? 2 : ($scope.selectedStream.confidenceConfigs[3].taskMatchTolerance !== undefined ? $scope.selectedStream.confidenceConfigs[3].taskMatchTolerance : 2);                 
                 obj.confidenceConfig[3].minMatchVal = $scope.selectedStream.confidenceConfigs[3] === undefined ? 0.5 : $scope.selectedStream.confidenceConfigs[3].minMatchVal ? $scope.selectedStream.confidenceConfigs[3].minMatchVal : 0.5;
                 obj.confidenceConfig[3].useDependencyParser =($scope.selectedStream.confidenceConfigs[3] && $scope.selectedStream.confidenceConfigs[3].useDependencyParser !== undefined) ? $scope.selectedStream.confidenceConfigs[3].useDependencyParser:false;

                 obj.confidenceConfig[3].isPreferDefinitiveMatch =($scope.selectedStream.confidenceConfigs[3] && $scope.selectedStream.confidenceConfigs[3].isPreferDefinitiveMatch !== undefined) ? $scope.selectedStream.confidenceConfigs[3].isPreferDefinitiveMatch:false;
                 obj.confidenceConfig[3].intentRescoring =($scope.selectedStream.confidenceConfigs[3] && $scope.selectedStream.confidenceConfigs[3].intentRescoring !== undefined) ? $scope.selectedStream.confidenceConfigs[3].intentRescoring:false;

                 obj.confidenceConfig[2].labelMatch = $scope.selectedStream.confidenceConfigs[2] === undefined ? true : ($scope.selectedStream.confidenceConfigs[2].hasOwnProperty('labelMatch')?$scope.selectedStream.confidenceConfigs[2].labelMatch: true);
                 obj.confidenceConfig[0].minThreshold = $scope.selectedStream.confidenceConfigs[0].minThreshold !== undefined ? $scope.selectedStream.confidenceConfigs[0].minThreshold : 0.3;
                 obj.confidenceConfig[0].exactMatchThreshold = $scope.selectedStream.confidenceConfigs[0].exactMatchThreshold !== undefined ? $scope.selectedStream.confidenceConfigs[0].exactMatchThreshold : 95;
                 obj.confidenceConfig[1].exactMatchThreshold = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].exactMatchThreshold !== undefined) ? $scope.selectedStream.confidenceConfigs[1].exactMatchThreshold : 95;
                 obj.confidenceConfig[1].suggestionsCount = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].suggestionsCount !== undefined) ? $scope.selectedStream.confidenceConfigs[1].suggestionsCount : 3;
                 obj.confidenceConfig[1].taskMatchTolerance = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].taskMatchTolerance !== undefined) ? $scope.selectedStream.confidenceConfigs[1].taskMatchTolerance : 5;
                 obj.confidenceConfig[1].pathCoverage = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].pathCoverage !== undefined) ? $scope.selectedStream.confidenceConfigs[1].pathCoverage : 50;
                 $scope.contextObj.qualifyContextualPaths = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].qualifyContextualPaths !== undefined) ? $scope.selectedStream.confidenceConfigs[1].qualifyContextualPaths : false;
                 obj.confidenceConfig[1].autoCorrPercentage = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].autoCorrPercentage !== undefined) ? $scope.selectedStream.confidenceConfigs[1].autoCorrPercentage : 5;
                 obj.confidenceConfig[1].qualifyContextualPaths =($scope.selectedStream.confidenceConfigs[1]&&  $scope.selectedStream.confidenceConfigs[1].qualifyContextualPaths !== undefined) ? $scope.selectedStream.confidenceConfigs[1].qualifyContextualPaths : false;
                 obj.confidenceConfig[1].autoSpellCorrectEnabled = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].autoSpellCorrectEnabled !== undefined) ? $scope.selectedStream.confidenceConfigs[1].autoSpellCorrectEnabled : false;
                 obj.confidenceConfig[2].minMatchVal = ($scope.selectedStream.confidenceConfigs[2]&& $scope.selectedStream.confidenceConfigs[2].minMatchVal !== undefined) ? $scope.selectedStream.confidenceConfigs[2].minMatchVal : 0.5;
                 obj.confidenceConfig[1].enPatternLemma = ($scope.selectedStream.confidenceConfigs[1] && $scope.selectedStream.confidenceConfigs[1].enPatternLemma !== undefined) ? $scope.selectedStream.confidenceConfigs[1].enPatternLemma : false;
            }
            $scope.intentDetect = {
                value: obj.confidenceConfig[2].labelMatch
            };
          $scope.showReset = function(a,b) {
                $(a).removeClass('hide');
                $scope.currentSlider = b;
          };

          $scope.hideReset = function(a) {
                $(a).addClass('hide');
          };
          $timeout(function(){
            updateRREngineData();
         });


          $scope.resetDefaultVal = function(current) {
                current = current || $scope.currentSlider;
                var defValue;
                switch(current){
//                    case "#slider1":
//                        defValue = 60;
//                        obj.confidenceConfig[2].wordCoverage = defValue;
//                        s1.bootstrapSlider('setValue', defValue);
//                        break;
                    case "#slider2":
                        defValue = 2;
                        obj.confidenceConfig[3].taskMatchTolerance = defValue;
                        s2.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider3":
                        defValue = 0.3;
                        obj.confidenceConfig[0].minThreshold = defValue;
                        s3.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider4":
                        defValue = 95;
                        obj.confidenceConfig[0].exactMatchThreshold = defValue;
                        s4.bootstrapSlider('setValue', defValue);
                        break;
/*                    case "#slider5":
                        defValue = 95;
                        obj.confidenceConfig[1].exactMatchThreshold = defValue;
                        s5.bootstrapSlider('setValue', defValue);
                        break;*/
                    case "#slider6":
                        defValue = 3;
                        obj.confidenceConfig[1].suggestionsCount = defValue;
                        s6.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider7":
                        defValue = 5;
                        obj.confidenceConfig[1].taskMatchTolerance = defValue;
                        s7.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider8":
                        defValue = 50;
                        obj.confidenceConfig[1].pathCoverage = defValue;
                        s8.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider9":
                        defValue = 5;
                        obj.confidenceConfig[1].autoCorrPercentage = defValue;
                        s9.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider10":
                        defValue = 0.5;
                        obj.confidenceConfig[2].minMatchVal = defValue;
                        s10.bootstrapSlider('setValue', defValue);
                        break;

                    case "#matchScore-slider":
                        defValue = 0.5;
                        obj.confidenceConfig[3].minMatchVal = defValue;
                        s11.bootstrapSlider('setValue',defValue);
                        break;

                    case "#dual-slider":
                        var slider = $("#knowledgeCollectionThresholds").find("#triple-slider")[0];
                        slider.noUiSlider.set([60, 80, 95]);
                        defValue = [60,80];
                        obj.confidenceConfig[1].minThreshold = defValue[0];
                        obj.confidenceConfig[1].maxThreshold = defValue[1];
                        obj.confidenceConfig[1].exactMatchThreshold = 95;
                        dualS.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider3CM":
                        defValue = 0.3;
                        obj.confidenceConfig[0].minThreshold = defValue;
                        s3.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider4CM":
                        defValue = 95;
                        obj.confidenceConfig[0].exactMatchThreshold = defValue;
                        s4.bootstrapSlider('setValue', defValue);
                        break;
                    case "#slider11":
                        defValue = 2;
                        obj.confidenceConfig[2].fmThreshold = defValue;
                        fmSlider.bootstrapSlider('setValue', defValue);
                        break;
                }
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    return;
                }
                formatTooltip(current,defValue);
                doServiceCalls(obj);

          };

          $scope.closeTrainSaveDiv = function() {
              $scope.showTrainSavingDiv = false;
          };

          $scope.closeKgTrainDiv = function(){
            $scope.showKgTrainingDiv = false;
          };


          $scope.$on('getProgressDockStatus', function() {
            $scope.trainStatus.saving = false;
            $scope.trainStatus.success = true;
            $scope.trainStatus.failed = false;
          });

             $scope.trainBot = function(callFrom) {
                BTStreamsService.trainUtterances($workflowService.selectedStream()._id)
                    .then(function(res) {
                            $scope.trainStatus.saving = true;
                            $scope.trainStatus.success = false;
                            $scope.trainStatus.failed = false;
                            $scope.showTrainBtn = false;
                            $scope.showTrainSavingDiv = true;
                            $rootScope.$emit('triggerAutoTrainStatusPoll');
                            $rootScope.$emit('clearTestTrainText');
                            $rootScope.$broadcast('getProgressDockStatus');
                            $rootScope.$broadcast('startTimer');
                            // $(".trainingProgress").addClass('open'); /** commented since dock shouldn't be showed for Kg training **/
                            NotificationService.notify( i18n.i18nString('bot_train'), "info");
                            $scope.trainShow = false;
                            $('.ml-threshold-saving').addClass('trainingTop20');
                        },
                        function(err) {
                            $scope.trainStatus.saving = false;
                            $scope.trainStatus.success = false;
                            $scope.trainStatus.failed = true;
                            if (err.data.errors.length > 0) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            } else {
                                NotificationService.notify( i18n.i18nString('bot_train_failure'), "error");
                            }

                        });
            };
          $scope.bulbIcon = window.appConfig.CONTEXT_PATH+'/assets/images/24x29-bulbicon.png';
            function  clearSliders(type){
                if(type=='FM'){
                    deRegisterSlider('#slider10');
                    deRegisterSlider('#slider11');
                }
                if(type=='KC'){
                    //deRegisterSlider('#slider5');
                    deRegisterSlider('#slider6');
                    deRegisterSlider('#slider7');
                    deRegisterSlider('#slider8');
                    deRegisterSlider('#slider9');
                    deRegisterSlider('#dual-slider');
                }
                if(type=='ML'){
                     deRegisterSlider('#slider3');
                     deRegisterSlider('#slider4');
                     deRegisterSlider('#nGramSlider');
                     deRegisterSlider('#skipGramSeq');
                     deRegisterSlider('#skipGramMax');
                }
                if(type == 'RR') {
                   deRegisterSlider('#slider2');
                }
                if(type === 'advConfig'){
                    deRegisterCustomSliders();
                }
                if(type === 'CM') {
                    deRegisterSlider('#slider3CM');
                    deRegisterSlider('#slider4CM');
                    deRegisterSlider('#nGramSliderCM');
                    deRegisterSlider('#skipGramSeqCM');
                    deRegisterSlider('#skipGramMaxCM');
                }
            }

            $scope.tripleSliderChanged = function(event){
                var intentSlid = Math.round($($('#triple-slider .noUi-handle')[0]).attr('aria-valuenow'));
                var kgTask = Math.round($($('#triple-slider .noUi-handle')[1]).attr('aria-valuenow'));
                var scoreSlid = Math.round($($('#triple-slider .noUi-handle')[2]).attr('aria-valuenow'));
                onSliderChanged("#dual-slider", [intentSlid, kgTask, scoreSlid]);
            };

            $scope.updateConfigs = function(oldConfig,configuration){
                $scope.currentConfiguration = configuration;
                $scope.previousConfiguration = oldConfig;
                $element.find('#editConfig').removeClass('fade').addClass('show');
            };

            $scope.updateConfigsCB = function(oldConfig,configuration){
                $scope.currentConfiguration = configuration;
                $scope.previousConfiguration = oldConfig;
                $element.find('#editConfig').removeClass('fade').addClass('show');
            };

            $scope.editConfigs = function(index,configuration,value){
                 $scope.currentConfiguration = configuration;
                 if(value){
                    $scope.currentConfiguration.value = value;
                 }
                $element.find('#editConfig').removeClass('fade').addClass('show');
            };


            function prepareSliders(type) {
                setTimeout(function () {
                    if (type == "FM") {
                        fmSlider = registerSlider("#slider11", {tooltip: 'always', tooltip_position: 'bottom'});
                        fmSlider.bootstrapSlider('setValue', obj.confidenceConfig[2].fmThreshold);
                        formatTooltip("#slider11", obj.confidenceConfig[2].fmThreshold);
                        // var s1 =  registerSlider("#hybrid-slider",{ tooltip: 'always',tooltip_position:'bottom'});
                        //          s1.bootstrapSlider('setValue', obj.confidenceConfig[2].wordCoverage);
                        //          formatTooltip("#slider1", obj.confidenceConfig[2].wordCoverage);
                        // s10 = registerSlider("#slider10", {tooltip: 'always', tooltip_position: 'bottom'});
                        // s10.bootstrapSlider('setValue', obj.confidenceConfig[2].minMatchVal);
                        // formatTooltip("#slider10", obj.confidenceConfig[2].minMatchVal);
                    } 
                    ///* there are no slider in FM so commented this section */
                    if (type == 'KC') {
                        //s5 = registerSlider("#slider5", {tooltip: 'always', tooltip_position: 'bottom'});
                        s6 = registerSlider("#slider6", {tooltip: 'always', tooltip_position: 'bottom'});
                        s7 = registerSlider("#slider7", {tooltip: 'always', tooltip_position: 'bottom'});
                        s8 = registerSlider("#slider8", {tooltip: 'always', tooltip_position: 'bottom'});
                        s9 = registerSlider("#slider9", {tooltip: 'always', tooltip_position: 'bottom'});
                        dualS = registerSlider("#dual-slider", {tooltip: 'always', tooltip_split: true, tooltip_position: 'bottom'});
                       // s5.bootstrapSlider('setValue', obj.confidenceConfig[1].exactMatchThreshold);
                        s6.bootstrapSlider('setValue', obj.confidenceConfig[1].suggestionsCount);
                        s7.bootstrapSlider('setValue', obj.confidenceConfig[1].taskMatchTolerance);
                        s8.bootstrapSlider('setValue', obj.confidenceConfig[1].pathCoverage);
                        s9.bootstrapSlider('setValue', obj.confidenceConfig[1].autoCorrPercentage);
                        //formatTooltip("#slider5", obj.confidenceConfig[1].exactMatchThreshold);
                        formatTooltip("#slider6", obj.confidenceConfig[1].suggestionsCount);
                        formatTooltip("#slider7", obj.confidenceConfig[1].taskMatchTolerance);
                        formatTooltip("#slider8", obj.confidenceConfig[1].pathCoverage);
                        formatTooltip("#slider9", obj.confidenceConfig[1].autoCorrPercentage);
                        var array = [];
                        array.push(Number(obj.confidenceConfig[1].minThreshold));
                        array.push(Number(obj.confidenceConfig[1].maxThreshold));
                        array.push(Number(obj.confidenceConfig[1].exactMatchThreshold));
                        dualS.bootstrapSlider('setValue', array);
                       // $timeout(function(){
                            var slider = $("#knowledgeCollectionThresholds").find("#triple-slider")[0];
                            noUiSlider.create(slider, {
                                start: [array[0], array[1], array[2]],
                                connect: [false, true, true, true],
                                tooltips: [wNumb({decimals: 0, suffix: '%'}), wNumb({decimals: 0, suffix: '%'}), wNumb({decimals: 0, suffix: '%'})],
                                range: {
                                    'min': [0],
                                    'max': [100]
                                }
                            });

                            var connect = slider.querySelectorAll('.noUi-connect');
                            var classes = ['c-1-color', 'c-2-color', 'c-3-color', 'c-4-color'];

                            for (var i = 0; i < connect.length; i++) {
                                connect[i].classList.add(classes[i]);
                            }
                        //},1500);


                        formatTooltip("#dual-slider", array);
                        if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs[1].longResponses) {
                            $scope.faqLong = $scope.selectedStream.confidenceConfigs[1].longResponses;
                            obj.confidenceConfig[1].longResponses = $scope.selectedStream.confidenceConfigs[1].longResponses;
                        }
                        if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs[1].searchInAnswer){
                                $scope.faqSearch = $scope.selectedStream.confidenceConfigs[1].searchInAnswer;
                                obj.confidenceConfig[1].searchInAnswer = $scope.selectedStream.confidenceConfigs[1].searchInAnswer;
                        }
                        
                    }
                    if (type == 'ML') {
                        s3 = registerSlider("#slider3", {tooltip: 'always', tooltip_position: 'bottom'});
                        s4 = registerSlider("#slider4", {tooltip: 'always', tooltip_position: 'bottom'});
                        nGram = registerSlider("#nGramSlider", {tooltip: 'always', tooltip_position: 'bottom'});
                        skipGramSeq = registerSlider("#skipGramSeq", {tooltip: 'always', tooltip_position: 'bottom'});
                        skipGramMax = registerSlider("#skipGramMax", {tooltip: 'always', tooltip_position: 'bottom'});
                        if(s3 && s4 && obj &&obj.confidenceConfig && obj.confidenceConfig[0]) {
                            s3.bootstrapSlider('setValue', obj.confidenceConfig[0].minThreshold);
                            s4.bootstrapSlider('setValue', obj.confidenceConfig[0].exactMatchThreshold);
                        }
                        if($scope.intentParams && $scope.intentParams.ngram && $scope.intentParams.ngram[1] && nGram) {
                            nGram.bootstrapSlider('setValue', $scope.intentParams.ngram[1]);
                            formatTooltip("#nGramSlider", $scope.intentParams.ngram[1]);
                            formatTooltip("#skipGramMax", $scope.intentParams.ngram[1]);
                            formatTooltip("#skipGramSeq", $scope.intentParams.ngram[1]);
                        }
                        if($scope.intentParams && $scope.intentParams.skip_gram && skipGramSeq) {
                            skipGramSeq.bootstrapSlider('setValue', ($scope.intentParams.skip_gram && $scope.intentParams.skip_gram.seqLength)?$scope.intentParams.skip_gram.seqLength:2);
                            skipGramMax.bootstrapSlider('setValue', ($scope.intentParams.skip_gram && $scope.intentParams.skip_gram.maxSkipDistance)?$scope.intentParams.skip_gram.maxSkipDistance:1);
                        }
                        formatTooltip("#slider3", obj.confidenceConfig[0].minThreshold);
                        formatTooltip("#slider4", obj.confidenceConfig[0].exactMatchThreshold);
                    }
                    if (type == 'RR') {
                        s2 = registerSlider("#slider2", {tooltip: 'always', tooltip_position: 'bottom'});
                        s2.bootstrapSlider('setValue', obj.confidenceConfig[3].taskMatchTolerance);
                        formatTooltip("#slider2", obj.confidenceConfig[3].taskMatchTolerance);
                        s11 = registerSlider('#matchScore-slider',{tooltip:'always',tooltip_position:'bottom'});
                        s11.bootstrapSlider('setValue', obj.confidenceConfig[3].minMatchVal);
                        formatTooltip("#matchScore-slider", obj.confidenceConfig[3].minMatchVal);
                    }
                    if(type == 'CM') {
                        s3 = registerSlider("#slider3CM", {tooltip: 'always', tooltip_position: 'bottom'});
                        s4 = registerSlider("#slider4CM", {tooltip: 'always', tooltip_position: 'bottom'});
                        nGram = registerSlider("#nGramSliderCM", {tooltip: 'always', tooltip_position: 'bottom'});
                        skipGramSeq = registerSlider("#skipGramSeqCM", {tooltip: 'always', tooltip_position: 'bottom'});
                        skipGramMax = registerSlider("#skipGramMaxCM", {tooltip: 'always', tooltip_position: 'bottom'});
                        formatTooltip("#slider3CM", obj.confidenceConfig[0].minThreshold);
                        formatTooltip("#slider4CM", obj.confidenceConfig[0].exactMatchThreshold);
                        formatTooltip("#nGramSliderCM", $scope.multipIntentModels.intentParams.ngram[1]);
                        formatTooltip("#skipGramMaxCM", $scope.multipIntentModels.intentParams.ngram[1]);
                        formatTooltip("#skipGramSeqCM", $scope.multipIntentModels.intentParams.ngram[1]);
                        nGram.bootstrapSlider('setValue', $scope.multipIntentModels.intentParams.ngram[1]);
                        skipGramSeq.bootstrapSlider('setValue', ($scope.multipIntentModels.intentParams.skip_gram && $scope.multipIntentModels.intentParams.skip_gram.seqLength)?$scope.multipIntentModels.intentParams.skip_gram.seqLength:2);
                        skipGramMax.bootstrapSlider('setValue', ($scope.multipIntentModels.intentParams.skip_gram && $scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance)?$scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance:1);
                        if($scope.multipIntentModels && $scope.multipIntentModels.selectedModel) {
                            s3.bootstrapSlider('setValue', $scope.multipIntentModels.selectedModel.minThreshold);
                            s4.bootstrapSlider('setValue', $scope.multipIntentModels.selectedModel.exactMatchThreshold);
                        }
                    }
                }, 100);
            }  

            var onSliderChanged=_.debounce(onSliderChangedProxy, 500);
            function onSliderChangedProxy(mode,val){
                $(".save-tip").show().text("Saving...");
                var currentEle = $(mode);
                switch(mode){
//                    case "#slider1":
//                        obj.confidenceConfig[2].wordCoverage = val;
//                        break;
                    case "#slider2":
                        obj.confidenceConfig[3].taskMatchTolerance = val;
                        break;
                    case "#slider3":
                        obj.confidenceConfig[0].minThreshold = val;
                        break;
                    case "#slider4":
                        obj.confidenceConfig[0].exactMatchThreshold = val;
                        break;
/*                    case "#slider5":
                        obj.confidenceConfig[1].exactMatchThreshold = val;
                        break;*/
                    case "#slider6":
                        obj.confidenceConfig[1].suggestionsCount = val;
                        break;
                    case "#slider7":
                        obj.confidenceConfig[1].taskMatchTolerance = val;
                        break;
                    case "#slider8":
                        obj.confidenceConfig[1].pathCoverage = val;
                        break;
                    case "#slider9":
                        obj.confidenceConfig[1].autoCorrPercentage = val;
                        break;
                    case "#slider10":
                        obj.confidenceConfig[2].minMatchVal = val;
                        break;
                    case "#nGramSlider":
                        $scope.intentParams.ngram[1]= val || 1;
                        delete $scope.intentParams.skip_gram;
                        break;
                     case "#skipGramSeq":
                        $scope.intentParams.skip_gram =  $scope.intentParams.skip_gram? $scope.intentParams.skip_gram:{};
                        $scope.intentParams.skip_gram.seqLength = val;
                        $scope.intentParams.skip_gram.maxSkipDistance = $scope.intentParams.skip_gram.maxSkipDistance?$scope.intentParams.skip_gram.maxSkipDistance:1;
                        delete $scope.intentParams.ngram;
                        delete $scope.intentParams.maxngram;
                        delete $scope.intentParams.minngram;
                        break;
                     case "#skipGramMax":
                        $scope.intentParams.skip_gram =  $scope.intentParams.skip_gram? $scope.intentParams.skip_gram:{};
                        $scope.intentParams.skip_gram.maxSkipDistance = val;
                        $scope.intentParams.skip_gram.seqLength = $scope.intentParams.skip_gram.seqLength?$scope.intentParams.skip_gram.seqLength:2;
                         delete $scope.intentParams.ngram;
                         delete $scope.intentParams.maxngram;
                         delete $scope.intentParams.minngram;
                        break;
                    case "#matchScore-slider":
                        obj.confidenceConfig[3].minMatchVal = val;
                        break;
                    case "#dual-slider":
                        obj.confidenceConfig[1].minThreshold = val[0];
                        obj.confidenceConfig[1].maxThreshold = val[1];
                        obj.confidenceConfig[1].exactMatchThreshold = val[2];
                        break;
                    case "#slider3CM":
                        obj.confidenceConfig[0].minThreshold = val;
                        break;
                    case "#slider4CM":
                        obj.confidenceConfig[0].exactMatchThreshold = val;
                        break;
                    case "#nGramSliderCM":
                        if(!$scope.multipIntentModels.intentParams.ngram || !$scope.multipIntentModels.intentParams.ngram.length) {
                            $scope.multipIntentModels.intentParams.ngram = [1,4];
                        }
                        $scope.multipIntentModels.intentParams.ngram[1]= val || 1;
                        delete $scope.multipIntentModels.intentParams.skip_gram;
                        break;
                    case "#skipGramSeqCM":
                        $scope.multipIntentModels.intentParams.skip_gram =  $scope.multipIntentModels.intentParams.skip_gram? $scope.multipIntentModels.intentParams.skip_gram:{};
                        $scope.multipIntentModels.intentParams.skip_gram.seqLength = val;
                        $scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance = $scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance?$scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance:1;
                        delete $scope.multipIntentModels.intentParams.ngram;
                        delete $scope.multipIntentModels.intentParams.maxngram;
                        delete $scope.multipIntentModels.intentParams.minngram;
                        break;
                    case "#skipGramMaxCM":
                        $scope.multipIntentModels.intentParams.skip_gram =  $scope.multipIntentModels.intentParams.skip_gram? $scope.multipIntentModels.intentParams.skip_gram:{};
                        $scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance = val;
                        $scope.multipIntentModels.intentParams.skip_gram.seqLength = $scope.multipIntentModels.intentParams.skip_gram.seqLength?$scope.multipIntentModels.intentParams.skip_gram.seqLength:2;
                         delete $scope.multipIntentModels.intentParams.ngram;
                         delete $scope.multipIntentModels.intentParams.maxngram;
                         delete $scope.multipIntentModels.intentParams.minngram;
                        break;
                    case "#slider11":
                        obj.confidenceConfig[2].fmThreshold = val;
                        break;
                }
                if(mode === "#nGramSlider" || mode==="#skipGramSeq" || mode==="#skipGramMax"){
                    $scope.payload.intentParams = $scope.intentParams;
                   saveMLSynonymSetting(null,false,null,null,$scope.intentParams.features);
                }else if(currentEle.hasClass('custom-configuration')){
                   $scope.proceedEditConfig(currentEle.scope().config,'',val);
                } else{
                    if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                        return;
                    }
                    formatTooltip(mode,val);
                    doServiceCalls(obj);
                }
            }
            
            $scope.saveGram = function(feature){
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    if(feature === 'n_gramCM'){
                        $scope.multipIntentModels.intentParams.ngram[1]= $scope.multipIntentModels.intentParams.ngram && $scope.multipIntentModels.intentParams.ngram.length?$scope.multipIntentModels.intentParams.ngram[1]:1;
                        delete $scope.multipIntentModels.intentParams.skip_gram;
                    } else if(feature === 'skip_gramCM') {
                        $scope.multipIntentModels.intentParams.skip_gram =  $scope.multipIntentModels.intentParams.skip_gram? $scope.multipIntentModels.intentParams.skip_gram:{};
                        $scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance = $scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance?$scope.multipIntentModels.intentParams.skip_gram.maxSkipDistance:1;
                        $scope.multipIntentModels.intentParams.skip_gram.seqLength = $scope.multipIntentModels.intentParams.skip_gram.seqLength?$scope.multipIntentModels.intentParams.skip_gram.seqLength:2;
                         delete $scope.multipIntentModels.intentParams.ngram;
                         delete $scope.multipIntentModels.intentParams.maxngram;
                         delete $scope.multipIntentModels.intentParams.minngram;
                    }
                    return;
                }
                if(feature === 'n_gram'){
                     $scope.intentParams.ngram[1]= $scope.intentParams.ngram && $scope.intentParams.ngram.length?$scope.intentParams.ngram[1]:1;
                    delete $scope.intentParams.skip_gram;
                }else if(feature === 'skip_gram'){
                    $scope.intentParams.skip_gram =  $scope.intentParams.skip_gram? $scope.intentParams.skip_gram:{};
                    $scope.intentParams.skip_gram.maxSkipDistance = $scope.intentParams.skip_gram.maxSkipDistance?$scope.intentParams.skip_gram.maxSkipDistance:1;
                    $scope.intentParams.skip_gram.seqLength = $scope.intentParams.skip_gram.seqLength?$scope.intentParams.skip_gram.seqLength:2;
                     delete $scope.intentParams.ngram;
                     delete $scope.intentParams.maxngram;
                     delete $scope.intentParams.minngram;
                }
                $scope.payload.intentParams = $scope.intentParams;
                saveMLSynonymSetting(null,false,null,null,feature);
            };

            $scope.saveToggleSwitch = function(_trainOntology) {
                $timeout(function(){
                    obj.confidenceConfig[1].autoSpellCorrectEnabled = $scope.kgCollection.autoCorrect;
                    obj.confidenceConfig[1].useBotSynonyms = $scope.kgCollection.useBotSynonyms;
                    obj.confidenceConfig[1].enPatternLemma  = $scope.kgCollection.enPatternLemma;
                    doServiceCalls(obj,_trainOntology);
                },250);
            };

            $scope.showRestore = function(){
                 if($scope.selectedStream.confidenceConfigs[3] && $scope.selectedStream.confidenceConfigs[3].rankingParameters){
                    var compareValue = _.isEqual($scope.rankResolveEngine.rankingParameters,$scope.defaultRankingParameters);
                    if(!compareValue){
                       $scope.hideRestore = false;
                    }else{
                        $scope.hideRestore = true;
                    }
                }
            };
         
            $scope.editConfigurations = function(){
                if($scope.selectedStream.confidenceConfigs[3] && $scope.selectedStream.confidenceConfigs[3].rankingParameters){
                    $scope.rankResolveEngine.rankingParameters = $scope.selectedStream.confidenceConfigs[3].rankingParameters;
                    $scope.showRestore();
                }else{
                    //fetchDefaultParams(false);
                    $scope.rankResolveEngine.rankingParameters = {};
                    $scope.hideRestore = false;
                }
                $timeout(function(){
                    $scope.openModalSlider('#editConfigurations');
                });
                
            };

            $scope.closeEditConfig = function(config){
                $scope.closeModalSlider('#editConfigurations');
            };

            $scope.updateConfig = function(){
                obj.confidenceConfig[3].rankingParameters = $scope.rankResolveEngine.rankingParameters;
                doServiceCalls(obj,false);
            };

            $scope.compareJson = function(){
                if($scope.rankResolveEngine && $scope.rankResolveEngine.rankingParameters){
                    var compareValue = _.isEqual($scope.rankResolveEngine.rankingParameters,$scope.defaultRankingParameters);
                    if(!compareValue){
                        $element.find('#restoreModal').removeClass('fade').addClass('show');
                    }
                }
            };

            $scope.closeRestoreModal = function(){
                $element.find('#restoreModal').removeClass('show').addClass('fade');
            };

            $scope.proceedConfiguration = function(){
                $element.find('#restoreModal').removeClass('show').addClass('fade');
                fetchDefaultParams(false);
            };

            $scope.intentDetectChange = function() {
                // $scope.intentDetect.value = !$scope.intentDetect.value;
                obj.confidenceConfig[2].labelMatch = $scope.intentDetect.value;
                doServiceCalls(obj, false);
            };
            $scope.fmThresholdChange = function() {
                obj.confidenceConfig[2].fmThreshold = obj.confidenceConfig[2].fmThreshold || 2;
                obj.confidenceConfig[2].isFMThreshold = $scope.intentDetect.isFMThreshold;
                doServiceCalls(obj, false);
                checkFMSettingCount();
            };

            function fetchDefaultParams(serviceCall){
                var contextUrl = window.appConfig.CONTEXT_PATH;
                $http.get(contextUrl+restoreConfigurationPath[$scope.currLang.langVal]).then(function(response){
                    $scope.rankResolveEngine.rankingParameters = response.data;
                    $scope.defaultRankingParameters = angular.copy($scope.rankResolveEngine.rankingParameters);
                    obj.confidenceConfig[3].rankingParameters = response.data;
                    if(serviceCall){
                        doServiceCalls(obj,false);
                    }
                    
                });
            }
            // if($scope.selectedStream && $scope.selectedStream.confidenceConfigs[3] && $scope.selectedStream.confidenceConfigs[3].useDependencyParser){
            //     fetchDefaultParams(false);
            // }
            $scope.preferDefinitiveShowMore = function() {
                $scope.preferDefinitiveDescLimit = $scope.preferDefinitiveDesc.length;
            };           
            $scope.RREngineChange = function(type) {
                if(type === 'isPreferDefinitiveMatch') {
                    obj.confidenceConfig[3].isPreferDefinitiveMatch = $scope.rankResolveEngine.isPreferDefinitiveMatch;
                    doServiceCalls(obj,false);
                } else if(type === 'intentRescoring') {
                    obj.confidenceConfig[3].intentRescoring = $scope.rankResolveEngine.intentRescoring;
                    doServiceCalls(obj,false);
                }
                checkRRSettingCount();
            };

            $scope.showEnableModal = function(){
                if(!$scope.rankResolveEngine.useDependencyParser){
                    $element.find('#enableModal').removeClass('fade').addClass('show');
                }else{
                    $scope.rankResolveEngine.useDependencyParser = false;
                    obj.confidenceConfig[3].useDependencyParser = $scope.rankResolveEngine.useDependencyParser;
                    $scope.resetDefaultVal('#matchScore-slider');
                    delete obj.confidenceConfig[3].minMatchVal;
                    delete obj.confidenceConfig[3].rankingParameters;
                    doServiceCalls(obj,false);
                }
                checkRRSettingCount();
            };

            $scope.closeEnableModal = function(){
                $scope.rankResolveEngine.useDependencyParser = false;
                $element.find('#enableModal').removeClass('show').addClass('fade');
            };

            $scope.enableDependency = function(){
                 $scope.rankResolveEngine.useDependencyParser = !$scope.rankResolveEngine.useDependencyParser;
                 $element.find('#enableModal').removeClass('show').addClass('fade');
                 obj.confidenceConfig[3].useDependencyParser = $scope.rankResolveEngine.useDependencyParser;
                 obj.confidenceConfig[3].minMatchVal = minMatchVal;
                 obj.confidenceConfig[3].rankingParameters = {};
                 doServiceCalls(obj,false);
                 //fetchDefaultParams(true);
                 
            };

            $scope.createConfiguration = function(){
                $scope.showEmptyConfig = false;
                $scope.showEmptyConfigCM = false;
            };


            var addConfigurationCall = function(_payload,configuration,previousConfiguration, model){
                $scope.parentRelationError = false;
                BTStreamsService.addConfiguration($scope.selectedStream._id,_payload).then(function(response){
                if(response && response.data){
                  configuration['_id'] = response.data._id;
                  configuration['requiresTraining'] = response.data.requiresTraining;
                  if(!configuration.isCustom){
                    $scope.savedConfigurations.push(configuration);
                  }
                   if(configuration['requiresTraining'] && configuration.nlpEngine === 'ML' && (configuration.configurationKeyName !== "kfold")) {
                        $scope.trainShow = true;
                   }
                   if(configuration['requiresTraining'] && configuration.nlpEngine === 'KG'){
                        $scope.trainBotOntology();
                   }
                   originalCopy = angular.copy($scope.savedConfigurations);
                   $workflowService.savedConfigurationsList(originalCopy);
                    if(configuration.uiComponent === 'slider'){
                        setTimeout(function(){
                             advancedConfigSlider(configuration);
                             advancedConfigSliderCM(configuration);
                        },200);
                    }
                    checkNetworkType();
                    $scope.totalConfigCount = originalCopy.length;
                    if(model === 'ml') {
                        finishSaving('.ml-savingStatus');
                    } else {
                        finishSaving('.savingStatus');
                    }
                    NotificationService.notify(i18n.i18nString('settings_saved'),'success');
                    _.remove($scope.uiConfiguration,{'_id':response.data._id});
                    $scope.search = {};
                    if(previousConfiguration){
                          BTStreamsService.deleteConfiguration($scope.selectedStream._id,previousConfiguration._id).then(function(response){
                              _.remove($scope.savedConfigurations,{'_id':previousConfiguration._id});
                                     deRegisterCustomSliders();
                                     $scope.uiConfiguration.push(previousConfiguration);
                                     originalCopy = angular.copy($scope.savedConfigurations);
                                     $workflowService.savedConfigurationsList(originalCopy);
                                     $timeout(function(){
                                        $scope.registerCustomSliders();
                                    });
                                    $scope.totalConfigCount = originalCopy.length;
                                    autoTrainStatus();
                   });
                    }

                }
            },function(err){
                 if(err && err.data && err.data.errors){
                        if(err.data.errors[0].msg === 'The required parent configuration for this child configuration is not configured.'){
                            $scope.parentRelationError = true;
                            // err.data.errors[0].msg = "Configuration cannot be added";
                        }
                        NotificationService.notify(err.data.errors[0].msg,'error');
                    }else{
                        NotificationService.notify(i18n.i18nString('some_thing_wrong_label'),'error');
                    }
                    $scope.search = {};
                    if(model === 'ml') {
                        stopSaving('.ml-savingStatus');
                    } else {
                        stopSaving('.savingStatus');
                    }
            });
            };

            var prepareSavedConfigurations = function(savedConfigurations){
                angular.forEach(savedConfigurations,function(config){
                    var configData = serverConfigOb[config.configurationKeyName];
                    _.remove($scope.uiConfiguration,{'configurationKeyName':config.configurationKeyName});
                    if(configData){
                        config['uiComponent'] = configData.uiComponent;
                        config['configurationName'] = configData.configurationName;
                        config['class'] = mapClass[configData.nlpEngine];
                        config['value'] = config.hasOwnProperty('configurationValue')?config.configurationValue:configData.value;
                        config['defaultValue'] = configData.defaultValue;
                        config['requiresTraining'] = configData.requiresTraining;
                        if(configData.uiComponent === 'slider'){
                            config['range'] = configData.range;
                            config['interval'] = configData.interval;
                        }
                        if(configData.uiComponent === 'dropdown'){
                            config['range'] = configData.range;
                        }
                    }else if(config.isCustom){
                        config['value'] = config.configurationValue;
                    }
                   
                });
                var networkIndex = savedConfigurations.findIndex(function(item) {
                    return item.configurationKeyName === 'network';             
                });
                if(networkIndex !== -1) {
                    $scope.networkTypeList = savedConfigurations[networkIndex];
                    savedConfigurations.splice(networkIndex, 1);
                }
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    $scope.savedConfigurationsCM = savedConfigurations;
                } else {
                    $scope.savedConfigurations = savedConfigurations;
                    originalCopy = angular.copy($scope.savedConfigurations);
                    $workflowService.savedConfigurationsList(originalCopy);    
                }               
            };
            // remove 'network' data from original copy
            function checkNetworkType() {
                var index;
                if($scope.savedConfigurations && $scope.savedConfigurations.length) {
                    index = $scope.savedConfigurations.findIndex(function(item) {
                        return item.configurationKeyName === 'network';
                    });
                    if(index !== -1) {
                        $scope.savedConfigurations.splice(index, 1);
                    }
                    if($scope.intentParams && ($scope.intentParams.type !== 'V3' && $scope.intentParams.type !== 'V4' && $scope.intentParams.type !== 'V5')) {
                        index = $scope.savedConfigurations.findIndex(function(item) {
                            return item.configurationKeyName === 'Multiple_Intent_Models';
                        });
                        if(index !== -1) {
                            $scope.savedConfigurations.splice(index, 1);
                        }
                    }
                }
                if(originalCopy && originalCopy.length) {
                    index = originalCopy.findIndex(function(item) {
                        return item.configurationKeyName === 'network';
                    });
                    if(index !== -1) {
                        originalCopy.splice(index, 1);
                    }
                    if($scope.intentParams && ($scope.intentParams.type !== 'V3' && $scope.intentParams.type !== 'V4' && $scope.intentParams.type !== 'V5')) {
                        index = $scope.originalCopy.findIndex(function(item) {
                            return item.configurationKeyName === 'Multiple_Intent_Models';
                        });
                        if(index !== -1) {
                            $scope.originalCopy.splice(index, 1);
                        }
                    }
                }
                if($scope.uiConfiguration && $scope.uiConfiguration.length) {
                    index = $scope.uiConfiguration.findIndex(function(item) {
                        return item.configurationKeyName === 'network';
                    });
                    if(index !== -1) {
                        $scope.uiConfiguration.splice(index, 1);
                    }
                    if($scope.intentParams && ($scope.intentParams.type !== 'V3' && $scope.intentParams.type !== 'V4' && $scope.intentParams.type !== 'V5')) {
                        index = $scope.uiConfiguration.findIndex(function(item) {
                            return item.configurationKeyName === 'Multiple_Intent_Models';
                        });
                        if(index !== -1) {
                            $scope.uiConfiguration.splice(index, 1);
                        }
                    }
                }
                checkMultipIntentModel();
            }
            var advancedConfigSlider = function(configData){
                        customSlider = configData.configurationKeyName;
                        customSlider = registerSlider("#"+configData.configurationKeyName, {tooltip: 'always', tooltip_position: 'bottom'});
                        customSlider.bootstrapSlider('setValue', configData.value);
                        $("#"+configData.configurationKeyName+'Slider').find(".tooltip-inner").text(configData.value);
            };
            var advancedConfigSliderCM = function(configData){
                customSlider = configData.configurationKeyName;
                customSlider = registerSlider("#"+configData.configurationKeyName + "CM", {tooltip: 'always', tooltip_position: 'bottom'});
                customSlider.bootstrapSlider('setValue', configData.value);
                $("#"+configData.configurationKeyName+'SliderCM').find(".tooltip-inner").text(configData.value);
            };

            var startSaving = function(className){
               if(className === '.ml-savingStatus') {
                $scope.refreshStatus2 = "refresh-spin";
               } else {
                $scope.refreshStatus = "refresh-spin";
               }
            };

           var stopSaving = function(className){
                if(className === '.ml-savingStatus') {
                    $scope.refreshStatus2 = '';
                    $timeout(function () {
                       $scope.refreshStatus2 = "times";
                       resetStatus();
                   }, 500);
                } else {
                    $scope.refreshStatus = '';
                    $timeout(function () {
                       $scope.refreshStatus = "times";
                       resetStatus();
                   }, 500);
                }
            };

            var resetStatus = function(){
                $timeout(function(){
                        $scope.refreshStatus = '';
                        $scope.refreshStatus2 = '';
                },2000);
            };

            var finishSaving = function(className){
                if(className === '.ml-savingStatus') {
                    $scope.refreshStatus2 = '';
                    $timeout(function () {
                       $scope.refreshStatus2 = "check";
                       resetStatus();
                    }, 500);
                } else {
                    $scope.refreshStatus = '';
                    $timeout(function () {
                       $scope.refreshStatus = "check";
                       resetStatus();
                    }, 500);
                }
            };
           $scope.addConfiguration = function(configuration,index,previousConfiguration){
            var _payload = {
                "configurationKeyName":configuration.configurationKeyName,
                "nlpEngine" : configuration.nlpEngine,
                "configurationValue" : configuration.value

            };
            if(configuration.isCustom){
                _payload['isCustom'] = configuration.isCustom;
            }
            startSaving('.savingStatus');
            addConfigurationCall(_payload,configuration,previousConfiguration);
        };
        $scope.addConfigurationCM = function(configuration,index,previousConfiguration){
            var _payload = {
                "configurationKeyName":configuration.configurationKeyName,
                "nlpEngine" : configuration.nlpEngine,
                "configurationValue" : configuration.value
            };
            if(configuration.isCustom){
                _payload['isCustom'] = configuration.isCustom;
            }
            if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                // configuration.configurationValue = false;
                if (!$scope.savedConfigurationsCM.some(function(entry) { return entry.configurationKeyName === configuration.configurationKeyName;})) {
                // if($scope.savedConfigurationsCM.indexOf(configuration) !== -1) {
                    $scope.savedConfigurationsCM.push(configuration);
                }
                if(configuration.uiComponent === 'slider'){
                    setTimeout(function(){
                         advancedConfigSliderCM(configuration);
                    },200);
                }
                return;
            }
        };
        // Network type change
        $scope.addNetworkTypeConfig = function(configuration, type){
            function confirm(){
                $scope.networkTypeList.value = type;
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    return;
                }
                resetDefaultIntentParams(); // reset to default 
                if(configuration && configuration._id) {
                    $scope.proceedEditConfig(configuration,'',type, 'ml');
                } else {
                   var _payload = {
                        "configurationKeyName":configuration.configurationKeyName,
                        "nlpEngine" : configuration.nlpEngine,
                        "configurationValue" : configuration.value
                    };
                    addConfigurationCall(_payload,configuration, 'ml');
                }
            }
            function cancel(){
               return;
            }
            var knowmoreLink = '<a href="https://developer.kore.ai/docs/bots/nlp/advanced-nlp-configurations/#Network_Type" target="_blank">know more</a>';
            var _msg = "Some of the ML Configurations may not be applicable for the '"+ type +"' and changing the Network Type would result in disabling such configuration. " + knowmoreLink;
            NotificationService.userConfirm( _msg, [confirm, cancel], {okText:  i18n.i18nString('confirm'),addHtmlContent:true,btnClass:"redBtn"}, "", undefined,  i18n.i18nString('confirm_proceed')); 
        };
        // reset default intent Params values
        function resetDefaultIntentParams() {
            if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                $scope.multipIntentModels.intentParams.minngram = 1;
                $scope.multipIntentModels.intentParams.maxngram = 4;
                $scope.multipIntentModels.intentParams.ngram = [1,1];
                $scope.multipIntentModels.intentParams.useSynonyms = false;
                $scope.multipIntentModels.intentParams.f_negation = false;
                $scope.multipIntentModels.intentParams.useStopwords = false;
                $scope.multipIntentModels.intentParams.usePlaceholders = false;
                $scope.multipIntentModels.intentParams.features = "n_gram";
                $scope.multipIntentModels.intentParams.skip_gram = {"seqLength": 2,"maxSkipDistance": 1};
                $scope.resetDefaultVal();
                $scope.resetNgram();
            } else {
                $scope.intentParams.minngram = 1;
                $scope.intentParams.maxngram = 4;
                $scope.intentParams.ngram = [1,1];
                $scope.intentParams.useSynonyms = false;
                $scope.intentParams.f_negation = false;
                $scope.intentParams.useStopwords = false;
                $scope.intentParams.usePlaceholders = false;
                $scope.intentParams.features = "n_gram";
                $scope.intentParams.skip_gram = {"seqLength": 2,"maxSkipDistance": 1};
                // $scope.resetDefaultVal();
                // $scope.resetNgram();
            }
        }
        // check FM engine config setting count
        function checkFMSettingCount() {
            if($scope.intentDetect.isFMThreshold) {
                $scope.fmSettingsCount = 2;
            } else {
                $scope.fmSettingsCount = 2;
            }
            if(!($scope.currLang.langVal === 'en' || $scope.currLang.langVal === 'de' || $scope.currLang.langVal === 'es' || $scope.currLang.langVal === 'fr')) {
                $scope.fmSettingsCount = 1;
            }
        }
        // check ML config setting count
        function checkMLSettingCount(config) {
            if($scope.multipIntentModels.configurationValue===true) { // if Multiple intent model is enabled
                $scope.mlSettingsCount = 8;
                return;
            }
            if($scope.intentParams.type==='SGD_V2') {
                $scope.mlSettingsCount = 2;
                return;
            }
            if(config === 'Standard') {
                $scope.mlSettingsCount = 8;
            } else if(config === 'MLP-BOW') {
                $scope.mlSettingsCount = 8;
            }else if(config === 'MLP-WordEmbeddings') {
                $scope.mlSettingsCount = 7;
            }else if(config === 'LSTM') {
                $scope.mlSettingsCount = 7;
            }else if(config === 'CNN') {
                $scope.mlSettingsCount = 7;
            } else if(config === 'Transformer') {
                $scope.mlSettingsCount = 4;
            } else {
                $scope.mlSettingsCount = 8;
            }

        }

        // check RR engine config setting count
        function checkRRSettingCount() {
            if($scope.rankResolveEngine.intentRescoring) {
                $scope.RRSettingsCount = 2;
            } else {
                $scope.RRSettingsCount = 2;
            }
            if($scope.currLang.langVal === 'de' || $scope.currLang.langVal === 'fr') {
                $scope.RRSettingsCount = $scope.RRSettingsCount + 1;
                if($scope.rankResolveEngine.useDependencyParser) {
                    $scope.RRSettingsCount = $scope.RRSettingsCount + 2;
                }
            }
        }

            $scope.deleteConfiguration = function(index,configuration){
                        $scope.currentIndex = index;
                        $scope.currentConfiguration = configuration;
                        if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                            $element.find('#deleteConfig').removeClass('fade').addClass('show');
                            return;                            
                        }
                        if(configuration._id){
                            $element.find('#deleteConfig').removeClass('fade').addClass('show');
                        }else{
                            $scope.savedConfigurations.splice(index,1);
                            $scope.invalidPattern = false;
                            $scope.invalidCustomValue = false;
                            autoTrainStatus();
                        }
                        
            };

            $scope.closeDeleteConfig = function(){
                $element.find('#deleteConfig').removeClass('show').addClass('fade');
            };

            $scope.closeEditConfigCustom = function(config){
                $element.find('#editConfig').removeClass('show').addClass('fade');
                if(config){
                    var res = _.find(originalCopy,{'_id':config._id});
                    config.value = res.value;
                    if(res.isCustom){
                        config.configurationKeyName = res.configurationKeyName;
                    }
                    if(config.uiComponent === 'slider'){
                        $("#"+config.configurationKeyName+'Slider').find(".tooltip-inner").text(res.value);
                    }
                }
                
            };

            var validateConfigKeyPattern = function(config){
                var lists = config.configurationKeyName.split('_');
                if(lists && lists.length > 1){
                    var value = lists[0].toString().toLowerCase();
                    if(engineList.indexOf(value) !== -1 && lists[1].length){
                        config.nlpEngine = mapEngines[value];
                        return true;   
                    }else{
                        return false;
                    }
                    
                }else{
                    return false;
                }
            };

            $scope.addCustomValue = function(e,config,form){
                if(e && e.keyCode === 13 && config.configurationKeyName && config.configurationKeyName !== undefined && config.value && config.value !== undefined && config.configurationKeyName.length && config.value.length){
                     $scope.invalidCustomKey = false;
                     $scope.invalidCustomValue = false;
                     config.invalidCustomKey = false;
                     config.invalidCustomValue = false;
                     var foundPattern = validateConfigKeyPattern(config);
                     if(foundPattern){
                        $scope.invalidPattern = false;
                        config.invalidPattern = false;
                         var _payload = {
                            "configurationKeyName":config.configurationKeyName,
                            "nlpEngine" : config.nlpEngine,
                            "configurationValue" : config.value, 
                            "isCustom" : true

                        };
                        startSaving('.savingStatus');
                        if(!config._id){
                            addConfigurationCall(_payload,config);
                        }else if(config._id){
                            var previousConfiguration = _.find(originalCopy,{'_id':config._id});
                            if( (config.configurationKeyName.toLowerCase() !== previousConfiguration.configurationKeyName.toLowerCase())){
                                 $scope.currentConfiguration = config;
                                 $scope.previousConfiguration = angular.copy(previousConfiguration);
                                 $element.find('#editConfig').removeClass('fade').addClass('show');
                            }else{
                                $scope.proceedEditConfig(config);
                            }
                        }
                       
                        
                    }else{
                        $scope.invalidPattern = true;
                        config.invalidPattern = true;
                    }
                    
                }else if((config.configurationKeyName && !config.configurationKeyName.length) && (config.value && !config.value.length)){
                    $scope.invalidCustomValue = true;
                     $scope.invalidCustomKey = true;
                     config.invalidCustomValue = true;
                     config.invalidCustomKey = true;
                }
                else if(config.configurationKeyName  && !config.configurationKeyName.length){
                    $scope.invalidCustomKey = true;
                    config.invalidCustomKey = true;
                }else if((config.value && !config.value.length)){
                    $scope.invalidCustomValue = true;
                    config.invalidCustomValue = true;
                }
            };

            $scope.addCustomKey = function(e,config,form){
                     if(config.configurationKeyName && config.configurationKeyName !== undefined  && config.configurationKeyName.length){
                        var foundPattern = validateConfigKeyPattern(config);
                         if(foundPattern){
                            config.invalidPattern = false;
                             $scope.invalidPattern = false;
                             if(config._id && e.keyCode === 13){
                                $scope.currentConfiguration = config;
                                var previousConfiguration = _.find(originalCopy,{_id:config._id});
                                $scope.previousConfiguration = angular.copy(previousConfiguration);
                                if($scope.currentConfiguration.configurationKeyName.toLowerCase() !== $scope.previousConfiguration.configurationKeyName.toLowerCase()){
                                    $element.find('#editConfig').removeClass('fade').addClass('show');
                                }
                                
                             }
                         }else{
                            $scope.invalidPattern = true;
                            config.invalidPattern = true;
                         }
                     }else{
                        $scope.invalidPattern = true;
                        config.invalidPattern = true;
                     }
                     
                
            };

            $scope.proceedDeleteConfig = function(index,configuration){
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    $scope.savedConfigurationsCM.splice(index, 1);
                    deRegisterCustomSliders();
                    $timeout(function(){
                        $scope.registerCustomSliders();
                        clearSliders('ML');
                        prepareSliders('ML');
                        $scope.closeDeleteConfig();
                        if(!$scope.savedConfigurationsCM.length){
                            $scope.showEmptyConfigCM = true;
                        }
                    });
                    if(configuration && configuration['requiresTraining'] && configuration.nlpEngine === 'ML'){
                        $scope.trainShow = true;
                    }
                    return;
                }
                startSaving('.savingStatus');
                BTStreamsService.deleteConfiguration($scope.selectedStream._id,configuration._id).then(function(response){
                    configuration.value = configuration.defaultValue;
                    if(configuration && configuration['requiresTraining'] && configuration.nlpEngine === 'ML'){
                         $scope.trainShow = true;
                    }
                    if(configuration && configuration['requiresTraining'] && configuration.nlpEngine === 'KG'){
                        $scope.trainBotOntology();
                    }
                    $scope.savedConfigurations.splice(index,1);
                    if(!$scope.savedConfigurations.length){
                        $scope.showEmptyConfig = true;
                    }
                    $scope.uiConfiguration.push(configuration);
                    $scope.closeDeleteConfig();
                    deRegisterCustomSliders();
                    originalCopy = angular.copy($scope.savedConfigurations);
                    checkNetworkType();
                    $scope.totalConfigCount = originalCopy.length;
                    $workflowService.savedConfigurationsList(originalCopy);
                    finishSaving('.savingStatus');
                    NotificationService.notify('Settings deleted successfully','success');
                    $timeout(function(){
                        $scope.registerCustomSliders();
                        clearSliders('ML');
                        prepareSliders('ML');
                    });
                },function(err){
                     if(err && err.data && err.data.errors){
                        NotificationService.notify(err.data.errors[0].msg,'error');
                    }else{
                        NotificationService.notify(i18n.i18nString('some_thing_wrong_label'),'error');
                    }
                    stopSaving('.savingStatus');
                });
            };
            $scope.proceedDeleteConfigCM = function(index,configuration){
                if($scope.multipIntentModels.configurationValue) {
                    $scope.savedConfigurationsCM.splice(index, 1);
                    deRegisterCustomSliders();
                    $timeout(function(){
                        $scope.registerCustomSliders();
                        clearSliders('ML');
                        prepareSliders('ML');
                        $scope.closeDeleteConfig();
                    });
                    return;
                }
            };

            $scope.proceedEditConfig = function(configuration,previousConfiguration,value, model){
                if(value){
                    configuration.value = value;
                }
                if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                    var findIndex = $scope.savedConfigurationsCM.findIndex(function(item) {
                        return item.configurationKeyName === previousConfiguration.configurationKeyName;
                    });
                    if(findIndex !== -1) {
                        $scope.savedConfigurationsCM[findIndex] = configuration;
                    }
                    deRegisterCustomSlidersCM();
                    $timeout(function(){
                        $scope.registerCustomSliders();
                    });
                    $scope.closeEditConfigCustom();
                    return;
                }
                if(previousConfiguration){
                    if(configuration.isCustom){
                        configuration.isEditCustom = true;
                     }
                     $scope.addConfiguration(configuration,null,previousConfiguration);
                     $scope.closeEditConfigCustom(); 
                }
                if(!previousConfiguration && configuration && configuration.configurationKeyName === "Multiple_Intent_Models") {
                    if(configuration.value) {
                        $scope.openEnableMultiIntents();
                    } else if(!configuration.value) {
                        $scope.openDisableMultiIntents();
                    }
                    $scope.loadConfiguration = configuration;
                    if(configuration['requiresTraining'] && configuration.nlpEngine === 'ML' && (configuration.configurationKeyName !== "kfold")) {
                        $scope.trainShow = true;
                    }
                    return ;
                }
                if(configuration && configuration._id) { // Edit config
                    editConfigurations(configuration,previousConfiguration,value, model);
                }
            };
            $scope.proceedEditConfigCM = function(configuration,previousConfiguration,value, model){
                if(value){
                    configuration.value = value;
                }
                // if(previousConfiguration){
                //     if(configuration.isCustom){
                //         configuration.isEditCustom = true;
                //      }
                //      $scope.addConfiguration(configuration,null,previousConfiguration);
                //      $scope.closeEditConfigCustom(); 
                // }
            };
            function editConfigurations(configuration,previousConfiguration,value, model) {
                var _payload = {};
                if(!previousConfiguration){
                _payload = {
                    "configurationValue":configuration.value
                };
                if(model === 'ml') {
                    startSaving('.ml-savingStatus');                    
                } else {
                    startSaving('.savingStatus');
                }
                }
                BTStreamsService.editConfigurations($scope.selectedStream._id,configuration._id,_payload).then(function(response){
                    if(response && response.data){
                        $scope.closeEditConfigCustom();
                        if(configuration['requiresTraining'] && configuration.nlpEngine === 'ML' && (configuration.configurationKeyName !== "kfold")) {
                                $scope.trainShow = true;
                        }
                        if(configuration['requiresTraining'] && configuration.nlpEngine === 'KG'){
                            $scope.trainBotOntology();
                        }
                        NotificationService.notify(i18n.i18nString('settings_saved'),'success');
                        if(model === 'ml') {
                            finishSaving('.ml-savingStatus');                 
                        } else {
                            finishSaving('.savingStatus');
                        }
                        if(response.data && response.data.configurationKeyName === "Multiple_Intent_Models") {
                            getMLParams();
                        }
                        autoTrainStatus();
                    }
                },function(err){
                     if(err && err.data && err.data.errors){
                        NotificationService.notify(err.data.errors[0].msg,'error');
                    }else{
                        NotificationService.notify(i18n.i18nString('some_thing_wrong_label'),'error');
                    }
                    if(model === 'ml') {
                        stopSaving('.ml-savingStatus');                 
                    } else {
                        stopSaving('.savingStatus');
                    }
                    
                });
            }

            var checkForSearchInAnsw = function(){
                var currentLang = $workflowService.currentLanguage();
                if(searchInAnsLang.indexOf(currentLang) >= 0){
                    $scope.showSearchInAns = true;
                }else{
                    $scope.showSearchInAns = false;
                }
            };

            function doServiceCalls(obj,_trainOntology) {
                if(($scope.currLang.langVal !== 'en') && ($scope.currLang.langVal !== 'de') && ($scope.currLang.langVal !== 'es') && ($scope.currLang.langVal !== 'fr')) {
                    delete obj.confidenceConfig[2].fmThreshold; // delete FM options in lang specific
                    delete obj.confidenceConfig[2].isFMThreshold;
                }
                BTStreamsService.updateThresholds($workflowService.selectedStream()._id, obj)
                        .then(function (res) {
                            //$scope.trainShow = true;
                            $(".save-tip").addClass("fa fa-check").show().text("saved...");
                            $timeout(function () {
                                $(".save-tip").removeClass("fa fa-check").hide().text("saving...");
                            },5000);
                            $scope.selectedStream.confidenceConfigs = res.data.confidenceConfigs;
                            if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs[1].longResponses){
                                $scope.faqLong = $scope.selectedStream.confidenceConfigs[1].longResponses;
                            }
                            if($scope.selectedStream.confidenceConfigs && $scope.selectedStream.confidenceConfigs[1].searchInAnswer){
                                $scope.faqSearch = $scope.selectedStream.confidenceConfigs[1].searchInAnswer;
                            }
                            if(_trainOntology && $scope.knowledgeTask._id) {
                                $scope.trainBotOntology();
                            }
                            _trainOntology = false;
                            $workflowService.selectedStream($scope.selectedStream, res.data);
                            $("#noty_center_layout_container").empty();
                            // if($scope.currentSlider || mode){  //ideally network call success api always should show notification  need to verify why this condition is added //
                                NotificationService.notify( i18n.i18nString('settings_saved_sucessfully'), "success");
                            // }
                        }, function (err) {
                            if(err.data && err.data && err.data.errors[0] && err.data.errors[0].msg){
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            }else{
                                NotificationService.notify( i18n.i18nString('some_thing_went_wrong_err_noty'), "error");
                            }
                            
                            $(".save-tip").removeClass("fa fa-check").hide().text("saving...");
                        });
            }

            $scope.qualifyContextualPaths = function(){
                $timeout(function(){
                    obj.confidenceConfig[1].qualifyContextualPaths = $scope.contextObj.qualifyContextualPaths;
                    doServiceCalls(obj);
                },500);
            };
            function saveMLSynonymSetting(type,reset,resetkey, isSynProceed,features) {
                 $element.find('#warningModal').removeClass('show').addClass('fade');
                resetkey = resetkey || '';
                BTStreamsService.updateMLSynonym($workflowService.selectedStream()._id , ""+reset,resetkey, $scope.payload)
                        .then(function (res) {
                            $workflowService.mlPharams(res.data);
                            if(type){
                               // $(".innerRightBody").scrollTop(0);
                                $scope.resetDefaultVal('#slider3');
                                $scope.resetDefaultVal('#slider4');
                            }
                            if(type=="V3" || features === "n_gram"){
                                $scope.intentParams = res.data.intentParams;
                                nGram.bootstrapSlider('setValue', $scope.intentParams.ngram[1]);
                                formatTooltip("#nGramSlider", $scope.intentParams.ngram[1]);
                                $scope.payload.nerParams.type = res.data.nerParams.type;
                            }else if(features === "skip_gram"){
                                $scope.intentParams = res.data.intentParams;
                                skipGramSeq.bootstrapSlider('setValue', $scope.intentParams.skip_gram.seqLength);
                                skipGramMax.bootstrapSlider('setValue',$scope.intentParams.skip_gram.maxSkipDistance);
                                formatTooltip("#skipGramSeq", $scope.intentParams.skip_gram.seqLength);
                                formatTooltip("#skipGramMax", $scope.intentParams.skip_gram.maxSkipDistance);
                                $scope.payload.nerParams.type = res.data.nerParams.type;
                            }
                            if(isSynProceed) {
                                $scope.trainBot();
                            }
                            $scope.prepareStopWords(res.data);
                             $scope.lodingStopWords = false;
                            $scope.searchWord.search='';
                            $scope.originalMlData = angular.copy(res.data);
                            $(".save-tip").addClass("fa fa-check").show().text("saved...");
                            $timeout(function () {
                                $(".save-tip").removeClass("fa fa-check").hide().text("saving...");
                            },5000);
                            //$workflowService.selectedStream(angular.extend($scope.selectedStream, res.data));
                            $("#noty_center_layout_container").empty();
                            $scope.trainShow = true;
                            NotificationService.notify(i18n.i18nString('settings_saved_sucessfully'), "success");
                        }, function (err) {
                            $scope.lodingStopWords = false;
                            $scope.payload = angular.copy($scope.originalMlData);
                            $scope.intentParams = angular.copy($scope.originalMlData.intentParams);
                            if(err.data && err.data && err.data.errors[0] && err.data.errors[0].msg){
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            }else{
                                NotificationService.notify(i18n.i18nString('some_thing_went_wrong_err_noty'), "error");
                            }
                            $(".save-tip").removeClass("fa fa-check").hide().text("saving...");
                        });
            }


              $(".fundamentalMeaning").click(function(){
               if(!$(this).hasClass("collapsed")){
                   clearSliders('FM'); 
                }else{
                   prepareSliders('FM');
                }
            });
            $(".knowledgeCollection").click(function(){
                if(!$(this).hasClass("collapsed")){
                     clearSliders('KC');
                }else{
                     prepareSliders('KC');
                     checkForSearchInAnsw();
                }
            });
            $(".machinelearning").click(function(){
                if(!$(this).hasClass("collapsed")){
                   clearSliders('ML'); 
                }else{
                     checkMultipIntentModel();
                     if(!$scope.multipIntentModels.configurationValue) {
                        prepareSliders('ML');                        
                    }
                }
            });

            $(".rankingResolverEngine").click(function(){
                if(!$(this).hasClass("collapsed")){
                   clearSliders('RR'); 
                }else{
                     prepareSliders('RR');
                }
            });

            $(".advConfigurations").click(function(){
                if(!$(this).hasClass("collapsed")){
                    $timeout(function(){
                        clearSliders('advConfig');
                    });
                    
                }else{
                    $timeout(function(){
                        $scope.registerCustomSliders();
                    });
                    
                }
            });


            function autoTrainStatus() {
                BTStreamsService.autoTrainStatus($workflowService.selectedStream()._id)
                .then(function(res) {
                        if (res && res.data && res.data.hasOwnProperty('isMlInSyncWithMlparams') && !res.data.isMlInSyncWithMlparams) {
                            $scope.trainShow = true;
                        } else{
                            $scope.trainShow = false;
                        }
                        if(res.data.trainingStatus==='Finished'){
                            $scope.trainStatus.saving = false;
                        }else if($scope.enableSynonyms){
                            $scope.trainStatus.saving =true;
                        } else {
                            $scope.trainStatus.saving =true;
                        }
                    },
                    function(err) {
                        var _msg =  i18n.i18nString( 'err_on_fetching_msg');
                        NotificationService.notify(_msg, "error");
                    });
            }
            autoTrainStatus();

                 //used while builder is resuming//
                 $scope.$emit('nestedComponentLoaded',{'id':'mlThreshold','flag':false}); 
                //Add below whenever nestedComponentLoaded is FINALLY emitted.
                $timeout(function(){                    
                    $scope.$emit('gSearchLoad');
                });

                 $('.faqSearchLink').popover({
                                html: true,
                                content: '<p class="content">'+ i18n.i18nString( 'you_may_host_custom')+'<span> <a class="knowmore" target="_blank" href="https://developer.kore.ai/docs/bots/nlp/knowledge-graph/#Search_by_Answer">'+i18n.i18nString( 'know_more')+'</a></span></p>',
                                trigger: "hover",
                                delay: {
                                    hide: 1500
                                }
                             });
                  $('.manageLongResponse').popover({
                                html: true,
                                content: '<p class="content">'+ i18n.i18nString( 'you_may_host_custom')+'<span> <a class="knowmore" target="_blank" href="https://developer.kore.ai/docs/bots/nlp/knowledge-graph/#Search_by_Answer">'+i18n.i18nString( 'know_more')+'</a></span></p>',
                                trigger: "hover",
                                delay: {
                                    hide: 1500
                                }
                             });
                $scope.preventEvent=function(e){
                    e.stopPropagation();
                    e.preventDefault();
                };
                           
                $('[data-toggle="popover"]').popover();


                $scope.addCustom = function(){
                    var _obj = {'configurationKeyName':'','isCustom':true,'nlpEngine':'','value':'','invalidPattern':true};
                    $scope.savedConfigurations.push(_obj);
                    $scope.invalidPattern = true;
                    $scope.invalidCustomValue = true;
                };
                $scope.addCustomCM = function(){
                    var _obj = {'configurationKeyName':'','isCustom':true,'nlpEngine':'','value':'','invalidPattern':true};
                    if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                        $scope.savedConfigurationsCM.push(_obj);
                    }
                    $scope.invalidPattern = true;
                    $scope.invalidCustomValue = true;
                };

                $scope.registerCustomSliders = function(){
                    if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                        var customSlidersCM = _.filter($scope.savedConfigurationsCM,{'uiComponent':'slider'});
                        angular.forEach(customSlidersCM,function(slider){
                            setTimeout(function(){
                                advancedConfigSliderCM(slider);
                            },200);
                        });
                    } else {
                        var customSliders = _.filter($scope.savedConfigurations,{'uiComponent':'slider'});
                        angular.forEach(customSliders,function(slider){
                            setTimeout(function(){
                                advancedConfigSlider(slider);
                            },200);
    
                        });
                    }
                };

                var deRegisterCustomSliders = function(){
                    var customSliders = _.filter($scope.savedConfigurations,{'uiComponent':'slider'});
                    angular.forEach(customSliders,function(slider){
                        setTimeout(function(){
                            $("#"+slider.configurationKeyName).slider().off('slideStop ');
                            $("#"+slider.configurationKeyName).slider().off('slide'); 
                        },200);

                    });
                };

                var deRegisterCustomSlidersCM = function(){
                    if($scope.multipIntentModels.configurationValue && $scope.multipIntentModels.formType) {
                        var customSlidersCM = _.filter($scope.savedConfigurationsCM,{'uiComponent':'slider'});
                        angular.forEach(customSlidersCM,function(slider){
                            setTimeout(function(){
                                $("#"+slider.configurationKeyName + "CM").slider().off('slideStop ');
                                $("#"+slider.configurationKeyName + "CM").slider().off('slide'); 
                            },200);
    
                        });
                    }
                };


                $scope.checkNetworkTypeConfig = function(config) {
                    var type = $scope.networkTypeList.value;
                    checkMLSettingCount(type); // check ML settings count
                    if($scope.intentParams.type === 'SGD_V2') {
                        return false; // Old version in ML
                    }

                    if((config === 'featureExtraction' || config === 'n_gram') && (type === 'LSTM' || type === 'MLP-WordEmbeddings' || type === 'CNN' || type === 'Transformer')) {
                        return false;
                    }
                    if((config === 'stopWords' || config === 'entityPlaceHolders') && (type === 'Transformer')) {
                        return false;
                    } 
                    return true;

                };


                function loadCustomConfigurations(){
                        $q.all([BTStreamsService.getAdvancedConfigurations($scope.selectedStream._id),BTStreamsService.getSavedConfiguration($scope.selectedStream._id)]).then(function(response){
                        if(response[0] && response[0].data){
                            serverConfigOb = response[0].data;
                            var _keys = Object.keys(response[0].data);
                            if(_keys.indexOf('network') !== -1) {
                                _keys.splice(_keys.indexOf('network'), 1); // remove network
                            }
                             angular.forEach(_keys,function(key,index){
                                $scope.configurationList.push(response[0].data[key]);
                             });
                            $scope.uiConfiguration = _.filter($scope.configurationList,function(configuration){
                              if((configuration.language && configuration.language.indexOf($workflowService.currentLanguage()) !== -1) || (configuration.language === 'ALL')){
                                     configuration['class'] = mapClass[configuration.nlpEngine];
                                     configuration['value'] = configuration.defaultValue;
                                     return configuration;
                                }
                            });
                            $workflowService.configurationList($scope.uiConfiguration);
                            if(serverConfigOb && serverConfigOb.network && serverConfigOb.network.configurationKeyName === 'network') {
                                $scope.networkTypeList = serverConfigOb.network;
                            }
                        }
                       if(response[1] && response[1].data && response[1].data.length){
                            $scope.showEmptyConfig = false;
                            prepareSavedConfigurations(response[1].data);
                            var index = response[1].data.findIndex(function(item) {
                                return item.configurationKeyName === 'network';   
                            });
                            if(index !== -1) {
                                response[1].data.splice(index, 1);
                            }
                            $scope.totalConfigCount = response[1].data.length;
                        }
                        // if(response[1] && response[1].data && response[1].data.length) { // remove network data

                        // }
                        if(!response[1].data.length) {
                            $scope.showEmptyConfig = true;
                            $scope.savedConfigurations = [];
                            $scope.totalConfigCount = 0;
                        }
                    },function(err){
                    if(err && err.data && err.data.errors){
                        NotificationService.notify(err.data.errors[0].msg,'error');
                    }else{
                        NotificationService.notify(i18n.i18nString('some_thing_wrong_label'),'error');
                    }
                });
                    
                    
                }

                loadCustomConfigurations();
                // Load Dialog intents
                function getDialogs (){
                    var deferred = $q.defer();
                    BTFlowtaskService.getFlowtaks($workflowService.selectedStream()._id)
                        .then(function (res) {
                            deferred.resolve(res.data);
                        }, function(err){
                            deferred.reject(err);
                        });
                    return deferred.promise;
                }
                
                // Multi Inetent custome configs
                $scope.customConfigurations = function(cell, type){
                    if(cell) {
                        $scope.multipIntentModels.selectedModel = cell;
                    }
                    $scope.multipIntentModels.intentParams = angular.copy(cell.intentParams);
                    updateCustomModelConfigs(cell, type);
                    if(cell && cell.intentParams) {
                        $scope.multipIntentModels.intentParams.usePlaceholders = cell.intentParams.usePlaceholders;
                        $scope.multipIntentModels.intentParams.useStopwords = cell.intentParams.useStopwords;
                    }
                    $timeout(function(){
                        $scope.openModalSlider('#customConfigurations');
                        $timeout(function(){
                            prepareSliders('CM');
                            $scope.registerCustomSliders();
                        });
                    });
                };
                // Close multi intent slider
                $scope.closeCustomConfigurations = function(){
                    $timeout(function(){
                        $scope.closeModalSlider('#customConfigurations');
                    });
                    getMLParams();
                    formReset();
                };
                // CREATE/UPDATE custom model
                $scope.updateCustomModel = function() {
                    var _payload = {
                        "dialogIntents": [],
                        "isDefault": false,
                        "intentParams": {
                         },
                        "nerParams": $scope.multipIntentModels.nerParams,
                        "intentData": {
                        },
                        "streamId": $scope.selectedStream._id,
                        "language": "en",
                        "state": "configured",
                        "type": 3,
                        "name": $scope.multipIntentModels.name,
                        "advancedMLConfigurations": [],
                        "exactMatchThreshold": 95,
                        "minThreshold": 0,
                        "maxThreshold": 0,
                        "__v": 0
                    };
                    if($scope.multipIntentModels.selectedModel && $scope.multipIntentModels.selectedModel._id) {
                        _payload.intentData = $scope.multipIntentModels.selectedModel.intentData;
                        // _payload.nerParams = $scope.multipIntentModels.selectedModel.nerParams;
                        _payload.language = $scope.multipIntentModels.selectedModel.language;
                        _payload.type = $scope.multipIntentModels.selectedModel.type;
                        _payload.advancedMLConfigurations = $scope.multipIntentModels.selectedModel.advancedMLConfigurations;
                        _payload.exactMatchThreshold = $scope.multipIntentModels.selectedModel.exactMatchThreshold;
                        _payload.minThreshold = $scope.multipIntentModels.selectedModel.minThreshold;
                        _payload.maxThreshold = $scope.multipIntentModels.selectedModel.maxThreshold;
                    }
                    if($scope.multipIntentModels.dialogIntentsList.length) {
                        $scope.multipIntentModels.dialogIntentsList.forEach(function(item) {
                            if(_payload.dialogIntents.indexOf(item.refId) === -1) {
                                _payload.dialogIntents.push(item.refId);
                            }
                        });
                    }
                    // ML Config settings
                    if(obj && obj.confidenceConfig) {
                        _payload.exactMatchThreshold = obj.confidenceConfig[0].exactMatchThreshold;
                        _payload.minThreshold = obj.confidenceConfig[0].minThreshold;
                        _payload.maxThreshold = obj.confidenceConfig[0].maxThreshold;
                    }
                    if($scope.multipIntentModels.intentParams) {
                        _payload.intentParams = $scope.multipIntentModels.intentParams;
                    }
                    if($scope.mlthreshold && $scope.mlthreshold.stopWords) {
                        _payload.intentData.stopwords = $scope.mlthreshold.stopWords.join(' ');
                    }

                    if($scope.multipIntentModels.formType !== 'default') {
                        if(($scope.multipIntentModels.name).trim() === '') {
                            NotificationService.notify('Group name is required','warning');
                            return;
                        }
                        _payload.name = ($scope.multipIntentModels.name).trim();
                    }
                    if($scope.multipIntentModels.nerParams && $scope.multipIntentModels.nerParams.type) {
                        _payload.nerParams = $scope.multipIntentModels.nerParams;
                    }
                    if($scope.multipIntentModels.formType === 'new' || $scope.multipIntentModels.formType === 'clone') {
                        if($scope.savedConfigurationsCM) {
                            var advdConf1 = [];
                            $scope.savedConfigurationsCM.forEach(function(item) {
                                if(item && item._id) {
                                    advdConf1.push({_id: item._id,configurationKeyName: item.configurationKeyName, nlpEngine: item.nlpEngine,configurationValue: item.value });
                                } else {
                                    advdConf1.push({configurationKeyName: item.configurationKeyName, nlpEngine: item.nlpEngine,configurationValue: item.value });
                                }
                            });
                            if($scope.networkTypeList) {
                                advdConf1.push({configurationKeyName: $scope.networkTypeList.configurationKeyName, nlpEngine: $scope.networkTypeList.nlpEngine,configurationValue: $scope.networkTypeList.value || $scope.networkTypeList.defaultValue});
                            }
                            _payload.advancedMLConfigurations = advdConf1;
                        }
                        BTStreamsService.createCustomModel($scope.selectedStream._id, _payload).then(function(response){
                            if(response && response.data){
                                NotificationService.notify(i18n.i18nString('collection_created'),'success');
                                $scope.closeCustomConfigurations();
                                autoTrainStatus();
                            }
                        },function(err){
                             if(err && err.data && err.data.errors){
                                NotificationService.notify(err.data.errors[0].msg,'error');
                            }else{
                                NotificationService.notify(i18n.i18nString('some_thing_wrong_label'),'error');
                            }
                        });
                    } else if($scope.multipIntentModels.formType === 'update' || $scope.multipIntentModels.formType === 'default') {
                        if($scope.savedConfigurationsCM) {
                            var advdConf2 = [];
                            $scope.savedConfigurationsCM.forEach(function(item) {
                                if(item && item._id) {
                                    advdConf2.push({_id: item._id, configurationKeyName: item.configurationKeyName, nlpEngine: item.nlpEngine,configurationValue: item.value });
                                } else {
                                    advdConf2.push({configurationKeyName: item.configurationKeyName, nlpEngine: item.nlpEngine,configurationValue: item.value });
                                }
                            });
                            if($scope.networkTypeList) {
                                if($scope.networkTypeList._id) {
                                    advdConf2.push({_id: $scope.networkTypeList._id, configurationKeyName: $scope.networkTypeList.configurationKeyName, nlpEngine: $scope.networkTypeList.nlpEngine,configurationValue: $scope.networkTypeList.value || $scope.networkTypeList.defaultValue});
                                } else {
                                    advdConf2.push({configurationKeyName: $scope.networkTypeList.configurationKeyName, nlpEngine: $scope.networkTypeList.nlpEngine,configurationValue: $scope.networkTypeList.value || $scope.networkTypeList.defaultValue});
                                }
                            }
                            _payload.advancedMLConfigurations = advdConf2;
                        }
                        var customId = $scope.multipIntentModels.selectedModel._id;
                        if(!customId) {
                            NotificationService.notify('customId not found!!','error');
                        }
                        BTStreamsService.updateCustomModel($scope.selectedStream._id, customId, _payload).then(function(response){
                            if(response && response.data){
                                NotificationService.notify(i18n.i18nString('collection_updated'),'success');
                                $scope.closeCustomConfigurations();
                                autoTrainStatus();
                            }
                        },function(err){
                             if(err && err.data && err.data.errors){
                                NotificationService.notify(err.data.errors[0].msg,'error');
                            }else{
                                NotificationService.notify(i18n.i18nString('some_thing_wrong_label'),'error');
                            }
                        });
                    }
                };
                // Update slider details
                function updateCustomModelConfigs(cell, type) {
                    $scope.savedConfigurationsCM = [];
                    if(type === 'new') {
                        $scope.multipIntentModels.formType = 'new';
                        $scope.multipIntentModels.customConfigText = i18n.i18nString('new_custom_config_group');
                        $scope.multipIntentModels.intentParams = {
                            f_negation: false,
                            features: "n_gram",
                            maxngram: 4,
                            minngram: 1,
                            ngram: [1, 4],
                            skip_gram: {seqLength: 2, maxSkipDistance: 1},
                            type: "V3",
                            usePlaceholders: false,
                            useStopwords: false,
                            useSynonyms: false,
                            useTestPlaceholders: false,                            
                        };
                        $scope.networkTypeList.value = 'Standard';
                        if(obj && obj.confidenceConfig[0]) {
                            obj.confidenceConfig[0].exactMatchThreshold = 95;
                            obj.confidenceConfig[0].minThreshold = 0.3;
                            $scope.multipIntentModels.selectedModel.minThreshold = 0.3;
                            $scope.multipIntentModels.selectedModel.exactMatchThreshold = 95;
                        }
                        $scope.multipIntentModels.nerParams.type = "corenlp";
                    } else if(type === 'default') {
                        $scope.multipIntentModels.formType = 'default';
                        $scope.multipIntentModels.customConfigText = i18n.i18nString('bot_level_intent_model_config_label');
                    } else if(type === 'clone') {
                        $scope.multipIntentModels.formType = 'clone';
                        $scope.multipIntentModels.customConfigText = i18n.i18nString('clone_custom_config_group');
                        $scope.multipIntentModels.name = '';
                        $scope.multipIntentModels.dialogIntentsList = [];
                    } else if(type === 'update') {
                        $scope.multipIntentModels.formType = 'update';
                        $scope.multipIntentModels.customConfigText = i18n.i18nString('update_custom_config_group');
                        $scope.multipIntentModels.name = cell.name;
                        $scope.multipIntentModels.dialogIntentsList = cell.dialogIntents;
                    } else {
                        $scope.multipIntentModels.formType = 'default';
                        formReset();
                    }
                    if(type !== 'new') {
                        if($scope.multipIntentModels.intentParams) {
                            if(!$scope.multipIntentModels.intentParams.ngram || $scope.multipIntentModels.intentParams.ngram.length === 0) {
                                $scope.multipIntentModels.intentParams.ngram = [1, 4];
                            }
                        }
                        if($scope.multipIntentModels.intentParams && $scope.multipIntentModels.intentParams.useSynonyms){
                            $scope.filterToggle = 'disabled';
                            $scope.multipIntentModels.intentParams.useSynonyms = true;
                        }
                        if($scope.multipIntentModels.intentParams && !$scope.multipIntentModels.intentParams.features){
                            $scope.multipIntentModels.intentParams.features = 'n_gram';
                        }
                        if($scope.multipIntentModels.intentParams && !$scope.multipIntentModels.intentParams.useStopwords){
                            $scope.multipIntentModels.intentParams.useStopwords = true;
                        }
                        if($scope.multipIntentModels.intentParams && !$scope.multipIntentModels.intentParams.usePlaceholders){
                            $scope.multipIntentModels.intentParams.usePlaceholders = true;
                        }
                        if($scope.multipIntentModels.selectedModel.nerParams && $scope.multipIntentModels.selectedModel.nerParams.type){
                            $scope.multipIntentModels.nerParams.type = $scope.multipIntentModels.selectedModel.nerParams.type;
                        } else {
                            $scope.multipIntentModels.nerParams.type = "corenlp";
                        }
                        $scope.prepareStopWords(cell); // init stopwords
                    }
                    if(cell && cell.advancedMLConfigurations) {
                        var findIndex = cell.advancedMLConfigurations.findIndex(function(item, index) {
                            return item.configurationKeyName === "network";
                        });
                        if(findIndex !== -1) {
                            $scope.networkTypeList.value = cell.advancedMLConfigurations[findIndex].configurationValue;
                            if(cell.advancedMLConfigurations && cell.advancedMLConfigurations[findIndex]._id) {
                                $scope.networkTypeList._id = cell.advancedMLConfigurations[findIndex]._id;
                            }
                            $scope.multipIntentModels.selectedModel.advancedMLConfigurations.splice(findIndex, 1);
                        } else {
                            $scope.networkTypeList.value = "Standard";
                        }
                    }
                    if($scope.multipIntentModels.selectedModel && $scope.multipIntentModels.selectedModel.advancedMLConfigurations) {
                        prepareSavedConfigurations($scope.multipIntentModels.selectedModel.advancedMLConfigurations);
                    } else {
                        $scope.savedConfigurationsCM = [];
                    }
                    if(!$scope.savedConfigurationsCM.length) {
                        $scope.showEmptyConfigCM = true;
                    } else {
                        $scope.showEmptyConfigCM = false;
                    }
                }
                function formReset() {
                    $scope.multipIntentModels.name = '';
                    $scope.multipIntentModels.dialogIntentsList = [];
                    // $scope.savedConfigurations = originalCopy;
                    $scope.multipIntentModels.formType = "";
                    $scope.savedConfigurationsCM = [];
                    $scope.multipIntentModels.selectedModel = {};
                    $scope.invalidPattern = false;
                    $scope.invalidCustomValue = false;
                }
                // check is custome form is valid
                $scope.isCustomFormValid = function() {
                    // if($scope.multipIntentModels.name !== '') {
                    //     return true;
                    // } else {
                    //     false;
                    // }
                    return true;
                };
                $scope.openEnableMultiIntents = function() {
                    $element.find('#enableMultiIntents').removeClass('fade').addClass('show');
                };
                $scope.openDisableMultiIntents = function() {
                    $element.find('#disableMultiIntents').removeClass('fade').addClass('show');
                };
                $scope.closeModalMultiIntents = function(type, currConfig) {
                    $element.find('#disableMultiIntents').removeClass('show').addClass('fade');
                    $element.find('#enableMultiIntents').removeClass('show').addClass('fade');
                    $element.find('#deleteMultiIntents').removeClass('show').addClass('fade');
                    $element.find('#configCannotDel').removeClass('show').addClass('fade');
                    if(type === 'enable' || type === 'disable') {
                        checkMultipleIntentToggle();
                    }
                };
                $scope.confirmMultiIntent = function() {
                    editConfigurations($scope.loadConfiguration, '', '', 'ML');
                    $scope.closeModalMultiIntents();
                };
                // Delete collection config 
                $scope.openDeleteConfirm = function(cell, index) {
                    $scope.loadConfiguration = cell;
                    if($scope.loadConfiguration.isDefault) {
                        $element.find('#configCannotDel').removeClass('fade').addClass('show');
                        return;
                    }
                    $element.find('#deleteMultiIntents').removeClass('fade').addClass('show');
                };
                $scope.deleteDialogIntentModel = function() {
                    var customId = $scope.loadConfiguration._id;
                    BTStreamsService.deleteDialogIntentModel($scope.selectedStream._id,customId).then(function(response){
                        if(response && response.data){
                            NotificationService.notify(i18n.i18nString('collection_deleted'),'success');
                            $scope.closeModalMultiIntents();
                            getMLParams();
                        }
                    },function(err){
                         if(err && err.data && err.data.errors){
                            NotificationService.notify(err.data.errors[0].msg,'error');
                        }else{
                            NotificationService.notify(i18n.i18nString('some_thing_wrong_label'),'error');
                        }
                        $scope.closeModalMultiIntents();
                    });
                };
                $scope.addDialogIntent = function(intent, index) {
                    if($scope.multipIntentModels.dialogIntentsList.indexOf(intent) == -1) {
                        $scope.multipIntentModels.dialogIntentsList.push(intent);
                    }

                };
                $scope.delDialogIntent = function(intent, index) {
                    $scope.multipIntentModels.dialogIntentsList.splice(index, 1);
                };
                function checkMultipIntentModel() {
                    if($scope.savedConfigurations && $scope.savedConfigurations.length) {
                        var findObj = $scope.savedConfigurations.find(function(item) {
                            return item.configurationKeyName === "Multiple_Intent_Models";
                        });
                        if(findObj && findObj.value) {
                            $scope.multipIntentModels.configurationValue = true;
                        } else {
                            $scope.multipIntentModels.configurationValue = false;
                        }
                    }
                }
                // transform refId to dialog obj
                $scope.dialogRefIdObj = function(refId, item) {
                    var findObj = $scope.getDialogIntents.find(function(item) {
                        if(item) {
                            return item.refId === refId;
                        }
                    });
                    if(findObj) {
                        if(item) {
                            findObj.defaultName = item.name;  
                        }
                        return findObj;
                    } else {
                        return {};
                    }
                };
                // check toggle in multiple intent models
                function checkMultipleIntentToggle() {
                    if($scope.savedConfigurations && $scope.savedConfigurations.length) {
                        var findIndex = $scope.savedConfigurations.findIndex(function(item) {
                            return $scope.loadConfiguration.configurationKeyName === item.configurationKeyName;
                        });
                        if(findIndex !== -1) {
                            if($scope.savedConfigurations[findIndex].value) {
                                $scope.savedConfigurations[findIndex].value = false;
                            } else {
                                $scope.savedConfigurations[findIndex].value = true;
                            }
                        }
                    }
                }
                // identity default dialog from mlparams
                $scope.identifyDefaultDialog = function(intent) {
                    var name = null;
                    if(intent && intent.defaultName) {
                        name = intent.defaultName;
                    }
                    return name;
                };
                // Get lang by lang code
                $scope.getLanguageNameByCode = function(){
                    if($scope.supportedLanguages && $scope.supportedLanguages.length) {
                        var findLang = $scope.supportedLanguages.find(function(item) {
                            return item.value === $scope.currLang.langVal;
                        });
                        if(findLang) {
                            $scope.currLang.langName = findLang.name;
                        } else {
                            $scope.currLang.langName = '---';
                        }
                    }
                };

                $scope.init = function() {
                    getDialogs().then(function(data){
                        if(data && data.length) {
                            var obj = _.uniq(data, function(x){
                                return x.name;
                            });
                            if(obj) {
                                $scope.getDialogIntents = obj;
                            } else {
                                $scope.getDialogIntents = [];
                            }
                            // data.forEach(function(val, index){
                            //     if(!val.isFollowUp) {
                            //         $scope.getDialogIntents[index] = {};
                            //         $scope.getDialogIntents[index].id = val.refId;
                            //         $scope.getDialogIntents[index].refId = val.refId;
                            //         $scope.getDialogIntents[index].name = val.name;
                            //         $scope.getDialogIntents[index].isFollowUp = val.isFollowUp;
                            //     }
                            // });
                            // $scope.getDialogIntents = data;
                            // $scope.getDialogIntents = _.filter(data,function(task){
                            //     return task && !task.isFollowUp;
                            // });
                            // $scope.getAllDialogIntents = data;
                        }
                        getMLParams(); // Load after Dialogs API
                    }, function(err){
                        NotificationService.notify(i18n.i18nString('unable_fetch_dialogs'), "error");
                    });
                    $scope.getLanguageNameByCode();
                };
                $scope.init();

        }]);
    _module.filter('configFilter', function () { // Filter selectedConfig from Original Configs
        return function (data, args) {
            var list = args.list;
            if(list && list.length) {
                list.forEach(function(selectedCon) {
                    var findIndex = data.findIndex(function(config) {
                        return config.configurationKeyName === selectedCon.configurationKeyName;
                    });
                    if(findIndex !== -1) {
                        data.splice(findIndex, 1);
                    }
                });
            }
            return data;
        };
    });

}(angular));


;(function(ng) {
	'use strict';
	var _module = ng.module('patterns-module', []);
	_module.controller('PatternsModuleCtrl', ['$window','$element','$scope','BTStreamsService','$workflowService','BTActionsService','BTAlertsService','BTFlowtaskService','_constants_','NotificationService','$q','$timeout','$filter','$location','indexerUtil','env_conf','accessControlService','$rootScope', '$applicationService','i18n', 'mixPanel',
            function ($window, $element, $scope,BTStreamsService,$workflowService,BTActionsService,BTAlertsService,BTFlowtaskService,_constants_,NotificationService,$q,$timeout,$filter,$location,indexerUtil,env_conf,accessControlService,$rootScope,$applicationService,i18n,mixPanel) {
                $scope.displayMode=accessControlService.getAccessRight('BOTBUILDER_NATURAL_LANGUAGE');

                 //Header toggle related//
            $scope.filterToggle = $workflowService.selectedStreamState();
//            $scope.updateStreamState = function(evn,streamState){
//            $scope.filterToggle = $workflowService.selectedStreamState();
//            $scope.filterToggle = streamState;
//            };
//            $scope.$on("updateStreamState",$scope.updateStreamState);
            //END--Header toggle related//
                var _notSupportedTrainLanguages = ['en','de','es','fr'];
                $scope.training = i18n.i18nString('training_label2');
                $scope.train = i18n.i18nString('train');
                $scope.alert = i18n.i18nString('alert');
                $scope.action = i18n.i18nString('action_label_lowercase');





                $scope.showTrain = false;
                $scope.tasks = [];
                var currentIntent = {};
                $scope.newpattern = {};
                $scope.upgradedTasks= [];
                $scope.constants=_constants_;
                $scope.patternModuleObj = {
                    triggeredFromSelect: false
                };
                $scope.stream      = angular.copy($workflowService.selectedStream());
                $scope.intentSelect2Options = {maxTagLength: 2048,sortable:false};
                $scope.entitySelect2Options = {maxTagLength: 2048,sortable:true};
                var streamId      = $scope.stream._id;
                $scope.title = i18n.i18nString('pattern_name');
                $scope.intents = [];
                $scope.entities = []; 
                $scope.saving     = false;
                $scope.assetsBase = env_conf['assets-url'];
                $scope.closeIconDark = $scope.assetsBase + "icons/closeIconDark.svg";
                $scope.orIcon = $scope.assetsBase + "icons/orIcon.svg";
                $scope.minusCircle = $scope.assetsBase + "icons/minus-circle.svg";
                $scope.editTaskPatternId = null;
                $scope.editTaskPattern = null;
                $scope.saveTaskPatternIdIndex = null;
                $scope.editFieldPatternId = null;
                $scope.editFieldPattern = null;
                $scope.editIntentPatternId = null;
                $scope.editIntentPattern = null;
                $scope.editEntityPatternId = null;
                $scope.editEntityPattern = null;
                $scope.helpIcon = window.appConfig.CONTEXT_PATH+'/assets/icons/helpIcon.svg';
                $scope.searchIconGray = env_conf['context-url']+'/assets/icons/searchIconGray.svg';
                $scope.searchClose = env_conf['context-url']+'/assets/icons/fa-close.svg';
                $scope.pencilIcon = env_conf['context-url']+'/assets/icons/pencilIcon.svg';
                $scope.trashIcon = env_conf['context-url']+'/assets/icons/trashIcon.svg';
                $scope.emptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/k-folder.png';
                $scope.initialObject = [{
                a: [], b: [], c: [], d: [], e: [], f: [], g: [], h: [], i: [], j: [], k: [], l: [], m: [], n: [], o: [], p: [], q: [], r: [], s: [], t: [], u: [], v: [], w: [], x: [], y: [], z: [], other: []
                }];
            $scope.taskPatternsObject = angular.copy($scope.initialObject);
            $scope.fieldPatternsObject = angular.copy($scope.initialObject);
            $scope.entityPatternsObject = [];//angular.copy($scope.initialObject);
            $scope.intentPatternsObject = angular.copy($scope.initialObject);
            $scope.indexObject = angular.copy($scope.initialObject);
            $scope.iPatterns ={};
            $scope.ePatterns ={};
            $scope.tPattern = {};
            $scope.allTasks=[];
            $scope.clickedTaskIndex = -1;
            $scope.clickedFieldIndex = -1;
            $scope.clickedIntentIndex = -1;
            $scope.clickedEntityIndex = -1;
            var dummy_traitAnd = [];
            $scope.dummyTraitOrCondition = [];
            $scope.dummyTraitOrCondition.push(angular.copy(dummy_traitAnd));
            $scope.trainStatus = {"success": false, "failed": false, "saving": false};
            $scope.patternsCB = {};
            setTimeout(function () {
                $rootScope.$emit('pefectScrollUpdate');
            }, 2000);
            $scope.onClickTaskindex=function(task,index){
                var taskId = task._id;
                if($scope.filterToggle === "indevelopment"){
                    if(task.state == "published"){
                        $scope.currentTask = task;
                        $scope.currentTab = "task";
                        $scope.currenttaskIndex = index;
                        NotificationService.alert('', $scope.upgrade, {okText: i18n.i18nString('upgrade')}, "", undefined, i18n.i18nString('add_utter_published_noty'));
                    } else{
                       setTimeout(function(){
                            if($scope.displayMode !== 'VIEW'){
                            $('.newPatternInput').trigger('focus');
                            }

                        },350);
                        $scope.clickedTaskIndex=index;
                        $scope.selectedTask = _.filter($scope.allTasks, {_id:taskId})[0];
                        $scope.openPatternModal('pattern');
                        $scope.patternsCB.loadingPatterns = true;
                        $scope.patternsCB.onClickTask($scope.selectedTask);
                    }
                }else if($scope.filterToggle === 'published'){
                        $scope.clickedTaskIndex=index;
                        $scope.editIntentPatternId = taskId;
                    }
            };
            $scope.selectTask = function(task){
                $scope.selectedTask = task;
            };
            function decodePattern(msg) {
                try {
                    return msg.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                } catch (e) {
                    return msg;
                }
            }
            $scope.onClickFieldindex=function(task,index){
                var taskId = task._id;                                    
                if(taskId == $scope.clickedFieldIndex){
                    $scope.clickedFieldIndex = -1;
                    $scope.selectedField=null;
                }
                else{
                    $scope.clickedFieldIndex=taskId;
                    $scope.selectedField = $scope.allFields[taskId];
                    $scope.selectedFieldPatterns = task;
                }  
                
            };
            $scope.selectField = function(field){
                $scope.selectedField = $scope.fieldPatternsObject.filter(function(item) {return item.task.name === field.task.name;});
            };

            $scope.selectIntent = function(intent){
                $scope.selectedIntent = intent;
            };
            $scope.onClickEntityindex=function(taskId,index){
                if(taskId == $scope.clickedEntityIndex){
                    $scope.clickedEntityIndex = -1;
                    $scope.editEntityPatternId=null;
                    var entity = _.filter($scope.allEntity, {_id:taskId})[0];
                    entity = $scope.selectedEntity;
                    $.each($scope.entityPatternsObject, function(i, entityCopy){
                        if(taskId == entityCopy._id){
                            $scope.entityPatternsObject[i] = _.merge($scope.entityPatternsObject[i], $scope.selectedEntity);
                        }
                    });
                    $scope.entities = $scope.entityPatternsObject;
                }
                else{
                    if($scope.filterToggle === 'indevelopment'){
                        $scope.clickedEntityIndex=taskId;
                        $scope.selectedEntity = _.filter($scope.allEntity, {_id:taskId})[0];
                        
                    }
                    
                }
                 $scope.selectedEntity = _.filter($scope.allEntity, {_id:taskId})[0];
                 $scope.openPatternModal('patterns');
                 $scope.patternsCB.onClickEntity($scope.selectedEntity);
            };
            $scope.selectEntity = function(entity){
                $scope.selectedEntity = entity;
            };
            $('.patternSearchIcon').click(function(){
                if($(this).hasClass('fa-remove')){
                    $(this).removeClass('fa-remove');
                    $(this).addClass('fa-search');
                    $('.searchPattern').removeClass('searchExpand');
                    $scope.gSearchCb.search="";
                }
                else{
                    setTimeout(function(){
                        $('.patternSearch').trigger('focus');
                    },350);
                    $(this).addClass('fa-remove');
                    $(this).removeClass('fa-search');
                    $('.searchPattern').addClass('searchExpand');
                }
            });

            if(!$scope.hideUi){
                $("#btPatternsModal").modal("show");
            }
            if (!_.isObject($scope.stream) || (_.isObject($scope.stream) && Object.keys($scope.stream).length === 0)) {
                goBack();
                return;
            }
            $scope.validateFieldPattern = (function () {
                return {
                    test: function (value) {
                        if (value && (value.split("*").length - 1) === 1) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                };
            })();

                $scope.editFieldPatternObject = function (task, fieldId,index,event) {
                    $scope.fieldPatternName = fieldId;
                    if($scope.filterToggle === "indevelopment"){
                    if(task.state == "published"){
                    $scope.currentTask = task;
                    $scope.currentTab = "field";
                    $scope.currentFieldId = fieldId;
                    $scope.currentIndex = index;
                    NotificationService.alert('', $scope.upgrade, {okText:  i18n.i18nString('upgrade')}, "", undefined,i18n.i18nString('add_utter_published_noty'));
                }else{
                    $('.fieldPatterns').removeClass('fieldPatternsaddStyleClass');
                    if($scope.clickedFieldId==fieldId){
                        $scope.clickedFieldId = -1;
                        $scope.tempClickedFieldId = -1;
                    }else{
                        setTimeout(function(){
                            $('.fieldPatternInput').trigger('focus');
                        },350);
                        $scope.cancelFieldPatternObject();
                        $scope.editFieldPatternId = task._id + fieldId;
                        $scope.tempClickedFieldId = task._id + fieldId;
                        $scope.clickedFieldId = fieldId;
                        $('.fieldParentDiv'+index).addClass("fieldPatternsaddStyleClass");
                        $timeout(function () {
                            $('.fieldPattern-select2 .select2-input').focus();
                        }, 500);    
                    }
                    if(event){
                     setTimeout(function(){
                        var ele=event.currentTarget;
                        var _container =$('.bt-patterns').closest('.ps-container');
                        if (_container && _container.offset()) {
                          var _scrollHeight = $(ele.parentElement).offset().top - _container.offset().top + _container.scrollTop();
                          _container.animate({
                            scrollTop: _scrollHeight
                          }, 'fast');
                        }
                    },350);   
                    }
                    
                    }
                }
                    $scope.editFieldPattern = angular.copy(task);
                    $scope.openPatternModal('patterns');
                    $scope.patternsCB.onClickField($scope.editFieldPattern,fieldId);
                };
                 
                $scope.editTaskPatternObject=function(task){
                    if ($scope.editTaskPatternId !== task._id) {
                        $scope.cancelTaskPattern(false);
                        $scope.editTaskPattern = angular.copy(task);
                        $scope.editTaskPatternId = task._id;
                        if ($scope.saveTaskPatternIdIndex !== $scope.editTaskPatternId) {
                            $scope.saveTaskPatternIdIndex = null;
                        }
                    } else {
                        $scope.cancelTaskPattern(false);
                    }

                };
                
                $scope.saveTaskPatternId = function(task){
                    $scope.cancelTaskPatternId();
                    $scope.editTaskPattern = angular.copy(task);
                    $scope.saveTaskPatternIdIndex = task._id;
                    $scope.editTaskPatternId = task._id;
                    $timeout(function () {
                        $('.patternInput').focus();
                    }, 250);
                };

                $scope.cancelTaskPatternId = function(){
                    $scope.saveTaskPatternIdIndex = null;
                    $scope.resetTaskPattern();
                };

                $scope.editEntityPatternObject = function (entity,event) {
                    if(entity.status == "published"){
                        $scope.editEntityPatternId = entity._id;
                        return;
                    }
                    $scope.cancelEntityPattern();
                    $scope.editEntityPattern = angular.copy(entity);
                    $scope.editEntityPatternId = entity._id;
                    $timeout(function () {
                        $('.entityPattern-select2 .select2-input').focus();
                    }, 350);
                    setTimeout(function(){
                        var ele=event.currentTarget;
                        var _container =$('.bt-patterns').closest('.ps-container');
                        if (_container && _container.offset()) {
                          var _scrollHeight = $(ele.parentElement).offset().top - _container.offset().top + _container.scrollTop();
                          _container.animate({
                            scrollTop: _scrollHeight
                          }, 'fast');
                        }
                    },350);
                
                };
                
                $scope.onClickIntentindex = function(intent,event,index,selectedType,intentId){
                    if(event){
                        event.stopPropagation();
                    }
                    var type= (selectedType || "patterns") + intentId;
                    $scope.traitRules={};
                    if($scope.filterToggle === "indevelopment"){
                        if(intent.status == "published"){
                            $scope.currentTask = intent;
                            $scope.selectedType = selectedType;
                            $scope.clickedIntentIndex = index;
                            NotificationService.alert('', $scope.upgrade, {okText: i18n.i18nString('upgrade')}, "", undefined, i18n.i18nString('add_utter_published_noty'));
                        } else{
                               $scope.dummyTraitOrCondition = [];
                                $scope.dummyTraitOrCondition.push(angular.copy(dummy_traitAnd));
                                $scope.selectIntentSection = type;
                                $scope.traitRules.traitMappings = intent.traitRules ||[];
                                $scope.clickedIntentIndex=index;
                                $scope.editIntentPatternId = intentId;
                                $scope.selectedTask = _.filter($scope.allIntent, {_id:intentId})[0];
                                $scope.openPatternModal(selectedType);
                                if(selectedType === 'patterns'){
                                    $scope.patternsCB.onClickTask($scope.selectedTask);
                                }else if(selectedType === 'traits'){
                                    $scope.patternsCB.onClickTraits($scope.selectedTask,'',$scope.traitRules);
                                }
                                
                        }
                    }else if($scope.filterToggle === 'published'){
                        $scope.editIntentPatternId = intentId;
                        $scope.traitRules.traitMappings = intent.traitRules ||[];
                        $scope.selectedTask = _.filter($scope.allIntent, {_id:intentId})[0];
                        $scope.openPatternModal();
                       if(selectedType === 'patterns'){
                                    $scope.patternsCB.onClickTask($scope.selectedTask);
                        }else if(selectedType === 'traits'){
                            $scope.patternsCB.onClickTraits($scope.selectedTask,'',$scope.traitRules);
                        }
                    }
                };
               $scope.openPatternModal = function(selectedType) {
                $('.pattern-modal').modal('show');
                   if(selectedType){
                    var _botInfo = {
                        streamId:$workflowService.selectedStream()._id,
                        BotName:$workflowService.selectedStream().name,
                     };
                     if(selectedType==='traits'){
                        mixPanel.postEvent('Add Rule',_botInfo);
                     } else {
                        mixPanel.postEvent('Add Pattern',_botInfo);
                     }
                   
                   }
               };
                $timeout (function(){
                    $scope.isTaskPatternsAvailable=function(currTasks){
                        var available = false;
                        currTasks.forEach(function(task,key){
                            if(task.state=="published" && $scope.filterToggle=="published"){
                                if(task.name.length > 0){
                                    available = true;
                                    return;
                                }
                            }else if($scope.filterToggle!="published" && task.state!="published" ){
                                if(task.name.length > 0){
                                    available = true;
                                    return;
                                }
                            }
                        });
                        return available;
                    };
                },350);

                $scope.cancelTaskPattern = function (resetIndex) {
                    $scope.editTaskPatternId = null;
                    if (resetIndex) {
                        $scope.editTaskPattern = null;
                    }
                    $scope.resetTaskPattern();

                };

                $scope.resetTaskPattern = function () {
                var indexTask = -1;
                $scope.tasks.map(function (task, index) {
                    task.newTaskPattern = null;
                    if ($scope.editTaskPattern && task._id === $scope.editTaskPattern._id) {
                        indexTask = index;
                    }
                });
                if (indexTask != -1) {
                    $scope.tasks[indexTask] = $scope.editTaskPattern;
                    indexUpdateForTaskPatterns();
                }
            };
                
                
                $scope.cancelFieldPatternObject = function (resetIndex) {
                   
                        $scope.editFieldPattern = null;
                        $scope.editFieldPatternId = null;
                    var indexTask = -1;
                    $scope.tasks.map(function (task, index) {
                        if ($scope.editFieldPattern && task._id === $scope.editFieldPattern._id) {
                            indexTask = index;
                        }
                    });
                    if (indexTask != -1) {
                        $scope.tasks[indexTask] = $scope.editFieldPattern;
                        prepareFieldIndexObject();
                    }

                };
//                $scope.updateFilterValue = function(filterVal){
//                    return filterVal === "indevelopment"?"published":"indevelopment";
//                };
                    $scope.filterToggleTask = function(task){   
                        var taskType = $scope.getTaskType(task);
                        var key = "state";
                        if (task && task.type === 'DialogIntent') {
                            key = "status";
                        }
                        else if (task && task.type === 'DialogEntity') {
                            key = "status";
                        }
                        if ($scope.filterToggle === 'published') {
                            if (task[key] === 'published') {
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                        else {
                    if (task[key] === 'published' && (taskType === 'alert' || taskType === 'action' || taskType === 'flowtask')) {
                        if (task.isParent || task.isDeleted) {
                            return false;
                        } else {
                            return true;
                        }
                    } else if (task[key] !== 'published') {

                        return true;

                    } else {
                        return false;
                    }
                }
                    };
                $scope.cancelEntityPattern = function (resetIndex) {
                    if (resetIndex) {
                        $scope.editEntityPatternId = null;
                    }
                    var indexEntity =-1;
                    $scope.entities.map(function (entity, index) {
                        if ($scope.editEntityPattern && entity._id === $scope.editEntityPattern._id) {
                            indexEntity = index;
                        }
                    });
                    if (indexEntity!=-1) {
                        $scope.entities[indexEntity] = $scope.editEntityPattern;
                        indexUpdateForEntitiesOrIntentsPatterns('entityPatterns');
                    }

                };
                
                $scope.cancelIntentPattern = function (resetIndex) {
                    if (resetIndex) {
                        $scope.editIntentPatternId = null;
                    }
                    var indexIntent=-1;
                    $scope.intents.map(function (intent, index) {
                        if ($scope.editIntentPattern && intent._id === $scope.editIntentPattern._id) {
                            indexIntent = index;
                        }
                    });
                    if (indexIntent!=-1) {
                        //$scope.intents[indexIntent] = $scope.editIntentPattern;
                        indexUpdateForEntitiesOrIntentsPatterns('intentPatterns');
                    }

                };

                $scope.saveTaskPatternsObject = function (task) {
                    var newTask = null;
                    if (task.newTaskPattern && task.newTaskPattern !== null && task.newTaskPattern !== '') {
                        createPattern($scope.editTaskPattern,task.newTaskPattern,true);
                    }
                    else if ($scope.tPattern.newTaskPattern !== null && $scope.tPattern.newTaskPattern !== ''){
                        createPattern(task,$scope.tPattern.newTaskPattern,true);
                    }

                };
                
                $scope.saveFieldPatternsObject = function (newTask) {    
                    if(!validateFieldPattern($scope.tPattern.newTaskPattern)){
                        NotificationService.notify(i18n.i18nString('patrn_module_valid_field_err'), "error");
                        return;
                    }
                    pullRemovedPatterns(angular.copy($scope.editFieldPattern),newTask);
                    $scope.editFieldPatternId = null;
                    $scope.editFieldPattern = null;
                };
                
                function updateComponentPatterns(component, msg,index,sortIndex){
                    BTFlowtaskService.updateComponentPatterns($scope.stream._id, component._id, {patterns: component.patternsArray}).then(function (res) {
                        //  $scope.editIntentPattern = null;
                        //  $scope.editIntentPatternId = null;
                        //  $scope.editEntityPattern = null;
                        //  $scope.editEntityPatternId = null;
                        if(component.type == "DialogIntent" || component.type == "intent"){
                            $.each($scope.intentPatternsObject, function(i, intentCopy){
                                if(component._id == intentCopy._id){
                                    $scope.intentPatternsObject[i].patterns = res.data.patterns ||[];
                                }
                            });
                        }else{
                            $.each($scope.entityPatternsObject, function(i, entityCopy){
                                if(component._id == entityCopy._id){
                                    $scope.entityPatternsObject[i].patterns =  res.data.patterns || [];
                                    $scope.editEntityPattern = $scope.entityPatternsObject[i];
                                }
                            });
                            $scope.entities = $scope.entityPatternsObject;
                        }
                        if(index >= 0){
                            NotificationService.notify(i18n.i18nString('patrn_module_pattern_updated_success'), "success");
                        }else if(sortIndex >= 0){
                            NotificationService.notify(i18n.i18nString('patrn_module_reorderd_sucess'), "success");
                        } else{
                            msg = msg || i18n.i18nString('patrn_module_added_sucess');
                            NotificationService.notify(msg, "success");
                        }
                        if(component.type == "DialogIntent" || component.type == "intent"){
                            $scope.iPatterns.newIntentPattern=""; 
                            $scope.iPatterns.editIntentPattern=""; 
                        }
                        else{
                            $scope.ePatterns.newEntityPattern="";
                            $scope.ePatterns.editEntityPattern="";
                            $scope.tPattern.editTaskPattern = "";
                        }
                    }, function (err) {
                        if(err.data.errors[0].code === "DENIED_ACTION"){
                            NotificationService.notify(err.data.errors[0].msg,"error");
                        }else{
                            var msg = i18n.i18nString('patrn_module_dup_patrn_err');
                            NotificationService.notify(msg,"error");
                        }
                    });
                }

                $scope.removeEditModeEntity = function(index){
                    if(index >= 0){
                        $(".hidingEntityPatterns"+index).removeClass('hide');
                        $(".editingEntityPatterns"+index).addClass('hide');
                    }
                };


                function validateIntentPattern(value) {
                    if (value && (value.split("*").length - 1) === 1) {
                        return true;
                    } else {
                        return false;
                    }
                }

                function validateEntityPattern(value) {
                    if (value && (value.split("*").length - 1) >= 1) {
                        return true;
                    } else {
                        return false;
                    }
                }
 
            $scope.bulbIcon = window.appConfig.CONTEXT_PATH+'/assets/images/24x29-bulbicon.png';   
            $scope.moveScrollToThis = function (key) {
                var keyEle ="";
                if ($scope.views.taskPatterns) {
                    keyEle = '#task' + key;
                } else if ($scope.views.fieldPatterns) {
                    keyEle = '#field' + key;
                } else if ($scope.views.intentPatterns) {
                    keyEle = '#intent' + key;
                } else {
                    keyEle = '#entity' + key;
                }
                if (!indexerUtil.isElementVisible(keyEle, true, '#botPatternsScroll')) {
                       $('#botPatternsScroll').animate({
                            scrollTop: $(keyEle).position().top
                        }, 'slow');
                }

            };

            // $scope.sortableOptions = {handle : ".sortBar", 'ui-floating': true, update: sortableCallback};
            // function sortableCallback (e, ui) {
            //     $timeout(function(){
            //         if(!$scope.selectedField){$scope.selectedField = $scope.fieldPatternsObject.filter(function(item) {
            //             return item.task._id ===$scope.clickedFieldIndex;});
            //         }
            //         $scope.saveOrUpdateFieldPatterns($scope.selectedField);
            //     }, 200);
                
            // }


            $scope.editTaskPattern = function(selectedTask,index){
                selectedTask.task_patterns[index].original =  selectedTask.task_patterns[index].original.replace(selectedTask.task_patterns[index].original,$scope.tPattern.editTaskPattern);
                var payload = {
                    patterns:[]
                };
                for(var i=0;i<$scope.selectedTask.task_patterns.length;i++){
                    var pattern = {};
                    pattern.intend = $scope.selectedTask.task_patterns[i].intend;
                    pattern.key = $scope.selectedTask.task_patterns[i].key;
                    pattern.input = $scope.selectedTask.task_patterns[i].original;
                    payload.patterns.push(pattern);
                }
                payload.resourceId = $scope.selectedTask._id;
                BTStreamsService.taskPattern($scope.stream._id,payload).then(function(res){
                    NotificationService.notify(i18n.i18nString('patrn_module_pattern_updated_success'), "success");
                    $(".hidingIntentPatterns"+index).removeClass('hide');
                    $(".editingIntentPatterns"+index).addClass('hide');
                });
            };

            $scope.removeEditMode = function(index){
                if(index >= 0){
                    $(".hidingIntentPatterns"+index).removeClass('hide');
                    $(".editingIntentPatterns"+index).addClass('hide');
                }
            };

            $scope.editFieldPatternData = function(selectedTask,index){
                selectedTask.fieldPatterns[$scope.fieldPatternName][index].original =  selectedTask.fieldPatterns[$scope.fieldPatternName][index].original.replace(selectedTask.fieldPatterns[$scope.fieldPatternName][index].original,$scope.tPattern.editTaskPattern);
                var payload = {
                    fieldPatterns:[]
                };
                for(var i=0;i<selectedTask.fieldPatterns[$scope.fieldPatternName].length;i++){
                    var pattern = {};
                    pattern.key = selectedTask.fieldPatterns[$scope.fieldPatternName][i].key;
                    pattern.input = selectedTask.fieldPatterns[$scope.fieldPatternName][i].original;
                    payload.fieldPatterns.push(pattern);
                }
                payload.fieldName = $scope.fieldPatternName;
                payload.resourceId = selectedTask._id;
                BTStreamsService.fieldPatternSortOrEdit($scope.stream._id,payload).then(function(res){
                    NotificationService.notify(i18n.i18nString('patrn_module_pattern_updated_success'), "success");
                    $(".hidingIntentPatterns"+index).removeClass('hide');
                    $(".editingIntentPatterns"+index).addClass('hide');
                });
            };
            
            function indexUpdateForTaskPatterns(mode) {
                $scope.taskPatternsObject = angular.copy($scope.initialObject);
                $scope.allTasks = $scope.tasks;
                $scope.fieldPatternsLength = _.filter($scope.allTasks,function(data){
                    if(data.fields && data.fields.length){
                        return data;
                    }
                });
                $scope.tasks.map(function (val) {
                    if ($scope.taskPatternsObject[val.name[0].toLowerCase()]) {
                        $scope.taskPatternsObject[val.name[0].toLowerCase()].push(val);
                    } 
                    // else {
                    //     $scope.taskPatternsObject['other'].push(val);
                    // }
                });
                if ($scope.views.taskPatterns) {
                    $scope.indexObject = angular.copy($scope.taskPatternsObject);
                }

                $scope.intentPatternsObject = _.uniq($scope.intentPatternsObject.concat($scope.tasks),"_id");
                $scope.intentPatternsObject =  _constants_.getAlphabeticallySortedArray($scope.intentPatternsObject,"name");
            }
              
            function prepareFieldIndexObject() {
                var fieldsArray = [];
                $scope.tasks.map(function (task) {
                    task.fields.map(function (field) {
                        var valueOfField = task.fieldPatterns && task.fieldPatterns[field.title] ? task.fieldPatterns[field.title].map(function(pattern){return pattern.original;}):[];
                        field.patterns = valueOfField;
                        field.oldPatterns = task.fieldPatterns && task.fieldPatterns[field.title];
                        var object = {task: task, fieldId: field.title, field: field};
                        fieldsArray.push(object);
                    });

                });
                fieldsArray = $filter('orderBy')(fieldsArray, 'fieldId');
                $scope.fieldPatternsObject = angular.copy($scope.initialObject);
                $scope.allFields = fieldsArray;
                $scope.allFields = _.uniq($scope.allFields, function(p){ return p.task._id;});
                $scope.fieldPatternsObject = fieldsArray || [];
                    if ($scope.views.fieldPatterns) {
                     $scope.indexObject = angular.copy($scope.fieldPatternsObject);
                    }
            }
                
            function indexUpdateForEntitiesOrIntentsPatterns(mode) {
                $scope.allIntent = $scope.intents;
                $scope.allEntity = $scope.entities;
                if (mode === 'intentPatterns') {
                    $scope.intentPatternsObject = angular.copy($scope.initialObject);
                    $scope.intentPatternsObject = $scope.intents;
                    $scope.intentPatternsObject =  $scope.intentPatternsObject.concat($scope.tasks);
                    $scope.intentPatternsObject =  _constants_.getAlphabeticallySortedArray($scope.intentPatternsObject,"name");
                } else {
                    // $scope.entityPatternsObject = angular.copy($scope.initialObject);
                    $scope.entityPatternsObject = $scope.entities;
                    $scope.atMentionsData = [];
                    $.each($scope.entityPatternsObject, function(i, entity){
                        if(entity.entityType !== "composite"){
                            var _object = {label:entity.name};
                            $scope.atMentionsData.push(_object);
                        }
                    });
                }
                if ($scope.views.intentPatterns) {
                    $scope.indexObject = angular.copy($scope.intentPatternsObject);
                }
                if ($scope.views.entityPatterns) {
                    $scope.indexObject = angular.copy($scope.entityPatternsObject);
                }
            }
            
                function updateIndexHeader(mode) {
                    switch (mode) {
                        case 'taskPatterns':
                            $scope.indexObject = angular.copy($scope.taskPatternsObject);
                            break;
                        case 'fieldPatterns':
                            $scope.indexObject = angular.copy($scope.fieldPatternsObject);
                            break;
                        case 'intentPatterns':
                            $scope.indexObject = angular.copy($scope.intentPatternsObject);
                            break;
                        case 'entityPatterns':
                              $scope.indexObject = angular.copy($scope.entityPatternsObject);
                            break;
                    }
                }

                $scope.processFieldPattern = function (inputArr) {
                    var outArray = [];
                    inputArr.forEach(function (input) {
                        if(input){
                            input=input.split("_*").join("~~FP~~");
                            input=input.split("* ").join("");
                            input=input.split("~~FP~~").join("*");
                            outArray.push(input);
                        }
                    });
                    return outArray;
                };

                $scope.steps      = {
                    currentPatternStage : 0,
                    currentFieldPatternStage : 0
                };

                $scope.views = {
                    taskPatterns  : false,
                    fieldPatterns : false,
                    intentPatterns :true,
                    entityPatterns:false
                };

                $scope.fieldPatternSearch = '';
                $scope.taskPatternSearch  = '';
                $scope.currentScreen  = "";
                $scope.showType = function(screen){
                    Object.keys($scope.views).map(function(key){
                        $scope.views[key] = false;
                        $('.patternsScrollTop').scrollTop(0);
                    });
                    $scope.views[screen] = true;
                    $scope.fieldPatternSearch = '';
                    $scope.taskPatternSearch  = '';
                    updateIndexHeader(screen);
                    $scope.currentScreen = screen;
                    $scope.addFieldPatternClass = function(){
                        $timeout(function(){
                            $('.fieldPatterns').addClass('removeFieldPatternsBorders');
                        },350);
                    };
                    $timeout(function(){
                        $scope.selectedTask=null;
                        $scope.clickedTaskIndex = -1;
                        $scope.clickedFieldId = null;
                        $scope.clickedFieldId = -1;
                        $scope.clickedIntentIndex = -1;
                        $scope.selectedIntent=null;
                        $scope.editIntentPatternId=null;
                        $scope.clickedEntityIndex = -1;
                        $scope.selectedEntity=null;
                        $scope.editEntityPatternId=null;
                        $scope.selectIntentSection = null;
                        $scope.selectedIntent = null;
                    },200);
                };

                $scope.gSearchCb.showType = $scope.showType;
                if($workflowService.storeSearchQry().userSearchQueryFlag) {
                    $scope.gSearchCb.search = $workflowService.storeSearchQry().searchQry;
                }
                else {
                    $scope.gSearchCb.search = '';    
                }
                

                function loadPatterns(){

                    $scope.taskPatternsLoading = true;

                    $scope.tasks.map(function(task){
                        delete task.task_patterns;
                    });

                    BTStreamsService.getPatterns($scope.stream._id)
                    .then(function(res){
                        res.data.map(function(pattern){
                            var obj = {};
                            Object.keys(pattern).map(function(key){
                                if(key === "resourceId"){
                                    obj._id  = pattern.resourceId;
                                }else{
                                    obj.name = key;
                                    obj.patterns = pattern[key];
                                }
                            });
                            $scope.tasks.map(function(task){
                                if(task._id === obj._id){
                                    task.task_patterns = ng.copy(obj.patterns);
                                }
                            });
                        });
                        $scope.taskPatternsLoading = false;
                        indexUpdateForTaskPatterns();
                    },function(err){
                        $scope.taskPatternsLoading = false;
                    });

                }

                $scope.context = $scope.context || {};
                $scope.context.addPattern      = addPattern;
                $scope.context.addFieldPattern = addFieldPattern;

                $scope.$watch('context',function(newVal,oldVal){
                    if(_.isObject(newVal)){
                        $scope.context.addPattern      = addPattern;
                        $scope.context.addFieldPattern = addFieldPattern;
                    }
                });


                function addPattern(pattern,event,task){
                    $scope.pattern        = {};
                    $scope.pattern.show   = true;
                    $scope.pattern.text   = pattern;
                    $scope.pattern.intent = task ? task._id : '';
                    $scope.pattern.showTaskPattern=true;
                    $timeout(function(){
                        $('.add-pattern').modal('show');
                    });
                    if(event){
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }

                function addFieldPattern(pattern,event,task){
                    $scope.pattern        = {};
                    $scope.pattern.show   = true;
                    $scope.pattern.text   = pattern;
                    $scope.pattern.intent = task ? task._id : '';
                    $scope.pattern.showFieldPattern=true;
                    $timeout(function(){
                        $('.add-field-pattern').modal('show');
                    });
                    if(event){
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
                $scope.clearSearch = function() {
                    $scope.$parent.goBack('.btPatternsModal');
                    $scope.$parent.resetDisplayTabID();
                    $timeout(function () {
                        $scope.gSearchCb.search = "";
                    }, 150);
                };

                $scope.$on();
                $scope.cancelAddPattern = function () {
                    $('.add-pattern').modal('hide');
                    $scope.pattern.show = false;
                    $scope.pattern.showTaskPattern = false;
                };

                $scope.cancelFieldPattern = function () {
                    
                };

              $scope.saveAddPattern = function(){
                    var task = $scope.getSelectedTaskForPattern();
                    createPattern(task,$scope.pattern.text,false);
             
                };
                
            function createPattern(task, text,isInlineMode) {
                var payload = {
                    input: text,
                    intend: task.name,
                    resourceId: task._id
                };
                $scope.saving = true;
                BTStreamsService.createPattern(streamId, payload)
                .then(function () {
                    if (!isInlineMode) {
                        $scope.cancelAddPattern();
                    }
                    $scope.tPattern.newTaskPattern = "";
                    $scope.cancelTaskPatternId();
                    $scope.editTaskPattern = null;
                    loadPatterns();
                    $scope.saving = false;
                    NotificationService.notify(i18n.i18nString('patrn_module_added_sucess'), "success");
                }, function (err) {
                    var msg = getErrorMsg(err, i18n.i18nString('patrn_module_adding_field'));
                    NotificationService.notify(msg, "error");
                    $scope.saving = false;
                });
            }
            
            function validateFieldPattern(value) {
                if (value && (value.split("*").length - 1) >= 1) {
                    return true;
                } else {
                    return false;
                }
            }
                
                

                $scope.showPatterns = function(index){
                    if($scope.steps.currentPatternStage == index){
                        $scope.steps.currentPatternStage = -1;
                    }else{
                        $scope.steps.currentPatternStage = index;
                    }
                };

                $scope.showFieldPatterns = function(index){
                    if($scope.steps.currentFieldPatternStage == index){
                        $scope.steps.currentFieldPatternStage = -1;
                    }else{
                        $scope.steps.currentFieldPatternStage = index;
                    }
                };


                $scope.getSelectedTaskForPattern = function(){
                    var task = $scope.tasks.filter(function(task){
                        return task._id == ($scope.pattern &&  $scope.pattern.intent);
                    })[0];
                    return task;
                };

                $scope.goBack = goBack;

                function arrangeData(data){
                    var entities = [];
                    data.Entities.map(function(entity){
                        var obj    = {};
                        obj.name   = entity.field;
                        obj.type   = entity.metadata;
                        obj.value  = entity.value;
                        entities.push(obj);
                    });
                    data.Entities = entities;
                    return data;
                }

                function goBack(){
                    $location.path(window.appConfig.CONTEXT_PATH);
                }


                function getDataFromServer(id) {
                    getEntitiesAndIntents();
                    $q.all([BTAlertsService.getAlerts(id), BTActionsService.getActions(id)])
                            .then(function (res) {
                                $workflowService.alertTasks(res[0].data);
                                $workflowService.actionTasks(res[1].data);
                                loadingEntities(id);
                            });

                }
                function loadingEntities(id,task,callbackFun){
                    var tasks    = [];
                    $scope.taskFieldPatternsLoading = true;
                    if(task){
                            tasks.push(task);
                        }
                        tasks = tasks.concat($workflowService.alertTasks());
                        tasks = tasks.concat($workflowService.actionTasks());
                        
                        $scope.findParenttasks(tasks);
                        tasks = tasks.map(function(task){
                            if(_.isArray(task.alertFieldsDefinition)){
                                task.fields = _.clone(task.alertFieldsDefinition || []);
                            }else if(_.isArray(task.payloadField) && _.isArray(task.queryField)){
                                task.fields = (task.payloadField || []).concat(task.queryField);
                            }
                            var patterns = [];
                                                  
                            Object.keys(task.fieldPatterns || {})
                            .map(function(field){
                                var valueOfField = [];
                                    valueOfField = task.fieldPatterns[field].map(function(pattern){return pattern.original;});
                                if (valueOfField.length) {
                                    patterns.push({
                                        key: task.fieldPatterns[field].map(function (pattern) {
                                            return pattern.key;
                                        }),
                                        fieldName: field,
                                        value: valueOfField,
                                        oldPatterns: task.fieldPatterns[field]
                                    });
                                }
                            });
                            task.field_patterns = patterns;
                            return task;
                        });
                        $scope.tasks    = JSON.parse(JSON.stringify(tasks));
                        $scope.allTasks = $scope.tasks;
                        if(callbackFun){
                            callbackFun();
                        }
                        $scope.taskFieldPatternsLoading = false;
                        prepareFieldIndexObject();
                        loadPatterns();       
                }




            function compareComponentPatternsAndSave(old, comp) {
                if (old && old.patternsArray && comp && comp.patternsArray && (old.patternsArray.join(',') !== comp.patternsArray.join(','))) {

                    BTFlowtaskService.updateComponentPatterns($scope.stream._id, old._id, {patterns: comp.patternsArray}).then(function (res) {
                     $scope.editIntentPattern = null;
                     $scope.editIntentPatternId = null;
                     $scope.editEntityPattern = null;
                     $scope.editEntityPatternId = null;
                        NotificationService.notify(i18n.i18nString('patrn_module_added_sucess'), "success"); 

                    }, function () {

                    });
                }
            }

                function pullRemovedPatterns(task,newTask){
                    var removedOnes = [];
                    var addedOnes   = [];
                        task.fields.map(function(field,i){
                            var newPattern = newTask.fields[i].patterns;
                            var oldPattern = field.patterns;
                            var removed    = _.difference(oldPattern,newPattern);
                            var added      = _.difference(newPattern,oldPattern);
                            if(removed.length > 0){
                                removedOnes.push({
                                    taskId : task._id,
                                    field : field.title,
                                    value : removed,
                                    patterns:field.oldPatterns
                                });
                            }
                            if(added.length > 0){
                                addedOnes.push({
                                    taskId : task._id,
                                    field : field.title,
                                    value : added
                                });
                            }
                        });
                
                    handlePatternAddition(addedOnes);
                    handlePatternRemoval(removedOnes);
                }

                function handlePatternRemoval(patternsToBeRemoved){

                    var patterns = [];

                    patternsToBeRemoved.map(function(stalePattern){
                        stalePattern.value.map(function(value){
                            stalePattern.patterns.map(function(patternInfo){
                                if(patternInfo.original == value){
                                    patterns.push({
                                        taskId : stalePattern.taskId,
                                        field : stalePattern.field,
                                        patternId : patternInfo.key
                                    });
                                }
                            });
                        });
                    });

                    patterns.map(function(pattern){
                        $scope.deleteFieldPattern({
                            _id : pattern.taskId
                        },{
                            key : pattern.patternId
                        },pattern.field,true);
                    });

                }

                function handlePatternAddition(patternsToBeAdded){
                    patternsToBeAdded.map(function(pattern){
                        pattern.value.map(function(value){
                            $scope.saveFieldPattern(pattern.taskId,pattern.field,value,true);
                        });
                    });
                }
                
                
                    function getEntitiesAndIntents() {
                       
                        var entities = [];
                        var intents = [];
               
                        resolveEntitiesOrIntents("intents");
                        resolveEntitiesOrIntents("entities");

                    }

               
                             
                var getFlowTasks = function(){
                    var deferred = $q.defer();
                    BTFlowtaskService.getFlowtaks($workflowService.selectedStream()._id).then(function(response){
                        deferred.resolve(response);
                    },function(err){
                        deferred.reject(err);
                    }); 
                    return deferred.promise;

                };
                function resolveEntitiesOrIntents(type,intent,callbackFun) {
                    $scope.entities = [];
                    BTFlowtaskService.getEntitiesOrIntents(streamId, type).then(function (res) {
                        if (res.data) {
                        if(type ==="entities"){
                            getFlowTasks().then(function(response){
                                 var entitiesList = $scope.entities.concat(res.data);
                                 $scope.dialogs = response.data;
                                 var _entitiesInDialogs = []; 
                                $.each($scope.dialogs, function(i, dialog){
                                 
                                    var _entitynodes = _.filter(dialog.nodes, {type: "entity"});
                                    var _entityIds = _.pluck(_entitynodes, "componentId");
                                    _entitiesInDialogs = _.union(_entitiesInDialogs, _entityIds); 
                                    
                                });
                                var tempEntities = [];
                                // $.each(entitiesList, function(i, entity){
                                //     var index = $.inArray(entity._id, _entitiesInDialogs);
                                //     if(index!== -1){
                                //         tempEntities.push(entity);
                                //     }
                                // }); BB-4847

                                $scope.entities = entitiesList;

                                 prepareEntityPatternsArray();
                               
                                },function(err){

                                });
                           
                           
                        }else{
                            if(intent){
                                $scope.intents = [];
                            }
                            $scope.intents = $scope.intents.concat(res.data);
                             getFlowTasks().then(function(response){
                                    $scope.dialogs = response.data;
                                    var hiddenHelpNodes = _.filter($scope.dialogs,function(dialog){
                                        return dialog.isHidden;
                                        
                                    });
                                     var hiddenDialogTasks = _.filter($scope.dialogs,function(dialog){
                                        return dialog.isDeleted;
                                        
                                    });
                                 var hiddenHelpIds = _.pluck(hiddenHelpNodes,'_id');
                                 var hiddenDialogTasksIds = _.pluck(hiddenDialogTasks,'_id');
                                 $scope.intents.map(function(intent){
                                    if($.inArray(intent.dialogId,hiddenHelpIds) !== -1){
                                        intent.isHidden = true;
                                    }
                                    if($.inArray(intent.dialogId,hiddenDialogTasksIds) !== -1){
                                        intent.isDeleted = true;
                                    }
                                 });
                            });
                            $scope.allIntent = $scope.intents;
                            $scope.findParenttasks($scope.intents);
                            preapareIntentsPatternsArray();
                            if(callbackFun){
                                callbackFun();
                            }
                            $timeout(function(){
                                $scope.loadingPatterns = false;
                            },400);
                            
                        }

                        }
                    }, function (error) {

                    });
                }
                             
               

            function preapareIntentsPatternsArray() {
                $scope.intents.map(function(intent){
                    intent.patternsArray =[];
                    intent.patterns = intent.patterns || [];
                    intent.patterns.forEach(function (msg) {
                        msg.original = decodePattern(msg.original);
                     });
                   intent.patterns.map(function(pattern){
                      intent.patternsArray.push(pattern.original); 
                   });
                });
                    indexUpdateForEntitiesOrIntentsPatterns("intentPatterns");
            }
            
            function prepareEntityPatternsArray() {
                $scope.entities.map(function (entity) {
                    entity.patternsArray = [];
                    entity.patterns = entity.patterns || [];
                    entity.patterns.forEach(function (msg) {
                        msg.original = decodePattern(msg.original);
                     });
                    entity.patterns.map(function (pattern) {
                        entity.patternsArray.push(pattern.original);
                    });
                });
                    indexUpdateForEntitiesOrIntentsPatterns("entityPatterns");   
            }
                function getErrorMsg(err,defaultMsg){
                    err = err && err.data;
                    return (err && err.errors && err.errors[0] && err.errors[0].msg) || defaultMsg;
                }
                
                
                // FOR UPGRADING THE PUBLISHED TASK//
               $scope.upgrade = function () {
                   $scope.isGlobalWorkProgress= true;
                   $scope.loaderMessage = i18n.i18nString('upgrading_task_label');
                var taskType = $scope.getTaskType($scope.currentTask);
                $scope.upgradeWorkflow($scope.currentTask, taskType,$scope.selectedType,$scope.clickedIntentIndex);
            };
            
            $scope.getTaskType = function (task) {
                if (task && task.hasOwnProperty('alertFieldsDefinition')) {
                    return "alert";
                } else if (task && task.hasOwnProperty('isReport')) {
                    return "action";
                } else if (task && task.type == "DialogIntent") {
                    return "flowtask";
                } else {
                    return "";
                }
            };
          
            $scope.upgradeWorkflow = function (task, type,selectedType,clickedIntentIndex) {
                
                if (type === "alert") {
                    BTAlertsService.upgradeBTAlert(task._id).then(function (response) {
                        BTAlertsService.upgradeMPAlert(task._id, response.data._id).then(function (upgradeRes) {
                            BTAlertsService.configured(upgradeRes.data._id).then(function (configRes) {
                                $scope.intentPatternsObject[$scope.currenttaskIndex].isParent = true;
                                function callbackFun(){
                                    if($scope.currentTab === "task"){
                                        $scope.onClickTaskindex(configRes.data[0],$scope.currenttaskIndex);
                                    }else if($scope.currentTab === "field"){    
                                        $scope.editFieldPatternObject(configRes.data[0],$scope.currentFieldId,$scope.currentIndex);
                                    }
                                }
                                loadingEntities(null,configRes.data[0],callbackFun);
                                $scope.isGlobalWorkProgress= false;
                             }, function (err) {
                                $scope.isGlobalWorkProgress= false;
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                                return;
                            });

                        }, function (err) {
                            $scope.isGlobalWorkProgress= false;

                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;

                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                } else if (type === "action") {
                    BTActionsService.upgradeBTAction(task._id).then(function (response) {
                        BTActionsService.upgradeMPAction(task._id, response.data._id).then(function (upgradeRes) {
                         BTActionsService.configured(upgradeRes.data._id).then(function(configRes){
                        $scope.intentPatternsObject[$scope.currenttaskIndex].isParent = true;
                        function callbackFun(){
                            if($scope.currentTab === "task"){
                                $scope.onClickTaskindex(configRes.data[0],currenttaskIndex);
                            }else if($scope.currentTab === "field"){    
                                $scope.editFieldPatternObject(configRes.data[0],$scope.currentFieldId,$scope.currentIndex);
                            }
                        }
						loadingEntities(null,configRes.data[0],callbackFun);
                        $scope.isGlobalWorkProgress= false;
					},function(err){
                        $scope.isGlobalWorkProgress= false;
						NotificationService.notify(err.data.errors[0].msg,'error');
						return;
					});
                        }, function (err) {
                           $scope.isGlobalWorkProgress= false;
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;
                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                } else if (type === "flowtask") {
                    BTFlowtaskService.upgradeFlowtask($workflowService.selectedStream()._id, task.dialogId).then(function (res) {
                        function callbackFun(){
                            $scope.onClickIntentindex(res.data.nodes[0],0,clickedIntentIndex,selectedType,res.data.nodes[0].componentId);
                        }
                        resolveEntitiesOrIntents("intents",res.data,callbackFun);
                        $scope.isGlobalWorkProgress= false;
//                        $scope.editIntentPatternObject(res.data);
                        $scope.cancelIntentPattern();
                        $scope.editIntentPatternId = res.data.nodes[0].componentId;
                        $timeout(function () {
                            $('.intentPattern-select2 .select2-input').focus();
                        }, 350);
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;
                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                }               
            };

           $scope.findParenttasks = function(taskObject){
                $.each(taskObject,function(i,task){
                    if(task.hasOwnProperty('parentId')){
                        $scope.upgradedTasks.push(task.parentId);
                    }
                });
                $.each(taskObject,function(i,task){
                    $.each($scope.upgradedTasks,function(j,upgradedId){
                    if(task._id === upgradedId){
                        task.isParent= true;
                    }
                 });
                 });
            };
            // FOR UPGRADING THE PUBLISHED TASK- END//
            
            $scope.updateFooterHeader = function () {
                $scope.footerInfoTitle = i18n.i18nString('pattern_name');
                $scope.footerHeaderId = "bt-Patterns";
                $scope.footerPanelId = "bt-Patterns-panel";
                $scope.nameDescription = i18n.i18nString('patrn_module_upgrade_task_desc');
                return true;
            };
            angular.element($window).on('resize', function (e) {
                var height = $window.innerHeight;
                height = height - 210;
                $('#botPatternsScroll').css('height', (height-70) + 'px');
                $('.pattern-parentDiv').css('height', height + 'px');
            });

            

            var retrieveData = function(){
                 $scope.loadingPatterns = true;
                 getDataFromServer($scope.stream._id);
                 $timeout(function(){
                    angular.element($window).trigger('resize');
                 });
                  
            }();

            $scope.$emit('nestedComponentLoaded',{'id':'patterns','flag':false});
            //Add below whenever nestedComponentLoaded is FINALLY emitted.
            $timeout(function(){
                $scope.$emit('gSearchLoad');
            });

            
            $scope.trainIntents = function(){
                   $scope.trainStatus.saving = true;
                   BTStreamsService.trainUtterances($workflowService.selectedStream()._id)
                    .then(function(res) {
                            if(res){
                                    $scope.trainStatus.saving = true;
                                    $scope.trainStatus.success = false;
                                    $scope.trainStatus.failed = false;
                                    $rootScope.$emit('triggerAutoTrainStatusPoll');
                                    $rootScope.$broadcast('getProgressDockStatus');
                                    NotificationService.notify(i18n.i18nString('bot_train'), "info");
                            }
                            
                        },
                        function(err) {
                               $scope.trainStatus.saving = false;
                                $scope.trainStatus.success = false;
                                $scope.trainStatus.failed = true;
                               if (err.data.errors.length > 0) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            } else {
                                NotificationService.notify(i18n.i18nString('bot_train_failure'), "error");
                            }
                        });
            };

            $rootScope.$on('patternTrainFinished', function($event) {
                $scope.trainStatus = { "success": true, "failed": false, "saving": false };
                NotificationService.notify(i18n.i18nString('bot_trained_successfully'), "success");
               
            });
            $rootScope.$on('patternTrainFailed',function($event){
                  $scope.trainStatus = {"success": false, "failed": true, "saving": false};
                  NotificationService.notify(i18n.i18nString('bot_train_failure'), "error");
              });

            var checkForTrain = function(){
                var _currentLanguage = $workflowService.currentLanguage();
                if(_notSupportedTrainLanguages.indexOf(_currentLanguage) >= 0){
                    $scope.showTrain = false;
                }else{
                    $scope.showTrain = true;
                }
                    
            };

            checkForTrain();

            $scope.patternsCB.getDataFromServer = getDataFromServer;

            $scope.patternsCB.updateIntentPattern = function(res){
                $scope.intentPatternsObject[$scope.clickedIntentIndex] = res;
            };




            }]);
                


}(angular));

;(function (ng) {

    'use strict';

    var _module = ng.module('synonyms-module', []);


    _module.controller('SynonymsModuleCtrl', ['$window', '$element','$scope', '$workflowService', '$location', '$routeParams', 'BTStreamsService', '$q', 'BTAlertsService', 'BTActionsService', 'BTFlowtaskService', '$timeout', 'color', '$filter', '_constants_', 'NotificationService', 'form_util','indexerUtil','env_conf','accessControlService','$rootScope','$interval','i18n','mixPanel',
        function ($window, $element, $scope, $workflowService, $location, $routeParams, BTStreamsService, $q, BTAlertsService, BTActionsService, BTFlowtaskService, $timeout, color, $filter, _constants_, NotificationService, form_util,indexerUtil, env_conf,accessControlService,$rootScope,$interval,i18n,mixPanel) {
           
            
             //Header toggle related//
            $scope.filterToggle = $workflowService.selectedStreamState();
//            $scope.updateStreamState = function(evn,streamState){
//            $scope.filterToggle = $workflowService.selectedStreamState();
//            $scope.filterToggle = streamState;
//            };
//            $scope.$on("updateStreamState",$scope.updateStreamState);
            //END--Header toggle related//
           
            $scope.displayMode=accessControlService.getAccessRight('BOTBUILDER_NATURAL_LANGUAGE');
            $scope.synonym = {};
            $scope.synonymsSelect2Options={maxTagLength:128};
            $scope.constants = _constants_;
            $scope.stream = $workflowService.cloneData($workflowService.selectedStream());
            $scope.tasks = [];
            $scope.oldTasks = [];
            $scope.title = 'Synonyms';
            $scope.entities = [];
            $scope.entity={};
            $scope.upgradedTasks= [];
            $scope.showLoading = true;
            $scope.placeholderMsg = i18n.i18nString('Synonym_word_placeholder');
            $scope.entityDevelopment = i18n.i18nString('entity_development');
            $scope.entityPublished   = i18n.i18nString('entity_published');
            $scope.synonymsDevelopment=i18n.i18nString('synonyms_development');
            $scope.synonymsPublished =i18n.i18nString('synonyms_published');
            $scope.enableSynonyms = '';
            $scope.ellipsisGray = env_conf['context-url'] + '/assets/icons-new/ellipsis/overflow-2.svg';
            $scope.bulbIcon = window.appConfig.CONTEXT_PATH + '/assets/images/24x29-bulbicon.png'; 
            $scope.searchIconGray = env_conf['context-url']+'/assets/icons/searchIconGray.svg';
            $scope.searchClose = env_conf['context-url']+'/assets/icons/fa-close.svg';
            $scope.trashIcon = env_conf['context-url']+'/assets/icons-new/delete-trash/trash-red.svg';
            $scope.pencilIcon = env_conf['context-url']+'/assets/icons-new/edit-pencil/pencil-gray.svg';
            $scope.currentEditItem = {};
            var updateKey = false; 
         
//            $scope.fieldCount = 0;
//            $scope.entityCount = 0;assets/icons-new/edit-pencil/pencil-gray.svg
            $scope.initialObject = {
                a: [], b: [], c: [], d: [], e: [], f: [], g: [], h: [], i: [], j: [], k: [], l: [], m: [], n: [], o: [], p: [], q: [], r: [], s: [], t: [], u: [], v: [], w: [], x: [], y: [], z: [], other: []

            };
             if($scope.displayMode === 'VIEW'){
                $(document).keydown(function (e) 
                {
                var keycode1 = (e.keyCode ? e.keyCode : e.which);
                if (keycode1 === 0 || keycode1 === 9) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            }
            if(!$scope.hideUi){
                $("#btSynonymsmodal").modal("show");
            }

            $scope.botSynonymObject = $workflowService.cloneData($scope.initialObject);
            $scope.fieldSynonymObject = $workflowService.cloneData($scope.initialObject);
            $scope.entitySynonymObject = $workflowService.cloneData($scope.initialObject);
            $scope.indexObject = $workflowService.cloneData($scope.initialObject);
            $scope.showBotSynonymForm = false;
            $scope.editBotSynonymId = null;
            $scope.editBotSynonym = null;
            $scope.editEntitySynonymId = null;
            $scope.editEntitySynonym = null;
            $scope.editFieldSynonym = null;
            $scope.editFieldSynonymId = null;
            $scope.assetsBase = env_conf['assets-url'];
            var _selectedLanguage = $workflowService.currentLanguage();
            $scope.currentLanguage = $workflowService.currentLanguage();
            $scope.supportedLanguages = $workflowService.supportedLanguages();
            $scope.languageList = {};
            $scope.trainShow = false;
            $scope.showTrainSavingSyn = false;
            $scope.editMode = [];
            $scope.trainStatus = { "success": true, "failed": false, "saving": false };
            setTimeout(function () {
                $rootScope.$emit('pefectScrollUpdate');
            }, 2000);

            $.each($scope.supportedLanguages,function(i,language){
                $scope.languageList[language.value] = language.name;
            });

            if (!_.isObject($scope.stream) || (_.isObject($scope.stream) && Object.keys($scope.stream).length === 0)) {
                $scope.goBack();
                return;
            }
            $scope.showEmojiModal = function(){
                $('#emojiModal').modal('show');
            };
            $scope.loadEmojis = function(){
                BTStreamsService.importEmojis($workflowService.selectedStream()._id)
                .then(function(res) {
                    if(res && res.data && res.data.synonyms){
                    $scope.stream.synonyms = res.data.synonyms;
                    }
                    transformBotSynonyms();
                    $('#emojiModal').modal('hide');
                        NotificationService.notify( i18n.i18nString('bot_train'), "info");
                        NotificationService.notify( i18n.i18nString('emojiImportedInfo'), "info");
                    },
                    function(err) {
                           if (err && err.data && err.data.errors && err.data.errors.length > 0 && err.data.errors[0] &&  err.data.errors[0].msg) {
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        } else {
                            NotificationService.notify(i18n.i18nString('bot_train_failure'), "error");
                        }
                    });
            };
            $scope.changeEditBotSynonym = function (synonym, key2,index) {
                // $scope.editBotSynonym = null;
                // $scope.editBotSynonymId = null;
                $scope.currentEditItem =  null;
                if(synonym && (synonym.key + key2) === $scope.editBotSynonymId) { //close
                    $scope.editBotSynonym = null;
                    $scope.editBotSynonymId = null;
                }else{
                     $scope.cancelBotSynonym();
                    $scope.editBotSynonym = synonym;
                    $scope.editBotSynonymId = synonym.key + key2;
                    $scope.editMode[key2] = [];
                    $scope.editMode[key2][index] = false;
                    $timeout(function () {
                        $('input[ti-autosize]').focus();
                    }, 250);
                }
            };
            $scope.changeEditEntitySynonym = function (entity) {
                if($scope.filterToggle === "indevelopment"){
                    // if(entity && entity._id === $scope.editEntitySynonymId) {
                    //     $scope.editEntitySynonym = null;
                    //     $scope.editEntitySynonymId = null;
                    // }
                    // else{
                    //     $scope.cancelEntitySynonym();
                    //     $scope.editEntitySynonym = JSON.parse(JSON.stringify(entity));
                    //     $scope.editEntitySynonymId = entity._id;
                       
                    // }
                    $scope.editEntitySynonym = JSON.parse(JSON.stringify(entity));
                    $scope.editEntitySynonymId = entity._id;
                    $timeout(function(){
                         $scope.cb.loadingSynonyms = false;
                    },200);
                   
                }
            };

            $scope.editSynonym = function(e,index,key,synonym){
                e.stopPropagation();
                $scope.editMode[key] = [];
                $scope.editMode[key][index] = true;
                 $scope.currentSynonym = $workflowService.cloneData(synonym);
                $scope.previousValue = $scope.currentSynonym;
                setTimeout(function(){
                    $(e.currentTarget).parent().find('input').focus();
                    $('.synonym-item-label').find('input').addClass('editExpand');
                },100);

                
            };  

            $scope.closeEdit = function(e,index,key,synonym){
                e.stopPropagation();
                $scope.editMode[key] = [];
                $scope.editMode[key][index] = false;
                setTimeout(function(){
                    $('.synonym-item-label').find('input').removeClass('editExpand');
                },100);
                if(synonym.key !== $scope.previousValue.key){
                    $scope.updateSynonymKey(synonym,index,key); 
                }
               
            };

            $scope.closeTrainSaveDiv = function() {
                $scope.showTrainSavingSyn = false;
            };

            $scope.updateSynonymKey = function(synonym,index,key){
                $scope.editMode[key] = [];
                $scope.editMode[key][index] = false;
                _.map($scope.synonyms,function(s){
                    if(s.key === synonym.key){
                         s.key = $scope.previousValue.key;
                    }
                });
                updateKey = true;
                saveTaskSynonyms(null,null,null,true,updateKey);
            };

            function synnoymsAutoTrainStatus (){
                BTStreamsService.getMLSynonym($workflowService.selectedStream()._id)
                .then(function(res) {
                    if((res.data.intentParams && res.data.intentParams.hasOwnProperty('useSynonyms')) || ($scope.stream && $scope.stream.confidenceConfigs && $scope.stream.confidenceConfigs.length)) {
                        $scope.enableSynonyms = (res.data.intentParams && res.data.intentParams.useSynonyms)?res.data.intentParams.useSynonyms : $scope.stream.confidenceConfigs && $scope.stream.confidenceConfigs.length && $scope.stream.confidenceConfigs[1]['useBotSynonyms']?$scope.stream.confidenceConfigs[1]['useBotSynonyms']:false;
                    }
                    
                    BTStreamsService.autoTrainStatus($workflowService.selectedStream()._id).then(function(res) {
                        if ($scope.enableSynonyms && res && res.data && res.data.hasOwnProperty('isMlInSyncWithSynonyms') && !res.data.isMlInSyncWithSynonyms) {
                            $scope.trainShow = true;
                        } else{
                            $scope.trainShow = false;
                        }
                        if(res.data.trainingStatus === 'Finished'){
                            $scope.showTrainSavingSyn = false;
                            $scope.trainStatus.saving = false;
                        } else if(res.data.trainingStatus === 'Failed'){
                            $scope.showTrainSavingSyn = false;
                            $scope.trainStatus.saving = false;
                        }
                        else if($scope.enableSynonyms){
                            $scope.showTrainSavingSyn = true;
                            $scope.trainStatus.saving =true;
                        } else {
                            $scope.trainStatus.saving =true;
                        }
                    },
                    function(err) {
                        $scope.showTrainSavingSyn = false;
                        $scope.trainStatus.saving = false;
                        var _msg = i18n.i18nString('fetching_ml_status_err');
                        NotificationService.notify(_msg, "error");
                    });
                    
                }, function(err) {

                });
            }
            
            $scope.trainBot = function() {
                BTStreamsService.trainUtterances($workflowService.selectedStream()._id)
                    .then(function(res) {
                            $scope.showTrainSavingSyn = true;
                            $scope.trainShow = false;
                            $scope.trainStatus = {
                                'success': false,
                                'failed': false,
                                'saving': true
                            };
                            $rootScope.$emit('triggerAutoTrainStatusPoll');
                            $rootScope.$broadcast('getProgressDockStatus');
                            $(".trainingProgress").addClass('open');
                            NotificationService.notify( i18n.i18nString('bot_train'), "info");
                        },
                        function(err) {
                               if (err.data.errors.length > 0) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            } else {
                                NotificationService.notify(i18n.i18nString('bot_train_failure'), "error");
                            }
                        });
            };
            var getProgressDockStatusDestroy=$rootScope.$on('getProgressDockStatus', function() {
                $scope.trainStatus = {
                    'success': false,
                    'failed': false,
                    'saving': true
                };
            });

            $rootScope.$on('SynonymsTrainFinished', function() {
                $scope.trainStatus = {
                    'success': true,
                    'failed': false,
                    'saving': false
                };
            });

             var synonymsTrainFailedDestroy=$rootScope.$on('SynonymsTrainFailed', function() {
                $scope.trainStatus = {
                    'success': false,
                    'failed': true,
                    'saving': false
                };
            });

             var botSynonymsToggleDestroy=$rootScope.$on('botSynonymsToggle', $scope.trainBot);

            $scope.changeEditFieldSynonym = function (task,fieldId,upgradeViewMode) {
                 $scope.currentTask = task;
                 $scope.currentFieldId= fieldId;
                 if(upgradeViewMode){
                    $scope.upgradeViewMode = upgradeViewMode.toUpperCase();
                 }
                 if($scope.viewMode){
                    $scope.viewMode = $scope.viewMode.toUpperCase();
                 }
                 if(task && (task._id+fieldId) === $scope.editFieldSynonymId) {//close
                            $scope.editFieldSynonym = null;
                            $scope.editFieldSynonymId = null;
                        }else{
                            $scope.cancelFieldSynonymIndex();
                            $scope.currentEditItem = $workflowService.cloneData(task);
                            $scope.editFieldSynonym = $workflowService.cloneData(task);
                            $scope.editFieldSynonymId = task._id+fieldId;
                            $timeout(function () {
                                $('input[ti-autosize]').focus();
                            }, 350);
                        }  
            };
            $scope.api = {
                addSynonym: addTaskSynonym,
                addFieldSynonym: addFieldSynonym,
                openManageTaskSynonym: openManageTaskSynonym,
                openManageFieldSynonym: openManageFieldSynonym
            };

            $scope.views = {
                botsynonyms: true,
                fieldsynonyms: false,
                entitysynonyms: false
            };                


            $scope.botsearch = '';
            $scope.fieldsearch = '';
            $scope.context = $scope.api;
            $scope.synonymsCurrentPage = 1;
            $scope.taskCurrentPage = 1;
            $scope.showIndex = 0;
            $scope.manageFieldSynonym = {};
            $scope.manageSynonym = {};
            $scope.manageBotSynonym = {};
            var synonyms = [];
            $scope.stream.synonyms = _.isObject($scope.stream.synonyms) ? $scope.stream.synonyms : {};
            $workflowService.nlpStream(ng.copy($scope.stream));

            $scope.showType = function (screen) {
                Object.keys($scope.views).map(function (key) {
                    $scope.views[key] = false;
                });
                $scope.views[screen] = true;
                if(!$workflowService.storeSearchQry().userSearchQueryFlag && $scope.gSearchCb) {
                    $scope.gSearchCb.text = '';
                }
                updateIndexHeader(screen);
                $scope.fieldEntityCount();
            };

            if($scope.gSearchCb){
                $scope.gSearchCb.showType = $scope.showType;
            }

            
            
            if(!$workflowService.storeSearchQry().userSearchQueryFlag && !$workflowService.storeSearchQry().userNavigateFlag && $scope.gSearchCb) {
                $scope.gSearchCb.text="";
            }
            var searchBarListner=function () {
                if ($(this).hasClass('fa-remove')) {
                    $('.synSearch').removeClass('searchExpand');
                    $(this).removeClass('fa-remove');
                    $(this).addClass('fa-search');
                    $scope.gSearchCb.text="";
                } else {
                    $('.synSearch').addClass('searchExpand');
                    $(this).addClass('fa-remove');
                    $(this).removeClass('fa-search');
                     $timeout(function () {
                    $('.synSearchInput').focus();
                }, 350);
                }
            };
            $('.searchBar').click(searchBarListner);
            
            function transformBotSynonyms(dontAssignTosynonyms) {
                synonyms = [];
                var synonymKeys = (Object.keys($scope.stream.synonyms || {})).sort();
                synonymKeys.map(function (key) {
                    var obj = {};
                    obj.key = key;
                    obj.value =  _constants_.getAlphabeticallySortedArray($scope.stream.synonyms[key]);
                    synonyms.push($workflowService.cloneData(obj));
                });
                
                if (!dontAssignTosynonyms) {
                    $scope.synonyms = $workflowService.cloneData(synonyms);
                    indexUpdateForBotSynonyms();
                }
                $scope.oldSynonyms = $workflowService.cloneData(synonyms);
            }

            function indexUpdateForBotSynonyms() {

                $scope.botSynonymObject = $workflowService.cloneData($scope.initialObject);
                $scope.synonyms.map(function (val) {
                    if ($scope.botSynonymObject[val.key && val.key[0]]) {
                        $scope.botSynonymObject[val.key && val.key[0]].push(val);
                    } else {
                        $scope.botSynonymObject['other'].push(val);
                    }

                });
                if ($scope.views.botsynonyms) {
                    $scope.indexObject = $workflowService.cloneData($scope.botSynonymObject);
                }

            }

            function indexUpdateForEntitySynonyms() {
                $scope.entitySynonymObject = $workflowService.cloneData($scope.initialObject);
                $scope.allEntity = $scope.entities;
                $scope.findParenttasks($scope.entities);
                $scope.entities.map(function (val) {
                    val.synonyms = _constants_.getAlphabeticallySortedArray(val.synonyms);
                    if ($scope.entitySynonymObject[val.name[0]]) {
                        $scope.entitySynonymObject[val.name[0]].push(val);
                    } else {
                        $scope.entitySynonymObject['other'].push(val);
                    }

                });
                if ($scope.views.entitysynonyms) {
                    $scope.indexObject = $workflowService.cloneData($scope.entitySynonymObject);
                }
            }

            $scope.moveScrollToThis = function (key) {


                var keyEle = "";
                if ($scope.views.botsynonyms) {
                    keyEle = '#bot' + key;
                } else if ($scope.views.fieldsynonyms) {
                    keyEle = '#field' + key;
                } else {
                    keyEle = '#entity' + key;
                }
                if (!indexerUtil.isElementVisible(keyEle, true, '#botSynonymnScroll')) {
                    $('#botSynonymnScroll').animate({
                        scrollTop: $(keyEle).position().top
                    }, 'fast');
                }

            };
            $scope.updateFooterHeader = function () {
                $scope.footerInfoTitle = "Synonyms";
                $scope.footerHeaderId = "bt-Synonyms";
                $scope.footerPanelId = "bt-Synonyms-panel";
                $scope.nameDescription = i18n.i18nString('add_synonyms_task_name');
                return true;
            };
            $scope.showAddSynonymForm = function() {
                $scope.showBotSynonymForm = true;
                $timeout(function () {
                    $('.synonym-keyword').focus();
                }, 350);
            };
            $scope.cancelAddSynonymForm = function() {
                $scope.showBotSynonymForm = false;
                $scope.cancelManageTaskSynonym();
                $scope.cancelAddTaskSynonym();
            };
            $scope.clearSearch = function() {
                $scope.$parent.goBack('.btSynonymsmodal');
                $timeout(function () {
                    $scope.gSearchCb.text = "";
                }, 150);
                $scope.$parent.resetDisplayTabID();
            };
            var windowResizeListner = function (e) {
                var height = $window.innerHeight;
                height = height - 210;
                $('#botSynonymnScroll').css('height', (height - 62) + 'px');
                $('.synonym-parentDiv').css('height', height + 'px');
            };
            angular.element($window).on('resize', windowResizeListner);
            $timeout(function () {
                angular.element($window).trigger('resize');
            }, 350);


            function synonymsChanged(oldOnes, newOnes) {

                if (_.isArray(oldOnes) && _.isArray(newOnes)) {

                    if (newOnes.length !== oldOnes.length) {
                        return true;
                    }

                    for (var i = 0; i < oldOnes.length; i++) {
                        if (_.isArray(oldOnes[i].value) && _.isArray(newOnes[i].value)) {
                            if ((oldOnes[i].value || []).join(',') != (newOnes[i].value || []).join(',')) {
                                return true;
                            }
                        } else {
                            return false;
                        }
                    }

                }

                return false;

            }

            $scope.filterFn = function (task)
            {
                 var taskType = $scope.getTaskType(task);
                var key = "state";
                if (task.type === 'DialogEntity') {
                    key = "status";
                }
                 //$scope.pos = $scope.pos.push(indexval);
                if ($scope.filterToggle === 'published') {
                    if (task[key] === 'published') {
                        
                      
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    if (task[key] === 'published' && (taskType === 'alert' || taskType === 'action')) {
                        if(task.isParent){
                             return false;
                        }else{
                            return true;
                        }
                     }else if (task[key] !== 'published') {
                        
                        return true;
                        
                    } else {
                        return false;
                    }
                }

            };
            // FOR UPGRADING THE PUBLISHED TASK//
               $scope.upgrade = function () {
                   $scope.isGlobalWorkProgress= true;
                   $scope.loaderMessage = i18n.i18nString('upgrading_task_label');
                var taskType = $scope.getTaskType($scope.currentTask);
                $scope.upgradeWorkflow($scope.currentTask, taskType);
            };
            
            $scope.getTaskType = function (task) {
                if (task && task.hasOwnProperty('alertFieldsDefinition')) {
                    return "alert";
                } else if (task && task.hasOwnProperty('isReport')) {
                    return "action";
                } else if (task && task.type == "DialogEntity") {
                    return "flowtask";
                } else {
                    return "";
                }
            };
          
            $scope.upgradeWorkflow = function (task, type) {
                
                if (type === "alert") {
                    BTAlertsService.upgradeBTAlert(task._id).then(function (response) {
                        BTAlertsService.upgradeMPAlert(task._id, response.data._id).then(function (upgradeRes) {
                            BTAlertsService.configured(upgradeRes.data._id).then(function (configRes) {
                                prepareObject(configRes.data[0]);
                                $scope.isGlobalWorkProgress= false;
                                $scope.changeEditFieldSynonym(configRes.data[0],$scope.currentFieldId);
                            }, function (err) {
                                $scope.isGlobalWorkProgress= false;
                                NotificationService.notify(err.data.errors[0].msg, 'error');
                                return;
                            });

                        }, function (err) {
                            $scope.isGlobalWorkProgress= false;

                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;

                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                } else if (type === "action") {
                    BTActionsService.upgradeBTAction(task._id).then(function (response) {
                        BTActionsService.upgradeMPAction(task._id, response.data._id).then(function (upgradeRes) {
                         BTActionsService.configured(upgradeRes.data._id).then(function(configRes){
						prepareObject(configRes.data[0]);
                                                $scope.isGlobalWorkProgress= false;
                                                $scope.changeEditFieldSynonym(configRes.data[0],$scope.currentFieldId);
					},function(err){
                                            $scope.isGlobalWorkProgress= false;
						NotificationService.notify(err.data.errors[0].msg,'error');
						return;
					});
                        }, function (err) {
                           $scope.isGlobalWorkProgress= false;
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        });
                    }, function (err) {
                        $scope.isGlobalWorkProgress= false;
                        NotificationService.notify(err.data.errors[0].msg, "error");
                    });
                }                
            };

           $scope.findParenttasks = function(taskObject){
                $.each(taskObject,function(i,task){
                    if(task.hasOwnProperty('parentId')){
                        $scope.upgradedTasks.push(task.parentId);
                    }
                });
                $.each(taskObject,function(i,task){
                    $.each($scope.upgradedTasks,function(j,upgradedId){
                    if(task._id === upgradedId){
                        task.isParent= true;
                    }
                 });
                 });
            };
            // FOR UPGRADING THE PUBLISHED TASK- END//
            var streamId = $scope.stream._id;

            function addTaskSynonym(pattern) {
                $scope.synonym = {};
                $scope.synonym.show = true;
                $scope.synonym.pattern = pattern;
                $timeout(function () {
                    $('.add-task-synonym').modal('show');
                });
            }

            $scope.cancelTaskSynonym = function () {
                $('.add-task-synonym').modal('hide');
                $scope.synonym.show = false;
            };

            function addFieldSynonym(pattern) {
                $scope.synonym = {};
                $scope.synonym.pattern = pattern;
                $timeout(function () {
                    $('.add-field-synonym').modal('show');
                });
            }

            $scope.cancelFieldSynonym = function () {
                $('.add-field-synonym').modal('hide');
            };

            $scope.getActualSynonyms = function getActualSynonyms() {
                return $workflowService.nlpStream().synonyms;
            };
                        

             $scope.saveEntitySynonym = function (type) {
                 if(type){
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_deleted_success');
                }else{
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_added_sucess');
                }
                var newEntity = null;
                $scope.entities.map(function (entity) {
                    if ($scope.editEntitySynonym && entity._id === $scope.editEntitySynonym._id) {
                        newEntity = entity;
                        setTimeout(function () {
                            compareComponentSynonymsAndSave($scope.editEntitySynonym, newEntity);
                        }, 500);
                    }
                });

            };

            $scope.saveEntitySynonymTraining = function(type,newEntity){
                if(type){
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_deleted_success');
                }else{
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_added_sucess');
                }
                
                $timeout(function () {
                            compareComponentSynonymsAndSave($scope.editEntitySynonym, newEntity, type);
                        }, 500);

            };

            $scope.saveBotSynonym = function (type) {
                if(type){
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_deleted_success');
                }else{
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_added_sucess');
                }
                 setTimeout(function () {
                  saveTaskSynonyms(null, null, null, true);
                        }, 500);
            };

            $scope.combineSynonyms = function(entity) {
                return (entity.synonyms || []);
                //  _.union((entity.synonyms && entity.synonyms[entity._id] || []), (entity.synonyms && entity.synonyms[entity.name] || []));
            };
            
            $scope.saveTaskFieldSynonyms = function(type){
                if(type){
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_deleted_success');
                }else{
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_added_sucess');
                }
                var newTask=null;
                   $scope.tasks.map(function (task) {
                    if ($scope.editFieldSynonym && task._id === $scope.editFieldSynonym._id) {
                        newTask = $workflowService.cloneData(task);
                        setTimeout(function () {
                            saveSynonymAtBot($scope.editFieldSynonym, newTask);
                        }, 500);
                    }
                }); 
              
            };

            $scope.saveTaskFieldSynonymsTraining = function(type,newField){
               if(type){
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_deleted_success');
                }else{
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_added_sucess');
                }
                setTimeout(function () {
                    var syns =  $scope.editFieldSynonym || $scope.currentEditItem;
                             saveSynonymAtBot(syns, newField);
                        }, 500);  
            };
            
            $scope.cancelBotSynonym = function (resetIndex) {
                if (resetIndex) {
                    $scope.editBotSynonymId = null;
                }
                transformBotSynonyms(false);
            };

            $scope.cancelEntitySynonym = function (resetIndex) {
                if (resetIndex) {
                    $scope.editEntitySynonymId = null;
                }
                 var indexEntity =-1;
                $scope.entities.map(function (entity,index) {
                    if ($scope.editEntitySynonym && entity._id === $scope.editEntitySynonym._id) {
                        indexEntity=index;
                    }
                });
                if (indexEntity !=-1) {
                    $scope.entities[indexEntity] = $scope.editEntitySynonym;
                    indexUpdateForEntitySynonyms();
                }
                
            };

            $scope.cancelFieldSynonymIndex = function (resetIndex) {
                if (resetIndex) {
                    $scope.editFieldSynonymId = null;
                }
                var indexTask =-1;
                $scope.tasks.map(function (task, index) {
                    if ($scope.editFieldSynonym && task._id === $scope.editFieldSynonym._id) {
                        indexTask = index;
                    }
                });
                if (indexTask !=-1) {
                    $scope.tasks[indexTask] = $workflowService.clone($scope.editFieldSynonym);
                    prepareFieldIndexObject();
                }
                
            };

            $scope.deleteSynonym = function (deletedSynonym, $event) {

                $event.stopPropagation();
                var index = -1;

                $scope.synonyms.map(function (synonym, i) {
                    if (synonym.key == deletedSynonym.key) {
                        index = i;
                    }
                });

                var synonym = $scope.synonyms[index];

                NotificationService.alert( i18n.i18nString('do_you_really_want_to_del_noty'), deleteSynonym, [$scope.stream._id, null, null, true]);

                function deleteSynonym() {
                    var synonyms = $workflowService.cloneData($scope.synonyms);
                    synonyms.splice(index, 1);
                    BTStreamsService.postSynonyms($scope.stream._id, {
                        synonyms: transformSynonymsToObject(synonyms)
                    })
                            .then(function (res) {
                                $scope.synonyms.splice(index, 1);
                                $scope.stream = res.data;
                                $workflowService.nlpStream($scope.stream);
                                $workflowService.selectedStream($scope.stream);
                                $scope.oldSynonyms = $workflowService.cloneData($scope.synonyms);
                                NotificationService.notify( i18n.i18nString('synonyms_deleted_success'), "success");
                                if($scope.enableSynonyms) {
                                    $scope.trainShow = true;
                                }
                                indexUpdateForBotSynonyms();
                            }, function (err) {
                                var msg = getErrorMsg(err,  i18n.i18nString('synonyms_added_failure'));
                                NotificationService.notify(msg, "error");
                            });
                }

            };

            $scope.saveTaskSynonym = function () {
                var synonyms = $scope.stream.synonyms[$scope.synonym.intent] || [];
                synonyms.push($scope.synonym.pattern);
                synonyms = synonyms.map(function (synonym) {
                    return synonym;
                });
                $scope.stream.synonyms[$scope.synonym.intent] = synonyms;
                saveTaskSynonyms(streamId, $scope.synonym.intent, synonyms)
                        .then(function (res) {
                            $scope.cancelTaskSynonym();
                            //NotificationService.notify("successfully saved synonyms", "success");
                        }, function (err) {
                           // var msg = getErrorMsg(err, "synnoyms adding failed");
                           // NotificationService.notify(msg, "error");
                        });
            };

            function saveTaskSynonyms(streamId, name, synonyms, forStream,updateKey) {
                var payload = {}, deferred = $q.defer();
                if (!forStream) {
                    payload[name] = synonyms;
                    return BTStreamsService
                            .postSynonyms(streamId, {synonyms: payload})
                            .then(function (res) {
                                $workflowService.selectedStream(res.data);
                                $workflowService.nlpStream(res.data);
                                mergeNewSyonymsToLocalStream(res.data.synonyms);
//                                $scope.editBotSynonymId = null;
//                                $scope.editBotSynonym = null;
                                transformBotSynonyms(true);
                                if($scope.enableSynonyms) {
                                    $scope.trainShow = true;
                                }

//                                NotificationService.notify("Synonyms updated successfully", 'success');
                                return deferred.resolve(res);
                            }, function (err) {
                                      var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_bot_synonym_failed');
                                        NotificationService.notify(msg, 'error');
                                return $q.reject(err);
                            });
                } else {
                    synonyms = $workflowService.cloneData($scope.synonyms);
                    synonyms = transformSynonymsToObject(synonyms);
                    return BTStreamsService
                            .postSynonyms($scope.stream._id, {synonyms: synonyms})
                            .then(function (res) {
                                $workflowService.selectedStream(res.data);
                                $workflowService.nlpStream(res.data);
                                $scope.stream.synonyms = res.data.synonyms;
                                mergeNewSyonymsToLocalStream(res.data.synonyms);
//                                $scope.editBotSynonymId = null;
//                                $scope.editBotSynonym = null;
                                if(updateKey){
                                    NotificationService.notify( i18n.i18nString('synonyms_updated_sucess'), 'success');
                                    transformBotSynonyms(false);
                                    $scope.editBotSynonym = null;
                                    $scope.editBotSynonymId = null;
                                }else{
                                    NotificationService.notify($scope.synUpdateMsg, 'success');
                                    transformBotSynonyms(true);
                                }
                                if($scope.enableSynonyms) {
                                    $scope.trainShow = true;
                                }
                                return deferred.resolve(res);
                            }, function (err) {
                                      var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_bot_synonym_failed');
                                        NotificationService.notify(msg, 'error');
                                return $q.reject(err);
                            });
                }
            }

            function mergeNewSyonymsToLocalStream(synonyms) {
                synonyms = synonyms || {};
                $scope.stream.synonyms = $scope.stream.synonyms || {};
                Object.keys(synonyms).map(function (key) {
                    $scope.stream.synonyms[key] = synonyms[key];
                });
            }

            $scope.saveFieldSynonym = function saveFieldSynonym() {
                var task = $scope.getSelectedTask($scope.synonym.intent);
                var type = task._id[0] == 'l' ? "alert" : "action";
                var payload = {};
                var getSynonym = type == 'alert' ? BTStreamsService.getAlertsFieldSynonyms : BTStreamsService.getActionsFieldSynonyms;
                var saveSynonym = type == 'alert' ? BTStreamsService.createAlertFieldSynonyms : BTStreamsService.createActionsFieldSynonyms;

                getSynonym(task._id, task.name)
                        .then(function (res) {
                            var synonyms = res.data[$scope.synonym.field] || [];
                            synonyms.push($scope.synonym.pattern);
                            payload[$scope.synonym.field] = getLowerCasedSynonyms(synonyms);
                            saveSynonym(task._id, $scope.synonym.field, payload)
                                    .then(function (res) {
                                        NotificationService.notify($scope.synUpdateMsg, 'success');
                                        $scope.cancelFieldSynonym();
                                    }, function (err) {
                                        var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_as_field_synonym_failed');
                                        NotificationService.notify(msg, 'error');
                                    });
                        }, function (err) {
                            var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_as_field_synonym_failed');
                            NotificationService.notify(msg, 'error');
                        });

            };

            function transformSynonymsToObject(synonyms) {
                var result = {};
                synonyms
                        .map(function (synonym) {
                            result[synonym.key] = synonym.value;
                        });
                return result;
            }


            function getLowerCasedSynonyms(synonyms) {
                return synonyms.filter(function (synonym) {
                    synonym = synonym || '';
                    return synonym;
                });
            }

            function openManageTaskSynonym(pattern) {
                $scope.manageSynonym = {};
                $timeout(function () {
                    $('.manage-task-synonym').modal('show');
                });
            }

            $scope.cancelManageTaskSynonym = function (form) {
                $scope.manageSynonym = {};
                $('.manage-task-synonym').modal('hide');
                form_util.makeItClean($scope.manageTaskSynonymForm);
            };
            
            $scope.cancelAddTaskSynonym = function(form){
                $scope.manageBotSynonym = {};
                form_util.makeItClean($scope.manageBotSynonymForm);
            };

            function openManageFieldSynonym(event, task) {

                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }

                $scope.manageFieldSynonym = {
                    task: task.name
                };

                $timeout(function () {
                    $('.manage-field-synonym').modal('show');
                });

            }

            $scope.cancelManageFieldSynonym = function (form) {
                $scope.manageFieldSynonym = {};
                $('.manage-field-synonym').modal('hide');
                form_util.makeItClean($scope.manageFieldSynonymForm);
            };

            $scope.saveManageTaskSynonym = function (form) {

                var key, synonyms;

                if (form.$invalid) {
                    form_util.touch(form);
                    return;
                }

                key = _.isObject($scope.manageSynonym.keyword) ? $scope.manageSynonym.keyword.key : $scope.manageSynonym.keyword;
                if (key) {
                    key = key;
                }
                synonyms = $scope.manageSynonym.synonyms || [];
                synonyms = _.uniq(synonyms.concat(($workflowService.nlpStream().synonyms || {})[key] || []));
                synonyms = synonyms.map(function (synonym) {
                    return synonym;
                });
                var allSynonyms = $workflowService.cloneData($workflowService.nlpStream().synonyms);
                allSynonyms[key] = synonyms;
                allSynonyms = {'synonyms': allSynonyms};

              saveManageBotSynonymsForm(key,synonyms, allSynonyms);

            };

            $scope.saveManageBotTaskSynonym = function (form) {
                $scope.saveStatusSynonym =  {'initial':false,'pending':true,'completed':false,'failed':false};
                if($scope.cb && $scope.cb.updateStatus){
                    $scope.cb.updateStatus($scope.saveStatusSynonym);
                }
                var _botInfo = {
                    streamId:$workflowService.selectedStream()._id,
                    BotName:$workflowService.selectedStream().name,
                 };
                 mixPanel.postEvent('Add Concept',_botInfo);
                var key, synonyms;

                if (form.$invalid) {
                    form_util.touch(form);
                    return;
                }

                key = _.isObject($scope.manageBotSynonym.keyword) ? $scope.manageBotSynonym.keyword.key : $scope.manageBotSynonym.keyword;
                if (key) {
                    key = key;
                }
                synonyms = $scope.manageBotSynonym.synonyms || [];
                synonyms = _.uniq(synonyms.concat(($workflowService.nlpStream().synonyms || {})[key] || []));
                synonyms = synonyms.map(function (synonym) {
                    return synonym;
                });
                var allSynonyms = $workflowService.cloneData($workflowService.nlpStream().synonyms);
                allSynonyms[key] = synonyms;
                allSynonyms = {'synonyms': allSynonyms};
                saveManageBotSynonymsForm(key, synonyms, allSynonyms);
            };
            
            function saveManageBotSynonymsForm(key,synonyms, allSynonyms) {
                BTStreamsService
                        .postSynonyms($scope.stream._id, allSynonyms)
                        .then(function (res) {
/*                
                saveTaskSynonyms(streamId,key, synonyms)
                        .then(function (res) {*/
                            $scope.stream = res.data; // bot synonyms data update after adding new keyword //
                             $workflowService.selectedStream($scope.stream, res.data);
                            $scope.cancelManageTaskSynonym();
                            $scope.cancelAddTaskSynonym();
                            $workflowService.nlpStream().synonyms[key] = synonyms;
                            if (($scope.synonyms && $scope.synonyms.length>0) && _.find($scope.synonyms, {key: key})) {
                                $workflowService.nlpStream().synonyms[key] = synonyms;
                                _.find($scope.synonyms, {key: key}).value = synonyms;
                            } else {
                                $scope.synonyms.push({
                                    key: key,
                                    value: synonyms
                                });
                            }
                            indexUpdateForBotSynonyms();
                            NotificationService.notify( i18n.i18nString('save_synonyms'), "success");
                            if($scope.enableSynonyms) {
                                $scope.trainShow = true;
                            }
                            $scope.saveStatusSynonym =  {'initial':false,'pending':false,'completed':true,'failed':false};
                           if($scope.cb && $scope.cb.updateStatus){
                                $scope.cb.updateStatus($scope.saveStatusSynonym);
                            }
                            $timeout(function(){
                                $scope.saveStatusSynonym =  {'initial':true,'pending':false,'completed':false,'failed':false};
                               if($scope.cb && $scope.cb.updateStatus){
                                    $scope.cb.updateStatus($scope.saveStatusSynonym);
                                }
                            },3000);
                        }, function (err) {
                            var msg = getErrorMsg(err,  i18n.i18nString('add_synonyms_failed'));
                            NotificationService.notify(msg, "error");
                        });
            }
            $scope.saveManageFieldSynonym = function saveFieldSynonym(form) {

                if (form.$invalid) {
                    form_util.touch(form);
                    return;
                }

                var task = $scope.getSelectedTask($scope.manageFieldSynonym.task);
                var type = task._id[0] == 'l' ? "alert" : task._id[0] === 'd' ? "dialog" : "action";
                var payload = {};
                if (type !== "dialog") {
                    var getSynonym = type == 'alert' ? BTStreamsService.getAlertsFieldSynonyms : BTStreamsService.getActionsFieldSynonyms;
                    var saveSynonym = type == 'alert' ? BTStreamsService.createAlertFieldSynonyms : BTStreamsService.createActionsFieldSynonyms;

                    getSynonym(task._id, task.name)
                            .then(function (res) {
                                var synonyms = res.data[$scope.manageFieldSynonym.field] || [];
                                synonyms = synonyms.concat($scope.manageFieldSynonym.synonyms);

                                payload[$scope.manageFieldSynonym.field] = getLowerCasedSynonyms(synonyms);

                                saveSynonym(task._id, $scope.manageFieldSynonym.field, payload)
                                        .then(function (res) {
                                            NotificationService.notify($scope.synUpdateMsg, 'success');
                                            $scope.cancelManageFieldSynonym();
                                            getDataFromServer(streamId);
                                        }, function (err) {
                                            var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_as_field_synonym_failed');
                                            NotificationService.notify(msg, 'error');
                                        });

                            }, function (err) {

                                var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg ||i18n.i18nString('adding_as_field_synonym_failed');
                                NotificationService.notify(msg, 'error');

                            });
                } else {

                    var task1 = $scope.tasks.filter(function (flowTask) {
                        return flowTask._id === task._id;
                    })[0];
                    var component = task1.nodes.filter(function (component) {

                        return component._id === $scope.manageFieldSynonym.field;

                    })[0];
                    var synonyms = component.synonyms[$scope.manageFieldSynonym.field] || [];
                    synonyms = synonyms.concat($scope.manageFieldSynonym.synonyms);
                    payload[$scope.manageFieldSynonym.field] = getLowerCasedSynonyms(synonyms);
                    BTFlowtaskService.updateComponent($scope.stream._id, $scope.manageFieldSynonym.field, {synonyms: payload}).then(function (res) {
                        NotificationService.notify($scope.synUpdateMsg, 'success');
                        $scope.cancelManageFieldSynonym();
                        getDataFromServer(streamId);
                    }, function (err) {
                        var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_as_field_synonym_failed');
                        NotificationService.notify(msg, 'error');
                    });
                }
            };

//            $scope.$watch('tasks', function (newVal, oldVal) {
//                saveSynonymAtBot(newVal);
//            }, true);

            function saveSynonymAtBot(oldTask,task) {
                    var fields = compareSynonyms(oldTask, task);
                    // compareComponentSynonymsAndSave(oldTask._id,oldTask.nodes,task.nodes);
                    if (fields.length > 0) {
                        var payload = {};
                        fields.map(function (field) {
                            var name = getFieldName(field, task);
                            if (name) {
                                payload[name] = task.fieldSynonyms[field];
                            }
                        });
                        Object.keys(payload).map(function (fieldName) {
                            var taskId = task._id?task._id:task.taskId;
                            triggerFieldSynonymSave(taskId, fieldName, payload[fieldName]);
                        });
                    }else if(fields.length === 0){
                        var taskId = task._id?task._id:task.taskId;
                        triggerFieldSynonymSave(taskId,task.name,[]);
                    }
                }

            function getFieldName(field, task) {
                var name;
                for (var i = 0; i < task.fields.length; i++) {
                    if (task.fields[i].title.toLowerCase() == field) {
                        return task.fields[i].title;
                    }
                }
                return name;
            }

            function triggerFieldSynonymSave(taskId, fieldName, synonyms) {
                var payload = {}, deferred = $q.defer();
                var type = taskId[0] == 'l' ? "alert" : taskId[0] == 'd' ? "dialog" : "action";
                payload[fieldName] = synonyms;
                if (type === "alert") {
                    $scope.saveStatusSynonym =  {'initial':false,'pending':true,'completed':false,'failed':false};
                    if($scope.cb && $scope.cb.updateStatus){
                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                    }
                    return BTStreamsService
                            .createAlertFieldSynonyms(taskId, fieldName, payload)
                            .then(function (res) {
                                $scope.oldTasks = clone($scope.tasks);
//                                $scope.editFieldSynonym = null;
//                                $scope.editFieldSynonymId = null;
                                $scope.saveStatusSynonym = {'initial':false,'pending':false,'completed':true,'failed':false};
                                  if($scope.cb && $scope.cb.updateStatus){
                                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                                    }
                                  $timeout(function(){
                                    $scope.saveStatusSynonym = {'initial':true,'pending':false,'completed':false,'failed':false};
                                    if($scope.cb && $scope.cb.updateStatus){
                                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                                     }
                                },3000);   
                                prepareFieldIndexObject();
                                 NotificationService.notify($scope.synUpdateMsg, "success");    
                                if($scope.enableSynonyms) {
                                    $scope.trainShow = true;
                                }
                                return deferred.resolve();
                            }, function (err) {
                                if($scope.cb && $scope.cb.updateStatus){
                                    $scope.cb.updateStatus($scope.saveStatusSynonym);
                                }
                                  $timeout(function(){
                                    $scope.saveStatusSynonym = {'initial':true,'pending':false,'completed':false,'failed':false};
                                    if($scope.cb && $scope.cb.updateStatus){
                                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                                    }
                                },3000); 
                                if(err.data && err.data.errors){
                                    NotificationService.notify(err.data.errors[0].msg,'error');
                                }else{
                                 var msg = i18n.i18nString('adding_as_field_synonym_failed');
                                 NotificationService.notify(msg, 'error');
                                }
                                
                                    
                                return deferred.resolve();
                            });
                } else if (type === "action") {
                    return BTStreamsService
                            .createActionsFieldSynonyms(taskId, fieldName, payload)
                            .then(function (res) {
                                $scope.oldTasks = clone($scope.tasks);
//                                $scope.editFieldSynonym = null;
//                                $scope.editFieldSynonymId = null;
                                 NotificationService.notify($scope.synUpdateMsg, "success");  
                                 $scope.saveStatusSynonym = {'initial':false,'pending':false,'completed':true,'failed':false};
                                    if($scope.cb && $scope.cb.updateStatus){
                                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                                    }
                                  $timeout(function(){
                                    $scope.saveStatusSynonym = {'initial':true,'pending':false,'completed':false,'failed':false};
                                    if($scope.cb && $scope.cb.updateStatus){
                                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                                    }
                                },3000);   
                                prepareFieldIndexObject();
                                return deferred.resolve();
                            }, function (err) {
                                  $scope.saveStatusSynonym = {'initial':false,'pending':false,'completed':false,'failed':true};
                                  if($scope.cb && $scope.cb.updateStatus){
                                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                                    }
                                  $timeout(function(){
                                    $scope.saveStatusSynonym = {'initial':true,'pending':false,'completed':false,'failed':false};
                                    if($scope.cb && $scope.cb.updateStatus){
                                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                                    }
                                },3000); 
                                  var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_as_field_synonym_failed');
                                        NotificationService.notify(msg, 'error');
                                return deferred.resolve();
                            });
                }
            }

            function compareSynonyms(source, destination) {
                var keys = [];
                source.fieldSynonyms = source.fieldSynonyms || {};
                destination.fieldSynonyms = destination.fieldSynonyms || {};
                Object.keys(destination.fieldSynonyms).map(function (key) {
                    source.fieldSynonyms[key] = _constants_.getAlphabeticallySortedArray(source.fieldSynonyms[key] || []);
                    destination.fieldSynonyms[key] = _constants_.getAlphabeticallySortedArray(destination.fieldSynonyms[key] || []);
                    if (source.fieldSynonyms[key].join(',') != destination.fieldSynonyms[key].join(',')) {
                        keys.push(key);
                    }
                });
                return keys;
            }
            function mixpanelEvent (type){
                var _botInfo = {
                    streamId: $workflowService.selectedStream()._id,
                    "Bot Name": $workflowService.selectedStream().name,
                    "Level":"Engagement L3",
                    "Category":"Engagement L3",
                };
                var event = "";
                 if(type === 'createEntitySynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Entity Synonym added";
                 }
                 if(type === 'deleteEntitySynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Entity Synonym deleted";
                 }
                 if(event && event.trim()) {
                    mixPanel.postEvent(event, _botInfo);
                 }
             }

            function compareComponentSynonymsAndSave(old, comp, type) {
                if ((old && old.synonyms && comp && (old.synonyms.join(',') !== comp.synonyms.join(','))) || (old && !old.synonyms)) {
                    $scope.saveStatusSynonym =  {'initial':false,'pending':true,'completed':false,'failed':false};
                    if($scope.cb && $scope.cb.updateStatus){
                        $scope.cb.updateStatus($scope.saveStatusSynonym);
                    }
                    BTFlowtaskService.updateComponentSynonyms($scope.stream._id, old._id, {synonyms: comp.synonyms}).then(function (res) {
//                        $scope.editEntitySynonym = null;
//                        $scope.editEntitySynonymId = null;
                        if (type) {
                            mixpanelEvent("deleteEntitySynonyms");
                        } else {
                            mixpanelEvent("createEntitySynonyms");
                        }
                        if($scope.enableSynonyms) {
                            $scope.trainShow = true;
                        }
                        $scope.entity.synonyms = res.data.synonyms;
                        $scope.editEntitySynonym = res.data;
                        NotificationService.notify($scope.synUpdateMsg, "success");  
                        $scope.saveStatusSynonym =  {'initial':false,'pending':false,'completed':true,'failed':false};
                        if($scope.cb && $scope.cb.updateStatus){
                            $scope.cb.updateStatus($scope.saveStatusSynonym);
                        }
                        $timeout(function(){
                            $scope.saveStatusSynonym = {'initial':true,'pending':false,'completed':false,'failed':false};
                            if($scope.cb && $scope.cb.updateStatus){
                                $scope.cb.updateStatus($scope.saveStatusSynonym);
                            }
                        },3000); 
                    }, function (err) {
                        var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg ||  i18n.i18nString('adding_as_entity_synonym_failed');
                        NotificationService.notify(msg, 'error');
                        $scope.saveStatusSynonym =  {'initial':false,'pending':false,'completed':false,'failed':true};
                        $timeout(function(){
                            $scope.saveStatusSynonym = {'initial':true,'pending':false,'completed':false,'failed':false};
                           if($scope.cb && $scope.cb.updateStatus){
                                $scope.cb.updateStatus($scope.saveStatusSynonym);
                            }
                        },3000); 
                    });
                }
            }
            function loadingEntities(id) {
                $scope.tasks = [];
                $scope.oldTasks = [];
                prepareObject();

            }

            function getDataFromServer(id, transform) {
                $scope.showLoading = true;

                setTimeout(function(){
                    $q.all([BTAlertsService.getAlerts(id), BTActionsService.getActions(id)])
                    .then(function(res){
                        $workflowService.alertTasks(res[0].data);
                        $workflowService.actionTasks(res[1].data);
                        resolveEntities();
                    });
                },1000);
                
                $q.all([BTStreamsService.getBTStream(id), BTStreamsService.getMPStream(id)])
                .then(function (res) {
                    $scope.stream = {};
                    $scope.stream = angular.extend($scope.stream, res[0].data);
                    delete res[1].data.visibility;
                    $scope.stream = angular.extend($scope.stream, res[1].data);
                    $workflowService.selectedStream($scope.stream);
                    loadingEntities(id);
                    if (transform) {
                        transformBotSynonyms();
                    }
                });

            }

            function updateIndexHeader(mode) {
                switch (mode) {
                    case 'botsynonyms':
                        $scope.indexObject = $workflowService.cloneData($scope.botSynonymObject);
                        break;
                    case 'fieldsynonyms':
                        $scope.indexObject = $workflowService.cloneData( $scope.fieldSynonymObject);
                        break;
                    case 'entitysynonyms':
                        $scope.indexObject = $workflowService.cloneData($scope.entitySynonymObject);
                        break;
                }
            }


            function resolveEntities() {
                $scope.entities = [];
                BTFlowtaskService.getEntitiesOrIntents(streamId, "entities").then(function (res) {
                    if (res.data) {

                        $scope.entities = $filter('orderBy')(res.data, 'name');
                        indexUpdateForEntitySynonyms();


                            // BTFlowtaskService.getFlowtaks($workflowService.selectedStream()._id).then(function(response){
                            //      var entitiesList = $scope.entities.concat(res.data);
                            //      $scope.dialogs = response.data;
                            //      var _entitiesInDialogs = []; 
                            // $.each($scope.dialogs, function(i, dialog){
                             
                            //     var _entitynodes = _.filter(dialog.nodes, {type: "entity"});
                            //     var _entityIds = _.pluck(_entitynodes, "componentId");
                            //     _entitiesInDialogs = _.union(_entitiesInDialogs, _entityIds); 
                                
                            // });
                            // var tempEntities = [];
                            // $.each(entitiesList, function(i, entity){
                            //     var index = $.inArray(entity._id, _entitiesInDialogs);
                            //     if(index!== -1){
                            //         tempEntities.push(entity);
                            //     }
                            // });

                            // $scope.entities = $filter('orderBy')(tempEntities, 'name');
                            //   indexUpdateForEntitySynonyms();
                            // $scope.entitiesCount= clone($scope.entities);
                            // $scope.nonPublishedEntitySyn = $scope.entitiesCount.filter(function (obj){
                            // if(obj.status !=="published"){
                            //  return obj;
                            // }
                   
                            // });
                            // $scope.entitySynInDev = $scope.nonPublishedEntitySyn.length;
                            // $scope.entitySynPublished = $scope.entities.length - $scope.entitySynInDev;
                            // $scope.entityCount = $scope.entitySynInDev;

                            // }, function(error){

                            // });

                            // commented getFlowtaks API call for BB-5343 Entity Synonyms: Published entity synonyms are not displayed in the Development mode and even the entities are not displayed to add new synonyms.

                       
                    }
                }, function (error) {

                });
            }
            function prepareObject(task) {
                $scope.showLoading = false;
                if(task){
                    $scope.tasks.push(task);
                }else{
                    $scope.tasks = $scope.tasks.concat($workflowService.alertTasks());
                $scope.tasks = $scope.tasks.concat($workflowService.actionTasks());
                }
                
                $scope.findParenttasks($scope.tasks);
                $scope.tasks = $scope.tasks.map(function (task) {
                    if (_.isArray(task.alertFieldsDefinition)) {
                        task.fields = _.clone(task.alertFieldsDefinition || []);
                        task.fields.map(function (field) {
                            field._id = field.title;
                        });
                    } else if (_.isArray(task.payloadField) && _.isArray(task.queryField)) {
                        task.fields = (task.payloadField || []).concat(task.queryField);
                        task.fields.map(function (field) {
                            field._id = field.title;
                        });
                    }
                    return task;
                });
                     prepareFieldIndexObject();
                
                $scope.oldTasks = clone($scope.tasks);

            }
            function prepareFieldIndexObject(){
               
                var fieldsArray = [];
                $scope.tasks.map(function (task) {
                    task.fields.map(function (field) {
                        var object = {task: task, fieldId: field._id,field:field};
                        fieldsArray.push(object);
                    });
                    
                });
                fieldsArray = $filter('orderBy')(fieldsArray, 'fieldId');
                       $scope.fieldSynonymObject = $workflowService.cloneData($scope.initialObject);
                $scope.allFields = fieldsArray;
                $scope.allFields = _.uniq($scope.allFields, function(p){ return p.task._id;});
                if($scope.stream.taskCounts.actions.length > 0 || $scope.stream.taskCounts.alerts.length > 0 || $scope.stream.taskCounts.informationTasks.length > 0){
                    $scope.fieldSynLength = true;
                }else{
                    $scope.fieldSynLength = false;
                }
                $scope.fieldPatternsObject = fieldsArray || [];
//                $scope.fieldcounts = clone(fieldsArray);
//                $scope.nonPublishedFieldSyn = $scope.fieldcounts.filter(function (obj){
//                    if(obj.task.state !=="published"){
//                        return obj;
//                    }
//                    
//                });
//                $scope.fieldSynInDev = $scope.nonPublishedFieldSyn.length;
//                $scope.fieldSynPublished = fieldsArray.length - $scope.fieldSynInDev;
//                $scope.fieldCount = $scope.fieldSynInDev;
                if ($scope.views.fieldsynonyms) {
                    $scope.indexObject = $workflowService.cloneData( $scope.fieldSynonymObject);
                }
            }
            
            $scope.fieldEntityCount = function(){
                $timeout(function () {
                    $scope.activeFieldsLength = $(".segrigateFields").length;
                    $scope.activeEntitiLengthIndevelopment = _.filter($scope.entities,function(data){
                        if(data.status === 'configured'){
                            return data;
                        }
                    });
                    $scope.activeEntitiLengthPublished = _.filter($scope.entities,function(data){
                        if(data.status === 'published'){
                            return data;
                        }
                    });
                    $('.synMainContainer').scrollTop(0);
                    $scope.editEntitySynonymId = null;
                    $scope.editEntitySynonym = null;
                    $scope.editFieldSynonym = null;
                    $scope.editFieldSynonymId = null;
                    $scope.editBotSynonymId = null;
                    $scope.editBotSynonym = null;
                    
                },350);
//                if($scope.filterToggle === "indevelopment"){
//                    $scope.fieldCount = $scope.fieldSynInDev;
//                    $scope.entityCount = $scope.entitySynInDev;
//                }else{
//                   $scope.fieldCount = $scope.fieldSynPublished;
//                   $scope.entityCount = $scope.entitySynPublished;
//                }
            };
//            $scope.fieldEntityCount();
            function clone(obj) {
                if(obj){
                    try {
                        return JSON.parse(JSON.stringify(obj));
                    } catch (err) {
                        return $workflowService.cloneData(obj);
                    }
                }
            }
       
            $scope.expand = function expand(index) {
                $scope.showIndex = $scope.showIndex == index ? -1 : index;
            };

            $scope.getSelectedTask = function (name) {
                var task = $scope.tasks.filter(function (task) {
                    return task.name == name;
                })[0];
                return task;
            };
            $scope.goBack = function () {
                $location.path(window.appConfig.CONTEXT_PATH);
            };
            $scope.$emit('nestedComponentLoaded',{'id':'synonyms','flag':false});
            //Add below whenever nestedComponentLoaded is FINALLY emitted.
            $timeout(function() {
                $scope.$emit('gSearchLoad');
            });
            
            function getErrorMsg(err, defaultMsg) {
                err = err && err.data;
                return (err && err.errors && err.errors[0] && err.errors[0].msg) || defaultMsg;
            }

            
            (function pulldata(id) {
                $timeout(function () {
                if($scope.hideUi){
                    $scope.showLoading = true;
                    resolveEntities();
                    $q.all([BTStreamsService.getBTStream(id), BTStreamsService.getMPStream(id)])
                        .then(function (res) {
                            $scope.stream = {};
                            $scope.stream = angular.extend($scope.stream, res[0].data);
                            delete res[1].data.visibility;
                            $scope.stream = angular.extend($scope.stream, res[1].data);
                            $workflowService.selectedStream($scope.stream);
                            loadingEntities(id);
                            if (true) {
                                transformBotSynonyms();
                            }
                        });

                    return;
                }
                    getDataFromServer(id, true);
                    synnoymsAutoTrainStatus();
                });
            }(streamId));
            $scope.getTemplateUrl = function(){
                        if($scope.templateUrl){
                            return window.appConfig.TMPLT_PRE_PATH + 'js/modules/synonyms-module/synonyms-module-entity.html';
                        }
                        return window.appConfig.TMPLT_PRE_PATH + 'js/modules/synonyms-module/synonyms-module.html';
            };
            $scope.$on("$destroy", function () {
                angular.element($window).off('resize', windowResizeListner);
                $('.searchBar').off('click',searchBarListner);
                if (getProgressDockStatusDestroy) {
                    getProgressDockStatusDestroy();
                }
                if (synonymsTrainFailedDestroy) {
                    synonymsTrainFailedDestroy();
                }
                if (botSynonymsToggleDestroy) {
                    botSynonymsToggleDestroy();
                }
            });

           

            

            if($scope.cb){
                $scope.cb.changeEditEntitySynonym = $scope.changeEditEntitySynonym;
                $scope.cb.changeEditFieldSynonym = $scope.changeEditFieldSynonym;
            }

           
            
             
        }

    ]);


}(angular));

;(function(ng) {

    'use strict';

    var _module = ng.module('utterances-module', []);

    _module.filter('filterTasks', function($applicationService) {
        return function(tasks) {
            return _.filter(tasks, function(task) {
                return task.state === "_checkString";
            });
        };
    });
    _module.directive('scrollPaginate',function(){
        return {
            restrict : 'EA',
            link : function($scope,element,attrs){
                var _batchSize = 20;
                element.bind('scroll',function(e){
                    var _currEle = e.currentTarget;
                    if(_currEle.scrollTop + _currEle.offsetHeight >= _currEle.scrollHeight * 0.9){
                        $scope.loadingClientBatch = true;
                        $scope.updateClientBatch(_batchSize);
                    }

                });
            }
        };
    });
    _module.filter('objLength',function(){
        return function(object) { 
            var objectKeysArr =  Object.keys(object); 
           return objectKeysArr.filter(function(val){
                return (val !== 'other' && object[val].length > 0);
           }).length;

         }; 
    });




    _module.directive('dropdownDirective',function($timeout){
        return {
            restrict : 'EA',
            scope:{},
            template:'<span class="count entity-count" data-toggle="dropdown"></span>'+
            '<ul  class="dropdown-menu content-menu entity-dropdown-associates" dynamic-height dynaoffset="-415">'+
            '<div class="position-relative" perfect-scroll dynamic-height dynaoffset="-415">'+
            '<li ng-repeat="value in filteredValues track by $index">'+
                            '<a>{{value}}</a>'+
                    '</li>'+
                '</div>'+
                '</ul>',
            
            link:{
                post:function($scope,$element,attr){
                function cb(){
                        var _elements = $element.parent().find('.patterns');
                        $scope.filteredValues = [];
                        var filteredElements;
                        _.map(_elements,function(e,i){
                            if($(_elements[0]).offset().top && ($(e).offset().top > $(_elements[0]).offset().top + 32 )){
                                $(e).css({'display':'none'});
                            }

                            filteredElements =  _.filter(_elements,function(e,i){
                                return (!$(e).is(':visible'));
                             });

                             if(filteredElements && filteredElements.length){
                                 var _countTag = filteredElements.length;
                                 var _ele = $element.find('.count');
                                 if(_ele && _ele.length){
                                     _ele[0].innerText = _countTag;
                                 }
                                 $element.find('.count').css({'display':'block'});
                             }else{
                                $element.find('.count').css({'display':'none'});
                             }
                    
          
                        });
                        angular.forEach(filteredElements,function(e){
                                $scope.filteredValues.push(e.innerText);
                        });   
                        
                   
                }
                $element.ready(cb);
               
                
            }
            }
        };
    });

    _module.directive('insertTilde',function($timeout){
        return {
            link:function($scope,$element,attrs){
                $element.on('keyup',function(){
                    $timeout(function(){
                         var r,validReg,preValue;
                        if($scope.currentEditSynonym){
                             if(!$scope.currentEditSynonym.key){
                                $scope.currentEditSynonym.key = '~';
                            }else if($scope.currentEditSynonym.key && $scope.currentEditSynonym.key.length){
                              r = new RegExp('^[~]');
                              validReg = r.test($scope.currentEditSynonym.key);
                              if(!validReg){
                                 $element.prop('disabled',true);
                                 preValue = '~';
                                 $scope.currentEditSynonym.key = preValue.concat($scope.currentEditSynonym.key);
                                 setTimeout(function(){
                                    $element.prop('disabled',false);
                                 },200);
                                 
                              }
                            } 
                        }
                        if($scope.manageBotSynonym){
                             if(!$scope.manageBotSynonym.keyword){
                                $scope.manageBotSynonym.keyword = '~';
                            }else if($scope.manageBotSynonym.keyword && $scope.manageBotSynonym.keyword.length){
                              r = new RegExp('^[~]');
                              validReg = r.test($scope.manageBotSynonym.keyword);
                              if(!validReg){
                                 $element.prop('disabled',true);
                                 preValue = '~';
                                 $scope.manageBotSynonym.keyword = preValue.concat($scope.manageBotSynonym.keyword);
                                setTimeout(function(){
                                    $element.prop('disabled',false);
                                 },200);
                              }
                            } 
                        }
                       
                    });
                    
                });
                
            }   
        };
        
    });



    _module.controller('UtterancesModuleCtrl', ['$scope', '$element', '$rootScope', '_constants_', '$timeout', '$window', '$workflowService', '$location', '$routeParams', 'BTStreamsService', '$q', 'BTAlertsService', 'BTActionsService', 'NotificationService', 'BTFlowtaskService', 'env_conf', '$applicationService', 'BTFileUploadService','accessControlService','i18n','$sce','$filter','mixPanel','nlpService',
        function($scope, $element, $rootScope, _constants_, $timeout, $window, $workflowService, $location, $routeParams, BTStreamsService, $q, BTAlertsService, BTActionsService, NotificationService, BTFlowtaskService, env_conf, $applicationService, BTFileUploadService,accessControlService,i18n,$sce,$filter,mixPanel,nlpService) {
            $timeout(function(){
                if (window.inline_manual_player) {
                    window.inline_manual_player.update();
                }   
            },3000);
            //Header toggle related//
            $scope.loadingWarnings = false;
            $scope.filterToggle = $workflowService.selectedStreamState();
            $scope.displayMode=accessControlService.getAccessRight('BOTBUILDER_NATURAL_LANGUAGE');
            $scope.assetsBase = env_conf['assets-url'];
            $scope.tmpltPrePath=$scope.$root.tmpltPrePath;
            var streamId = $workflowService.selectedStream()._id;
            $scope._constants_=_constants_;
            $scope.verifying = false;
            $scope.tasks = [];
            $scope.utteranceSearch = [];
            $scope.totalTasks = [];
            $scope.activeTask = 0;
            $scope.activeType = 'DialogIntent';
            $scope.utterences = [];
            $scope.autoTrainedUtterances = [];
            $scope.editId = -1;
            $scope.moreAvailable = true;
            $scope.fetchingTrainingData =  true;
            $scope.moreAutoTrainedAvailable = true;
            $scope.count = 0;
            $scope.entityCmpt = {};
            $scope.entityCmpt.showentityDropdown = false;
            $scope.entityCmpt.fromEdit = false;
            $scope.entityCmpt.offsetObject = {};
            $scope.stream = $workflowService.selectedStream();
            $scope.title = i18n.i18nString('machine_learning');
            $scope.fetching = false;
            $scope.autoTrainFetching = false;
            $scope.focusedIndex = -1;
            $scope.activeTabType = "developer";
            $scope.bulbIcon = window.appConfig.CONTEXT_PATH + '/assets/images/24x29-bulbicon.png';
            $scope.ellipsisGray = window.appConfig.CONTEXT_PATH + '/assets/icons-new/ellipsis/overflow-2.svg';
            $scope.searchIconGray = env_conf['context-url']+'/assets/icons/searchIconGray.svg';
            $scope.searchIcon = env_conf['context-url']+'/assets/icons/search.svg';
            $scope.closeIcon  = env_conf['context-url']+'/assets/icons-new/close/close-dark.svg';
            $scope.searchClose = env_conf['context-url']+'/assets/icons/fa-close.svg';
            $scope.caretRight = env_conf['context-url']+'/assets/icons/caretRight.svg';
            $scope.caretDown = env_conf['context-url']+'/assets/icons-new/chevron/chevron-down-white.svg';
            $scope.emptyStateIcon = env_conf['context-url'] + '/assets/empty-state-images/k-folder.png';
            $scope.reloadpng = env_conf['context-url'] + '/assets/images/reload.png';
            $scope.spinnerIcon = env_conf['context-url'] + '/assets/images/spinner.svg';
            $scope.refreshIcon = env_conf['context-url']+'/assets/icons-new/refresh/refresh-white.svg';
            $scope.emptyStateIcon_training = env_conf['context-url'] + '/assets/empty-state-images/empty-train.png';
            $scope.roundCheck = env_conf['context-url'] + '/assets/icons/round-check.svg';
            $scope.saving = env_conf['context-url'] + '/assets/gif/saving.gif';
            $scope.brokenImageSmall = env_conf['context-url'] + '/assets/images/brokenImageSmall.png';
            $scope.showTrainBtn = false;
            $scope.showTrainSavingDiv = false;
            $scope.trainTitle = "";
            $scope.speechTrainTitle = "";
            $scope.trainStatus = { "success": false, "failed": false, "saving": false };
            $scope.kfoldtrainStatus = { "success": true, "failed": false, "training": false };
            $scope.speechTrainStatus = { "success": true, "failed": false, "saving": false };
            $scope.autoTrainedUtteranceCount = 0;
            $scope.fetchingUtterances = false;
             $scope.rightClass = "right900";
            $scope.upgradedTasks = [];
            $scope.indexWatch = [];
            $scope.mlInfo = [];
            $scope.mlInfo.mlScore = false;
            $scope.mlInfo.intents = [];
            $scope.mlInfo.filterToggle = 'indevelopment';
            $scope.taskTypes = [{ name: i18n.i18nString('dialog_intents_label'), id: "DialogIntent", count: 0 }, { name: i18n.i18nString('constants.alerts'), id: "alert", count: 0 }, { name: i18n.i18nString('constants.reports'), id: "information", count: 0 }, { name: i18n.i18nString('constants.actions'), id: "action", count: 0 }];
            var previousUtteranceIndex = -1;
            var previousUnsavedUtteranceValue = "";
            $scope.entityCallbacks = {};
            $scope.btUtteranceObject = {};
            $scope.streamstate = {};
            $scope.streamstate.toggleState = $workflowService.selectedStreamState();
            var _selectedLanguage = $workflowService.currentLanguage();
            $scope.dragDropIcon = window.appConfig.CONTEXT_PATH + '/assets/images/import.png';
            $scope.wentWrongIcon = window.appConfig.CONTEXT_PATH + '/assets/images/wentwrong.png';
            $scope.importingIcon = env_conf['context-url'] + '/assets/images/importing.png';
            $scope.importDoneIcon = env_conf['context-url'] + '/img/import-success.png';
            $scope.helpIcon = window.appConfig.CONTEXT_PATH+'/assets/icons/helpIcon.svg';
            $scope.infoIcon = env_conf['context-url'] + '/assets/icons-new/info/info-gray.svg';
            $scope.dropdownToggle = env_conf['context-url'] + '/assets/icons-new/dropdown-toggle/dropdown-toggle.svg';
            $scope.config = {};
            $scope.config.includeIsHidden = true;
            $scope.doneButton = i18n.i18nString('done');
            $scope.okButton  = i18n.i18nString('ok_label');
            $scope.showKfoldModal = false;
            $scope.uiCopyTasks = [];
            $scope.constants = _constants_;
            $scope.search = {};
            $scope.selectedIntent = {};
            $scope.callback = {};
            $scope.taskSearch = {};
            $scope.select = {};
            $scope.select.name = 'All Intents';
            $scope.select.key = 'allIntent';
            $scope.activeTab = 'intents';
            $scope.componentsCount = [];
            $scope.filteredResults = [];
            $scope.isInvalidTag = false;
            $scope.viewMode  = false;
            $scope.notificationEnabled = true;
            $scope.notificationInputEnabled = true;
            // $scope.warningEnabled = true;
            $scope.warningBar = true;
            $scope.supportedIntents = [
                                       {'name':"Dialog Intent",'key':"dialogIntent",'selected':false},
                                       {'name':"Sub Intent Dialogs",'key':"subDialogIntent",'selected':false},
                                       {'name':"Sub-Intents",'key':"subIntent",'selected':false}];
            $scope.saveStatus = {'initial':true,'pending':false,'completed':false,'failed':false};
            $scope.modalSlider = {};
            $scope.initialObject = {
                a: [], b: [], c: [], d: [], e: [], f: [], g: [], h: [], i: [], j: [], k: [], l: [], m: [], n: [], o: [], p: [], q: [], r: [], s: [], t: [], u: [], v: [], w: [], x: [], y: [], z: [], concepts:[],other: []

            };
            $scope.patternsCB = {};
            $scope.synonymsCB = {};
            $scope.manageBotSynonym = {};
            $scope.manageBotSynonym.synonyms = [];
            $scope._selectedFilters = [];
            var _alertActionArray = ['alert','action','information'];
            $scope.views = {
                intents: true,
                entity: false,
                fields: false,
                botsynonyms:false,
                concepts:false,
                traits:false
            }; 
            $scope.gSearchCb = {};  
            $scope.gSearch = {};
            $scope.upgrade = {};
            $scope.searchTask = '';
            $scope.exportStep = 1;
            $scope.data = {
                downloadURL: "",
                label:getTextEncoded($scope.stream.name)
            };
            $scope.requestStatus = {
                interval: null
            };
            $scope.stream.synonyms = _.isObject($scope.stream.synonyms) ? $scope.stream.synonyms : {};
            $workflowService.nlpStream(ng.copy($scope.stream));
            $scope.traitsCb = {};
            $scope.trainSyncData = {};
            $scope.ob = {};
            var _mode;

            if($scope.displayMode === 'VIEW'){
                $(document).keydown(function (e) 
                {
                var keycode1 = (e.keyCode ? e.keyCode : e.which);
                if (keycode1 === 0 || keycode1 === 9) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            }
            $scope.supportedLanguages = $workflowService.seedData().supportedLanguages;
            $scope.nluSupportedLanguages = $workflowService.seedData().nluSupportedLanguages;
            $scope.defaultLanguage = $workflowService.selectedStream().defaultLanguage;
            _.forEach($scope.supportedLanguages, function (eachLang) {
            if (eachLang.value === _selectedLanguage) {
            $scope.selectedDefaultLanguage = eachLang;
            }
            });
                $scope.multiLingualConfigurations = $workflowService.selectedStream().multiLingualConfigurations;
                if ($scope.multiLingualConfigurations && $scope.multiLingualConfigurations[_selectedLanguage] && $scope.multiLingualConfigurations[_selectedLanguage].nluLanguage && $scope.multiLingualConfigurations[_selectedLanguage].nluLanguage !== _selectedLanguage) {
                $scope.notificationEnabled = true;
                $scope.notificationInputEnabled = true;
                _.forEach($scope.nluSupportedLanguages, function (eachLang) {
                    if (eachLang.value === $scope.multiLingualConfigurations[_selectedLanguage].nluLanguage) {
                        $scope.selectedNluLanguage = eachLang;
                        }
                        });
                        } else if($scope.multiLingualConfigurations && $scope.multiLingualConfigurations[_selectedLanguage] && $scope.multiLingualConfigurations[_selectedLanguage].nluLanguage && $scope.multiLingualConfigurations[_selectedLanguage].nluLanguage === _selectedLanguage){
                            $scope.notificationInputEnabled = false;
                            $scope.notificationEnabled = false;
                        }else{
                            $scope.notificationEnabled = false;
                            $scope.notificationInputEnabled = false;
                        }


            loadingEntities(streamId);
            
            
            function getTextEncoded(name){
                if(name){
                   return name.replace(/</g, '&lt;').replace(/>/g, '&gt;'); 
                }else{
                   return '';
                }
            }
            $scope.showFailedErrors = true;

                $('.dropdown-submenu a.test').on("click", function(e){
                $(this).next('ul').toggle();
                e.stopPropagation();
                e.preventDefault();
              });
            
            function hideEntityDetails () {
                $element.find('.entityInfoDiv').hide();   
            }

            $scope.showUtteranceInternalHeader = function(type) {
                $scope.activeTabType = type;
                $('.utterances-content-view').bind("scroll", bindScroll);
            };
            $scope.closeTrainSaveDiv = function() {
                $scope.showTrainSavingDiv = false;
                $scope.trainStatus = { "success": true, "failed": false, "saving": false };
                $scope.speechTrainStatus = { "success": true, "failed": false, "saving": false };
                $scope.trainTitle = "";
            };

            $scope.toggleHiddenTasks = function(e){
                $scope.loadingWarnings =  true;
                e.stopPropagation();
                e.stopImmediatePropagation();
                $scope.config.includeIsHidden = !$scope.config.includeIsHidden;
                var _tasks;
                if($scope.concatedTasks && $scope.concatedTasks.length){
                    _tasks = $scope.concatedTasks;
                }else{
                     _tasks = mapTasks['allIntent']();
                }
                if(!$scope.config.includeIsHidden){
                    var excludeHiddenTasks = _.filter(_tasks,function(task){
                        return !task.isHidden;
                    });
                    $scope.uiCopyTasks = excludeHiddenTasks.slice(0,20);
                }else if($scope.config.includeIsHidden){
                    $scope.uiCopyTasks = _tasks.slice(0,20);
                }
                if($scope.uiCopyTasks && $scope.uiCopyTasks.length >= 20){
                   $('.utteranceScrollContainer').animate({scrollTop:10});
                }else{
                    $('.utteranceScrollContainer').animate({scrollTop:0});
                }
                setTimeout(function(){
                    $scope.loadingWarnings =  false;
                },200);
                
            };

            $scope.updateFooterHeader = function() {
                $scope.footerInfoTitle = i18n.i18nString('machine_learning');
                $scope.footerHeaderId = "bt-machineLearning";
                $scope.footerPanelId = "bt-machineLearning-panel";
                $scope.nameDescription = i18n.i18nString('utterance_module_machine_learing_desc');
                return true;
            };

            var prepareTrainLabel = function(data){
                $scope.trainSyncData = data;
                if($scope.trainStatus && !$scope.trainStatus.saving){
                     $scope.showTrainBtn = true;   
                }
                if((data.hasOwnProperty('isMlInSyncWithSentences') && !data.isMlInSyncWithSentences) && (data.hasOwnProperty('isMlInSyncWithTraits') && !data.isMlInSyncWithTraits)){
                    $scope.trainLabel = i18n.i18nString('untrained_utterances_ml_traits');
                }else if((data.hasOwnProperty('isMlInSyncWithSentences') && !data.isMlInSyncWithSentences)){
                     $scope.trainLabel = i18n.i18nString('untrained_utterance_ml');
                }else if((data.hasOwnProperty('isMlInSyncWithTraits') && !data.isMlInSyncWithTraits)){
                    $scope.trainLabel = i18n.i18nString('untrained_utterance_traits');
                }
            };
            

            /* Fetching ML utterances sync status */
            function checkMLSyncStatus(disableNotify) {
                BTStreamsService.autoTrainStatus($workflowService.selectedStream()._id).then(function(res) {
                    if ((res && res.data && res.data.hasOwnProperty('isMlInSyncWithSentences') && !res.data.isMlInSyncWithSentences) || (res && res.data && res.data.hasOwnProperty('isMlInSyncWithTraits') && !res.data.isMlInSyncWithTraits)) {
                       prepareTrainLabel(res.data);
                    } else{
                        $scope.showTrainBtn = false;
                    }
                    if(res.data.kFold){
                        $scope.showKfoldTrainSaving = false;
                    }
                    if(res.data.kFoldStatus === 'Waiting'){
                        $scope.kfoldtrainStatus.success = false;
                        $scope.kfoldtrainStatus.failed = false;
                        $scope.kfoldtrainStatus.training = true;
                        $rootScope.$broadcast('getProgressDockStatus');
                        $rootScope.$broadcast('startTimer');
                    }
                    if(res.data.kfoldTriggeredOn){
                        $scope.kfoldTriggeredOn = moment(res.data.kfoldTriggeredOn).format('MM-DD-YYYY, hh:mm A');
                    }
                    $scope.kfoldtrainStatus.kFold = res.data.kFold;
                    $scope.kfoldtrainStatus.kFoldStatus = res.data.kFoldStatus;
                    if(res.data.trainingStatus === 'Finished'){
                        $scope.showTrainSavingDiv = false;
                        $scope.trainStatus.saving = false;
                    } else if(res.data.trainingStatus === 'Failed' || res.data.isError){
                        $scope.showTrainSavingDiv = false;
                        $scope.trainStatus.saving = false;
                        if(res.data.isError){
                            $scope.failed_to_train_utt_msg =  i18n.i18nString('failed_to_train_utt_msg');
                            if(res.data.errorDesc && res.data.errorDesc.message){
                            //     _msg = res.data.errorDesc.message;
                                $scope.showTrainBtn = true;
                            }
                            if(!disableNotify){
                                NotificationService.notify(failed_to_train_utt_msg, "error");
                            }
                        }
                    }
                    else if(res.data && res.data.trainingStatus && res.data.trainingStatus.toLowerCase() === 'waiting'){
                        $scope.showTrainSavingDiv = true;
                        if(!$scope.trainProgressLabel){
                            prepareTrainProgressLabel();
                        }
                        $scope.trainStatus = {'success':false,'failed':false,'saving':true};
                    }
                },
                function(err) {
                    $scope.showTrainSavingDiv = false;
                    $scope.trainStatus.saving = false;
                    $scope.err_on_fetching_msg =  i18n.i18nString('err_on_fetching_msg');
                    NotificationService.notify(err_on_fetching_msg, "error");
                });
            }
            checkMLSyncStatus();
            /* Fetching ML utterances sync status function ends */
            $rootScope.$on('MLUtterencesTrainFinished', function($event) {
                $scope.trainStatus = { "success": true, "failed": false, "saving": false };
                $workflowService.currTrainStatus($scope.trainStatus);
                $scope.trainTitle = "";
                setTimeout(function() {
                        $scope.showTrainBtn = false;
                        $scope.showTrainSavingDiv = false;
                    }, 3000);
                if($scope.invokedFrom){
                    $scope.cb.updateTrainStatus($scope.trainStatus);
                }
               
            });
            $rootScope.$on('kfoldTrainingSuccess', function($event) {
                if($scope.kfoldModalOpened && $scope.kfoldtrainStatus.training){
                    // NotificationService.notify(i18n.i18nString('training_kfold_success_noty'),'success');
                    $scope.viewKfold(true);
                    checkMLSyncStatus();
                }
                $scope.kfoldtrainStatus.success = true;
                $scope.kfoldtrainStatus.failed = false;
                $scope.kfoldtrainStatus.training = false;
               
            });
            $rootScope.$on('kfoldTrainingFailed', function($event) {
                if($scope.kfoldModalOpened && $scope.kfoldtrainStatus.training){
                    NotificationService.notify(i18n.i18nString('problm_in_training_kfold_noty'),'success');
                }
                $scope.kfoldtrainStatus.success = false;
                $scope.kfoldtrainStatus.failed = true;
                $scope.kfoldtrainStatus.training = false;
             });
             $scope.trainKfold = function(hideNotify) {
                if ($scope.stream && $scope.stream.nlMeta && $scope.stream.nlMeta) {
                    if(!$scope.stream.nlMeta.mlUtterances  || ($scope.stream.nlMeta.mlUtterances < 250)) {
                       NotificationService.notify( i18n.i18nString('min_250_utterances_reqired'), "error");
                       return;
                    }
                 }
                $scope.kfoldTraining = true;
                var payload = {
                    crossValidation: true
                };
                BTStreamsService.trainUtterances(streamId,payload)
                    .then(function(res) {
                           $scope.kfoldtrainStatus = { "success": false, "failed": false, "training": true };
                            $rootScope.$broadcast('getProgressDockStatus');
                            $rootScope.$broadcast('startTimer');
                            if(!hideNotify){
                                NotificationService.notify( i18n.i18nString('kfold_training_intiated'), "info");
                            }
                        },
                        function(err) {
                            if (err.data.errors.length > 0) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            } else {
                                NotificationService.notify(i18n.i18nString('kfold_training_intiated_err'), "error");
                            }

                        });
            };
            $rootScope.$on('MLUtterencesTrainFailed', function($event) {
                $scope.trainStatus = { "success": false, "failed": true, "saving": false };
                $scope.trainTitle = i18n.i18nString('problm_in_training_utter_noty');
                if (!$scope.speechTrainStatus.saving) {
                    setTimeout(function() {
                        $scope.showTrainBtn = true;
                        //$scope.showTrainSavingDiv = false;
                    }, 350);
                }
                if($scope.invokedFrom){
                    $scope.cb.updateTrainStatus($scope.trainStatus);
                }
            });
            $rootScope.$on('MLSpeechTrainFinished', function($event) {
                $scope.speechTrainStatus = { "success": true, "failed": false, "saving": false };
                $scope.speechTrainTitle = "";
                if ($scope.trainStatus.failed) {
                    setTimeout(function() {
                        $scope.showTrainBtn = true;
                        $scope.showTrainSavingDiv = false;
                    }, 350);
                }
               
            });
            $rootScope.$on('MLSpeechTrainFailed', function($event) {
                $scope.speechTrainStatus = { "success": false, "failed": true, "saving": false };
                $scope.speechTrainTitle = i18n.i18nString('speech_training_intiated_err');
                if (!$scope.trainStatus.saving) {
                    setTimeout(function() {
                        $scope.showTrainBtn = true;
                        //$scope.showTrainSavingDiv = false;
                    }, 350);
                }
            });
            //To Open ML compare Graph//
            //
            function getErrorMsg(err, defaultMsg) {
                err = err && err.data;
                return (err && err.errors && err.errors[0] && err.errors[0].msg) || defaultMsg;
            }

            $scope.exportKfoldData = function() {
                function startKfoldExport(){
                    BTStreamsService.mlKfoldScoreDownload($workflowService.selectedStream()._id)
                    .then(function (res) {
                        if(res && res.data){
                            $scope.hrefURL = res.data.fileUrl + '&clientfilename=Kfold_' + ($workflowService.selectedStream().name || 'Kfold_Data')+ '_' + moment().format('YYYYMMDDHHmmSS') +'.csv'+ '&batchtesting=true';
                            var xyz = ("#kfold_report");
                            $(xyz).attr('href', $scope.hrefURL);
                            $(xyz).attr('download', true);
                            $(xyz).on('click',function(e){
                                e.stopPropagation();
                            });
                            $timeout(function() {
                                $(xyz).get(0).click(function(e){
                                    e.preventDefault();
                                    e.stopImmediatePropagation();
                                    e.stopPropagation();
                                });
                            },750);
                        }
                    },function(err){
                         if (err.data && err.data.errors && err.data.errors.length > 0) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            } else {
                                NotificationService.notify( i18n.i18nString('prblm_in_fectching_kFold'), "error");
                            }
                    });
                }
                function cancleExport(){
                    return;
                }
                function checkBoxCb(checkValue){
                  console.log(checkValue);
                  $scope._constants_.updateDownloadPopUppreferance(checkValue);
                }
                if($scope._constants_.config.showDownloadPopUps){
                 NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startKfoldExport, cancleExport], {okText:  i18n.i18nString( 'confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined, i18n.i18nString( 'export'));  
                }else{
                    startKfoldExport();
                }
            };
            
           
            $scope.viewKfold = function(){
                $scope.LoadingKfold = true;
                BTStreamsService.getBTStream($scope.stream._id).then(function (res) {
                    res.data.isInMarket = true;
                    $workflowService.selectedStream(res.data);
                    $scope.stream = $workflowService.selectedStream();
               BTStreamsService.mlKfoldScore($workflowService.selectedStream()._id)
               .then(function (res) {
                   if(res.data && res.data.error){
                       $scope.errorKfold = true;
                       $scope.showKfoldModal = false;
                       $scope.LoadingKfold = false;
                       $scope.kfoldObjErrorMsg = res.data.error;
                       $scope.kfoldErrCode = res.data.errorCode;
                       // NotificationService.notify( res.data.error, "error");
                   } else {
                       $scope.kfoldErrCode = null;
                       $scope.showKfoldModal = true;
                       $scope.LoadingKfold = false;
                       $scope.errorKfold = false;
                   }
                   if ($scope.stream && $scope.stream.nlMeta && $scope.stream.nlMeta &&  !(res && res.data && res.data.split_scores && res.data.split_scores.length)) {
                       
                        if(!$scope.stream.nlMeta.mlUtterances  || ($scope.stream.nlMeta.mlUtterances < 250)) {
                           NotificationService.notify( i18n.i18nString('min_250_utterances_reqired'), "error");
                           return;

                        }
                     }
                    $scope.kfoldModalOpened = true;
                    $('.kfold-modal').modal('show');
                    $(".sidenav").addClass('zindex1');
                    $scope.kfoldObjErrorMsg = null;
                   $scope.kfoldObj = res.data;
              
               },function(err){
                   $scope.errorKfold = true;
                   $scope.showKfoldModal = false;
                   $scope.LoadingKfold = false;
                   $scope.kfoldObjErrorMsg = null;
                   // $scope.kfoldObj = $scope.kfoldObj1;
                    if (err.data && err.data.errors && err.data.errors.length > 0) {
                           NotificationService.notify(err.data.errors[0].msg, "error");
                       } else {
                           NotificationService.notify( i18n.i18nString('prblm_in_fectching_kFold'), "error");
                       }
               });
                  }, function (err) {
                    $scope.LoadingKfold = false;
              });
                
            };
            $scope.closeKFoldModal = function(){
                $('.kfold-modal').modal('hide');
                $(".sidenav").removeClass('zindex1');
                $scope.showKfoldModal = true;
                $scope.kfoldModalOpened = false;
            };
            $scope.viewMlScore = function() {
                $scope.viewMlScoreInprogress = true;
                if ($scope.isTrainInprogress()) {
                    NotificationService.notify( i18n.i18nString('training_prog_pls_retry_err'), "error");
                    return;
                }
                if (!$scope.totalTasks.length) {
                    NotificationService.notify(i18n.i18nString('notasksfound_errr'), "error");
                    return;
                } else {
                    BTStreamsService.mlUtterencesScore($scope.stream._id)
                        .then(function(res) {
                            
                            $scope.mlInfo.MlScoreRes = res.data;
                            var isEmpty = !res.data.count;
                            if (isEmpty) {
                                if ($scope.utterences.length > 0) {
                                    NotificationService.alert('', $scope.trainBot, { okText: i18n.i18nString('train') }, "", undefined, i18n.i18nString('training_inti_ml_model'));
                                    $scope.viewMlScoreInprogress = false;
                                } else {
                                    NotificationService.notify(i18n.i18nString('viewml_model_err'), "error");
                                    $scope.viewMlScoreInprogress = false;
                                }
                                return;
                            } else if (!isEmpty && res.data.hasOwnProperty('order') && res.data.hasOwnProperty('count')) {
                                $scope.mlInfo.directiveLoading = true;
                                $('.mlScore-modal').modal('show');
                                $scope.mlInfo.intents = $scope.intentdata;
                                $scope.mlInfo.filterToggle = $scope.filterToggle;
                                $scope.mlInfo.checkMLSyncStatus = checkMLSyncStatus;
                                $(".sidenav").addClass('zindex1');
                                setTimeout(function() {
                                    $scope.mlInfo.openMLScore = true;
                                },100);
                                setTimeout(function(){
                                    $scope.mlInfo.directiveLoading = false;
                                },2000);
                            } else {
                                NotificationService.alert('', $scope.trainBot, { okText: i18n.i18nString('train') }, "", undefined,  i18n.i18nString('training_inti_ml_model'));
                            }
                            $scope.viewMlScoreInprogress = false;

                        },function(err){
                            $scope.viewMlScoreInprogress = false;
                             if (err.data && err.data.errors && err.data.errors.length > 0) {
                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                } else {
                                    NotificationService.notify( i18n.i18nString('prblm_in_fectching_utter_err'), "error");
                                }
                        });
                }
            };
            $scope.closeMlScore = function() {
                $scope.mlInfo.openMLScore = false;
            };
            //ML compare ends here//
            $scope.isTrainInprogress = function() {
                if ($scope.speechTrainStatus.saving || $scope.trainStatus.saving) {
                    return true;
                }
                return false;
            };
            $scope.trainBotSpeech = function() {
                if (!$scope.speechTrainStatus.saving) {
                    $scope.speechTrainStatus = { "success": false, "failed": false, "saving": true };
                    BTStreamsService.trainBotSpeech(streamId)
                        .then(function(res) {
                                $rootScope.$emit('triggerSpeechTrainStatusPoll');
                                NotificationService.notify(i18n.i18nString('speech_training_intiated'), "info");
                                $scope.speechTrainTitle = "";
                            },
                            function(err) {
                                $scope.speechTrainStatus = { "success": false, "failed": true, "saving": false };
                                if (err.data && err.data.errors && err.data.errors.length > 0) {
                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                    $scope.speechTrainTitle = err.data.errors[0].msg;
                                } else {
                                    $scope.speechTrainTitle = i18n.i18nString('speech_training_intiated_err');
                                    NotificationService.notify(i18n.i18nString('speech_training_intiated_err'), "error");
                                }

                            });
                }
            };

            var prepareTrainProgressLabel = function(){
                if($scope.trainSyncData){
                     if(($scope.trainSyncData.hasOwnProperty('isMlInSyncWithSentences') && !$scope.trainSyncData.isMlInSyncWithSentences) && ($scope.trainSyncData.hasOwnProperty('isMlInSyncWithTraits') && !$scope.trainSyncData.isMlInSyncWithTraits)){
                    $scope.trainProgressLabel = " Intent, Entity & Traits training are currently in progress. ";
                    }else if(($scope.trainSyncData.hasOwnProperty('isMlInSyncWithSentences') && !$scope.trainSyncData.isMlInSyncWithSentences)){
                         $scope.trainProgressLabel = " Intent & Entity training are currently in progress.  ";
                    }else if(($scope.trainSyncData.hasOwnProperty('isMlInSyncWithTraits') && !$scope.trainSyncData.isMlInSyncWithTraits)){
                        $scope.trainProgressLabel = "Traits training is currently in progress. ";
                    }

                }
               
            };

            $scope.trainBot = function(source) {
                if(source){
                    $scope.invokedFrom = source;
                }
                var _botInfo = {
                    streamId:$workflowService.selectedStream()._id,
                    BotName:$workflowService.selectedStream().name,
                 };
                prepareTrainProgressLabel();
                mixPanel.postEvent('ML Training Initiated',_botInfo);
                $scope.showTrainBtn = false;
                $scope.showTrainSavingDiv = true;
                $scope.trainStatus = { "success": false, "failed": false, "saving": true };
                $workflowService.currTrainStatus($scope.trainStatus);
                BTStreamsService.trainUtterances(streamId)
                    .then(function(res) {
                       
                            //$scope.trainStatus = {"success":true,"failed":false,"saving":false};
                            $rootScope.$emit('triggerAutoTrainStatusPoll');
                            $rootScope.$emit('clearTestTrainText');
                            $rootScope.$broadcast('getProgressDockStatus');
                            $rootScope.$broadcast('startTimer');
                            $(".trainingProgress").addClass('open');
                            NotificationService.notify( i18n.i18nString('utterences_training_intiated'), "info");
                            $scope.trainTitle = "";
                        },
                        function(err) {
                            $scope.trainStatus = { "success": false, "failed": true, "saving": false };
                             $workflowService.currTrainStatus($scope.trainStatus);
                             $scope.showTrainBtn = true;
                            $scope.showTrainSavingDiv = false;
                            if (err.data.errors.length > 0) {
                                NotificationService.notify(err.data.errors[0].msg, "error");
                                $scope.trainTitle = err.data.errors[0].msg;
                            } else {
                                $scope.trainTitle = i18n.i18nString('problm_in_training_utter_noty');
                                NotificationService.notify(i18n.i18nString('utterences_training_intiated_err'), "error");
                            }

                        });
            };
            
            $scope.cancelEditUtterance = function() {
                setTimeout(function() {
                    //duplicate($scope.utterencesCopy, $scope.utterences[previousUtteranceIndex].sentence); 
                    $scope.utterences[previousUtteranceIndex].sentence = $scope.utterencesCopy[previousUtteranceIndex].sentence;
                    $scope.editId = -1;
                    savedUtteranceFlag = true;
                }, 5);
            };

            
            $scope.getTaskType = function(task) {
                    if (task && task.hasOwnProperty('alertFieldsDefinition')) {
                        return "alert";
                    } else if (task && task.hasOwnProperty('isReport')) {
                        if (task.isReport) {
                            return "information";
                        } else {
                            return "action";
                        }
                    } else if (task && task.taskType == "DialogIntent") {
                        return "flowtask";
                    } else {
                        return "";
                    }
            };
            
            $scope.filterFn = function(task, indexval) {
                var type = $scope.getTaskType(task);
                var key = "state";
                if (task.taskType === 'DialogIntent') {
                    key = "status";
                }
                //$scope.pos = $scope.pos.push(indexval);
                if ($scope.filterToggle === 'published') {
                    if (task[key] === 'published') {


                        return true;
                    } else {
                        return false;
                    }
                } else {
                    if (task[key] === 'published' && (type === 'alert' || type === 'action' || type === 'flowtask' || type === 'information')) {
                        if (task.isParent || task.isDeleted || task.isSubIntent) {
                            return false;
                        } else {
                            return true;
                        }
                    } else if (task[key] !== 'published') {

                        return true;

                    } else {
                        return false;
                    }
                }

            };
            $scope.getActiveTaskIndex = function(res) {
                var index;
                if (res.hasOwnProperty('nodes')) {
                    $.each($scope.tasks, function(i, task) {
                        if (task._id == res.nodes[0].componentId) {
                            index = i;
                        }
                    });
                } else {
                    $.each($scope.tasks, function(i, task) {
                        if (task._id == res._id) {
                            index = i;
                        }
                    });
                }
                return index;
            };
            $scope.findParenttasks = function(taskObject) {
                $.each(taskObject, function(i, task) {
                    if (task.hasOwnProperty('parentId')) {
                        $scope.upgradedTasks.push(task.parentId);
                    }
                });
                $.each(taskObject, function(i, task) {
                    $.each($scope.upgradedTasks, function(j, upgradedId) {
                        if (task._id === upgradedId) {
                            task.isParent = true;
                        }
                    });
                });
            };
            // FOR UPGRADING THE PUBLISHED TASK- END//
            $scope.selectFirstTask = function() {
                $timeout(function() {
                    var index = $($(".sagrigate-task")[0]).attr("task-index");
                    $scope.activeTaskLength = $(".sagrigate-task").length;
                    $scope.selectTask(+index);
                }, 100);
                //            $scope.activeCount(); 
            };

            //            $scope.activeCount=function(type){
            //                $timeout(function (){
            //                $.each($scope.taskTypes, function(i, taskTypeObj){
            //                    if(taskTypeObj.id == $scope.activeType){
            //                        taskTypeObj.count = $(".sagrigate-task").length;
            //                    }
            //                });
            //         }, 100);
            //            };

           

            $workflowService.registerModalHiddenEvent();

            function isBotPublished() {
                return $scope.stream.visibility.namespace !== 'private';
            }

            function decodePattern(msg) {
                try {
                    return msg.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                } catch (e) {
                    return msg;
                }
            }

             var loadUITasks = function(tasks,offset,limit){
                var _offset = {};
                _offset['start'] = offset?offset:0;
                _offset['limit'] = limit?limit:20;
                if(!$scope.config.includeIsHidden){
                    tasks =  _.filter(tasks,function(task){
                            return !task.isHidden;
                        });   
                }
                $scope.uiCopyTasks = tasks.slice(_offset.start,_offset.limit);
                return $scope.uiCopyTasks;
                
            };

            $scope.showType = function(type,cb,fromFlag) {
                var _selectedIntent,_selectedNode;
                if(cb && fromFlag === 'fromUpgrade' && $scope.upgrade.callbackType === 'addUtterance'){
                    if(type === 'DialogIntent'){
                         _selectedNode = _.filter(cb.nodes,{'nodeId':'intent0'})[0];
                        _selectedIntent = _.find($scope.tasks,{_id:_selectedNode.componentId});
                    }else{
                        _selectedIntent = _.find($scope.tasks,{_id:cb._id});
                    }
                    $scope.selectedIntent = _selectedIntent;
                    $scope.concatTasks();
                    $scope.callback.addUtteranceCall(null, $scope.upgrade.currentUtt, fromFlag,$scope.selectedIntent);
                }else if(cb && fromFlag === 'fromUpgrade'){
                    if(type === 'DialogIntent'){
                         _selectedNode = _.filter(cb.nodes,{'nodeId':'intent0'})[0];
                        _selectedIntent = _.find($scope.tasks,{_id:_selectedNode.componentId});
                    }else{
                        _selectedIntent = _.find($scope.tasks,{_id:cb._id});
                    }
                    $scope.selectedIntent = _selectedIntent;
                    NotificationService.notify(i18n.i18nString("upgraded_success"),"success");
                    $scope.callback.loadingMLUtterances = true;
                    $scope.callback.getUtterances($scope.selectedIntent,$scope.callback);
                   // $scope.callback.editUtterance($scope.upgrade.currentIndex, $scope.upgrade.currentUtterenceId, $scope.upgrade.currentUtt,$scope.selectedIntent);
                }
                else{
                    $scope.totalTasks = $filter('orderBy')($scope.totalTasks,'name');
                    $scope.tasks = $scope.totalTasks.filter(function(task) {
                        return ($scope.filterFn(task));
                    });
                    loadUITasks($scope.tasks);
                }
                

            };



            var fetchEntities = function(id,type,cb,fromFlag){
                $scope.fetchingTrainingData =  true;
                var state = "published";
                if($scope.filterToggle==='indevelopment' || $scope.filterToggle==='configured'){
                   state = "configured";
                }
                $q.all([BTAlertsService.getAlerts(id), BTActionsService.getActions(id), BTFlowtaskService.getEntitiesOrIntents(id, "intents"), BTFlowtaskService.getFlowtaks(id),BTFlowtaskService.getComponentsByTypeAndState(id,'intent',state)])
                    .then(function(res) {
                        res[0].data = res[0].data.map(function(task) {
                            task.taskType = "alert";
                            task.intentTypeName = "Alert";
                            task.state = task.state.toLowerCase();
                            if (task.state === "inprogress" || task.state === "suspended" || task.state === "rejected") {
                                task.hide = true;
                            }
                            return task;
                        });

                        res[0].data = _.filter(res[0].data, function(d) {
                            return !d.hide;
                        });

                        $scope.alertTasks = res[0].data;


                        res[1].data = res[1].data.map(function(task) {
                            if (task.isReport) {
                                task.taskType = "information";
                            } else {
                                task.taskType = "action";
                            }
                            task.state = task.state.toLowerCase();
                            if (task.state == "inprogress" || task.state == "suspended" || task.state == "rejected") {
                                task.hide = true;
                            }

                            if (task.state !== "published" && !task.hide && isBotPublished()) {
                                task.taskstate = "@development";
                            }
                            return task;
                        });

                        res[1].data = _.filter(res[1].data, function(d) {
                            return !d.hide;
                        });

                        var componentIDs = [];
                        var _filteredNodes = [];
                        var filteredDialogTasks = [];
                        var _hiddenDialogTaskIds = [];
                       
                        


                        filteredDialogTasks = _.filter(res[3].data, function(task, i) {
                            return (task.state !== "inprogress" && task.state !== "suspended" && task.state !== "rejected") || (!task.isDeleted);
                        });

                        $.each(filteredDialogTasks, function(i, dialog) {
                            _filteredNodes = _filteredNodes.concat(_.filter(dialog.nodes, { nodeId: "intent0" }));
                            // var _compID = _.pluck(dialog.nodes, "componentId")[0] || [];
                            // componentIDs = componentIDs.concat(_compID);
                        });

                        _.map(filteredDialogTasks,function(task){
                            if(task.isDeleted){
                                _hiddenDialogTaskIds.push(task._id);
                            }
                        });

                        var hiddenHelpNodes = _.filter(filteredDialogTasks,function(dialog){return dialog.isHidden; });
                        var hiddenHelpIds = _.pluck(hiddenHelpNodes,'_id');

                        var dialogSubIntents = _.filter(filteredDialogTasks,function(dialog){return dialog.isFollowUp;});
                        var dialogSubIntentsIds = _.pluck(dialogSubIntents,'_id');

                        componentIDs = _.pluck(_filteredNodes, 'componentId');

                        //dialogIDs = _.pluck(filteredDialogTasks, "_id");

                        res[2].data = res[2].data.map(function(task) {
                            task.taskType = "DialogIntent";
                            task.intentTypeName = "Dialog Intent";

                            if (task.status) {
                                task.status = task.status.toLowerCase();
                            }

                            if($.inArray(task.dialogId,hiddenHelpIds) !== -1){
                                task.isHidden = true;
                            }

                            if (!task.hasOwnProperty('dialogId')) {
                                task.hide = true;
                            }

                            if($.inArray(task.dialogId,dialogSubIntentsIds) !== -1){
                                task.subDialogIntent = true;
                                task.intentTypeName = "Sub Intent Dialog";
                            }

                            if($.inArray(task.dialogId,_hiddenDialogTaskIds) !== -1){
                                task.isDeleted = true;
                            }

                            if (task.status !== "published" && !task.hide && isBotPublished()) {
                                task.taskstate = "@development";
                            }

                            return task;
                        });
                        res[4].data = res[2].data.filter(function(task){
                            if (!task.hasOwnProperty('dialogId')) {
                                task.taskType = "DialogIntent";
                                task.isSubIntent = true;
                                task.intentTypeName = "Sub Intent";
                                return task;
                            }
                        });
                        $scope.subIntentData = res[4].data;
                         res[2].data = _.filter(res[2].data, function(task) {
                            return !task.hide;
                        });
                         $scope.callback.allIntents = res[2].data;
                        $scope.intentdata = res[2].data;
                        function getDialogEntities(dialogId) {
                            var entitiesArray = [];
                            $.each(filteredDialogTasks, function(i, dialog) {

                                if (dialogId === dialog._id) {
                                    entitiesArray = dialog.nodes;
                                    return false;
                                }

                            });

                            return entitiesArray;
                        }

                        $.each(res[0].data, function(i, alertTask) {
                            alertTask.entitiesArray = alertTask.alertFieldsDefinition;
                        });

                        $.each(res[1].data, function(i, actionTask) {
                            actionTask.entitiesArray = [].concat(actionTask.payloadField, actionTask.queryField);
                        });


                        // $.each(res[2].data, function(i, dialogIntent){
                        //        dialogIntent.entitiesArray =  getDialogEntities(dialogIntent.dialogId);
                        // });

                        $scope.tasks = [];
                        $scope.tasks = $scope.tasks.concat(res[0].data);
                        $scope.tasks = $scope.tasks.concat(res[1].data);
                        $scope.tasks = $scope.tasks.concat(res[2].data);
                        $scope.tasks = $scope.tasks.concat(res[4].data);
                        $scope.fetchingTrainingData =  false;
                        $scope.findParenttasks($scope.tasks);
                        mapPatternsArray($scope.tasks);
                        $scope.totalTasks = $scope.tasks;
                        if (type) {
                            $scope.showType(type, cb, fromFlag);
                        } else {
                            $scope.showType();
                        }
                });

            };

            var openManageTraining = function(){
                $scope.callback.showIntentsLabel = true;
                $scope.intentStateData = $scope.totalIntentData.filter(function(intent) {
                        return ($scope.filterFn(intent));
                });
                for(var i=0;i<$scope.intentStateData.length;i++){
                    if($scope.intentStateData[i]._id === $scope.primaryIntent._id){
                        $scope.selectedIntent = $scope.intentStateData[i];
                        break;
                    }
                }
                $scope.callback.allIntents = $scope.intentStateData;

                $scope.onClickIntent(null,$scope.selectedIntent,null,'DialogIntent');
            };

            var fetchIntents = function(primaryIntent,displayMode){
                $scope.$watch('intentdata',function(newVal,oldVal){
                        $scope.totalIntentData = newVal;
                        $scope.primaryIntent = primaryIntent;
                        if(displayMode && displayMode.toUpperCase() === 'VIEW'){
                            $scope.filterToggle = 'published';
                        }
                        if(primaryIntent){
                            $scope.callback.primaryIntentOb = JSON.parse(JSON.stringify(primaryIntent));
                        }
                        
                        if($scope.totalIntentData){
                             openManageTraining();
                        }
                });
                   
            };

            var mapPatternsArray = function(tasks){
                                tasks.forEach(function(task){
                                    task.patterns = task.patterns || [];
                                    task.patternsArray = [];
                                     task.negativePatternsArray = [];
                                     task.negativePatterns = task.negativePatterns || [];
                                    task.patterns.forEach(function (msg) {
                                        msg.original = decodePattern(msg.original);
                                        task.patternsArray.push(msg.original);
                                     });
                                    task.negativePatterns.forEach(function(msg){
                                        msg.original = decodePattern(msg.original);
                                        task.negativePatternsArray.push(msg.original); 
                                    });
                                });
                };

            function loadingEntities(id, type, cb, fromFlag) {
                $scope.loadingUtterances = true;
                $scope.fetchingTrainingData =  true;
                 var state = "published";
                if($scope.filterToggle==='indevelopment' || $scope.filterToggle==='configured'){
                   state = "configured";
                }
            
                $q.all([BTAlertsService.getAlerts(id), BTActionsService.getActions(id), BTFlowtaskService.getEntitiesOrIntents(id, "intents"), BTFlowtaskService.getFlowtaks(id),BTFlowtaskService.getComponentsByTypeAndState(id,'intent',state)])
                    .then(function(res) {
                         nlpService.intents(res[2].data);
                         nlpService.alerts(res[0].data);

                        res[0].data = res[0].data.map(function(task) {
                            task.taskType = "alert";
                            task.intentTypeName = "Alert";
                            task.state = task.state.toLowerCase();
                            if (task.state === "inprogress" || task.state === "suspended" || task.state === "rejected") {
                                task.hide = true;
                            }
                            return task;
                        });

                        res[0].data = _.filter(res[0].data, function(d) {
                            return !d.hide;
                        });

                        $scope.alertTasks = res[0].data;
                        var _alertTaskFound = _.find($scope.supportedIntents,{'key':'alertTask'});
                        if($scope.alertTasks && $scope.alertTasks.length && !_alertTaskFound){
                            $scope.supportedIntents.push({'name':"Alert",'key':"alertTask",'selected':false});
                        }

                        res[1].data = res[1].data.map(function(task) {
                            if (task.isReport) {
                                task.taskType = "information";
                                task.intentTypeName = "Information Task";
                            } else {
                                task.intentTypeName = "Action Task";
                                task.taskType = "action";
                            }
                            task.state = task.state.toLowerCase();
                            if (task.state == "inprogress" || task.state == "suspended" || task.state == "rejected") {
                                task.hide = true;
                            }

                            if (task.state !== "published" && !task.hide && isBotPublished()) {
                                task.taskstate = "@development";
                            }
                            return task;
                        });

                        res[1].data = _.filter(res[1].data, function(d) {
                            return !d.hide;
                        });

                        $scope.actionTasks = _.filter(res[1].data,{'taskType':'action'});
                        $scope.informationTasks = _.filter(res[1].data,{'taskType':'information'});

                        var _actionTaskFound = _.find($scope.supportedIntents,{'key':'actionTask'});
                        var _informationTaskFound = _.find($scope.supportedIntents,{'key':'informationTask'});

                        if($scope.actionTasks && $scope.actionTasks.length && !_actionTaskFound){
                            $scope.supportedIntents.push({'name':"Action Tasks",'key':"actionTask"});
                        }
                        if($scope.informationTasks && $scope.informationTasks.length && !_informationTaskFound){
                            $scope.supportedIntents.push({'name':"Information Tasks",'key':"informationTask"});
                        }

                        var componentIDs = [];
                        var _filteredNodes = [];
                        var filteredDialogTasks = [];
                        var _hiddenDialogTaskIds = [];
                        


                        filteredDialogTasks = _.filter(res[3].data, function(task, i) {
                            return (task.state !== "inprogress" && task.state !== "suspended" && task.state !== "rejected") || (!task.isDeleted);
                        });

                        $.each(filteredDialogTasks, function(i, dialog) {
                            _filteredNodes = _filteredNodes.concat(_.filter(dialog.nodes, { nodeId: "intent0" }));
                            // var _compID = _.pluck(dialog.nodes, "componentId")[0] || [];
                            // componentIDs = componentIDs.concat(_compID);
                        });

                        _.map(filteredDialogTasks,function(task){
                            if(task.isDeleted){
                                _hiddenDialogTaskIds.push(task._id);
                            }
                        });

                        var hiddenHelpNodes = _.filter(filteredDialogTasks,function(dialog){return dialog.isHidden; });
                        var hiddenHelpIds = _.pluck(hiddenHelpNodes,'_id');

                        var dialogSubIntents = _.filter(filteredDialogTasks,function(dialog){return dialog.isFollowUp;});
                        var dialogSubIntentsIds = _.pluck(dialogSubIntents,'_id');

                        componentIDs = _.pluck(_filteredNodes, 'componentId');

                        //dialogIDs = _.pluck(filteredDialogTasks, "_id");

                        res[2].data = res[2].data.map(function(task) {
                            task.taskType = "DialogIntent";
                            task.intentTypeName = "Dialog Intent";
                           
                            if (task.status) {
                                task.status = task.status.toLowerCase();
                            }

                            if (!task.hasOwnProperty('dialogId')) {
                                task.hide = true;
                            }

                            if($.inArray(task.dialogId,hiddenHelpIds) !== -1){
                                task.isHidden = true;
                            }

                            if($.inArray(task.dialogId,dialogSubIntentsIds) !== -1){
                                task.subDialogIntent = true;
                                task.intentTypeName = "Sub Intent Dialog";
                            }

                            if($.inArray(task.dialogId,_hiddenDialogTaskIds) !== -1){
                                task.isDeleted = true;
                            }

                            if (task.status !== "published" && !task.hide && isBotPublished()) {
                                task.taskstate = "@development";
                            }

                            return task;
                        });
                        res[4].data = res[2].data.filter(function(task){
                            if (!task.hasOwnProperty('dialogId')) {
                                task.taskType = "DialogIntent";
                                task.isSubIntent = true;
                                task.intentTypeName = "Sub Intent";
                                return task;
                            }
                        });
                        $scope.subIntentData = res[4].data;
                        res[2].data = _.filter(res[2].data, function(task) {
                            return !task.hide;
                        });
                         $scope.callback.allIntents = res[2].data;
                        $scope.intentdata = res[2].data;
                        function getDialogEntities(dialogId) {
                            var entitiesArray = [];
                            $.each(filteredDialogTasks, function(i, dialog) {

                                if (dialogId === dialog._id) {
                                    entitiesArray = dialog.nodes;
                                    return false;
                                }

                            });

                            return entitiesArray;
                        }



                        $.each(res[0].data, function(i, alertTask) {
                            alertTask.entitiesArray = alertTask.alertFieldsDefinition;
                        });

                        $.each(res[1].data, function(i, actionTask) {
                            actionTask.entitiesArray = [].concat(actionTask.payloadField, actionTask.queryField);
                        });




                        // $.each(res[2].data, function(i, dialogIntent){
                        //        dialogIntent.entitiesArray =  getDialogEntities(dialogIntent.dialogId);
                        // });

                        $scope.tasks = [];
                        $scope.tasks = $scope.tasks.concat(res[0].data);
                        $scope.tasks = $scope.tasks.concat(res[1].data);
                        $scope.tasks = $scope.tasks.concat(res[2].data);
                        $scope.tasks = $scope.tasks.concat(res[4].data);
                        $scope.findParenttasks($scope.tasks);
                        $scope.totalTasks = $scope.tasks;
                        $scope.alertActionTasks = $scope.totalTasks.filter(function(task){
                            if(task.taskType === 'action' || task.taskType === 'alert' || task.taskType === 'information'){
                                if(_.isArray(task.alertFieldsDefinition)){
                                    task.fields = _.clone(task.alertFieldsDefinition || []);
                                }else if(_.isArray(task.payloadField) && _.isArray(task.queryField)){
                                    task.fields = (task.payloadField || []).concat(task.queryField);
                                }
                                var patterns = [];
                                                  
                                Object.keys(task.fieldPatterns || {})
                                .map(function(field){
                                    var valueOfField = [];
                                        valueOfField = task.fieldPatterns[field].map(function(pattern){return pattern.original;});
                                    if (valueOfField.length) {
                                        patterns.push({
                                            key: task.fieldPatterns[field].map(function (pattern) {
                                                return pattern.key;
                                            }),
                                            fieldName: field,
                                            value: valueOfField,
                                            oldPatterns: task.fieldPatterns[field]
                                        });
                                    }
                                });
                                task.field_patterns = patterns;
                                return task;
                                }
                        });
                        if (type) {
                            $scope.showType(type, cb, fromFlag);
                        } else {
                            $scope.showType();
                        }
                        loadFields();
                        
                        setTimeout(function(){
                        $('[data-toggle="dropdown"').on('click',function(e){
                            $scope.entityCmpt.showentityDropdown = false;
                            $element.find('.entity-selection-dropdown').removeClass('entity-selection-dropdown');
                        });
                        $('.select2-choice').on('mousedown',function(e){
                            $scope.entityCmpt.showentityDropdown = false;
                            $element.find('.entity-selection-dropdown').removeClass('entity-selection-dropdown');
                        });
                        $('.timeInterval.tasks').on('mousedown',function(){
                            $scope.entityCmpt.showentityDropdown = false;
                            $element.find('.entity-selection-dropdown').removeClass('entity-selection-dropdown');
                        });
                        if(!($('body .talkToBot').is(":visible"))){
                                $('body .talkToBot').css({'display':'block'});
                        }
                        $scope.loadingUtterances = false;
                        $scope.fetchingTrainingData =  false;
                        },500);
                    }, function(error) {
                        $scope.loadingUtterances = false;
                        $scope.fetchingTrainingData =  false;
                    });

            }

            $scope.$watch('showTrainBtn', function(newVal, oldVal) {
                if (newVal !== oldVal) {
                    setTimeout(function() {
                        // $(window).trigger("resize");
                    }, 200);
                }
            });
            $scope.$watch('showTrainSavingDiv', function(newVal, oldVal) {
                if (newVal !== oldVal) {
                    setTimeout(function() {
                        // $(window).trigger("resize");
                    }, 100);
                }
            });

            $scope.importUtterancesModal = function() {
                $scope.importing = "initial";
                $('.import-utterance-modal').modal('show');
                $timeout(function() {
                    initDragDropFile();
                }, 500);
            };

            $scope.exportUtterancesModal = function(filetype) {

                function startExport(){
                    var reqStatus;
                    reqStatus = $scope.filterToggle === 'published'?'published':$scope.filterToggle === 'indevelopment'?'configured':reqStatus;
                    BTStreamsService.utteranceExport($applicationService.userInfo().userId, streamId, reqStatus,filetype).then(function(response){
                        if(response.data.status === "IN_PROGRESS" || response.data.status === "SUCCESS") {
                            NotificationService.notify(i18n.i18nString('utterance_module_ml_utterances_export_in_progress'),"success");
                            $rootScope.$broadcast('getProgressDockStatus');
                            $rootScope.$broadcast('startTimer');
                            $(".trainingProgress").addClass('open'); 
                        } else if (response.data.status === "failed") {
                            console.log("ML utterance JSON export Failed");
                        }
                    }, function(error) {
                        if(error.data.errors[0].code === 'RequestExists'){
                            var msg = error.data.errors[0].code;
                            NotificationService.notify(msg,"warning");
                        }
                    });

                }
             function cancleExport(){
                 return;
             }
             function checkBoxCb(checkValue){
               console.log(checkValue);
               $scope._constants_.updateDownloadPopUppreferance(checkValue);
             }
             if($scope._constants_.config.showDownloadPopUps){
              NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined,i18n.i18nString('export_utterance'));  
             }else{
                 startExport();
             }

         
            };

            $scope.onCancel = function() {
                $('.import-utterance-modal').modal('hide');
                $scope.fileName = "";
                clearTimeout($scope._importStatusInit); 
                $scope.exportingUtter = "";
                loadingEntities($workflowService.selectedStream()._id);
            };

            $scope.onDone = function(){
                $scope.exportingUtter = "success";
                $('.import-utterance-modal').modal('hide');
                $scope.fileName = "";
                clearTimeout($scope._importStatusInit); 
                checkMLSyncStatus();
                $scope.select.name = 'All Intents';
                $scope.config.includeIsHidden = true;
                loadingEntities($workflowService.selectedStream()._id);
            };

            $scope.removeFile = function() {
                $scope.fileName = "";

            };

            $scope.uploadJSONFile = function(fileObject) {
                var _ext = "";
                if (fileObject.name) {
                    _ext = fileObject.name.substring(fileObject.name.lastIndexOf('.'));
                     _ext.slice(1).toUpperCase();
                    var supportingFileFormats = [".json",".csv"];
                    if ($.inArray(_ext, supportingFileFormats) === -1) {
                        NotificationService.notify(i18n.i18nString('upload_only_csv_json_error_noty'), "error");
                        $scope.fileExtensionError = true;
                        return;
                    }
                }




                var reader = new FileReader();
                reader.readAsText(fileObject);

                reader.onload = function(e) {
                    var respnoseData = reader.result;
                    $scope.jsonData = respnoseData;
                    if (!respnoseData || respnoseData && !respnoseData.length) {
                        NotificationService.notify(i18n.i18nString('please_upload_valid_err') + _ext.slice(1).toUpperCase() + i18n.i18nString('file'), "error");
                        $scope.fileEmptyError = true;
                    } else {
                        console.log("fileobject", fileObject.name);
                        $scope.fileName = fileObject.name;
                        $scope.fileExtensionError = false;

                        var data = new FormData();
                        data.append('file', fileObject);
                        data.append('fileContext', 'bulkImport');
                        data.append('fileExtension', _ext.substring(_ext.lastIndexOf('.') + 1));
                        data.append('Content-Type', fileObject.type);
                        $scope.data = data;
                        $scope.fileObject = fileObject;

                    }
                };



            };

            function initDragDropFile() {
                (function(window) {
                    function triggerCallback(e, callback) {
                        if (!callback || typeof callback !== 'function') {
                            return;
                        }
                        var files;
                        if (e.dataTransfer) {
                            files = e.dataTransfer.files;
                        } else if (e.target) {
                            files = e.target.files;
                        }
                        callback.call(null, files);
                    }

                    function makeDroppable(ele, callback) {
                        if ($element.find('[type="file"]').length > 0) {
                            return;
                        }

                        var input = document.createElement('input');
                        input.setAttribute('type', 'file');
                        input.setAttribute('multiple', true);
                        input.style.display = 'none';
                        input.id = "fileInputID";

                        input.addEventListener('change', function(e) {
                            triggerCallback(e, callback);
                        });

                        ele = ele[0];

                        ele.appendChild(input);


                        ele.addEventListener('dragover', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            ele.classList.add('dragover');
                        });

                        ele.addEventListener('dragleave', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            ele.classList.remove('dragover');
                        });

                        ele.addEventListener('drop', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            ele.classList.remove('dragover');
                            triggerCallback(e, callback);
                        });

                        $(ele).find(".browseBtn")[0].addEventListener('click', function() {
                            input.value = null;
                            input.click();
                        });

                    }
                    window.makeDroppable = makeDroppable;
                })(window);
                (function(window) {
                    window.makeDroppable($('.fileDropContainer'), function(files) {
                        $scope.uploadJSONFile(files[0]);
                    });
                })(window);

            }
            function startPollImportStatus(timeout) {
                    return setInterval(function () {
                        BTFlowtaskService.botutteranceImportStatus($applicationService.userInfo().userId,streamId,$scope.streamRefId)
                            .then(function (res) {
                                if (res && res.data) {
                                    $scope.statusLogs = res.data.statusLogs || [];
                                    if(res.data.status === 'success') {
                                        stopImportBotPolling('success');
                                    }
                                    else if(res.data.status === 'failed') {
                                        $scope.importmessage = res.data.message;
                                        $scope.showFailedErrors = false;
                                        stopImportBotPolling('failed');
                                    }
                                }
                            },
                            function (err) {
                                stopImportBotPolling();
                                $scope.bot_import_error =  i18n.i18nString('bot_import_error');
                                if (err.data && err.data.errors && err.data.errors.length > 0) {
                                    _msg = err.data.errors[0].msg;
                                }
                                NotificationService.notify(bot_import_error, "error");
                            });
                    }, timeout);
                }
            function stopImportBotPolling(_status) {
                        if($scope._importStatusInit !== undefined) {
                            clearTimeout($scope._importStatusInit);
                            $scope._importStatusInit = null;
                        }
                        if(_status === 'success') {
                            finishedImport();
                        }
                        else{
                            $scope.importing = "failed";
                            $scope.exportingUtter = "failed";
                        }
                    }

            function finishedImport(){
                setTimeout(function(){
                        $scope.importing = "finished";
                        $scope.exportingUtter = "finished";

                },2000);
            }
           
            $scope.backup = function(){
                $scope.importing = "backup";
            };
            $scope.startImport = function() {
                $scope.exportingUtter = "pending";
                BTStreamsService.uploadBotFunctionsFile($applicationService.userInfo,$scope.data).then(function(res){
                  var fileUploaded = {
                    fileName:$scope.fileObject.name,
                    fileId:res.data.fileId
                  }; 
                  BTFlowtaskService.startImporting($applicationService.userInfo().userId,streamId,fileUploaded)
                    .then(function(res) {
                        if (res && res.data) {
                            $scope.streamRefId = res.data._id || "";
                            $scope.statusLogs = res.data.statusLogs || [];
                            if(res.data.status === 'pending') {
                                $scope.importing = res.data.status;
                                $scope._importStatusInit = startPollImportStatus(3000);
                            }
                            else if(res.data.status === 'success') {
                                stopImportBotPolling('success');
                            }
                            else {
                                stopImportBotPolling('failed');
                            }
                        }

                    }, function(err) {
                        $scope.importing = 'failed';
                        $scope.errorMsg = err.data.errors;
                        $scope.exportingUtter = "failed";

                    });

                });
            };

            $scope.downloadLog = function()
            {
              $('.import-utterance-modal').modal('hide');
             writeAndDownloadLog("botImportLog.json", JSON.stringify($scope.statusLogs));   
             loadingEntities($workflowService.selectedStream()._id); 
             $scope.importing = 'initial';
              $scope.removeFile();
            };

            function writeAndDownloadLog(filename,data)
            {
                var element = document.createElement('a');
                element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(data));
                element.setAttribute('download', filename);

                element.style.display = 'none';
                document.body.appendChild(element);
                
                element.click();

                document.body.removeChild(element);
            }

            $scope.moveForward = function(step) {
                $scope.importing = step;
                if (step == "initial") {
                    $scope.removeFile();

                }
            };

            $scope.goToStep = function(step) {
                if (step == "initial") {
                    $scope.moveForward(step);
                }
            };

            function startPollExportStatus(timeout){
                return setInterval(function(){
                    BTStreamsService.utteranceStatus($applicationService.userInfo().userId, streamId).then(function(response) {
                        if(response && response.data){
                           if(response.data.status === 'success' && response.data.downloadURL){
                                $scope.downloadUrl = response.data.downloadURL;
                                stopExportBotPolling('success');
                            }else if(response.data.status === 'pending'){
                                stopExportBotPolling('pending');
                            } 
                        }
                            
                    },function(err){
                        stopExportBotPolling('failed');
                        $scope.backup_err = i18n.i18nString('backup_err');
                         if (err.data && err.data.errors && err.data.errors.length > 0) {
                             _msg = err.data.errors[0].msg;
                         }
                        NotificationService.notify(backup_err, "error");
                    });
                },timeout);

            }
            function stopExportBotPolling(_status){
                if($scope._exportStatusInit) {
                                clearTimeout($scope._exportStatusInit);
                                $scope._exportStatusInit = null;
                            }
                             $scope.exporting = _status;
                            if(_status === 'success') {
                                $timeout(function(){
                                    $element.find('#backupUtterBtn')[0].click();
                                },500);
                            }
            }


            $scope.backupUtterance = function(filetype){

                function startExport(){
                    
                var reqStatus = $scope.filterToggle === 'published'?'published':$scope.filterToggle === 'indevelopment'?'configured':reqStatus;
                BTStreamsService.utteranceExport($applicationService.userInfo().userId, streamId, reqStatus,filetype).then(function(response){
                    if(response && response.data){
                      if(response.data.status === "pending") {
                        $scope.exporting = response.data.status;
                        $scope._exportStatusInit = startPollExportStatus(3000); 
                    }else if(response.data.status === "success"){
                        stopExportBotPolling('success');
                    }
                    else if(response.data.status === "failed"){
                        stopExportBotPolling('success');
                    }  
                }
                    
                },function(error){
                    if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if(error.errors && _.isArray(error)){
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg,'error');
                            } else {
                                NotificationService.notify( i18n.i18nString('unexpected_err_while_backing_err_noty'), 'error');
                            }
                });
                }
             function cancleExport(){
                 return;
             }
             function checkBoxCb(checkValue){
               console.log(checkValue);
               $scope._constants_.updateDownloadPopUppreferance(checkValue);
             }
             if($scope._constants_.config.showDownloadPopUps){
              NotificationService.userConfirm($scope._constants_.downloadPopUpMsg, [startExport, cancleExport], {okText: i18n.i18nString('confirm'),checkBox:{'enable':true,'checkBoxCb':checkBoxCb}}, "", undefined,i18n.i18nString('export_utterance'));  
             }else{
                 startExport();
             }

                
            };

            $scope.onmMenuOptionClicked = function(e){
                e.stopPropagation();
                if (e.currentTarget) {
                  var _currEle = $(e.currentTarget);
                  _currEle.siblings().removeClass('active');
                  _currEle.addClass('active');
                  _currEle.find('.dropdown').addClass('open');
                }
            };

            $scope.showCSVModal = function(){
                $('.export-csv-modal').modal('show');
            };

            $scope.canelExportCsv = function(){
                $('.export-csv-modal').modal('hide');
            };

            if($scope.gSearchSelect){
                $scope.gSearchSelect.showUtteranceInternalHeader = $scope.showUtteranceInternalHeader;   
            }

            
            //used while builder is resuming// 
            $scope.$emit('nestedComponentLoaded',{'id':'machineLearningUtterances','flag':false});
            //Add below whenever nestedComponentLoaded is FINALLY emitted.
            $timeout(function(){
            $scope.$emit('gSearchLoad');
            });

            // ML NEW DESIGN //
            
           // function clickIntentCB(){
           //              setTimeout(function(){
           //                  $scope.onClickIntent(null,$scope.selectedIntent);
           //              },2000);
                        
           //          }
           //       
            $scope.getTaskType = function(task) {
                if (task && task.hasOwnProperty('alertFieldsDefinition')) {
                    return "alert";
                } else if (task && task.hasOwnProperty('isReport')) {
                    if (task.isReport) {
                        return "information";
                    } else {
                        return "action";
                    }
                } else if (task && task.taskType == "DialogIntent") {
                    return "flowtask";
                } else {
                    return "";
                }
            };

             $scope.cancel = function(){
                return;
            };

            $scope.upgradeWorkflow = function(task, type) {
                        if (type === "alert") {
                            BTAlertsService.upgradeBTAlert(task._id).then(function(response) {
                                BTAlertsService.upgradeMPAlert(task._id, response.data._id).then(function(upgradeRes) {
                                    BTAlertsService.configured(upgradeRes.data._id).then(function(configRes) {
                                        loadingEntities($scope.streamId,type);
                                        $scope.isGlobalWorkProgress = false;
                                         NotificationService.notify(i18n.i18nString('upgraded_success'), 'success');
                                         $scope.displayMode = 'FULL';
                                    }, function(err) {
                                        $scope.isGlobalWorkProgress = false;
                                        NotificationService.notify(err.data.errors[0].msg, 'error');
                                        return;
                                    });

                                }, function(err) {
                                    $scope.isGlobalWorkProgress = false;

                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                });
                            }, function(err) {
                                $scope.isGlobalWorkProgress = false;

                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        } else if (type === "action" || type === "information") {
                            BTActionsService.upgradeBTAction(task._id).then(function(response) {
                                BTActionsService.upgradeMPAction(task._id, response.data._id).then(function(upgradeRes) {
                                    BTActionsService.configured(upgradeRes.data._id).then(function(configRes) {
                                        loadingEntities($scope.streamId);
                                        $scope.isGlobalWorkProgress = false;
                                    }, function(err) {
                                        $scope.isGlobalWorkProgress = false;
                                        NotificationService.notify(err.data.errors[0].msg, 'error');
                                        return;
                                    });
                                }, function(err) {
                                    $scope.isGlobalWorkProgress = false;
                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                });
                            }, function(err) {
                                $scope.isGlobalWorkProgress = false;
                                NotificationService.notify(err.data.errors[0].msg, "error");
                            });
                        } else if (type === "flowtask") {
                                BTFlowtaskService.upgradeFlowtask($workflowService.selectedStream()._id, task.dialogId).then(function(res) {
                                    $scope.isGlobalWorkProgress = false;
                                    loadingEntities($scope.streamId);
                                    NotificationService.notify(i18n.i18nString('upgraded_success'), 'success');
                                }, function(err) {
                                    $scope.isGlobalWorkProgress = false;
                                    NotificationService.notify(err.data.errors[0].msg, "error");
                                });
                            }

            };
            

            $scope.upgrade = function() {
                $scope.isGlobalWorkProgress = true;
                $scope.loaderMessage = "Upgrading task..";
                var taskType = $scope.getTaskType($scope.selectedIntent);
                $scope.upgradeWorkflow($scope.selectedIntent, taskType);
            };

            $scope.upgradeAlertTask = function(){
                $scope.isGlobalWorkProgress = true;
                $scope.loaderMessage = "Upgrading task..";
                var taskType = $scope.getTaskType($scope.selectedTask);
                $scope.upgradeWorkflow($scope.selectedTask, taskType);
            };
            
            $scope.onClickIntent = function(e,intent,index,type){
                                if(e){
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                }
                                $scope.selectedIntent = intent;
                                $scope.callback.showTrainBtn = $scope.showTrainBtn;
                                $scope.selectedTask = _.filter($scope.totalTasks, {_id:intent._id})[0];
                                if($scope.selectedIntent && $scope.selectedIntent.type.indexOf(_alertActionArray) === -1){
                                    $scope.selectedIntent.patternsArray =[];
                                    $scope.selectedIntent.negativePatternsArray = [];

                                    $scope.selectedIntent.patterns = intent.patterns || [];
                                    $scope.selectedIntent.negativePatterns = intent.negativePatterns || [];

                                    $scope.selectedIntent.patterns.forEach(function (msg) {
                                        msg.original = decodePattern(msg.original);
                                        $scope.selectedIntent.patternsArray.push(msg.original); 
                                     });

                                    $scope.selectedIntent.negativePatterns.forEach(function(msg){
                                        msg.original = decodePattern(msg.original);
                                         $scope.selectedIntent.negativePatternsArray.push(msg.original); 
                                    });
                                }
                                //$scope.callback.loadingMLUtterances = true;
                                $scope.callback.getUtterances($scope.selectedIntent,$scope.callback);
                                $scope.callback.checkMLSyncStatus();
                                $('.builderMaincontainer').addClass('showBot');
                                 var _obj = {
                                            'showTrainBtn':$scope.showTrainBtn,
                                            'showTrainSavingDiv':$scope.showTrainSavingDiv,
                                            'trainStatus': $scope.trainStatus,
                                };
                                switch(type){
                                    case 'utterances':
                                        // $scope.callback.loadingMLUtterances = true;
                                        $scope.callback.showActiveType('utterances',null,_obj);
                                        break;

                                    case 'patterns':
                                        $scope.selectedIntent['intentSection'] = 'patterns';
                                        $scope.callback.showActiveType('patterns',null,_obj);
                                        break;

                                    case 'rules':
                                        $scope.selectedIntent['intentSection'] = 'traits';
                                        $scope.callback.showActiveType('rules',null,_obj);
                                        break;

                                    default:
                                        $scope.callback.showActiveType('utterances');
                                        break;
                                }
                                $scope.closeUtteranceDropdown();
                                $scope.modalSlider.open('#trainingFullModal');
                                var _botInfo = {
                                    streamId:$workflowService.selectedStream()._id,
                                    BotName:$workflowService.selectedStream().name,
                                 };
                                 mixPanel.postEvent('Add ML Utterance',_botInfo);

                
               
            };

            var dialogIntent = function(){
                $scope.tasks = $filter('orderBy')($scope.tasks,'name');
                return _.filter($scope.tasks,function(task){
                    return task.taskType === 'DialogIntent' && !task.isSubIntent && !task.subDialogIntent && $scope.filterFn(task);
                });
            };

            var subDialogIntent = function(){
                 $scope.tasks = $filter('orderBy')($scope.tasks,'name');
                 return _.filter($scope.tasks,function(task){
                    return task.taskType === 'DialogIntent' && task.subDialogIntent && $scope.filterFn(task);
                });
            };

            var subIntent = function(){
                $scope.subIntentData = $filter('orderBy')($scope.subIntentData,'name');
                 return _.filter($scope.subIntentData,function(task){
                    return task.isSubIntent && $scope.filterFn(task);
                });
            };

            var alertTask = function(){
                 $scope.tasks = $filter('orderBy')($scope.tasks,'name');
                 return _.filter($scope.tasks,function(task){
                    return task.taskType === 'alert' && $scope.filterFn(task);
                });
            };

            var actionTask = function(){
                $scope.tasks = $filter('orderBy')($scope.tasks,'name');
                 return _.filter($scope.tasks,function(task){
                    return task.taskType === 'action' && $scope.filterFn(task);
                });
            };

            var informationTask = function(){
                $scope.tasks = $filter('orderBy')($scope.tasks,'name');
                 return _.filter($scope.tasks,function(task){
                    return task.taskType === 'information' && $scope.filterFn(task);
                });
            };

            var allIntent = function(){
                $scope.tasks = $filter('orderBy')($scope.tasks,'name');
                return $scope.tasks.filter(function(task) {
                    return ($scope.filterFn(task));
                });
            };

            var mapTasks = {
                'dialogIntent':dialogIntent,
                'subDialogIntent':subDialogIntent,
                'subIntent':subIntent,
                'alertTask':alertTask,
                'allIntent':allIntent,
                'actionTask':actionTask,
                'informationTask':informationTask

            };

            $scope.concatTasks = function(offset,limit){
                $scope.concatedTasks = [];
                $scope._selectedFilters = _.filter($scope.supportedIntents,{'selected':true});
                for(var i = 0;i <  $scope._selectedFilters.length;i++){
                    $scope.concatedTasks = $scope.concatedTasks.concat(mapTasks[$scope._selectedFilters[i].key]());
                    $scope.concatedTasks = _.unique($scope.concatedTasks,"_id");
                }
                if($scope._selectedFilters.length){
                    return loadUITasks($scope.concatedTasks,offset,limit); 
                }else{
                    return loadUITasks(mapTasks['allIntent'](),offset,limit);
                }
            };

            $scope.selectIntentType = function(e){
                if(e){
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
                $scope.concatTasks();
                $('.utteranceScrollContainer').animate({scrollTop:0});
                
            };

            $scope.removeFilterTag = function(i,selectedFilter){
                var toRemoveIndex = _.findIndex($scope._selectedFilters,function(filter){
                    return filter === selectedFilter;
                });
                var intentFound = _.find($scope.supportedIntents,{key:selectedFilter.key});
                if(intentFound){
                    intentFound.selected = false;
                }
                $scope._selectedFilters.splice(toRemoveIndex,1);
                $scope.selectIntentType();
            };

            $scope.clearFilters = function(){
                 $scope._selectedFilters = [];
                 loadUITasks(mapTasks['allIntent']());
                 $scope.supportedIntents.forEach(function(intent){
                    intent.selected = false;
                 });
            };

           

            $scope.updateClientBatch = function(batchSize){
                if($scope.search.searchTask){
                     $scope.uiCopyTasks = $scope.uiCopyTasks.concat($scope.totalSearchRecords.slice($scope.uiCopyTasks.length,$scope.uiCopyTasks.length+batchSize));
                   
                }else{
                   $scope.uiCopyTasks =  $scope.uiCopyTasks.concat($scope.concatTasks($scope.uiCopyTasks.length,$scope.uiCopyTasks.length+batchSize));
                   
                }

            };

            $scope.clearSearch = function(e){
                if(e){
                    e.stopPropagation();
                }
                $scope.gSearchCb.search = '';
            };

            $scope.clearSearchUtter = function(e){
                if(e){
                    e.stopPropagation();
                }
                $scope.search.searchTask = '';
                $('.utteranceScrollContainer').animate({scrollTop:0});
                $scope.concatTasks();
               setTimeout(function(){
                    $scope.loadingWarnings =  false;
               },300);
            };

            $scope.searchTasks = function(e,searchQuery){
                $scope.search.searchTask = angular.copy(searchQuery);
                if(e && e.keyCode === 13 && searchQuery.length){
                   $scope.loadingWarnings = true;
                  var _totalTasks = $scope.tasks;
                  $scope.totalSearchRecords = _.filter(_totalTasks,function(task){
                        var _expTask = new RegExp(searchQuery,'i');
                        var searchResult = _expTask.test(task.intent?task.intent:task.name);
                        if(searchResult){
                            return task;
                        }
                  });
                   $('.utteranceScrollContainer').animate({scrollTop:0});
                  $scope.uiCopyTasks = $scope.totalSearchRecords.slice(0,20);
                  setTimeout(function(){
                    $scope.loadingWarnings =  false;
               },200);
                }
                else if(!searchQuery['length']){
                    $scope.loadingWarnings = true;
                    $scope.clearSearchUtter();
                }
               
            };

            $scope.callback.updateTrainDetails = function(obj){
                $scope.showTrainBtn = obj.showTrainBtn;
                $scope.showTrainSavingDiv = obj.showTrainSavingDiv;
                $scope.trainStatus  = obj.trainStatus;
                $scope.trainProgressLabel = obj.trainProgressLabel;
                $('.utteranceScrollContainer').animate({scrollTop:0});
                $scope.clearSearch();
    
            };

            $scope.callback.updateTrainBtnDetails = function(obj){
                $scope.showTrainBtn = obj.showTrainBtn;
                $scope.trainLabel = obj.trainLabel;
                $scope.trainStatus = obj.trainStatus;
                $scope.trainProgressLabel = obj.trainProgressLabel;
            };

            $scope.callback.loadingEntities = function(streamId,type,data,fromFlag){
                fetchEntities(streamId,type,data,fromFlag);
            };

            $scope.mlInfo.loadingEntities = function(streamId){
                $scope.select.name = 'All Intents';
                $scope.select.key = 'allIntent';
                loadingEntities(streamId);
                
            };

            function getNodeUsedList(tmpNode) {
                var flowtaskNames = [];
                $.each($scope.flowTasks, function (k, task) {
                    $.each(task.nodes, function (k, node) {
                        if(node.type === tmpNode.type && ((node.componentId === tmpNode._id) || (node.componentId===tmpNode.parentId))) {
                            flowtaskNames.push(task.name);
                            return false;
                        }
                    });
                      if (task.child && task.child.length) {
                        $.each(task.child[0].nodes, function (k, node) {
                            if (node.type === tmpNode.type && ((node.componentId === tmpNode._id) || (node.componentId === tmpNode.parentId))) {
                                flowtaskNames.push(task.name);
                                return false;
                            }
                        });
                    }
                });
                return _.uniq(flowtaskNames);
            }
            



            var fetchComponentsByType = function(type){
                var state = "published";
                var _searchQuery = $workflowService.subTabSearchQuery();
                if($scope.filterToggle==='indevelopment' || $scope.filterToggle==='configured'){
                   state = "configured";
                }
                BTFlowtaskService.getComponentsByTypeAndState($scope.streamId,type,state).then(function (res) {
                            $scope._botComponents = [];
                            if (res && res.data && res.data.length > 0) {
                                $.each(res.data, function (k, comp) {
                                    comp.flowtasksInvolved = getNodeUsedList(comp);
                                    if (comp.status === state) {
                                        $scope._botComponents.push(comp);
                                    }
                                    if(comp.status === state) {
                                        $scope.componentsCount[comp.type.toLowerCase()] = $scope.componentsCount[comp.type.toLowerCase()]+1;
                                    }
                                });
                                 $scope._nodes = angular.copy($scope._botComponents);
                                 
                       
                            }
                            $timeout(function () {
                                    $scope.entityLoading = false;
                                },200);

                            if(_searchQuery && _searchQuery.searchQry && _searchQuery.subTab && _searchQuery.subTab === 'entity'){
                                    $timeout(function(){
                                        $('#entityTab').find('.synSearch .searchBar').trigger('click');
                                        $scope.gSearchCb.search = _searchQuery.searchQry;
                                        $workflowService.subTabSearchQuery({'searchQry':'','subTab':''});
                                    },1000);
                                            
                            }
                            
                        }, function (error) {
                            $scope._botComponents = [];
                            $scope.entityLoading = false;
                            if (error && error.data && error.data.errors) {
                                var _msg = error.data.errors[0].msg;
                                NotificationService.notify(_msg, 'error');
                            } else if (error.errors && _.isArray(error)) {
                                var msg = error.errors[0].msg;
                                NotificationService.notify(msg, 'error');
                            } else {
                                NotificationService.notify(i18n.i18nString('fetch_error'), 'error');
                            }
                        });
            };

           
            var loadFields = function(){
                $scope.alertActionCopy = $scope.alertActionTasks.filter(function(task) {
                        return ($scope.filterFn(task));
                    });
                $scope._taskFields = [];
                $scope.alertActionCopy.forEach(function(task){
                    if(task.fields && task.fields.length){
                       $.each(task.fields,function(index,field){
                            field.task = {};
                            field.task.name = task.name;
                            field.task.taskId = task._id;
                            field.task.fieldPatterns = task.fieldPatterns;
                            field.task.fieldSynonyms = task.fieldSynonyms;
                            $scope._taskFields.push(field);
                       });

                    }  
                });
                console.log($scope._taskFields);


                
                $timeout(function(){
                     $scope.fieldsLoading = false;
                },200);
               
            };

            function indexUpdateForBotSynonyms() {

                $scope.botSynonymObject = angular.copy($scope.initialObject);
                $scope.synonyms.map(function (val) {
                    if ($scope.botSynonymObject[val.key && val.key[0].toLowerCase()]) {
                        $scope.botSynonymObject[val.key && val.key[0].toLowerCase()].push(val);
                    } else if(val && val.key.startsWith('~')) {
                        $scope.botSynonymObject['concepts'].push(val);
                    }else{
                        $scope.botSynonymObject['other'].push(val);
                    }

                });
               

            }

            var transformBotSynonyms = function(dontAssignTosynonyms){
                var synonyms = [];
                 var _searchQuery = $workflowService.subTabSearchQuery();
                var synonymKeys = (Object.keys($scope.stream.synonyms || {})).sort();
                synonymKeys.map(function (key) {
                    var obj = {};
                    obj.key = key;
                    obj.value =  _constants_.getAlphabeticallySortedArray($scope.stream.synonyms[key]);
                    synonyms.push(angular.copy(obj));
                });
                
                if (!dontAssignTosynonyms) {
                    $scope.synonyms = angular.copy(synonyms);
                    indexUpdateForBotSynonyms();
                }
                $scope.oldSynonyms = angular.copy(synonyms);
                $scope.synonymsLoading = false;
                if(_searchQuery && _searchQuery.searchQry && _searchQuery.subTab){
                                if(_searchQuery.subTab === 'botsynonyms'){
                                    $timeout(function(){
                                       $('#botSynonym').find('.synSearch .searchBar').trigger('click');
                                        $scope.gSearchCb.search = _searchQuery.searchQry;
                                        $workflowService.subTabSearchQuery({'searchQry':'','subTab':''});
                                    },3000);   
                                }else if(_searchQuery.subTab === 'concepts'){
                                    $timeout(function(){
                                        $('#concepts').find('.synSearch .searchBar').trigger('click');
                                            $scope.gSearchCb.search = _searchQuery.searchQry;
                                            $workflowService.subTabSearchQuery({'searchQry':'','subTab':''});
                                    },3000);   
                                            
                                }
                    }
            };

            var closeSearchSlider = function(_ele){
                if(_ele.hasClass('fa-remove')){
                    $(_ele[0]).parent().removeClass('searchExpand');
                    _ele.removeClass('fa-remove');
                    _ele.addClass('fa-search');
                }    
            };

            var openSearchSlider = function(_ele,_searchQuery){
                 _ele.trigger('click');
                $scope.gSearchCb.search = _searchQuery.searchQry;
                $workflowService.subTabSearchQuery({'searchQry':'','subTab':''});
            };

            var globalSearchForInternalTabs = function(_searchQuery){
                var _ele;
                if(_searchQuery && _searchQuery.searchQry && _searchQuery.subTab && _searchQuery.subTab === 'entity'){
                        _ele = $('#entityTab').find(".searchBar");
                        closeSearchSlider(_ele);
                        $timeout(function(){
                           openSearchSlider(_ele,_searchQuery);
                        },1000);
                                    
                }else if(_searchQuery && _searchQuery.searchQry && _searchQuery.subTab && (_searchQuery.subTab === 'botsynonyms' || _searchQuery.subTab === 'concepts')){
                    if(_searchQuery.subTab === 'botsynonyms'){
                         _ele = $('#botSynonym').find(".searchBar");
                        closeSearchSlider(_ele);
                        $timeout(function(){
                          openSearchSlider(_ele,_searchQuery);
                        },3000);   
                    }else if(_searchQuery.subTab === 'concepts'){
                         _ele = $('#concepts').find(".searchBar");
                        closeSearchSlider(_ele);
                        $timeout(function(){
                           openSearchSlider(_ele,_searchQuery);
                        },3000);   
                                
                    }
                }
            };

            var loadAlertTasks = function(cb){
                BTAlertsService.getAlerts($workflowService.selectedStream()._id).then(function(res){
                    var _alertTasks = res.data;
                    _alertTasks = _alertTasks.map(function(task) {
                            task.taskType = "alert";
                            task.intentTypeName = "Alert";
                            task.state = task.state.toLowerCase();
                            if (task.state === "inprogress" || task.state === "suspended" || task.state === "rejected") {
                                task.hide = true;
                            }
                            return task;
                        });
                    _alertTasks = _.filter(_alertTasks, function(d) {
                            return !d.hide;
                        });

                    $scope.alertTasks = _alertTasks;
                    $scope.findParenttasks($scope.alertTasks);
                    $scope.alertActionTasks = $scope.alertTasks.filter(function(task){
                            if(task.taskType === 'action' || task.taskType === 'alert' || task.taskType === 'information'){
                                if(_.isArray(task.alertFieldsDefinition)){
                                    task.fields = _.clone(task.alertFieldsDefinition || []);
                                }else if(_.isArray(task.payloadField) && _.isArray(task.queryField)){
                                    task.fields = (task.payloadField || []).concat(task.queryField);
                                }
                                var patterns = [];
                                                  
                                Object.keys(task.fieldPatterns || {})
                                .map(function(field){
                                    var valueOfField = [];
                                        valueOfField = task.fieldPatterns[field].map(function(pattern){return pattern.original;});
                                    if (valueOfField.length) {
                                        patterns.push({
                                            key: task.fieldPatterns[field].map(function (pattern) {
                                                return pattern.key;
                                            }),
                                            fieldName: field,
                                            value: valueOfField,
                                            oldPatterns: task.fieldPatterns[field]
                                        });
                                    }
                                });
                                task.field_patterns = patterns;
                                return task;
                                }
                    });
                    cb();
                });
            };


            $scope.showActiveType = function(tab){
                if($scope.views[tab]){
                     var _searchQuery = $workflowService.subTabSearchQuery();
                    if(_searchQuery){
                         globalSearchForInternalTabs(_searchQuery);
                    }
                    return;
                }
                Object.keys($scope.views).forEach(function(view){
                        $scope.views[view] = false;
                });
                $scope.views[tab] = true;
                $scope.activeTab = tab;

                switch(tab){
                    case 'intents':
                            loadingEntities($scope.streamId);
                            break;
                    case 'entity':
                            $scope.flowTasks = $workflowService.dialogTasks();
                            $scope.synonymsTemplateUrl = window.appConfig.TMPLT_PRE_PATH + 'js/forms/synonyms-module/synonyms-module-entity.html';
                            $scope.entityLoading = true;
                            fetchComponentsByType(tab);
                            break;
                    case 'fields':
                            $scope.fieldsLoading = true;
                            $scope.synonymsTemplateUrl = window.appConfig.TMPLT_PRE_PATH + 'js/forms/synonyms-module/synonyms-module-entity.html';
                            loadAlertTasks(loadFields);
                            break;

                    case ('botsynonyms'):
                            $scope.synonymsLoading = true;
                            transformBotSynonyms();
                            break;

                    case "concepts":
                            $scope.synonymsLoading = true;
                            transformBotSynonyms();
                            break;
                    case "traits":
                             $scope.traitTemplateUrl = window.appConfig.TMPLT_PRE_PATH + 'js/forms/bt-traits/bt-traits-training.html';
                             break;
                    default:
                        break;
                }   
               
            };

            var invokeEditSlider = function(){
                 $scope.openModalSlider('#editSlider');
                if($scope.currentEditTask && $scope.currentEditTask.patterns){
                    $scope.currentEditTask.patternsArray = [];
                    $scope.currentEditTask.patterns.map(function(pattern){
                          $scope.currentEditTask.patternsArray.push(pattern.original); 
                    });
                }
                
                $scope.setEditActive('synonyms',$scope.currentType);
            };
            
            $("body").off('click').on('click','.fieldEditView',function(){
                $timeout(function(){
                    $('.cancleUserConfirm').click();
                    $scope.upgradeViewMode = "VIEW";
                    invokeEditSlider();
                });
                
            });


            $scope.openEditSlider = function(node,type){
                $scope.editViews = {
                    'synonyms':true,
                    'patterns':false
                };
                $scope.currentEditTask = node;
                $scope.currentType = type;

                if(type === 'fields'){
                    var _taskObj = _.find($scope.alertActionCopy,{'_id':node.task.taskId});
                    $scope.selectedTask = angular.copy(_taskObj);
                    node.task.fields = _taskObj.fields;
                      if ($scope.filterToggle === "indevelopment") {
                            var key = "state";
                            if (_taskObj[key] == "published") {
                                NotificationService.userConfirm(i18n.i18nString('userconfirm_publish')+'</br>'+i18n.i18nString('upgrade_permission')+'</br><br></br><span class="grayInfoText">'+i18n.i18nString('alternatively')+'</br><span id="fieldEditView" class="marginLeft5 bthelpLinksTextcolor pointer-hand fieldEditView">'+i18n.i18nString('view_publish_version')+'</span></span>', [$scope.upgradeAlertTask, $scope.cancel], {okText: i18n.i18nString('upgrade') ,addHtmlContent:true}, "", undefined, i18n.i18nString('confirm_proceed'));   
                                return;
                            }else{
                                $scope.upgradeViewMode = "FULL";
                            }
                        }
                }
                invokeEditSlider();
            };

            $scope.closeEditTraining = function(){
                $timeout(function(){
                    $scope.entityLoading = false;
                    removeTagValidation();
                },300);
                $scope.entityLoading = true;
                $scope.closeModalSlider('#editSlider');
            };

            $scope.closeEditTrainingFields = function(){
                  $timeout(function(){
                    $scope.fieldsLoading = false;
                    removeTagValidation();
                },300);
                $scope.fieldsLoading = true;
                $scope.closeModalSlider('#editSlider');
            };


            $scope.setEditActive = function(tab,type){
                Object.keys($scope.editViews).forEach(function(view){
                        $scope.editViews[view] = false;
                });
                $scope.editViews[tab] = true;
                type = $scope.activeTab;
                switch(true){
                    case(tab === 'patterns' && type === 'entity'):
                         $scope.patternsCB.loadingPatterns = true;
                         $scope.patternsCB.onClickEntity($scope.currentEditTask,'DialogEntity');
                         break;
                    case(tab === 'synonyms' && type === 'entity'):
                        $scope.synonymsCB.type = 'entity';
                        $scope.synonymsCB.loadingSynonyms = true;
                        setTimeout(function(){
                            $scope.synonymsCB.changeEditEntitySynonym($scope.currentEditTask);
                        },500);
                        
                        break;
                    case(tab === 'synonyms' && type === 'fields'):
                         $scope.synonymsCB.type = 'fields';
                        setTimeout(function(){
                             $scope.synonymsCB.changeEditFieldSynonym($scope.currentEditTask.task,undefined,$scope.upgradeViewMode);   
                        },500);
                        break;

                    case(tab === 'patterns' && type === 'fields'):
                            $scope.patternsCB.loadingPatterns = true;
                            $scope.patternsCB.onClickField($scope.currentEditTask.task,$scope.currentEditTask.title);
                          
                        break;

                    default:
                        break;
                

                }
                 $('.edit-modal').animate({scrollTop:0});
                
            };

            $scope.openEditSynonymSlider = function(currentEditSynonym){
                if(currentEditSynonym){
                    $scope.currentEditSynonym = angular.copy(currentEditSynonym);
                    $scope.editSynonymCopy = angular.copy(currentEditSynonym);
                }
                $scope.openModalSlider('#editSynonymSlider');
            };

            $scope.closeEditSynonym = function(){
                 $timeout(function(){
                    $scope.synonymsLoading = false;
                    removeTagValidation();
                },300);
                $scope.synonymsLoading = true;
                $scope.closeModalSlider('#editSynonymSlider');
            };

            $scope.closeTrainingModalSlider = function(){
                $scope.closeModalSlider('#trainingFullModal');
                // $scope.callback.loadingMLUtterances = false;
            };

            $scope.createSynonym = function(){
                $scope.openModalSlider('#createSynonymSlider');
                if($scope.views && $scope.views.concepts){
                    $scope.manageBotSynonym.keyword = '~';
                }else{
                     $scope.manageBotSynonym.keyword = '';
                }
                setTimeout(function(){
                    $('#editInput').focus();
                },200);
            };

            function removeTagValidation(){
                $('.tags').find('input').val('');
            }

            $scope.closeCreateSynonym = function(){
                $scope.manageBotSynonym = {};
                $scope.manageBotSynonym.synonyms = [];
                 $timeout(function(){
                    $scope.synonymsLoading = false;
                    removeTagValidation();
                },300);
                $scope.synonymsLoading = true;
                $scope.closeModalSlider('#createSynonymSlider');

            };

            function mixpanelEvent(type) {
                var _botInfo = {
                    streamId: $workflowService.selectedStream()._id,
                    "Bot Name": $workflowService.selectedStream().name,
                    "Level": "Engagement L3",
                    "Category": "Engagement L3",
                };
                var event = "";
                 if(type === 'createBotSynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Bot Synonym Added";
                 }
                 if(type === 'createConceptSynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Concept Synonym added";
                 }
                 if(type === 'editSynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Bot Synonym edited";
                 }
                 if(type === 'editConceptSynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Concept Synonym edited";
                 }
                 if(type === 'deleteSynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Bot Synonym deleted";
                 }
                 if(type === 'deleteConceptSynonyms') {
                    _botInfo.Level = "Engagement L3";
                    _botInfo.Category = "Engagement L3";
                    _botInfo["Sub Category"] = "NLP - Training";
                     event = "NLP - Concept Synonym deleted";
                 }
                if (event && event.trim()) {
                    mixPanel.postEvent(event, _botInfo);
                }
            }

            function saveManageBotSynonymsForm(key,synonyms, allSynonyms) {
                $scope.saveStatus =  {'initial':false,'pending':true,'completed':false,'failed':false};
                BTStreamsService
                        .postSynonyms($scope.stream._id, allSynonyms)
                        .then(function (res) {
                            if($scope.views && $scope.views.botsynonyms){
                            mixpanelEvent("createBotSynonyms");
                            }else{
                                mixpanelEvent("createConceptSynonyms");
                            }
/*                
                saveTaskSynonyms(streamId,key, synonyms)
                        .then(function (res) {*/
                            $scope.saveStatus =  {'initial':false,'pending':false,'completed':true,'failed':false};
                            $scope.stream = res.data; // bot synonyms data update after adding new keyword //
                            $workflowService.selectedStream($scope.stream, res.data);
                            $workflowService.nlpStream().synonyms[key] = synonyms;
                            if (($scope.synonyms && $scope.synonyms.length>0) && _.find($scope.synonyms, {key: key})) {
                                $workflowService.nlpStream().synonyms[key] = synonyms;
                                _.find($scope.synonyms, {key: key}).value = synonyms;
                            } else {
                                $scope.synonyms.push({
                                    key: key,
                                    value: synonyms
                                });
                            }
                            indexUpdateForBotSynonyms();
                            NotificationService.notify( i18n.i18nString('save_synonyms'), "success");
                            if($scope.enableSynonyms) {
                                $scope.trainShow = true;
                            }
                            $timeout(function(){
                                  $scope.saveStatus =  {'initial':true,'pending':false,'completed':false,'failed':false};
                            },3000);
                        }, function (err) {
                            var msg = getErrorMsg(err,  i18n.i18nString('add_synonyms_failed'));
                            NotificationService.notify(msg, "error");
                            $scope.saveStatus =  {'initial':false,'pending':false,'completed':false,'failed':true};
                            $timeout(function(){
                                  $scope.saveStatus =  {'initial':true,'pending':false,'completed':false,'failed':false};
                            },3000);
                        });
            }

            function saveManageBotSynonyms(){
                   var _botInfo = {
                    streamId:$workflowService.selectedStream()._id,
                    BotName:$workflowService.selectedStream().name,
                 };
                //  mixPanel.postEvent('Add Concept',_botInfo);
                var key, synonyms;


                key = _.isObject($scope.manageBotSynonym.keyword) ? $scope.manageBotSynonym.keyword.key : $scope.manageBotSynonym.keyword;
                if (key) {
                    key = key;
                }
                $scope.manageBotSynonym.synonyms = _.map($scope.manageBotSynonym.synonyms,function(synonym){
                    if(_.isObject(synonym)){
                        return synonym['text'];
                    }else{
                        return synonym;
                    }
                });

                synonyms = $scope.manageBotSynonym.synonyms || [];
                synonyms = _.uniq(synonyms.concat(($workflowService.nlpStream().synonyms || {})[key] || []));
                synonyms = synonyms.map(function (synonym) {
                    return synonym;
                });
                var allSynonyms = angular.copy($workflowService.nlpStream().synonyms);
                allSynonyms[key] = synonyms;
                allSynonyms = {'synonyms': allSynonyms};
                saveManageBotSynonymsForm(key, synonyms, allSynonyms);
            }

            var saveSynonyms = function(){
                    $timeout(function(){
                        if($scope.manageBotSynonym.synonyms.length > 1){
                            var _editSynonym = _.find($scope.synonyms,{'key':$scope.manageBotSynonym.keyword});
                            if(_editSynonym){
                                _editSynonym['value'] = $scope.manageBotSynonym.synonyms;
                            }
                            $scope.saveBotSynonym();
                        }else{
                            saveManageBotSynonyms();
                        }
                    });
            };

             $scope.saveManageBotTaskSynonym = function () {
                if($scope.views.botsynonyms && $scope.manageBotSynonym.keyword.startsWith('~')){
                    _mode = 'create';
                    $('#warningSynonymModal').modal('show');
                    return;
                }else{
                    saveSynonyms();
                }
               
             
            };

            $scope.saveAsConcepts = function(){
                if(_mode === 'create'){
                    if($scope.manageBotSynonym && $scope.manageBotSynonym.keyword && $scope.manageBotSynonym.keyword.length > 0){
                        saveSynonyms();
                        $timeout(function(){
                             $scope.closeCreateSynonym();
                        },200);
                       
                    }
                  }else if(_mode === 'edit'){
                    if($scope.currentEditSynonym && $scope.currentEditSynonym.key && $scope.currentEditSynonym.key.length > 0){
                        $scope.updateSynonyms();
                        $timeout(function(){
                             $scope.closeEditSynonym();
                        },200);
                       
                    }
                  }
                  $('#warningSynonymModal').modal('hide');
            };

            $scope.closeSynonymModal = function(){
                $('#warningSynonymModal').modal('hide');
                 if(_mode === 'create'){
                    $scope.manageBotSynonym.keyword = $scope.manageBotSynonym.keyword.substr(1,$scope.manageBotSynonym.keyword.length);
                }else if(_mode === 'edit'){
                    $scope.currentEditSynonym.key = $scope.currentEditSynonym.key.substr(1,$scope.currentEditSynonym.key.length);
                }
                 
                 saveSynonyms();
            };

            $scope.proceedAsConcept = function(){
                $scope.saveAsConcepts();
                Object.keys($scope.views).forEach(function(view){
                        $scope.views[view] = false;
                });
                $scope.views['concepts'] = true;
                $scope.activeTab = 'concepts';
                
            };


            function transformSynonymsToObject(synonyms) {
                var result = {};
                synonyms
                        .map(function (synonym) {
                            result[synonym.key] = synonym.value;
                        });
                return result;
            }

            function mergeNewSyonymsToLocalStream(synonyms) {
                synonyms = synonyms || {};
                $scope.stream.synonyms = $scope.stream.synonyms || {};
                Object.keys(synonyms).map(function (key) {
                    $scope.stream.synonyms[key] = synonyms[key];
                });
            }



            function saveTaskSynonyms(streamId, name, synonyms, forStream,updateKey, type) {
                var payload = {}, deferred = $q.defer();
                $scope.saveStatus =  {'initial':false,'pending':true,'completed':false,'failed':false};
                if (!forStream) {
                    payload[name] = synonyms;
                    return BTStreamsService
                            .postSynonyms(streamId, {synonyms: payload})
                            .then(function (res) {
                                if (type) {
                                    if ($scope.views && $scope.views.botsynonyms) {
                                        mixpanelEvent("deleteSynonyms");
                                    } else {
                                        mixpanelEvent("deleteConceptSynonyms");
                                    }
                                } else {
                                    if ($scope.views && $scope.views.botsynonyms) {
                                        mixpanelEvent("editSynonyms");
                                    } else {
                                        mixpanelEvent("editConceptSynonyms");
                                    }
                                }
                                $scope.saveStatus =  {'initial':false,'pending':false,'completed':true,'failed':false};
                                $workflowService.selectedStream(res.data);
                                $workflowService.nlpStream(res.data);
                                mergeNewSyonymsToLocalStream(res.data.synonyms);
//                                $scope.editBotSynonymId = null;
//                                $scope.editBotSynonym = null;
                                transformBotSynonyms(true);
                                if($scope.enableSynonyms) {
                                    $scope.trainShow = true;
                                }
                              
                                $timeout(function(){
                                    $scope.saveStatus =  {'initial':true,'pending':false,'completed':false,'failed':false};
                                },3000);

//                                NotificationService.notify("Synonyms updated successfully", 'success');
                                return deferred.resolve(res);
                            }, function (err) {
                                      var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_bot_synonym_failed');
                                        NotificationService.notify(msg, 'error');
                                         $scope.saveStatus =  {'initial':false,'pending':false,'completed':false,'failed':true};
                                            $timeout(function(){
                                                $scope.saveStatus =  {'initial':true,'pending':false,'completed':false,'failed':false};
                                            },3000);
                                return $q.reject(err);
                            });
                } else {
                    synonyms = angular.copy($scope.synonyms);
                    synonyms = transformSynonymsToObject(synonyms);
                    return BTStreamsService
                            .postSynonyms($scope.stream._id, {synonyms: synonyms})
                            .then(function (res) {
                                if(type){
                                 mixpanelEvent("deleteSynonyms");
                                }else{
                                mixpanelEvent("editSynonyms");
                                }
                                $scope.saveStatus = {'initial':false,'pending':false,'completed':true,'failed':false};
                                $workflowService.selectedStream(res.data);
                                $workflowService.nlpStream(res.data);
                                $scope.stream.synonyms = res.data.synonyms;
                                mergeNewSyonymsToLocalStream(res.data.synonyms);
//                                $scope.editBotSynonymId = null;
//                                $scope.editBotSynonym = null;
                                if(updateKey){
                                    NotificationService.notify( i18n.i18nString('synonyms_updated_sucess'), 'success');
                                    transformBotSynonyms(false);
                                    $scope.editBotSynonym = null;
                                    $scope.editBotSynonymId = null;
                                }else{
                                    NotificationService.notify($scope.synUpdateMsg, 'success');
                                    transformBotSynonyms();
                                }
                                if($scope.enableSynonyms) {
                                    $scope.trainShow = true;
                                }
                                $timeout(function(){
                                    $scope.saveStatus =  {'initial':true,'pending':false,'completed':false,'failed':false};
                                },3000);
                                return deferred.resolve(res);
                            }, function (err) {
                                      var msg = err.data && err.data.errors && err.data.errors[0] && err.data.errors[0].msg || i18n.i18nString('adding_bot_synonym_failed');
                                        NotificationService.notify(msg, 'error');
                                          $scope.saveStatus = {'initial':false,'pending':false,'completed':false,'failed':true};
                                        $timeout(function(){
                                            $scope.saveStatus =  {'initial':true,'pending':false,'completed':false,'failed':false};
                                        },3000);
                                return $q.reject(err);
                            });
                }
            }

            $scope.showEmojiModal = function(){
                $('#emojiModal').modal('show');
            };

            $scope.loadEmojis = function(){
                BTStreamsService.importEmojis($workflowService.selectedStream()._id)
                .then(function(res) {
                    if(res && res.data && res.data.synonyms){
                    $scope.stream.synonyms = res.data.synonyms;
                    }
                    transformBotSynonyms();
                    $('#emojiModal').modal('hide');
                        NotificationService.notify( i18n.i18nString('bot_train'), "info");
                        NotificationService.notify( i18n.i18nString('emojiImportedInfo'), "info");
                    },
                    function(err) {
                           if (err && err.data && err.data.errors && err.data.errors.length > 0 && err.data.errors[0] &&  err.data.errors[0].msg) {
                            NotificationService.notify(err.data.errors[0].msg, "error");
                        } else {
                            NotificationService.notify(i18n.i18nString('bot_train_failure'), "error");
                        }
                    });
            };

            $scope.updateSynonyms = function(type){
                $timeout(function(){
                             var _synonym = _.find($scope.synonyms,{'key':$scope.editSynonymCopy.key});
                             if(_synonym){
                                 _synonym.key = $scope.currentEditSynonym.key;
                                _synonym.value = $scope.currentEditSynonym.value;
                             }
                         $scope.saveBotSynonym(type);
                    });
            };


            $scope.saveBotSynonym = function (type) {
                if(type){
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_deleted_success');
                }else{
                    $scope.synUpdateMsg= i18n.i18nString('synonyms_added_sucess');
                }
                 setTimeout(function () {
                  saveTaskSynonyms(null, null, null, true,"",type);
                        }, 500);
            };



            $scope.saveEditBotSynonym = function(type){
                if($scope.views.botsynonyms && $scope.currentEditSynonym && $scope.currentEditSynonym.key && $scope.currentEditSynonym.key.startsWith('~')){
                    _mode = 'edit';
                    $('#warningSynonymModal').modal('show');
                    return;
                }else{
                    $scope.updateSynonyms(type);
                }
            };

             $scope.deleteSynonym = function (deletedSynonym,type,$event) {

                $event.stopPropagation();
                var index = -1;

                $scope.synonyms.map(function (synonym, i) {
                    if (synonym.key == deletedSynonym.key) {
                        index = i;
                    }
                });

                var synonym = $scope.synonyms[index];
                if(type === 'synonym'){
                     NotificationService.alert( i18n.i18nString('do_you_really_want_to_del_noty'), deleteSynonym, [$scope.stream._id, null, null, true]);
                }else if(type === 'concept'){
                     NotificationService.alert( i18n.i18nString('do_you_really_want_to_del_noty_concept'), deleteSynonym, [$scope.stream._id, null, null, true]);
                }
               

                function deleteSynonym() {
                    var synonyms = angular.copy($scope.synonyms);
                    synonyms.splice(index, 1);
                    BTStreamsService.postSynonyms($scope.stream._id, {
                        synonyms: transformSynonymsToObject(synonyms)
                    })
                            .then(function (res) {
                                $scope.synonyms.splice(index, 1);
                                $scope.stream = res.data;
                                $workflowService.nlpStream($scope.stream);
                                $workflowService.selectedStream($scope.stream);
                                $scope.oldSynonyms = angular.copy($scope.synonyms);
                                if(type === 'synonym'){
                                    NotificationService.notify( i18n.i18nString('synonyms_deleted_success'), "success");
                                }else if(type === 'concept'){
                                    NotificationService.notify( i18n.i18nString('concept_deleted_success'), "success");
                                }
                                
                                if($scope.enableSynonyms) {
                                    $scope.trainShow = true;
                                }
                                indexUpdateForBotSynonyms();
                            }, function (err) {
                                var msg = getErrorMsg(err,  i18n.i18nString('synonyms_added_failure'));
                                NotificationService.notify(msg, "error");
                            });
                }



            };

            $scope.restrictDeletingTilde = function(e,keyword,type){
                    if((type === 'concepts') && (keyword && keyword.length === 1 && keyword === '~') && (e.keyCode === 8 || e.keyCode === 46)){
                        e.preventDefault();
                    }else if((type === 'synonyms') && (keyword.startsWith('~') && 
                        (e.keyCode === 13 &&  keyword.length > 1 ))){
                        _mode = 'edit';
                        $('#warningSynonymModal').modal('show');
                        return;
                    }else if(e.keyCode === 13 && keyword.length > 1 && type === 'concepts'){
                        $scope.saveEditBotSynonym();   
                    }
                    else if(e.keyCode === 13 && keyword.length > 0 && !(keyword.startsWith('~')) && type === 'synonyms'){
                        $scope.saveEditBotSynonym();
                    }
            };
            $scope.validateTilde = function(e,keyword){
                 if((keyword && keyword.length === 1 && keyword === '~') && (e.keyCode === 8 || e.keyCode === 46)){
                        e.preventDefault();
                    }
            };

            
            
            $scope.createNewTraits = function(){
                $timeout(function(){
                    $scope.traitsCb.createNewTraits();
                });
                
            };

            var updateStatus = function(status){
                $scope.saveStatus = status;
            };

            $scope.onInvalidTag = function(){
                $scope.isInvalidTag = true;
            };

            $scope.updateTrainDataDetails = function(intentData){
                   if($scope.cb && $scope.cb.updateTrainDataDetails){
                        $scope.cb.updateTrainDataDetails(intentData);
                   }
                   
            };

            $scope.updateIntentData = function(trainData){
                if($scope.cb && $scope.cb.updateIntentData){
                    $scope.cb.updateIntentData(trainData);
                }
            };
            $scope.deleteEnabledNotification = function(){
                $scope.notificationEnabled = false;
                $scope.notificationInputEnabled = true;
            };
            // $scope.deleteEnabledWarning = function(){
            //     $scope.warningEnabled = false;
            // };
            $scope.closeWarningNotification = function(){
                $scope.notificationInputEnabled = false;
            };
            $scope.closeUtteranceDropdown = function(){
                if ($(".taskSelectContainer .kr-sg-dropdowns .dropdown.dropdown-open.open").length) {
                    $(".taskSelectContainer .kr-sg-dropdowns .dropdown.dropdown-open.open").removeClass("open");
                }
            };
            $scope.multiLinguale ={};

            var enabledSupportedLanguages = $workflowService.currentLanguage();
                if(($workflowService.selectedStream() && $workflowService.selectedStream().multiLingualConfigurations &&  $workflowService.selectedStream().multiLingualConfigurations[enabledSupportedLanguages] && $workflowService.selectedStream().multiLingualConfigurations[enabledSupportedLanguages].inputTranslation) || ($workflowService.selectedStream() && $workflowService.selectedStream().multiLingualConfigurations &&  $workflowService.selectedStream().multiLingualConfigurations[enabledSupportedLanguages] && $workflowService.selectedStream().multiLingualConfigurations[enabledSupportedLanguages].nluLanguage && $workflowService.selectedStream().multiLingualConfigurations[enabledSupportedLanguages].nluLanguage === 'ge')){
                $scope.multiLinguale.inputTranslation = true;
                $scope.multiLinguale.language =$workflowService.selectedStream().multiLingualConfigurations[enabledSupportedLanguages].nluLanguage;
                }else{
                $scope.multiLinguale.inputTranslation = false;
                }
            $scope.configureInputTranslation = function(){
               if($scope.rightPanelCb && $scope.rightPanelCb.showView){
                $workflowService.storeSearchQry({
                    'userSearchQueryFlag': true,
                    'searchQry': 'openInputTranslation'
                });
            
                   $scope.rightPanelCb.showView('languageManagement');
               } 
            };

            


           


            $scope.synonymsCB.updateStatus = updateStatus;
            $scope.callback.closeTrainingModalSlider = $scope.closeTrainingModalSlider;
            if($scope.cb){
                $scope.cb.fetchIntents = fetchIntents;
                $scope.cb.trainBot = $scope.trainBot;
                $scope.cb.loadingEntities = loadingEntities;
            }
            $scope.traitsCb.prepareTrainLabel = prepareTrainLabel;
            $scope.callback.fetchMLStatus = checkMLSyncStatus;
            if($scope.rightPanelCb){
                $scope.rightPanelCb.showActiveType = $scope.showActiveType;
                $scope.rightPanelCb.clearSearch = $scope.clearSearch;
            }

            $scope.callback.updateTrainDataDetails = $scope.updateTrainDataDetails;
            $scope.callback.updateIntentData = $scope.updateIntentData;
            
           






        }
    ]);


}(angular));